<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Leetcode之比特位计数</title>
      <link href="/passages/leetcode-zhi-bi-te-wei-ji-shu/"/>
      <url>/passages/leetcode-zhi-bi-te-wei-ji-shu/</url>
      
        <content type="html"><![CDATA[<h3 id="Counting-Bits"><a href="#Counting-Bits" class="headerlink" title="Counting Bits"></a>Counting Bits</h3><ul><li>code with Python</li><li>title number：338</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li><p>给定一个非负整数<code>num</code>，对于<code>0 &lt;= n &lt;= num</code>范围中的每个数字<code>i</code>，计算器二进制数中的<code>1</code>的数目并将他们作为数组返回</p></li><li><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：2</span><br><span class="line">输出：[0, 1, 1]</span><br><span class="line">解释：0: 00, 1: 01, 2: 10, 包含的1的个数分别为0, 1, 1</span><br></pre></td></tr></table></figure></li></ul><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>遍历整个范围，对范围中的每个数统计其包含的<code>1</code>的个数，将统计结果添加到结果集中<ul><li>将数字和<code>1</code>进行<strong>与</strong>操作，判断当前最低位是否为<code>1</code></li><li>将数字进行左移操作，删除掉低位被统计过的<code>1</code></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countBits</span><span class="params">(self, num: int)</span> -&gt; List[int]:</span></span><br><span class="line">    res = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num + <span class="number">1</span>):</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i:</span><br><span class="line">            count += i &amp; <span class="number">1</span></span><br><span class="line">            res.append(count)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>时间复杂度为<code>O(n*sizeof(integer))</code></p><br><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li>题目要求使用线性时间复杂度的算法，并且算法的空间复杂度为<code>O(n)</code></li><li>要想实现时间复杂度是<code>O(n)</code>的算法，必然不能一边遍历一遍统计；需要在遍历的同时，<strong>利用之前的结果计算当前数字中<code>1</code>的个数</strong><ul><li>如果当前数字是偶数，则<code>f(i)=f(i//2)</code></li><li>如果当前数字是奇数，则<code>f(i)=f(i-1)+1</code></li></ul></li><li>具体解释一下<ul><li>如果当前数字是偶数，说明数字的最低位一定是<code>0</code>，所以将数字左移一位（除2），数字中所包含的<code>1</code>的个数是不变的</li><li>如果当前数字是奇数，则其前一位必定是偶数，当前奇数只是在前一个数字的最低位加了一个<code>1</code>，所以其<code>1</code>的个数是前一个数字的<code>1</code>的个数<code>+1</code></li></ul></li><li>其实这就是动态规划</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countBits</span><span class="params">(self, num: int)</span> -&gt; List[int]:</span></span><br><span class="line">    res = [<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, num+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            res.append(res[i // <span class="number">2</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res.append(res[i - <span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之只出现一次的数字Ⅲ</title>
      <link href="/passages/leetcode-zhi-zhi-chu-xian-yi-ci-de-shu-zi-iii/"/>
      <url>/passages/leetcode-zhi-zhi-chu-xian-yi-ci-de-shu-zi-iii/</url>
      
        <content type="html"><![CDATA[<p>Single Number Ⅲ</p><a id="more"></a><h3 id="Single-Number-Ⅲ"><a href="#Single-Number-Ⅲ" class="headerlink" title="Single Number Ⅲ"></a>Single Number Ⅲ</h3><ul><li>code with Python</li><li>title number：260</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个整数数组，其中恰好有两个元素只出现一次，其余所有元素均出现两次。</li><li>找出只出现一次的那两个元素</li></ul><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>沿用之前的思路，数学方法、字典、位运算</li><li>由于这里是要求两个元素，故前面用过的数学方法不适用</li><li>这里先用字典解决：<ul><li>遍历数组，统计每个元素出现的次数</li><li>返回出现次数为<code>1</code>的元素</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SingleNumber</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">    map_ = dict()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> num <span class="keyword">in</span> map_:</span><br><span class="line">            map_[num] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            map_[num] = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> map_keys():</span><br><span class="line">        <span class="keyword">if</span> map_[key] == <span class="number">1</span>:</span><br><span class="line">            res.append(key)</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><br><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li><p>位运算背景知识：</p><ul><li><code>0</code>和所有数异或得到数字本身</li><li>相同的数字进行异或得到的结果为<code>0</code></li><li>补码等于原码的反码加<code>1</code>，负数用补码表示</li><li>一个数和它的相反数异或得到该数二进制表示<strong>最左边的1</strong></li><li>例如</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原码：0000 0101</span><br><span class="line">反码：1111 1010</span><br><span class="line">补码：1111 1111</span><br><span class="line">5 &amp; (-5) &#x3D; 1</span><br></pre></td></tr></table></figure></li><li><p>思路：</p><ul><li>所有数进行异或操作，得到<strong>只出现一次的两个数的异或</strong></li><li>将这个异或与自己的相反数进行<strong>与操作</strong>，得到两个数最左边出现的<code>1</code>，记为<code>2</code></li><li>分别用<code>a</code>与每个数进行与操作，将数组分为两部分</li><li>每部分分别进行异或操作，即可得到这两个只出现一次的数</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums； List[int])</span> -&gt; List[int]:</span></span><br><span class="line">    a = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 遍历，进行异或操作</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        a ^= num</span><br><span class="line">    x, y = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 得到两个数的异或的最左边的1</span></span><br><span class="line">    a &amp;= -a</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> a &amp; num:</span><br><span class="line">            x ^= num</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            y ^= num</span><br><span class="line">    <span class="keyword">return</span> [x, y]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之只出现一次的数字Ⅱ</title>
      <link href="/passages/leetcode-zhi-zhi-chu-xian-yi-ci-de-shu-zi-ii/"/>
      <url>/passages/leetcode-zhi-zhi-chu-xian-yi-ci-de-shu-zi-ii/</url>
      
        <content type="html"><![CDATA[<p>Single Number Ⅱ</p><a id="more"></a><h3 id="Single-Number-Ⅱ"><a href="#Single-Number-Ⅱ" class="headerlink" title="Single Number Ⅱ"></a>Single Number Ⅱ</h3><ul><li>code with Python</li><li>title number：137</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li><p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次之外，其余的元素均出现了三次，找出那个只出现了一次的元素</p></li><li><p>说明</p><ul><li>算法应具有线性时间复杂度，尽量不要使用额外空间</li></ul></li></ul><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li><p>数学方法</p></li><li><p>利用集合的特性，求整个数组的不重复元素，乘<code>3</code>求和</p></li><li><p>对所有数组元素求和</p></li><li><p>两者相减除以<code>2</code>即为只出现了一次的元素</p></li><li><p>例如:</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[2, 2, 3, 2]</span><br><span class="line">输出：3</span><br><span class="line">解释：[2*3 * 3*3 - (2+2+3+2)] &#x2F; 2 &#x3D; 3</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    single = set(nums)</span><br><span class="line">sum_3 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> single:</span><br><span class="line">        sum_3 += <span class="number">3</span>*i</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        sum_3 -= num</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sum_3 / <span class="number">2</span></span><br></pre></td></tr></table></figure><br><h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><ul><li>利用字典</li><li>遍历整个数组，统计每个元素出现的次数</li><li>返回出现次数为1的元素</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    map_ = dict()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> num <span class="keyword">in</span> map_:</span><br><span class="line">            map_[num] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            map_[num] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> map_.keys():</span><br><span class="line">        <span class="keyword">if</span> map_[key] == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> key</span><br></pre></td></tr></table></figure><br><h4 id="思路三"><a href="#思路三" class="headerlink" title="思路三"></a>思路三</h4><ul><li>先进行排序（将相同的数字放到一起）</li><li>遍历，如果<code>nums[i]==nums[i+2]</code>，则说明该数字出现了三次</li><li>否则返回当前数字</li><li>如果遍历完也没有找到，则最后一个数字为出现一次的</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, List[int])</span> -&gt; int:</span></span><br><span class="line">    nums.sort()</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i + <span class="number">2</span> &lt; len(nums):</span><br><span class="line">        <span class="keyword">if</span> nums[i] == nums[i+<span class="number">2</span>]:</span><br><span class="line">            i += <span class="number">3</span></span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            <span class="keyword">return</span> nums[i]</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><br><h4 id="思路三-1"><a href="#思路三-1" class="headerlink" title="思路三"></a>思路三</h4><ul><li><p>上述方法都使用了额外的空间</p></li><li><p>使用位运算进行，先介绍三种位运算：</p><ul><li><code>and</code>，且运算，使用<code>&amp;</code>表示</li><li><code>not</code>，非运算，使用<code>~</code>表示</li><li><code>xor</code>，异或运算，使用<code>^</code>表示<ul><li>使用异或运算可以检测出现奇数次的数字</li><li><code>0</code>异或所有数字都为该数字本身</li><li>两个相同的数进行异或操作，结果为<code>0</code></li></ul></li></ul></li><li><p>对于出现两次的相同数，我们可以通过异或置<code>0</code></p></li><li><p>对于出现三次的相同数，我们要构造一种方法，将同一个位置上的三个<code>1</code>清零，这样就可以发现出现三次的数字了</p><ul><li>在异或运算中，<code>1^1=0, 1^0=0, 0^1=1</code>，可以将其理解为不进位的二进制加法，<strong>而不进位可以理解为进位为对<code>2</code>取模</strong></li><li>这样，我们可以定义<strong>二进制加法，且进位为对<code>3</code>取模</strong>的做法为三个相同位的清零运算，即可实现<code>a?a?a=0</code></li></ul></li><li><p>所谓清零</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">21: 10101</span><br><span class="line">21: 10101</span><br><span class="line">异或:  00000</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">64</span>):</span><br><span class="line">        <span class="comment"># 初始化每一位1的个数为0</span></span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="comment"># 通过右移的方式，统计每一位1的个数</span></span><br><span class="line">            sum += nums[j] &gt;&gt; i &amp; <span class="number">1</span></span><br><span class="line">        <span class="comment"># 最终将抵消后剩余的1放到对应的位数上</span></span><br><span class="line">        res ^= (sum % <span class="number">3</span>) &lt;&lt; i</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><ul><li>推而广之，如果是定义一个<code>a?a?a?a?a=0</code>的运算，只需要进行<strong>二进制加法，进位对5取模</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之01矩阵</title>
      <link href="/passages/leetcode-zhi-01-ju-zhen/"/>
      <url>/passages/leetcode-zhi-01-ju-zhen/</url>
      
        <content type="html"><![CDATA[<p>01 Matrix</p><a id="more"></a><h3 id="01-Matrix"><a href="#01-Matrix" class="headerlink" title="01 Matrix"></a>01 Matrix</h3><ul><li>code with Python</li><li>title number：542</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个由<code>0, 1</code>组成的矩阵，找出每个元素到最近的<code>0</code>的距离</li><li>两个相邻元素间的距离为<code>1</code></li><li>例如：</li></ul><img src="/.top//ZivBlog\source\_posts\Leetcode之01矩阵\example.png" style="zoom:75%;"><ul><li>矩阵元素只能在四个方向上相邻：上、下、左、右</li></ul><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>由题意可知，所求距离为曼哈顿距离，即方向上只能沿这横、竖到达下一个位置</li><li>在一个图中，从一个点出发求<strong>最短距离</strong>，首先想到的是<strong>广度优先遍历</strong><ul><li>广度优先遍历会优先将最近的一圈搜索完之后，再去搜索下一圈</li></ul></li><li>所以在本题中，第<code>i</code>圈对应的就是距离为<code>i</code></li><li>题目给出了多个<code>1</code>，要求找到每个<code>1</code>到<code>0</code>的最近曼哈顿距离。而<code>0</code>到<code>1</code>的距离和<code>1</code>到<code>0</code>的距离是相同的<ul><li>故我们可以将问题转化为:<strong>每个0到1距离</strong></li><li>问题抽象为:<strong>多个起始点的广度优先搜索</strong></li></ul></li><li>接下来是广度优先搜索：<ul><li>将每个还未搜索到的点依次放入队列，再弹出队列的头部元素作为当前的遍历点</li></ul></li><li>要确定遍历到哪一层，需要加一个<code>level</code>记录遍历的层数<ul><li>访问完每层的元素之后，<code>level+1</code></li></ul></li><li>具体算法细节，请结合代码和注释理解</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">updateMatrix</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; List[List[int]]:</span></span><br><span class="line">    M, N = len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line">    queue = collections.deque()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 记录已访问过的位置</span></span><br><span class="line">    visited = [[<span class="number">0</span>] * N <span class="keyword">for</span> _ <span class="keyword">in</span> range(M)]</span><br><span class="line">    <span class="comment"># 结果</span></span><br><span class="line">    res = [[<span class="number">0</span>] * N <span class="keyword">for</span> _ <span class="keyword">in</span> range(M)]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将所有的0添加到队列中</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(M):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(N):</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] == <span class="number">0</span>:</span><br><span class="line">                queue.append((i, j))</span><br><span class="line">                visited[i][j] = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 四个方向</span></span><br><span class="line">    dirs = [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">-1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">-1</span>, <span class="number">0</span>)]</span><br><span class="line">    <span class="comment"># 距离 = 层数</span></span><br><span class="line">    step = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 出队所有元素</span></span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        size = len(queue)</span><br><span class="line">        <span class="comment"># 当前元素所有邻居</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(size):</span><br><span class="line">            x, y = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> matrix[x][y] == <span class="number">1</span>:</span><br><span class="line">                res[x][y] = step</span><br><span class="line">            <span class="comment"># 广度优先遍历，四个方向</span></span><br><span class="line">            <span class="keyword">for</span> dx, dy <span class="keyword">in</span> dirs:</span><br><span class="line">                newx, newy = x + dx, y + dy</span><br><span class="line">                <span class="keyword">if</span> newx &lt; <span class="number">0</span> <span class="keyword">or</span> newx &gt;= M <span class="keyword">or</span> newy &lt; <span class="number">0</span> <span class="keyword">or</span> newy &gt;= N <span class="keyword">or</span> visited[newx][newy] == <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 新节点入队</span></span><br><span class="line">                queue.append((newx, newy))</span><br><span class="line">                visited[newx][newy] = <span class="number">1</span></span><br><span class="line">       <span class="comment"># 下一层</span></span><br><span class="line">        step += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之柱状图中最大的矩形</title>
      <link href="/passages/leetcode-zhi-zhu-zhuang-tu-zhong-zui-da-de-ju-xing/"/>
      <url>/passages/leetcode-zhi-zhu-zhuang-tu-zhong-zui-da-de-ju-xing/</url>
      
        <content type="html"><![CDATA[<p>Largest Rectangle in Histogram</p><a id="more"></a><h3 id="Largest-Rectangle-in-Histogram"><a href="#Largest-Rectangle-in-Histogram" class="headerlink" title="Largest Rectangle in Histogram"></a>Largest Rectangle in Histogram</h3><ul><li>code with Python</li><li>title number：84</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定<code>n</code>个非负数，用来表示柱状图中每个柱子的高度。</li><li>每个柱子彼此相邻，且宽度为<code>1</code></li><li>求在该柱状图中，能够勾勒出来的矩形的最大面积</li></ul><br><h4 id="先验知识"><a href="#先验知识" class="headerlink" title="先验知识"></a>先验知识</h4><ul><li>单调栈适合处理<strong>两端元素的大小决定中间元素大小的问题</strong></li><li>单调栈有一下性质：<ul><li>如果是单调递增栈，则从栈顶到栈底的元素是严格递增的；如果是单调递减栈，则从栈顶到栈底的元素是严格递减的</li><li>只能在栈顶操作</li></ul></li><li>进栈过程（以单调递增栈为例）：<ul><li>如过当前进栈元素为<code>e</code>，从栈顶开始遍历元素，把小于<code>e</code>或等于<code>e</code>的元素弹出</li><li>直到遇到一个大于<code>e</code>的元素或栈空为止，然后再把<code>e</code>压入栈中</li></ul></li></ul><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>当前位置的高度能决定的最大阴影面积由其左右第一个小于该元素的元素决定<ul><li>以第i根柱子为最矮柱子所能延伸的最大面积：<code>当前高度 * 左右第一个小于该元素之间的距离</code></li></ul></li><li>使用单调栈用以找到当前元素左右第一个小于它的元素</li><li>上述思路体现在单调栈上的操作，即：<ul><li>从左到右遍历每一根柱子，我们要找到第一个小于当前高度的柱子</li><li>如果柱子高度大于栈顶的柱子高度（不是我们要找的），则入栈</li><li>如果柱子高度小于栈顶的柱子高度（所求），<ul><li><strong>对于栈顶元素</strong>，其右边的第一个小于它的就是当前遍历到的柱子，左边第一个小于它的柱子就是栈中下一个要被弹出的元素</li><li>因此，当前栈顶元素决定的最大阴影面积为：<code>当前栈顶的柱子高度 * (当前遍历到的柱子索引 - 栈中下一个要被弹出的元素的索引 + 1)</code></li></ul></li><li>为了方便操作，在<code>heights</code>的左右两边各添加一个哨兵元素，保证所有的柱子都会出栈</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span><span class="params">(self, heights: List[int])</span> -&gt; int:</span></span><br><span class="line">    n, heights, stack, ans = len(heights), [<span class="number">0</span>]+heights+[<span class="number">0</span>], [], <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">2</span>):</span><br><span class="line">        <span class="comment"># 当前元素是栈顶元素右边第一小于它的元素</span></span><br><span class="line">        <span class="comment"># 栈顶第二元素是栈顶元素左边第一个小于它的元素</span></span><br><span class="line">        <span class="keyword">while</span> st <span class="keyword">and</span> heights[stack[<span class="number">-1</span>]] &gt; heights[i]:</span><br><span class="line">            ans = max(ans, heights[stack.pop(<span class="number">-1</span>)] * (i - stack[<span class="number">-1</span>] - <span class="number">1</span>))</span><br><span class="line">        stack.append(i)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><ul><li>不愧是<code>hard</code>的题目啊，🤦‍♂️🤦‍♂️🤦‍♂️</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之克隆图</title>
      <link href="/passages/leetcode-zhi-ke-long-tu/"/>
      <url>/passages/leetcode-zhi-ke-long-tu/</url>
      
        <content type="html"><![CDATA[<p>Clone Graph</p><a id="more"></a><h3 id="Clone-Graph"><a href="#Clone-Graph" class="headerlink" title="Clone Graph"></a>Clone Graph</h3><ul><li>code with Python</li><li>title number：133</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个无向连通图中一个节点的引用，请返回该图的<strong>深拷贝（克隆）</strong></li><li>图中每个节点包含它的<strong>值</strong>和它的<strong>邻居列表</strong></li></ul><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>由于图是连通图，可以通过一次遍历访问到<strong>所有节点</strong>（深度优先搜索 or 广度优先搜索）</li><li>深拷贝，即所有节点的<strong>空间要重新申请</strong>，而不是只创建索引</li><li>图中可能存在环，因此需要存储已经访问过的节点，防止陷入死循环</li><li>这里我们使用<strong>深度优先搜索</strong>遍历图</li><li>用于存储已访问过（且拷贝过）节点的数据结构为<strong>字典<code>{原节点:复制节点}</code></strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.visited = &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cloneGraph</span><span class="params">(self, node: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        <span class="comment"># 深度优先遍历并克隆</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node)</span>:</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="comment"># 已访问过，直接返回已创建的克隆对象</span></span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">in</span> self.visited:</span><br><span class="line">                <span class="keyword">return</span> self.visited[node]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 未访问过，创建克隆对象</span></span><br><span class="line">            ans = Node(node.val)</span><br><span class="line">            self.visited[node] = ans</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 深度优先搜索其邻居节点</span></span><br><span class="line">            <span class="keyword">for</span> neighbor <span class="keyword">in</span> node,neighbors:</span><br><span class="line">                ans.neighbors.append(dfs(neighbor))</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> dfs(node)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之字符串解码</title>
      <link href="/passages/leetcode-zhi-zi-fu-chuan-jie-ma/"/>
      <url>/passages/leetcode-zhi-zi-fu-chuan-jie-ma/</url>
      
        <content type="html"><![CDATA[<p>Decode String</p><a id="more"></a><h3 id="Decode-String"><a href="#Decode-String" class="headerlink" title="Decode String"></a>Decode String</h3><ul><li>code with Python</li><li>title number：394</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li><p>给定一个经过编码的字符串，返回它解码后的字符串。</p></li><li><p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的<code>encoded_string</code>正好重复<code>k</code>次。注意<code>k</code>保证为正整数。</p></li><li><p>输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p></li><li><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像<code>3a</code>或 <code>2[4]</code>的输入。</p></li></ul><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>本题的难点在于解码过程存在<strong>嵌套现象</strong>，即需要先对内部进行解码拼接，再依次对外部进行解码</li><li>这与栈的<strong>先入后出</strong>十分吻合，这里我们使用辅助栈进行解码操作：<ul><li>遇到数字（’[‘之前的元素，转化为数字）压入栈中</li><li>遇到’[‘之后，将左右括号之间的元素压入栈中</li><li>遇到’]’之后，取出栈中元素进行拼接，将结果放入栈中</li></ul></li><li>栈中唯一元素即为拼接后的结果</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decodeString</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">    stack, res, multi = [], <span class="string">''</span>, <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> c == <span class="string">'['</span>:</span><br><span class="line">            stack.append([multi, res])</span><br><span class="line">            res, multi = <span class="string">''</span>, <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">elif</span> c == <span class="string">']'</span>:</span><br><span class="line">            cur_multi, last_res = stack.pop()</span><br><span class="line">            res = last_res + cur_multi * res</span><br><span class="line">        <span class="keyword">elif</span> <span class="string">'0'</span> &lt;= c &lt;= <span class="string">'9'</span>:</span><br><span class="line">            multi = multi * <span class="number">10</span> + int(c)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res += c</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><br><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li><p>这种嵌套结构也会令人自然想到<strong>递归</strong></p></li><li><p>左右括号间的内容是需要递归的主体：</p><ul><li>遇到’[‘，开启一层新的递归</li><li>遇到’]’，返回当前括号内的字符串和索引<code>i</code></li></ul></li><li><p>遍历完返回结果</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decodeString</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(s, i)</span>:</span></span><br><span class="line">        res, multi = <span class="string">""</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(s):</span><br><span class="line">            <span class="keyword">if</span> <span class="string">'0'</span> &lt;= s[i] &lt;= <span class="string">'9'</span>:</span><br><span class="line">                multi = multi *<span class="number">10</span> + int(s[i])</span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">'['</span>:</span><br><span class="line">                i, temp = dfs(s, i + <span class="number">1</span>)</span><br><span class="line">                res += multi * temp</span><br><span class="line">                multi = <span class="number">0</span></span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">']'</span>:</span><br><span class="line">                <span class="keyword">return</span> i, res</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += s[i]</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">return</span> dfs(s, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之复制带随机指针的链表</title>
      <link href="/passages/leetcode-zhi-fu-zhi-dai-sui-ji-zhi-zhen-de-lian-biao/"/>
      <url>/passages/leetcode-zhi-fu-zhi-dai-sui-ji-zhi-zhen-de-lian-biao/</url>
      
        <content type="html"><![CDATA[<p>Copy List with Random Pointer</p><a id="more"></a><h3 id="Copy-List-with-Random-Pointer"><a href="#Copy-List-with-Random-Pointer" class="headerlink" title="Copy List with Random Pointer"></a>Copy List with Random Pointer</h3><ul><li>code with Python</li><li>title number：138</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li><p>给定一个链表，每个节点包含一个额外增加的<strong>随机指针</strong>，该指针可以指向链表中的任何节点或空节点</p></li><li><p>要求返回该链表的<strong>深拷贝</strong></p></li><li><p>用一个有<code>n</code>个节点组成的链表来表示输入/输出的链表。每个节点用一个<code>[val, random_index]</code>表示：</p><ul><li><code>val</code>：节点值</li><li><code>random_index</code>：随机指针</li></ul></li><li><p>示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class="line">输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br></pre></td></tr></table></figure></li></ul><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>深拷贝与浅拷贝的区别：<ul><li>深拷贝在于创建新的指针和空间，即深拷贝得到的对象与原对象之间相互独立，互不影响</li><li>浅拷贝只创建新的指针指向原对象的空间，原对象上的修改都会浅拷贝对象的改变</li></ul></li><li>本题的关键在于存在随机指针，所以链表中可能存在<strong>环</strong>，如果直接遍历复制可能导致死循环，故有以下考虑：<ul><li>使用hash表存储已访问过的节点</li><li>对<code>next</code>和<code>random</code>两个指针同时进行递归复制</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.visited = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span><span class="params">(self, head: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">in</span> self.visited:</span><br><span class="line">            <span class="keyword">return</span> self.visited[head]</span><br><span class="line">        </span><br><span class="line">        node = Node(head.val, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line">        </span><br><span class="line">        self.visited[head] = node</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 递归</span></span><br><span class="line">        node.next = self.copyRandomList(head.next)</span><br><span class="line">        node.random = self.copyRandomList(node.random)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure><br><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li>本题的难点在于<strong>随机指针的复制</strong>，我们通过一下三步实现：<ul><li>根据遍历到的原节点创建对应的新节点，每个新创建的节点<strong>添加到原节点的后面</strong>（为了方便的复制随机指针）</li><li>对所有新创建节点组成的链表<strong>添加随机指针</strong>（若<code>node1.random=node3</code>，则<code>node1_new.random=node3_new</code>）</li><li>将两个链表分离</li></ul></li><li>另外，我们是沿着next链进行的遍历，无需使用额外的空间来记录访问过的节点</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> Node</span><br><span class="line">        </span><br><span class="line">        p = head</span><br><span class="line">        <span class="comment"># 第一步：在每个节点后创建新节点</span></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            new_node = Node(p.val, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line">            new_node.next = p.next</span><br><span class="line">            p.next = new_node</span><br><span class="line">            p = new_node.next</span><br><span class="line">            </span><br><span class="line">        p = head</span><br><span class="line">        <span class="comment"># 第二步：复制随机指针</span></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            <span class="keyword">if</span> p.random:</span><br><span class="line">                p.next.random = p.random.next</span><br><span class="line">            p = p.next.next</span><br><span class="line">        </span><br><span class="line">        p = head</span><br><span class="line">        dummy = Node(<span class="number">-1</span>, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line">        cur = dummy</span><br><span class="line">        <span class="comment"># 将两个链表分离</span></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            cur.next = p.next</span><br><span class="line">            cur = cur.next</span><br><span class="line">            p.next = cur.next</span><br><span class="line">            p = p.next</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之回文链表</title>
      <link href="/passages/leetcode-zhi-hui-wen-lian-biao/"/>
      <url>/passages/leetcode-zhi-hui-wen-lian-biao/</url>
      
        <content type="html"><![CDATA[<p>Palindrome Linked List</p><a id="more"></a><h3 id="Palindrome-Linked-List"><a href="#Palindrome-Linked-List" class="headerlink" title="Palindrome Linked List"></a>Palindrome Linked List</h3><ul><li>code with Python</li><li>title number：234</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个单链表，判断其是否为回文链表</li></ul><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li><strong>快慢指针</strong>找到中间节点</li><li><strong>反转</strong>后半部分链表</li><li>两子链表从头比较是否完全相同</li><li>具体细节参看代码注释</li></ul><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, head: ListNode)</span> -&gt; bool:</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 链表为空或链表长度为1，为回文链</span></span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.next <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 反转链表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(head)</span>:</span></span><br><span class="line">        pre, cur = <span class="literal">None</span>, head</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            temp = cur.next        </span><br><span class="line">            cur.next = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = temp        </span><br><span class="line">        <span class="keyword">return</span> pre</span><br><span class="line">    </span><br><span class="line">    fast, slow = head.next, head</span><br><span class="line">    <span class="comment"># 查找中间节点</span></span><br><span class="line">    <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">        fast, slow = fast.next.next, slow.next</span><br><span class="line">        <span class="keyword">if</span> fast == slow:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 指向两子链表头节点        </span></span><br><span class="line">    p, q = head, slow.next</span><br><span class="line">    <span class="comment"># 断开链表</span></span><br><span class="line">    slow.next = <span class="literal">None</span></span><br><span class="line">    <span class="comment"># 反转后半部分链表</span></span><br><span class="line">    q = reverse(q)</span><br><span class="line">    <span class="keyword">while</span> p <span class="keyword">and</span> q:</span><br><span class="line">        <span class="comment"># 中间存在不相等节点</span></span><br><span class="line">        <span class="keyword">if</span> p.val != q.val:</span><br><span class="line">            <span class="keyword">return</span> Fasle  </span><br><span class="line">        p, q = p.next, q.next</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之环形链表Ⅱ</title>
      <link href="/passages/leetcode-zhi-huan-xing-lian-biao-ii/"/>
      <url>/passages/leetcode-zhi-huan-xing-lian-biao-ii/</url>
      
        <content type="html"><![CDATA[<p>Linked List Cycle Ⅱ</p><a id="more"></a><h3 id="Linked-List-Cycle-Ⅱ"><a href="#Linked-List-Cycle-Ⅱ" class="headerlink" title="Linked List Cycle Ⅱ"></a>Linked List Cycle Ⅱ</h3><ul><li>code with Python</li><li>title number：142</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个链表，返回链表开始<strong>入环的第一个节点</strong>。</li><li>如果链表中不存在环， 返回<code>None</code></li><li>链表<strong>不允许修改</strong></li></ul><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li><p>首先要判断链表中是否存在环，使用快慢指针即可</p></li><li><p>其次查找链表中入环的第一个节点（有点绕，自己画个示意图）</p><ul><li><p>假设，头结点到链表入环的第一个节点的长度为<strong><code>a</code></strong>（a的值即为所求）</p></li><li><p>假设，环的长度为<strong><code>b</code></strong></p></li></ul></li><li><p><strong>分析</strong></p><ul><li>两节点相遇时，慢指针走过的长度必<strong>小于<code>a+b</code></strong>（假设为<code>a+x</code>）</li><li>快指针必定已经走完至少一圈环（假设为<code>m</code>圈）</li><li>此时有：快指针走过的长度为<code>a + mb + x</code>，慢指针走过的长度为<code>a + x</code></li><li>快指针走过的长度是慢指针的两倍，故<code>a + mb + x = 2*(a + x)</code>，可得<code>a = mb - x</code></li></ul></li><li><p><strong>方法</strong></p><ul><li>在两指针相遇时，在头结点出设置一指针，令其与快指针同步移动（每次一个位置）</li><li>两指针相遇的位置即为环的入口</li><li>证明如下：<ul><li>新指针到达入口需要走的长度为<code>a</code></li><li>快指针再走<code>a</code>总长度为<code>a + mb + x + mb - x = a + 2*mb</code>，即刚好走完两个环，到达环的入口位置</li></ul></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">    </span><br><span class="line">fast, slow = head, head</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">        fast = fast.next.next</span><br><span class="line">        slow = slow.next</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 有环</span></span><br><span class="line">      <span class="keyword">if</span> fast == slow:</span><br><span class="line">        meetNode = slow</span><br><span class="line">            start = head</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">while</span> meetNode != start:</span><br><span class="line">                meetNode, start = meetNode.next, start.next     </span><br><span class="line">            <span class="keyword">return</span> meetNode</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之环形链表</title>
      <link href="/passages/leetcode-zhi-huan-xing-lian-biao/"/>
      <url>/passages/leetcode-zhi-huan-xing-lian-biao/</url>
      
        <content type="html"><![CDATA[<p>Linked List Cycle</p><a id="more"></a><h3 id="Linked-List-Cycle"><a href="#Linked-List-Cycle" class="headerlink" title="Linked List Cycle"></a>Linked List Cycle</h3><ul><li>code with Python</li><li>title number：141</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个链表，判断链表中是否存在<strong>环</strong></li></ul><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>快慢指针</li><li>如果链表中存在环，则两指针必会相遇</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head: ListNode)</span> -&gt; bool:</span></span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    fast, slow = head.next, head</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">        fast = fast.next.nxt</span><br><span class="line">        slow = slow.next</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果有环，则跳不出循环</span></span><br><span class="line">        <span class="keyword">if</span> fast == slow:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 跳出循环则无环    </span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之重排列表</title>
      <link href="/passages/leetcode-zhi-chong-pai-lie-biao/"/>
      <url>/passages/leetcode-zhi-chong-pai-lie-biao/</url>
      
        <content type="html"><![CDATA[<p>Reorder List</p><a id="more"></a><h3 id="Reorder-List"><a href="#Reorder-List" class="headerlink" title="Reorder List"></a>Reorder List</h3><ul><li>code with Python</li><li>title number：143</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个链表，形如：<ul><li><code>L : L0 -&gt; L1 -&gt; L2 -&gt; … -&gt; Ln-1 -&gt; Ln</code></li></ul></li><li>将其重新排序为：<ul><li><code>L : L0 -&gt; Ln -&gt; L1 -&gt; Ln-1 -&gt; …</code></li></ul></li><li>不能仅交换节点内部的值，需要进行实际的节点交换</li></ul><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li><strong>实名反对所有使用栈和列表等外部结构的解法</strong></li><li>算法分为三部分：<ul><li>查找前后两部分的分割点 —— 快慢指针查找中点</li><li>反转后半部分的链表</li><li>将两部分链表进行拼接 —— 两个指针遍历两个链表</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reorderList</span><span class="params">(self, head: ListNode)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    <span class="comment"># 反转链表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(head)</span>:</span></span><br><span class="line">        pre, cur = <span class="literal">None</span>, head</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            temp = cur.next</span><br><span class="line">            cur.next = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = temp</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> cur</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 快慢指针查找中间节点</span></span><br><span class="line">    fast, slow = head.next, head</span><br><span class="line">    <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">        fast = fast.next.next</span><br><span class="line">        slow = slow.next</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取后半部分的头节点，截断两部分链表</span></span><br><span class="line">    last_part, slow.next = slow.next, <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    last_part = reverse(last_part)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 两个指针用于遍历两个子链表</span></span><br><span class="line">    p, q = head, last_part</span><br><span class="line">    <span class="keyword">while</span> p <span class="keyword">and</span> q:</span><br><span class="line">        p_temp, q_temp = p.next, q.next</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 链接</span></span><br><span class="line">        p.next = q</span><br><span class="line">        q.next = p_temp</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 指针后移</span></span><br><span class="line">        p, q = p_temp, q_temp</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之排序链表</title>
      <link href="/passages/leetcode-zhi-pai-xu-lian-biao/"/>
      <url>/passages/leetcode-zhi-pai-xu-lian-biao/</url>
      
        <content type="html"><![CDATA[<p>Sort List</p><a id="more"></a><h3 id="Sort-List"><a href="#Sort-List" class="headerlink" title="Sort List"></a>Sort List</h3><ul><li>code with Python</li><li>title number：148</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>在<code>O(nlogn)</code>的<strong>时间复杂度</strong>和<strong>常数级空间复杂度</strong>下，对链表进行排序</li></ul><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li><p>常见的排序算法都可以在链表上应用，只不过为了追求操作上的简便，一些方法我们一般不用，例如：</p><ul><li>快速排序：需要使用首尾指针，对于单链表来说不容易实现</li></ul></li><li><p>通常我们只考虑只需要比较相邻元素的排序算法</p></li><li><p>链表结构不同与顺序结构：</p><ul><li>不支持随机访问，只能单向遍历</li><li>节点交换涉及至少三个节点（单链表），操作繁琐</li></ul></li><li><p>这里要求常数级空间复杂度和<code>O(nlogn)</code>的时间复杂度，所以我们选择<strong>归并排序</strong></p><ul><li>归并排序采用分治法的思想，将已有序的子序列合并，得到完全有序的子序列</li><li>可以很方便的使用递归的方式实现</li></ul></li><li><p>递归实现链表的归并排序有两个环节：</p><ul><li>分割环节<ul><li>找到链表的中点（使用快慢指针，快指针每次移动两个位置，慢指针每次移动一个位置），将链表切断</li><li>递归分割链表</li></ul></li><li>合并环节<ul><li>双指针法进行合并</li><li>使用辅助节点作为头部，比较两个待合并的链表中元素的大小，将合适的加到辅助节点的后面</li></ul></li></ul></li></ul><p><img src="https://pic.leetcode-cn.com/8c47e58b6247676f3ef14e617a4686bc258cc573e36fcf67c1b0712fa7ed1699-Picture2.png" alt></p><ul><li>盗张图，演示一下😜😜😜</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">    <span class="comment"># 链表为空 or 只包含一个节点</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 快慢指针查找中间位置</span></span><br><span class="line">    slow, fast = head, head.next</span><br><span class="line">    <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">        fast, slow = fast.next.next, slow.next</span><br><span class="line">    mid, slow.next = slow.next, <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 递归分割</span></span><br><span class="line">    left, right = self.sortList(head), self.sortList(mid)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 双指针进行合并</span></span><br><span class="line">    h = res = ListNode(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">while</span> left <span class="keyword">and</span> right:</span><br><span class="line">        <span class="comment"># 左子链中当前节点更小</span></span><br><span class="line">        <span class="keyword">if</span> left.val &lt; right.val:</span><br><span class="line">            h.next, left = left, left.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            h.next, right = right, right.next</span><br><span class="line">        h = h.next</span><br><span class="line">    h.next = left <span class="keyword">if</span> left <span class="keyword">else</span> right</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res.next</span><br></pre></td></tr></table></figure><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li>这是一种比较<strong>讨巧</strong>的方法</li><li>通过一次遍历，将链表中的元素全部读取到数组中</li><li>对数组中的元素进行排序（选择符合复杂度要求的排序算法）</li><li>最后将有序数组依次写入链表节点中</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">    p = head</span><br><span class="line">    arr = []</span><br><span class="line">    <span class="keyword">while</span> p:</span><br><span class="line">        arr.append(p.val)</span><br><span class="line">        p = p.next</span><br><span class="line">    </span><br><span class="line">    arr.sort()</span><br><span class="line">    p, i = head, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> p:</span><br><span class="line">        p.val = arr[i]</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        p = p.next</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之删除排序链表中的重复元素Ⅱ</title>
      <link href="/passages/leetcode-zhi-shan-chu-pai-xu-lian-biao-zhong-de-chong-fu-yuan-su-ii/"/>
      <url>/passages/leetcode-zhi-shan-chu-pai-xu-lian-biao-zhong-de-chong-fu-yuan-su-ii/</url>
      
        <content type="html"><![CDATA[<p>Remove Duplicates from Sorted List Ⅱ</p><a id="more"></a><h3 id="Remove-Duplicates-from-Sorted-List-Ⅱ"><a href="#Remove-Duplicates-from-Sorted-List-Ⅱ" class="headerlink" title="Remove Duplicates from Sorted List Ⅱ"></a>Remove Duplicates from Sorted List Ⅱ</h3><ul><li>code with Python</li><li>title number：82</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个排序链表，删除所有含有重复数字的节点</li><li>最终链表中只保留原始链表中没有重复出现的数字</li></ul><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>本题的特殊之处在于：删除所有重复的节点，即头结点也有可能被删除</li><li>故这里需要使用<code>dummpy</code>头结点</li><li>具体思路结合代码注释理解</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">    <span class="comment"># 创建虚拟节点</span></span><br><span class="line">    dummp_node = TreeNode(<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 添加到头结点之前</span></span><br><span class="line">    dummp_node.next = head</span><br><span class="line">    <span class="comment"># 将头指针指向虚拟节点</span></span><br><span class="line">    head = dummpy_node</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> head.next <span class="keyword">and</span> head.next.next:</span><br><span class="line">        <span class="comment"># 出现连续相同的元素</span></span><br><span class="line">        <span class="keyword">if</span> head.next.val == head.next.next.val:</span><br><span class="line">            <span class="comment"># 依次删除</span></span><br><span class="line">            val = head.next.val</span><br><span class="line">            <span class="keyword">while</span> head.next <span class="keyword">and</span> head.next.val == val:</span><br><span class="line">                head.next = head.next.next</span><br><span class="line">        <span class="comment"># 头指针向后移</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            head = head.next</span><br><span class="line">    <span class="keyword">return</span> dummp_node.next</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之删除排序链表中的重复元素</title>
      <link href="/passages/leetcode-zhi-shan-chu-pai-xu-lian-biao-zhong-de-chong-fu-yuan-su/"/>
      <url>/passages/leetcode-zhi-shan-chu-pai-xu-lian-biao-zhong-de-chong-fu-yuan-su/</url>
      
        <content type="html"><![CDATA[<p>Remove Duplicates from Sorted List</p><a id="more"></a><h3 id="Remove-Duplicates-from-Sorted-List"><a href="#Remove-Duplicates-from-Sorted-List" class="headerlink" title="Remove Duplicates from Sorted List"></a>Remove Duplicates from Sorted List</h3><ul><li>code with Python</li><li>title number：83</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个排序数组，删除所有重复的元素，使得每个元素只出现一次</li></ul><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>由于是排序数组，所以相同的元素是连续的</li><li>单指针</li><li>遇到重复项就使用指针指向其下一项，以此来完成删除操作</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicate</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">    temp = head</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> temp:</span><br><span class="line">        <span class="keyword">while</span> temp.next <span class="keyword">and</span> temp.val == temp.next.val:</span><br><span class="line">            temp.next = temp.next.next</span><br><span class="line">        temp = temp.next</span><br><span class="line">    <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之二叉搜索树中的插入操作</title>
      <link href="/passages/leetcode-zhi-er-cha-sou-suo-shu-zhong-de-cha-ru-cao-zuo/"/>
      <url>/passages/leetcode-zhi-er-cha-sou-suo-shu-zhong-de-cha-ru-cao-zuo/</url>
      
        <content type="html"><![CDATA[<p>Insert into a Binary Search Tree</p><a id="more"></a><h3 id="Insert-into-a-Binary-Search-Tree"><a href="#Insert-into-a-Binary-Search-Tree" class="headerlink" title="Insert into a Binary Search Tree"></a>Insert into a Binary Search Tree</h3><ul><li>code with Python</li><li>title number：701</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一棵二叉搜索树的根节点以及要插入树总的值，将值插入二叉搜索树</li><li>返回插入后二叉搜索树的根节点</li></ul><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li><p>二叉搜索树的新插入节点比定位叶子节点</p></li><li><p>二叉搜索树是一种递归结构，即左孩子小于根节点的值，右孩子大于根节点的值</p></li><li><p>使用<strong>递归</strong>的方式查找待插入的位置，在合适的位置穿件新节点并连接到树中即可</p></li><li><p>返回根节点</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertIntoBST</span><span class="params">(self, root: TreeNode, val: int)</span> -&gt; TreeNode:</span></span><br><span class="line">    <span class="comment"># 插入位置</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        root = TreeNode(val)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    <span class="comment"># 递归在右子树中查找插入位置</span></span><br><span class="line">    <span class="keyword">if</span> root.val &lt; val:</span><br><span class="line">        root.right = self.insertIntoBST(root.right, val)</span><br><span class="line"><span class="comment"># 递归在左子树中查找插入位置</span></span><br><span class="line">    <span class="keyword">if</span> root.val &gt; val:</span><br><span class="line">        root.left = self.insertIntoBST(root.left, val)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><br><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li>还是上面的思路，使用迭代的方式进行</li><li>沿着树结构不断查找合适的插入位置，到达根节点后穿件新节点插入</li><li>单独处理树为空的情况</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertIntoBST</span><span class="params">(self, root: TreeNode, val: int)</span> -&gt; TreeNode:</span></span><br><span class="line">    node = root</span><br><span class="line">    <span class="comment"># 迭代查找插入位置，并插入</span></span><br><span class="line">    <span class="keyword">while</span> node:</span><br><span class="line">        <span class="keyword">if</span> val &gt; node.val:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                node.right = TreeNode(val)</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node = node.right</span><br><span class="line">        <span class="keyword">if</span> val &lt; node.val:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left:</span><br><span class="line">                node.left = TreeNode(val)</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node = node.left</span><br><span class="line">    <span class="comment"># 处理根节点为空的情况</span></span><br><span class="line">    <span class="keyword">return</span> TreeNode(val)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之二叉树的层序遍历Ⅱ</title>
      <link href="/passages/leetcode-zhi-er-cha-shu-de-ceng-xu-bian-li-ii/"/>
      <url>/passages/leetcode-zhi-er-cha-shu-de-ceng-xu-bian-li-ii/</url>
      
        <content type="html"><![CDATA[<p>Binary Tree Level Order Traversal Ⅱ</p><a id="more"></a><h3 id="Binary-Tree-Level-Order-Traversal-Ⅱ"><a href="#Binary-Tree-Level-Order-Traversal-Ⅱ" class="headerlink" title="Binary Tree Level Order Traversal Ⅱ"></a>Binary Tree Level Order Traversal Ⅱ</h3><ul><li>code with Python</li><li>title number：107</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一棵二叉树，返回其节点值自底向上的层次遍历。</li><li>按叶子节点所在的层到根节点所在的层，逐层从左向右遍历</li></ul><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>按照正常的自顶向下的方式进行层序遍历</li><li>对遍历结果的顺序进行翻转</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">levelOrderBottom</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    </span><br><span class="line">    queue = [root]</span><br><span class="line">    res = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        len_ len(queue)</span><br><span class="line">        res.append([])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len_):</span><br><span class="line">            node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            </span><br><span class="line">            res[<span class="number">-1</span>].append(node.val)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">    res = res[::<span class="number">-1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><br><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li>沿用上面的思路，调整添加当前层结果到结果集中的位置，省去最后翻转的过程<ul><li>自顶向下进行层序遍历</li><li>每次都将当前层的遍历结果添加到结果集的头部</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">levelOrderBottom</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    </span><br><span class="line">    queue = [root]</span><br><span class="line">    res = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        len_ len(queue)</span><br><span class="line">        res.insert(<span class="number">0</span>, [])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len_):</span><br><span class="line">            node = queue.pop(<span class="number">0</span>) </span><br><span class="line">            res[<span class="number">0</span>].append(node.val)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之平衡二叉树</title>
      <link href="/passages/leetcode-zhi-ping-heng-er-cha-shu/"/>
      <url>/passages/leetcode-zhi-ping-heng-er-cha-shu/</url>
      
        <content type="html"><![CDATA[<p>Balanced Binary Tree</p><a id="more"></a><h3 id="Balanced-Binary-Tree"><a href="#Balanced-Binary-Tree" class="headerlink" title="Balanced Binary Tree"></a>Balanced Binary Tree</h3><ul><li>code with Python</li><li>title number：110</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一棵二叉树，判断它是否为<strong>平衡二叉树</strong></li><li>平衡二叉树的定义为：<ul><li><strong>二叉树中，每个节点的左右两棵子树的高度差的绝对值不超过1</strong></li></ul></li></ul><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li><p>题目的关键在于：<strong>得到每个节点的高度</strong></p></li><li><p>关于树形结构，最省心的方法就是<strong>递归</strong></p><ul><li>递归判断每个节点是否为平衡点</li><li>若是，返回<code>True</code>和当前节点高度</li><li>若否，返回<code>False</code>和当前节点高度（统一格式）</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">is_Bala</span><span class="params">(root)</span>:</span></span><br><span class="line">           </span><br><span class="line">       <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">True</span>, <span class="number">0</span></span><br><span class="line">               </span><br><span class="line">       bool_left, left_height = is_Bala(root.left)</span><br><span class="line">       bool_right, right_height = is_Bala(root.right)</span><br><span class="line">           </span><br><span class="line">       <span class="keyword">if</span> bool_left <span class="keyword">and</span> bool_right:</span><br><span class="line">           <span class="keyword">if</span> abs(left_height - right_height) &lt;= <span class="number">1</span>:</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">True</span>, max(left_height, right_height) + <span class="number">1</span></span><br><span class="line">           <span class="keyword">else</span>:</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">False</span>, max(left_height, right_height) + <span class="number">1</span></span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">False</span>, max(left_height, right_height) + <span class="number">1</span></span><br><span class="line">       </span><br><span class="line">   bool_, height = is_Bala(root) </span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> bool_</span><br></pre></td></tr></table></figure><br>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sword-offer-03-数组中的重复元素</title>
      <link href="/passages/sword-offer-03-shu-zu-zhong-de-chong-fu-yuan-su/"/>
      <url>/passages/sword-offer-03-shu-zu-zhong-de-chong-fu-yuan-su/</url>
      
        <content type="html"><![CDATA[<p>Sword Offer</p><a id="more"></a><h3 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h3><ul><li>code with Python</li><li>title number：03</li></ul><br><h3 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h3><ul><li>在一个长度为<code>n</code>的数组<code>nums</code>里的所有数字都在<code>[0, n-1]</code>的范围内</li><li>数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次</li><li>请找出数组中<strong>任意</strong>一个重复的数字</li></ul><br><h3 id="思路一（常规）"><a href="#思路一（常规）" class="headerlink" title="思路一（常规）"></a>思路一（常规）</h3><ul><li>使用字典保存每个元素出现的次数<ul><li>如果不在字典内，则添加</li><li>如果在字典内，直接返回该元素</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findRepeatNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    count = dict()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> count:</span><br><span class="line">            count[num] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> num</span><br></pre></td></tr></table></figure><br><h3 id="思路二（时间优先）"><a href="#思路二（时间优先）" class="headerlink" title="思路二（时间优先）"></a>思路二（时间优先）</h3><ul><li>使用字典保存每个元素出现的次数</li><li>使用排序，将相同元素聚集到一起，加快遇到重复元素的速度</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findRepeatNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    count = dict()</span><br><span class="line">    nums.sort()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> count:</span><br><span class="line">            count[num] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> num</span><br></pre></td></tr></table></figure><br><h3 id="思路三（空间优先）"><a href="#思路三（空间优先）" class="headerlink" title="思路三（空间优先）"></a>思路三（空间优先）</h3><ul><li>原地哈希<ul><li>不使用额外的空间来保存字典</li><li>由于数组中元素的值域为<code>[0, len(nums)]</code>，所以可以利用第<code>i</code>个位置存储元素<code>i</code>，如此“<ul><li>当前元素为<code>i</code>，需要与第``i`个位置的元素交换</li><li>如果第<code>i</code>个位置的元素不为<code>i</code>，则执行交换</li><li>如果第<code>i</code>个位置的元素为<code>i</code>，则说明该元素重复了，直接返回</li></ul></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findRepeatNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">while</span> i != nums[i]:</span><br><span class="line">            <span class="keyword">if</span> nums[i] == nums[nums[i]]:</span><br><span class="line">                <span class="keyword">return</span> nums[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                temp = nums[i]</span><br><span class="line">                nums[i], nums[temp] = nums[temp], nums[i]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Sword Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python环境配置</title>
      <link href="/passages/python-huan-jing-pei-zhi/"/>
      <url>/passages/python-huan-jing-pei-zhi/</url>
      
        <content type="html"><![CDATA[<p>Python环境配置</p><a id="more"></a><h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><ul><li>现在百度来的环境配置教程太<del>繁</del>琐~，且不友好，遂整理出这篇博文，希望对看到的你有所帮助</li><li>中间遇到问题或错误，欢迎交流指正</li><li><strong>内容仅针对Window10，MaxOS可自行百度</strong></li></ul><br><h3 id="你需要下载这些东西"><a href="#你需要下载这些东西" class="headerlink" title="你需要下载这些东西"></a>你需要下载这些东西</h3><ul><li><p>Python3.x，在<a href="https://www.python.org/downloads/windows/" target="_blank" rel="noopener">这里</a>下载你顺眼的版本，</p><ul><li>不要用最新的，推荐<strong>3.6或者3.7</strong></li><li>下载带<strong>executable installer</strong>且<strong>x86-64</strong>字样的，省心</li></ul><img src="/.top//python.png" style="zoom:60%;"></li><li><p>Pycharm</p><ul><li>在<a href="https://www.jetbrains.com/pycharm/download/#section=windows" target="_blank" rel="noopener">这里</a>下载，有两种可选<ul><li>专业版，功能齐全，需要PJ</li><li>社区版，功能经过阉割，无需PJ，免费使用</li></ul></li><li>社区版足够使用，如需进行网页开发，Python开发及远程连接功能，请下载专业版</li><li>PJ教程参考<a href="https://shimo.im/docs/DJ3h3tJv98ppTYyH/read" target="_blank" rel="noopener">一份香甜的免费午餐</a></li></ul></li></ul><br><h3 id="只需以下几步"><a href="#只需以下几步" class="headerlink" title="只需以下几步"></a>只需以下几步</h3><ul><li><p>对于下载好的Python3.x，双击</p></li><li><p><strong>需要注意的来了</strong>（两点）</p><img src="/.top//install.png" style="zoom:70%;"><ul><li>直接点击<code>Install Now</code>会安装到寸土寸金的<code>C</code>盘，所以我们选择下面的<code>Customize installation</code></li><li>之后一路<code>Next</code>，直到：</li></ul><img src="/.top//advance.png" style="zoom:67%;"><ul><li>勾选红色箭头所指的选项，其他的凭个人喜好</li><li>下面的<code>Customize install location</code>选择一个位置（尽量不要是C盘，最好是盘符下的根目录，该文件夹需自行创建），例如<code>D:\Python3.8</code></li><li>等待安装完成，打开<code>cmd</code>——组合键<code>win+R</code>，输入<code>cmd</code></li><li>在命令行界面输入<code>python</code>，出现版本等信息证明安装成功，输入<code>exit()</code>即可退出<code>Python</code>环境</li></ul></li><li><p><strong><code>Pycharm</code></strong></p><ul><li>正常安装即可，没有需要注意的地方</li><li>安装之后打开（截图来自专业版，实际都大同小异）</li></ul><img src="/.top//pycharm.png" style="zoom:67%;"><ul><li><p><code>location</code>处，取一个你喜欢的响当当的名字~，例如：’python_learn’。这个是工程的名字，即一个文件夹，下面可以有很多<code>python</code>文件</p></li><li><p><code>Project Interpreter</code>处选择<code>Existing interpreter</code>，找到之前安装的python</p></li><li><p>不推荐使用虚拟环境，也就是上面的<code>New environment</code>，这个会创建一个基于本工程的Python环境。如果使用的话注意这个会下载python文件用于编译该工程的文件，需等待片刻才能使用</p></li><li><p>进入工程后，创建文件</p><img src="/.top//create.png" style="zoom:67%;"></li><li><p>输入内容并编译执行，即可得到代码执行后的内容</p><img src="/.top//test.png" style="zoom:60%;"></li></ul></li><li><p>后续如果想要使用更多的Python包，可使用Anaconda——一款Python的集成环境，预装了很多常用工具包，使用<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/" target="_blank" rel="noopener">清华源</a>下载更快</p><p><img src="/.top//Python%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%5Cana.png" alt></p></li></ul><p>完结，撒花🎈🎈🎈</p>]]></content>
      
      
      <categories>
          
          <category> 工具配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之每个元音包含偶数次的最长子字符串</title>
      <link href="/passages/leetcode-zhi-mei-ge-yuan-yin-bao-han-ou-shu-ci-de-zui-chang-zi-zi-fu-chuan/"/>
      <url>/passages/leetcode-zhi-mei-ge-yuan-yin-bao-han-ou-shu-ci-de-zui-chang-zi-zi-fu-chuan/</url>
      
        <content type="html"><![CDATA[<p>Find the Longest Substring Containing Vowels in Even Counts</p><a id="more"></a><h3 id="Find-the-Longest-Substring-Containing-Vowels-in-Even-Counts"><a href="#Find-the-Longest-Substring-Containing-Vowels-in-Even-Counts" class="headerlink" title="Find the Longest Substring Containing Vowels in Even Counts"></a>Find the Longest Substring Containing Vowels in Even Counts</h3><ul><li>code with Python</li><li>title numbers：1371</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li><p>给定一个字符串<code>s</code>，返回满足下列条件的最长字符串的长度</p><ul><li>每个出现在子串中的元音字母（<code>a, e, i, o, u</code>）都恰好出现了偶数次</li></ul></li><li><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;eleetminicoworoep&quot;</span><br><span class="line">输出：13</span><br><span class="line">解释：最长子字符串是 &quot;leetminicowor&quot; ，它包含 e，i，o 各 2 个，以及 0 个 a，u</span><br></pre></td></tr></table></figure></li></ul><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>暴力+剪枝<ul><li>双层循环找到所有的子串，对每个子串统计元音字母的个数，如果满足条件，则更新最长字符串的长度</li><li>可以反向枚举，即从最长的子串开始枚举，这样就可以更快的接近答案</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findTheLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s), <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(s) - i + <span class="number">1</span>):</span><br><span class="line">            sub = s[j:j + i]</span><br><span class="line">            has_odd_vowel = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">for</span> vowel <span class="keyword">in</span> [<span class="string">'a'</span>, <span class="string">'e'</span>, <span class="string">'i'</span>, <span class="string">'o'</span>, <span class="string">'u'</span>]:</span><br><span class="line">                <span class="keyword">if</span> sub.count(vowel) % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">                    has_odd_vowel = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> has_odd_vowel: <span class="keyword">return</span>  i</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><br><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li>我们知道枚举所有子串是会有很多重复统计的</li><li>简化这部分操作会使时间复杂度显著降低<ul><li>对每个字母维护一个前缀和，<code>p[i][k]</code>表示字符串前<code>i</code>个字符中，第<code>k</code>个原因字母出现的次数</li><li>此时如果要判断子串<code>[l:r]</code>是否满足条件，就可以使用<code>p[r][k]-p[l-1][k]</code>来直接得到该子串中第<code>k</code>个元音字母是否满足条件</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">i_mapper = &#123;</span><br><span class="line">    <span class="string">"a"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">"e"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">"i"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">"o"</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="string">"u"</span>: <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(self, s, pre, l, r)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        <span class="keyword">if</span> s[l] <span class="keyword">in</span> self.i_mapper <span class="keyword">and</span> i == self.i_mapper[s[l]]: cnt = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (pre[r][i] - pre[l][i] + cnt) % <span class="number">2</span> != <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findTheLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">    n = len(s)</span><br><span class="line"></span><br><span class="line">    pre = [[<span class="number">0</span>] * <span class="number">5</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># pre</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">in</span> self.i_mapper <span class="keyword">and</span> self.i_mapper[s[i]] == j:</span><br><span class="line">                pre[i][j] = pre[i - <span class="number">1</span>][j] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre[i][j] = pre[i - <span class="number">1</span>][j]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n - i):</span><br><span class="line">            <span class="keyword">if</span> self.check(s, pre, j, i + j):</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之阈值距离内邻居最少的城市</title>
      <link href="/passages/leetcode-zhi-yu-zhi-ju-chi-nei-lin-ju-zui-shao-de-cheng-shi/"/>
      <url>/passages/leetcode-zhi-yu-zhi-ju-chi-nei-lin-ju-zui-shao-de-cheng-shi/</url>
      
        <content type="html"><![CDATA[<p>Find the City With the Smallest Number of Neighbors at a Threshold Distance</p><a id="more"></a><h3 id="Find-the-City-With-the-Smallest-Number-of-Neighbors-at-a-Threshold-Distance"><a href="#Find-the-City-With-the-Smallest-Number-of-Neighbors-at-a-Threshold-Distance" class="headerlink" title="Find the City With the Smallest Number of Neighbors at a Threshold Distance"></a>Find the City With the Smallest Number of Neighbors at a Threshold Distance</h3><ul><li>code with Python</li><li>title number：1334</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li><p>有<code>n</code>个城市，按<code>0</code>到<code>n-1</code>编号</p></li><li><p>给你一个边数组<code>edges</code>，其中<code>edges[i]=[from_i, to_i, weight_i]</code>，代表的是从<code>from_i</code>到<code>to_i</code>两个城市之间的双向加权边</p></li><li><p>距离阈值是一个整数<code>distanceThreshold</code></p></li><li><p>返回能通过某些路径到达其他城市<strong>数目最多，且路径距离最大为distanceThreshold</strong>的城市</p></li><li><p>如果有多个这样的城市，则返回编号最大的</p></li><li><p>示例：</p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/26/find_the_city_01.png" style="zoom:30%;"><ul><li>在上图中，设距离阈值为<code>4</code></li><li>每个城市阈值距离范围内的邻居城市如下<ul><li>城市0：城市1，城市2</li><li>城市1：城市0，城市2，城市3</li><li>城市2：城市0，城市1，城市3</li><li>城市3：城市1，城市2</li></ul></li><li><strong>返回3</strong>（编号最大，邻居最少）</li></ul></li></ul><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>问题的本质是查找两个城市之间的最短路径</li><li>对于多源最短路径，我们使用<code>Floyd-Warshall</code>算法<ul><li>得到各个城市之间的最短路径</li><li>对每个城市筛选距离不大于阈值的邻居城市</li><li>最后统计每个城市满足条件的城市</li><li>返回邻居城市最少且编号最大的城市</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findTheCity</span><span class="params">(self, n: int, edges: List[List[int]], distanceThreshold: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="comment"># distance矩阵，二维矩阵</span></span><br><span class="line">    dist = [[float(<span class="string">'inf'</span>)] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">    <span class="comment"># 初始化</span></span><br><span class="line">    <span class="keyword">for</span> i, j, w <span class="keyword">in</span> edges:</span><br><span class="line">        dist[i][j] = w</span><br><span class="line">        dist[j][i] = w</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        dist[i][i] = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 求最短</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 过滤</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    minCnt = float(<span class="string">'inf'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> d <span class="keyword">in</span> dist[i]:</span><br><span class="line">            <span class="keyword">if</span> d &lt;= distanceThreshold:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> cnt &lt;= minCnt:</span><br><span class="line">            minCnt = cnt</span><br><span class="line">            res = i</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之子数组异或查询</title>
      <link href="/passages/leetcode-zhi-zi-shu-zu-yi-huo-cha-xun/"/>
      <url>/passages/leetcode-zhi-zi-shu-zu-yi-huo-cha-xun/</url>
      
        <content type="html"><![CDATA[<p>XOR Queries of a Subarray</p><a id="more"></a><h3 id="XOR-Queries-of-a-Subarray"><a href="#XOR-Queries-of-a-Subarray" class="headerlink" title="XOR Queries of a Subarray"></a>XOR Queries of a Subarray</h3><ul><li>code with Python</li><li>title number：1310</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li><p>有一个正整数数组<code>arr</code>，现给定一个对应的查询数组<code>queries</code>，其中<code>queries[i]</code>= $[L_i, R_i]$</p></li><li><p>对于每个查询<code>i</code>，请计算从<code>Li</code>到<code>Ri</code>的<strong>XOR</strong>值（即<code>arr[i] xor arr[Li+1] xor .. xor arr[Ri]​</code>）作为本次查询的结果</p></li><li><p>并返回一个包含给定查询<code>queries</code>所有结果的数组</p></li><li><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：arr &#x3D; [1,3,4,8], queries &#x3D; [[0,1],[1,2],[0,3],[3,3]]</span><br><span class="line">输出：[2,7,14,8] </span><br><span class="line">解释：</span><br><span class="line">数组中元素的二进制表示形式是：</span><br><span class="line">1 &#x3D; 0001 </span><br><span class="line">3 &#x3D; 0011 </span><br><span class="line">4 &#x3D; 0100 </span><br><span class="line">8 &#x3D; 1000 </span><br><span class="line">查询的 XOR 值为：</span><br><span class="line">[0,1] &#x3D; 1 xor 3 &#x3D; 2 </span><br><span class="line">[1,2] &#x3D; 3 xor 4 &#x3D; 7 </span><br><span class="line">[0,3] &#x3D; 1 xor 3 xor 4 xor 8 &#x3D; 14 </span><br><span class="line">[3,3] &#x3D; 8</span><br></pre></td></tr></table></figure></li></ul><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>直接线上暴力解法<ul><li>双层循环</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xorQueries</span><span class="params">(self, arr: List[int], queriesL List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> (L, R) <span class="keyword">in</span> queries:</span><br><span class="line">        i = L</span><br><span class="line">        xor = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; R:</span><br><span class="line">            xor ^= arr[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        res.append(xor)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><ul><li>毫无悬念的超时了</li></ul><br><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li><p>前缀表达式</p></li><li><p>我们使用一个数组<code>pre</code>来表示数组<code>arr</code>的<strong>前缀异或和</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pre[0] &#x3D; 0</span><br><span class="line">pre[i] &#x3D; arr[0] ^ arr[1] ... ^ arr[i-1]</span><br></pre></td></tr></table></figure></li><li><p>这样以来，我们要计算<code>arr[Li]</code>到<code>arr[Ri]</code>的异或值时，我们可以通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pre[Li] ^ pre[Ri+1] </span><br><span class="line">&#x3D; (arr[0] ^ ... ^ arr[Li-1])^(arr[0] ^ ... ^ arr[Ri])</span><br><span class="line">&#x3D; (arr[0] ^ ... ^ arr[Li - 1]) ^ (arr[0] ^ ... ^ arr[Li - 1]) ^ (arr[Li] ^ ... ^ arr[Ri]) （异或运算的结合律）</span><br><span class="line">&#x3D; 0 ^ (arr[Li] ^ ... ^ arr[Ri]) （异或运算的逆运算，即 a ^ a &#x3D; 0）</span><br><span class="line">&#x3D; arr[Li] ^ ... ^ arr[Ri]</span><br></pre></td></tr></table></figure></li><li><p>总的来说，需要知道异或运算的一个规律，即<code>x ^ y ^ x = y</code></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xorQueries</span><span class="params">(self, arr: List[int], queriesL List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">pre = [<span class="number">0</span>]</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">        pre.append(pre[i] ^ arr[i])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (L, R) <span class="keyword">in</span> queries:</span><br><span class="line">        res.append(pre[L] ^ pre[R + <span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之子串出现的最大次数</title>
      <link href="/passages/leetcode-zhi-zi-chuan-chu-xian-de-zui-da-ci-shu/"/>
      <url>/passages/leetcode-zhi-zi-chuan-chu-xian-de-zui-da-ci-shu/</url>
      
        <content type="html"><![CDATA[<p>Maximum Number of Occurrences of a Substring</p><a id="more"></a><h3 id="Maximum-Number-of-Occurrences-of-a-Substring"><a href="#Maximum-Number-of-Occurrences-of-a-Substring" class="headerlink" title="Maximum Number of Occurrences of a Substring"></a>Maximum Number of Occurrences of a Substring</h3><ul><li>code with Python</li><li>title number：1297</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li><p>给定一个字符串<code>S</code>，返回满足下列条件且出现次数最大的<strong>任意</strong>子串的出现次数：</p><ul><li>子串中不同字母的数目必须小于等于<code>maxLetters</code></li><li>子串的长度必须大于等于<code>minSize</code>且小于等于<code>maxSize</code></li></ul></li><li><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;aababcaab&quot;, maxLetters &#x3D; 2, minSize &#x3D; 3, maxSize &#x3D; 4</span><br><span class="line">输出：2</span><br><span class="line">解释：子串 &quot;aab&quot; 在原字符串中出现了 2 次。</span><br><span class="line">它满足所有的要求：2 个不同的字母，长度为 3 （在 minSize 和 maxSize 范围内）。</span><br></pre></td></tr></table></figure></li></ul><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>尝试暴力解法：<ul><li>找出所有满足长度要求（<code>[minSize, maxSize]</code>）的子串</li><li>对于<code>maxLetter</code>满足题意的子串，统计其出现次数</li><li>返回最大的出现次数</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxFreq</span><span class="params">(self, s: str, maxLetters: int, minSize: int, maxSize: int)</span> -&gt; int:</span></span><br><span class="line">    n = len(s)</span><br><span class="line">    letters = set()</span><br><span class="line">    cnts = dict()</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n - minSize + <span class="number">1</span>):</span><br><span class="line">        length = minSize</span><br><span class="line">        <span class="keyword">while</span> i + length &lt;= n <span class="keyword">and</span> length &lt;= maxSize:</span><br><span class="line">            t = s[i:i+length]</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> t:</span><br><span class="line">                <span class="keyword">if</span> len(letters) &gt; maxLetters:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                letters.add(c)</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span> len(letters) &lt;= maxLetters:</span><br><span class="line">                cnts[t] = cnts.get(t, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">                res = max(res, cnts[t])</span><br><span class="line">            letters.clear()</span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><ul><li>代码超时</li></ul><br><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li>我们尝试在上述思路的基础上进行优化<ul><li>从题目要求中可以分析出——<code>maxSize</code>属于无用信息，不需要考虑，而是只需要统计长度等于<code>minSize</code>的子串即可</li><li>原因是，如果一个长度大于<code>minSize</code>的子串满足条件，那么该子串其中必定至少一个长度为<code>minSize</code>的子串满足条件</li><li>所以如果一个长度大于<code>minSize</code>的子串出现了<code>n</code>次，必定有一个长度为<code>minSize</code>的子串出现了<code>n</code>次</li></ul></li><li>于是题目转化为了一个滑动窗口的问题，我们只需要通过滑动窗口来判断所有长度为<code>minSize</code>的子串中有多少满足条件即可</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxFreq</span><span class="params">(self, s: str, maxLetters: int, minSize: int, maxSize: int)</span> -&gt; int:</span></span><br><span class="line">    counter, res = &#123;&#125;, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(s) - minSize + <span class="number">1</span>):</span><br><span class="line">        sub = s[i: i + minSize]</span><br><span class="line">        <span class="keyword">if</span> len(set(sub)) &lt;= maxLetters:</span><br><span class="line">            counter[sub] = counter.get(sub, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            res = max(res, counter[sub])</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之可被三整除的最大和</title>
      <link href="/passages/leetcode-zhi-ke-bei-san-zheng-chu-de-zui-da-he/"/>
      <url>/passages/leetcode-zhi-ke-bei-san-zheng-chu-de-zui-da-he/</url>
      
        <content type="html"><![CDATA[<p>Greatest Sum Divisible by Three</p><a id="more"></a><h3 id="Greatest-Sum-Divisible-by-Three"><a href="#Greatest-Sum-Divisible-by-Three" class="headerlink" title="Greatest Sum Divisible by Three"></a>Greatest Sum Divisible by Three</h3><ul><li>code with Python</li><li>title number：1262</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个数组，找出并返回可被三整除的元素最大和</li><li>示例：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [3,6,5,1,8]</span><br><span class="line">输出：18</span><br><span class="line">解释：选出数字 3, 6, 1 和 8，它们的和是 18（可被 3 整除的最大和）</span><br></pre></td></tr></table></figure><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>比较暴力的想法是穷举所有可能的组合，然后判断是否可被三整除</li><li>由于<code>nums</code>的长度为<code>[1, 4*10^4]</code>，这种方法必定会超时</li></ul><br><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li>排序+减法<ul><li>我们首先计算出所有元素的总和并判断是否能被三整除</li><li>如果能整除，即余数为<code>0</code>，则直接返回结果</li><li>如果不能整除，可能的情况有两种：余数为<code>1</code>或余数为<code>2</code></li><li>针对这两种情况，我们分别建立数组<code>one</code>和<code>two</code>，数组内元素被<strong>排序</strong></li><li>两个数组分别存储余数为<code>1</code>和余数为<code>2</code>的元素</li></ul></li><li>如果余数为<code>1</code>，我们减去<code>one</code>数组中最小的元素，或者减去<code>two</code>数组中最小的两个元素。取决于两者谁更小</li><li>如果余数为<code>1</code>，我们减去<code>two</code>数组中最小的元素，或者减去<code>one</code>数组中最小的两个元素。取决于两者谁更小</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxSumDivThree</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    one, two = [], []</span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        total += num</span><br><span class="line">        <span class="keyword">if</span> num % <span class="number">3</span> == <span class="number">1</span>:</span><br><span class="line">            one.append(num)</span><br><span class="line">        <span class="keyword">if</span> num % <span class="number">3</span> == <span class="number">2</span>:</span><br><span class="line">            two.append(num)</span><br><span class="line">    one.sort(), two.sort()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> total % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> total</span><br><span class="line">    <span class="keyword">elif</span> total %<span class="number">3</span> == <span class="number">1</span> <span class="keyword">and</span> one:</span><br><span class="line">        <span class="keyword">if</span> len(two) &gt;= <span class="number">2</span> <span class="keyword">and</span> one[<span class="number">0</span>] &gt; two[<span class="number">0</span>]+two[<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> total - two[<span class="number">0</span>] - two[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> total - one[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">elif</span> total % <span class="number">3</span> == <span class="number">2</span> <span class="keyword">and</span> two:</span><br><span class="line">        <span class="keyword">if</span> len(one) &gt;= <span class="number">2</span> <span class="keyword">and</span> two[<span class="number">0</span>] &gt; one[<span class="number">0</span>]+one[<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> total - one[<span class="number">0</span>] - one[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> total - two[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><br><h4 id="思路二-1"><a href="#思路二-1" class="headerlink" title="思路二"></a>思路二</h4><ul><li>我们发现上述的算法中，我们只用到了<code>one</code>数组和<code>two</code>数组中最小的两个数</li><li>所以我们只需要使用4个存储空间来存储两个数组即可</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxSumDivThree</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">one, two = [float(<span class="string">'inf'</span>)]*<span class="number">2</span>, [float(<span class="string">'inf'</span>)]*<span class="number">2</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        total += num</span><br><span class="line">        <span class="keyword">if</span> num % <span class="number">3</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> num &lt; one[<span class="number">0</span>]:</span><br><span class="line">                t = one[<span class="number">0</span>]</span><br><span class="line">                one[<span class="number">0</span>] = num</span><br><span class="line">                one[<span class="number">1</span>] = t</span><br><span class="line">            <span class="keyword">elif</span> num &lt; one[<span class="number">1</span>]:</span><br><span class="line">                one[<span class="number">1</span>] = num</span><br><span class="line">        <span class="keyword">if</span> num % <span class="number">3</span> == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> num &lt; two[<span class="number">0</span>]:</span><br><span class="line">                t = two[<span class="number">0</span>]</span><br><span class="line">                two[<span class="number">0</span>] = num</span><br><span class="line">                two[<span class="number">1</span>] = t</span><br><span class="line">            <span class="keyword">elif</span> num &lt; two[<span class="number">1</span>]:</span><br><span class="line">                two[<span class="number">1</span>] = num</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> total % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> total</span><br><span class="line">    <span class="keyword">elif</span> total %<span class="number">3</span> == <span class="number">1</span> <span class="keyword">and</span> one:</span><br><span class="line">        <span class="keyword">if</span> len(two) &gt;= <span class="number">2</span> <span class="keyword">and</span> one[<span class="number">0</span>] &gt; two[<span class="number">0</span>]+two[<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> total - two[<span class="number">0</span>] - two[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> total - one[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">elif</span> total % <span class="number">3</span> == <span class="number">2</span> <span class="keyword">and</span> two:</span><br><span class="line">        <span class="keyword">if</span> len(one) &gt;= <span class="number">2</span> <span class="keyword">and</span> two[<span class="number">0</span>] &gt; one[<span class="number">0</span>]+one[<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> total - one[<span class="number">0</span>] - one[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> total - two[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之在受污染的二叉树中查找元素</title>
      <link href="/passages/leetcode-zhi-zai-shou-wu-ran-de-er-cha-shu-zhong-cha-zhao-yuan-su/"/>
      <url>/passages/leetcode-zhi-zai-shou-wu-ran-de-er-cha-shu-zhong-cha-zhao-yuan-su/</url>
      
        <content type="html"><![CDATA[<p>Find Elements in a Contaminated Binary Tree</p><a id="more"></a><h3 id="Find-Elements-in-a-Contaminated-Binary-Tree"><a href="#Find-Elements-in-a-Contaminated-Binary-Tree" class="headerlink" title="Find Elements in a Contaminated Binary Tree"></a>Find Elements in a Contaminated Binary Tree</h3><ul><li>code with Python</li><li>title number：1261</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个满足下述规则的二叉树<ul><li><code>root.val == 0</code></li><li>如果<code>treeNode.val == x</code>且<code>treeNode.left != null</code>，那么<code>treeNode.left.val == 2*x + 1</code></li><li>如果<code>treeNode.val == x</code>且<code>treeNode.right != null</code>，那么<code>treeNode.right.val == 2*x +2</code></li></ul></li><li>现在，二叉树受到了污染，所有的<code>treeNode.val</code>都变成了<code>-1</code></li><li>需要先还原二叉树，然后实现<code>FindElements</code>类<ul><li><code>FindElements(TreeNode* root)</code>用受污染的二叉树初始化对象，需要先将其还原</li><li><code>bool find(int target)</code>判断目标值<code>target</code>是否存在于还原后的二叉树中并返回结果</li></ul></li></ul><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>根据题目描述，我们可以递归的由根结点得到所有结点的值，这样，就可以通过一次遍历，还原所有的结点的值</li><li>所以，比较朴素的想法就是全上递归<ul><li>递归建树</li><li>递归查找</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FindElements</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, root: TreeNode)</span>:</span></span><br><span class="line">        node = <span class="literal">None</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recover</span><span class="params">(node)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> node</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                node.left.val = <span class="number">2</span> * node.val + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                node.right.val = <span class="number">2</span> * node.val + <span class="number">2</span></span><br><span class="line">            recover(node.left)</span><br><span class="line">            recoder(node.right)</span><br><span class="line">           <span class="keyword">return</span> node</span><br><span class="line">       root.val = <span class="number">0</span></span><br><span class="line">        self.node = recover(root)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, target: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">findTree</span><span class="params">(node, target)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> node.val == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> findTree(node.left, target) <span class="keyword">or</span> findTree(node.right, target)</span><br><span class="line">       <span class="keyword">return</span> findTree(self.node, target)</span><br></pre></td></tr></table></figure><ul><li>不出意外的超时了😂😂😂</li></ul><br><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li>延续上一题的思路，使用空间换时间</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FindElements</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, root: TreeNode)</span>:</span></span><br><span class="line">        self.seen = set()</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recover</span><span class="params">(node)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> node</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                node.left.val = <span class="number">2</span> * node.val + <span class="number">1</span></span><br><span class="line">                self.seen.add(node.left.val)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                node.right.val = <span class="number">2</span> * node.val + <span class="number">2</span></span><br><span class="line">                self.seen.add(node.right.val)</span><br><span class="line">            recover(node.left)</span><br><span class="line">            recover(node.right)</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        root.val = <span class="number">0</span></span><br><span class="line">        self.seen.add(<span class="number">0</span>)</span><br><span class="line">        self.node = recover(root)</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, target: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> target <span class="keyword">in</span> self.seen</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之飞机座位分配概率</title>
      <link href="/passages/leetcode-zhi-fei-ji-zuo-wei-fen-pei-gai-lu/"/>
      <url>/passages/leetcode-zhi-fei-ji-zuo-wei-fen-pei-gai-lu/</url>
      
        <content type="html"><![CDATA[<p>Airplane Seat Assignment Probability</p><a id="more"></a><h3 id="Airplane-Seat-Assignment-Probability"><a href="#Airplane-Seat-Assignment-Probability" class="headerlink" title="Airplane Seat Assignment Probability"></a>Airplane Seat Assignment Probability</h3><ul><li>code with Python</li><li>title number：1227</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>有<code>n</code>位乘客即将登机，飞机正好有<code>n</code>个作为，第一位乘客的票丢了，它随便选了一个作为坐下</li><li>剩下的乘客将会<ul><li>如果他们的座位还空着，就做到自己的座位上</li><li>如果它们的座位被占用时，随机选择其他座位</li></ul></li><li>第<code>n</code>位乘客坐在自己作为上的概率是多少</li></ul><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>按照题意，暴力递归<ul><li>原问题定义为<code>f(n)</code>，对于第一个人来说，有<code>n</code>种选择，选择每个位置的概率都是$\frac{1}{n}$</li><li>如果<strong>第一个人选择了自己的位置</strong>，则剩下的人只需按自己票上的座位坐好即可，即<strong>最后一个人必会坐到自己的座位上</strong></li><li>如果<strong>第一个人选择了最后一个人的位置</strong>，则<strong>最后一个人必不能坐到自己的位置上</strong></li><li>如果<strong>第一个人选择了第<code>i</code>个位置（ 1 &lt; i &lt; n）</strong>，那么第<code>i</code>个人就成为了新的“丢票的人”，问题转化为<code>f(n-i+1)</code></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nthPersonGetNthSeat</span><span class="params">(self, n: int)</span> -&gt; float:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span></span><br><span class="line">    res = <span class="number">1</span> / n</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">        res += self.nthPersonGetNthSeat(n-i+<span class="number">1</span>) * <span class="number">1</span> / n</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><ul><li>栈溢出</li></ul><br><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li><p>数学思想</p></li><li><p>首先，将上述的递归表达式写出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f(n) </span><br><span class="line">&#x3D; 1&#x2F;n + 0 + 1&#x2F;n*(f(n-1)+f(n-2)...f(2))</span><br><span class="line">&#x3D; 1&#x2F;n * (f(n-1)+f(n-2)...f(2)+1)</span><br><span class="line">&#x3D; 1&#x2F;n * (f(n-1)+f(n-2)...f(2)+f(1))</span><br></pre></td></tr></table></figure></li><li><p>下面对其进行化简</p><ul><li>首先，写出<code>f(n-1)</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(n-1) &#x3D; 1&#x2F;(n-1) * (f(n-2)+f(n-3)...f(1))</span><br></pre></td></tr></table></figure><ul><li>将上述两式两遍分别乘以<code>n</code>和<code>n-1</code>，即消除右侧分母</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n * f(n) &#x3D; f(n-1) + f(n-2) + ... + f(1)</span><br><span class="line">(n-1) * f(n-1) &#x3D; f(n-2) + f(n-3) + ... + f(1)</span><br></pre></td></tr></table></figure><ul><li>将两者相减</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n*f(n) - (n-1)*f(n-1) &#x3D; f(n-1)</span><br></pre></td></tr></table></figure><ul><li>将<code>(n-1)*f(n-1)</code>移到右边</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n * f(n) &#x3D; n * f(n-1)</span><br></pre></td></tr></table></figure><ul><li><strong>即<code>f(n) == f(n-1)</code>（n &gt; 2）</strong></li></ul></li><li><p>这是一个重要的结论，以此，我们可以得到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f(1) &#x3D; 1</span><br><span class="line">f(2) &#x3D; 0.5</span><br><span class="line">f(3) &#x3D; f(2) &#x3D; 0.5</span><br><span class="line">...</span><br><span class="line">f(n) &#x3D; f(n-1) &#x3D; 0.5</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nthPersonGetNthSeat</span><span class="params">(self, n: int)</span> -&gt; float:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">else</span> <span class="number">0.5</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之最长定差子序列</title>
      <link href="/passages/leetcode-zhi-zui-chang-ding-chai-zi-xu-lie/"/>
      <url>/passages/leetcode-zhi-zui-chang-ding-chai-zi-xu-lie/</url>
      
        <content type="html"><![CDATA[<p>Longest Arithmetic SubSequence of Fiven Difference</p><a id="more"></a><h3 id="Longest-Arithmetic-SubSequence-of-Fiven-Difference"><a href="#Longest-Arithmetic-SubSequence-of-Fiven-Difference" class="headerlink" title="Longest Arithmetic SubSequence of Fiven Difference"></a>Longest Arithmetic SubSequence of Fiven Difference</h3><ul><li>code with Python</li><li>title number：1218</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li><p>给定一个整数数组<code>arr</code>和一个整数<code>difference</code>，请你找出<code>arr</code>中所有相邻元素之间等于给定<code>difference</code>的等差子序列，并返回其中最长的等差子序列的长度</p></li><li><p>示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr &#x3D; [1, 2, 3, 4], difference &#x3D; 1</span><br><span class="line">输出：4</span><br><span class="line">解释：最长的等差子序列是 [1, 2, 3, 4]</span><br></pre></td></tr></table></figure></li></ul><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>最直观的思路就是使用双循环，我们暴力枚举出<strong>以每一个元素为开始元素，以最后元素结尾的所有情况</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestSubsequence</span><span class="params">(self, arr: List[int], difference: int)</span> -&gt; int:</span></span><br><span class="line">n = len(arr)</span><br><span class="line">    res = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">in</span> range(n):</span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> arr[i] + difference * count == arr[j]:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> count &gt; res:</span><br><span class="line">                res = count</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><ul><li>超时，时间复杂度为$O(n^2)$</li></ul><br><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li><p>动态规划</p></li><li><p>将每一个元素结尾的最长等差子序列的长度保存起来，这样在遍历新的元素的时候，只需从之前的存储中找是否有符合的，如果有，则更新当前的值，否则就不进行操作</p></li><li><p>具体而言</p><ul><li><p>使用<code>dp[num]</code>中每个位置记录<strong>以当前元素为结尾的最长等差子序列的长度</strong></p></li><li><p>当遍历到一个新的元素的时候，就去之前的存储中找<code>dp[num-difference]</code></p></li><li><p>如果找到了，则更新当前值为<code>dp[num] = dp[num-difference]+1</code>；</p></li><li><p>否则，更新当前值为<code>dp[num] = 1</code></p></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestSubsequence</span><span class="params">(self, arr: List[int], difference: int)</span> -&gt; int:</span></span><br><span class="line">    n = len(arr)</span><br><span class="line">    res = <span class="number">1</span></span><br><span class="line">    dp = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> arr:</span><br><span class="line">        dp[num] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> num - difference <span class="keyword">in</span> dp:</span><br><span class="line">            dp[num] = dp[num - difference] + <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> max(dp.values())</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之删除一次得到子数组最大和</title>
      <link href="/passages/leetcode-zhi-shan-chu-yi-ci-de-dao-zi-shu-zu-zui-da-he/"/>
      <url>/passages/leetcode-zhi-shan-chu-yi-ci-de-dao-zi-shu-zu-zui-da-he/</url>
      
        <content type="html"><![CDATA[<p>Maximum Subarray Sum with One Deletion</p><a id="more"></a><h3 id="Maximum-Subarray-Sum-with-One-Deletion"><a href="#Maximum-Subarray-Sum-with-One-Deletion" class="headerlink" title="Maximum Subarray Sum with One Deletion"></a>Maximum Subarray Sum with One Deletion</h3><ul><li>code with Python</li><li>title number：1186</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li><p>给定一个整数数组，返回其某个<strong>非空子数组</strong>（连续元素）在执行一次可选的删除操作后，所能得到的最大元素总和</p></li><li><p>换句话说，你可以从原数组中选出一个子数组，并可以决定要不要从中删除一个元素，（删除后）子数组中至少应当有一个元素，然后该子数组（剩下）的元素总和是所有子数组中最大的</p></li><li><p>示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：arr &#x3D; [1, -2, 0, 3]</span><br><span class="line">输出：4</span><br><span class="line">解释：我们可以选择[1, -2, 0, 3]，然后删掉-2，这样得到的[1, 0, 3]和最大</span><br><span class="line"></span><br><span class="line">输入：arr &#x3D; [-1, -1, -1, -1]</span><br><span class="line">输出：-1</span><br><span class="line">解释：最后得到的子数组不能为空，所以可以选择[-1, -1]删掉其中一个；或者选择[-1],不删除任何元素</span><br></pre></td></tr></table></figure></li></ul><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>暴力的做法是<ul><li>计算所有可能的情况，取出最大的即可</li><li>使用双层循环，外循环用于确定我们丢弃的元素，内循环用于计算</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maximumSum</span><span class="params">(self, arr: List[int])</span> -&gt; int:</span></span><br><span class="line">    res = arr[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubSum</span><span class="params">(arr, skip)</span>:</span></span><br><span class="line">        res = maxSub = float(<span class="string">"-inf"</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">            <span class="keyword">if</span> i == skip:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            maxSub = max(arr[i], maxSub+arr[i])</span><br><span class="line">            res = max(res, maxSub)</span><br><span class="line">        <span class="keyword">return</span> res   </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)+<span class="number">1</span>):</span><br><span class="line">        res = max(res, maxSubSum(arr, i))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><ul><li>超时</li></ul><br><h4 id="思路一-1"><a href="#思路一-1" class="headerlink" title="思路一"></a>思路一</h4><ul><li><p>基于上述方法会超时，我们考虑能否用<strong>空间换时间</strong></p></li><li><p>从头尾分别遍历，建立两个子数组集合<code>L, R</code></p><ul><li>第一次从左向右遍历，建立数组<code>L</code>，<code>L[i]</code>表示从左向右以<code>arr[i]</code>结尾的子数组的最大值</li><li>第二次从右向左遍历，建立数组<code>R</code>，<code>R[i]</code>表示从右向左以<code>arr[i]</code>结尾的子数组的最大值</li><li>第三次遍历，计算<code>L[i-1]+R[i+1]</code>的最大值</li></ul></li><li><p>这样，我们就可以在空间扩大一倍的情况下，将时间由<code>O(n^2)</code>降低到了<code>O(n)</code></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maximumSum</span><span class="params">(self, arr: List[int])</span> -&gt; int:</span></span><br><span class="line">n = len(arr)</span><br><span class="line">    L = [arr[<span class="number">0</span>]] * n</span><br><span class="line">    R = [arr[n - <span class="number">1</span>]] * n</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    res = arr[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        L[i] = max(L[i<span class="number">-1</span>] + arr[i], arr[i])</span><br><span class="line">        res = max(res, L[i])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        R[i] = max(R[i+<span class="number">1</span>]+arr[i], arr[i])</span><br><span class="line">        res = max(res, R[i])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n<span class="number">-1</span>):</span><br><span class="line">        res = max(res, L[i<span class="number">-1</span>]+R[i+<span class="number">1</span>])</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之绝对值表达式的最大值</title>
      <link href="/passages/leetcode-zhi-jue-dui-zhi-biao-da-shi-de-zui-da-zhi/"/>
      <url>/passages/leetcode-zhi-jue-dui-zhi-biao-da-shi-de-zui-da-zhi/</url>
      
        <content type="html"><![CDATA[<p>Maximum of Absolute Value Expression</p><a id="more"></a><h3 id="Maximum-of-Absolute-Value-Expression"><a href="#Maximum-of-Absolute-Value-Expression" class="headerlink" title="Maximum of Absolute Value Expression"></a>Maximum of Absolute Value Expression</h3><ul><li>code with Python</li><li>title number：1131</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li><p>给定两个长度相等的整数数组，返回下面表达式的最大值：</p><p><code>|arr1[i] - arr1[j]| + |arr2[i] - arr2[j]| + |i - j|</code></p></li><li><p>其中<code>i, j</code>，满足<code>0 &lt;= i, j &lt; arr1.length</code></p></li><li><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：arr1 &#x3D; [1, 2, 3, 4], arr2 &#x3D; [-1, 3, 5, 6]</span><br><span class="line">输出：13</span><br><span class="line">解释：</span><br><span class="line">|1 - 4| + |-1 - 6| + |1 - 4| &#x3D; 13</span><br></pre></td></tr></table></figure></li></ul><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li><p><strong>数学分析</strong>，即去绝对值运算</p></li><li><p>表达式分为三部分，每一个部分绝对值内的计算结果会有<strong>两种情况</strong>（大于等于0 or小于0），故共有<code>2 * 2 * 2 = 8</code>种情况</p></li><li><p>我们尝试去掉绝对值，可以得到八个可能的表达式</p><ul><li><code>arr1[i]-arr1[j]+arr2[i]-arr2[j]+i-j</code></li><li><code>arr1[i]-arr1[j]-(arr2[i]-arr2[j])+i-j</code></li><li><code>-(arr1[i]-arr1[j])+arr2[i]-arr2[j]+i-j</code></li><li><code>-(arr1[i]-arr1[j])-(arr2[i]-arr2[j])+i-j</code></li><li><code>arr1[i]-arr1[j]+arr2[i]-arr2[j]-(i-j)</code></li><li><code>arr1[i]-arr1[j]-(arr2[i]-arr2[j])-(i-j)</code></li><li><code>-(arr1[i]-arr1[j])+arr2[i]-arr2[j]-(i-j)</code></li><li><code>-(arr1[i]-arr1[j])-(arr2[i]-arr2[j])-(i-j)</code></li></ul></li><li><p>由于<code>i, j</code>之间没有大小关系，所以上述表达式可以缩减为4个</p><ul><li><code>arr1[i]-arr1[j]+arr2[i]-arr2[j]+i-j</code></li><li><code>arr1[i]-arr1[j]-(arr2[i]-arr2[j])+i-j</code></li><li><code>-(arr1[i]-arr1[j])+arr2[i]-arr2[j]+i-j</code></li><li><code>-(arr1[i]-arr1[j])-(arr2[i]-arr2[j])+i-j</code></li></ul></li><li><p>我们<strong>只需计算上述四个表达式的最大值</strong>即可</p></li><li><p>再次进行变换，我们分别将与<code>i, j</code>相关的聚合到一起</p><ul><li><code>arr1[i] + arr2[i] + i - (arr1[j] + arr2[j] + j)</code></li><li><code>arr1[i] - arr2[i] + i - (arr1[j] - arr2[j] + j)</code></li><li><code>arr2[i] - arr1[i] + i - (arr2[j] - arr1[j] + j)</code></li><li><code>-arr2[i] - arr1[i] + i - (-arr1[j] - arr2[j] + j)</code></li></ul></li><li><p>观察上式，可以发现，表达式的最大值即<strong>左半部分的最大值和右半部分的最小值之差</strong></p></li><li><p>并且，由于<code>i, j</code>之间可以互换，前半部分和后半部分是等价的</p></li><li><p><strong>故</strong></p><ul><li>遍历一遍数组，计算四个表达式的最大值和最小值<ul><li>``arr1[i] + arr2[i] + i`</li><li><code>arr1[i] - arr2[i] + i</code></li><li><code>arr2[i] - arr1[i] + i</code></li><li><code>-arr2[i] - arr1[i] + i</code></li></ul></li><li>分别取出四个表达式的最大值和最小值的差值</li><li>比较得到四个表达式中最大的差值即可</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxAbsValExpr</span><span class="params">(self, arr1: List[int], arr2: List[int])</span> -&gt; int:</span></span><br><span class="line">    A, B, C, D = [], [], [], []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr1)):</span><br><span class="line">        a = arr1[i] + arr2[i] + i</span><br><span class="line">        b = arr1[i] - arr2[i] + i</span><br><span class="line">        c = arr2[i] - arr1[i] + i</span><br><span class="line">        d = <span class="number">-1</span> * arr2[i] - arr1[i] + i</span><br><span class="line">        </span><br><span class="line">        A.append(a)</span><br><span class="line">        B.append(b)</span><br><span class="line">        C.append(c)</span><br><span class="line">        D.append(d)</span><br><span class="line">    <span class="keyword">return</span> max(max(A)-min(A), max(B)-min(B), max(C)-min(C), max(D)-min(D))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之二叉树寻路</title>
      <link href="/passages/leetcode-zhi-er-cha-shu-xun-lu/"/>
      <url>/passages/leetcode-zhi-er-cha-shu-xun-lu/</url>
      
        <content type="html"><![CDATA[<p>Path In Zigzag Labelled Binary Tree</p><a id="more"></a><h3 id="Path-In-Zigzag-Labelled-Binary-Tree"><a href="#Path-In-Zigzag-Labelled-Binary-Tree" class="headerlink" title="Path In Zigzag Labelled Binary Tree"></a>Path In Zigzag Labelled Binary Tree</h3><ul><li>code with Python</li><li>title number：1104</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>在一棵无限的二叉树上，每个结点都有两个子节点，树中的结点逐行“之”字型进行标记<ul><li>在奇数行从左向右标记</li><li>在偶数行按从右到左标记</li></ul></li><li>给出树上的某个结点的标号<code>label</code>，返回从根节点到该标号为<code>label</code>的路径。路径由途径的结点标号组成</li></ul><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/06/28/tree.png" style="zoom:30%;"><ul><li><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：label &#x3D; 14</span><br><span class="line">输出：[1, 3, 4, 14]</span><br></pre></td></tr></table></figure></li></ul><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li><p>随便说句：如果这道题是按层次遍历（一个方向）来标记，那么可以直接由子节点推算出父节点的标记</p></li><li><p>通过观察我们发现一个规律：</p></li><li><p>以上图最后一层为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">按“之”字形排列：15, 14, 13, 12, 11, 10, 9, 8</span><br><span class="line">按常规层次遍历： 8,  9,  10, 11, 12, 13,14,15</span><br></pre></td></tr></table></figure><ul><li>可以观察到，”之“字型排列和常规排列之和为一常数，并且等于该行的<strong>最大最小值之和</strong></li></ul></li><li><p>因此，问题转化为求每行行对应的常数，然后用其减去当前值就能得到标记的值</p><ul><li>当前值可以通过二叉树子节点和父节点的关系得到</li></ul></li><li><p>更进一步，由于满二叉树的性质：每一行的最小值为<code>2^(level-1)</code>，最大值为<code>2^level - 1</code></p></li><li><p>那么，问题更简化为求每一行的<code>level</code>（直接用一个变量记录即可）</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pathInZigZagTree</span><span class="params">(self, label: int)</span> -&gt; List[int]:</span></span><br><span class="line">level = <span class="number">0</span></span><br><span class="line">    res = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="number">2</span>** level - <span class="number">1</span> &lt; label:</span><br><span class="line">        level += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">while</span> level &gt; <span class="number">0</span>:</span><br><span class="line">        res.insert(<span class="number">0</span>, label)</span><br><span class="line">        label = <span class="number">2</span> ** (level<span class="number">-1</span>) + <span class="number">2</span> ** level <span class="number">-1</span> - label</span><br><span class="line">        </span><br><span class="line">        label //= <span class="number">2</span></span><br><span class="line">        level -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之两个非重叠子数组的最大和</title>
      <link href="/passages/leetcode-zhi-liang-ge-fei-chong-die-zi-shu-zu-de-zui-da-he/"/>
      <url>/passages/leetcode-zhi-liang-ge-fei-chong-die-zi-shu-zu-de-zui-da-he/</url>
      
        <content type="html"><![CDATA[<p>Maximum Sum of Two Non-Overlapping Subarrays</p><a id="more"></a><h3 id="Maximum-Sum-of-Two-Non-Overlapping-Subarrays"><a href="#Maximum-Sum-of-Two-Non-Overlapping-Subarrays" class="headerlink" title="Maximum Sum of Two Non-Overlapping Subarrays"></a>Maximum Sum of Two Non-Overlapping Subarrays</h3><ul><li>code with Python</li><li>title number：1031</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li><p>给出非负整数数组<code>A</code>，返回两个非重叠（连续）子数组中元素的最大和，子数组的长度分别为<code>L</code>和<code>M</code></p></li><li><p>长为<code>L</code>的子数组可以出现在长为<code>M</code>的子数组之前或之后</p></li><li><p>从形式上看，返回最大的<code>V</code>，<code>V = (A[i] + A[i+1] + ... + A[i+L-1]) + (A[j] + A[j+1] + ... + A[j+M-1])</code></p></li><li><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [0, 6, 5, 2, 2, 5, 1, 9, 4], L &#x3D; 1, M &#x3D; 2</span><br><span class="line">输出: 20</span><br><span class="line">解释: 长度为1的子数组为[9]，长度为2的子数组为[6, 5]</span><br></pre></td></tr></table></figure></li></ul><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li><p>一个简单的想法是穷举所有符合长度为<code>L</code>的子数组，再对剩余的数组元素列举所有长度为<code>M</code>的子数组，返回最大值即可</p></li><li><p>时间复杂度太高，必会超时</p></li><li><p>这里尝试用动态规划进行求解</p><ul><li>根据题意，数组必定会被分为两部分（左边包含长为<code>L</code>的子数组，右边包含长为<code>M</code>的子数组，或者反过来）</li><li>这样就有四种状态，我们分别使用一次动态规划来得到相应的结果</li><li><code>dp[i][0]</code>：从<code>A[0]~A[i]</code>中长为<code>L</code>的最大连续子数组</li><li><code>dp[i][1]</code>：从<code>A[0]~A[i]</code>中长为<code>M</code>的最大连续子数组</li><li><code>dp[i][2]</code>：从<code>A[i+1]~A[len(A)-1]</code>中长为<code>L</code>的最大连续子数组</li><li><code>dp[i][3]</code>：从<code>A[i+1]~A[len(A)-1]</code>中长为<code>M</code>的最大连续子数组</li><li>这里使用滑动窗口分别对每个动态规划任务进行计算</li><li>最终，取其中的最大组合即可（<code>dp[i][0]+dp[i][2]</code>或<code>dp[i][1]+dp[i][3]</code>）</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxSumTwoNoOverlap</span><span class="params">(self, A: List[int], L: int, M: int)</span> -&gt; int:</span></span><br><span class="line">    dp = [[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(A))]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># L在左边</span></span><br><span class="line">    presum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(L):</span><br><span class="line">        presum += A[i]   </span><br><span class="line">    maxsum = presum</span><br><span class="line">    dp[L<span class="number">-1</span>][<span class="number">0</span>] = maxsum</span><br><span class="line">    <span class="comment"># 华东窗口</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(L, len(A)):</span><br><span class="line">        presum -= A[i-L]</span><br><span class="line">        presum += A[i]</span><br><span class="line">        maxsum = max(maxsum, presum)</span><br><span class="line">        dp[i][<span class="number">0</span>] = maxsum</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># M在左边    </span></span><br><span class="line">    presum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(M):</span><br><span class="line">        presum += A[i]      </span><br><span class="line">    maxsum = presum</span><br><span class="line">    dp[M<span class="number">-1</span>][<span class="number">1</span>] = maxsum</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(M, len(A)):</span><br><span class="line">        presum -= A[i-M]</span><br><span class="line">        presum += A[i]</span><br><span class="line">        maxsum = max(maxsum, presum)</span><br><span class="line">        dp[i][<span class="number">1</span>] = maxsum</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># L在右边 </span></span><br><span class="line">    presum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)<span class="number">-1</span>, len(A)-L<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        presum += A[i]   </span><br><span class="line">    maxsum = presum</span><br><span class="line">    dp[len(A)-L][<span class="number">2</span>] = maxsum</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)-L<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        presum -= A[i+L]</span><br><span class="line">        presum += A[i]</span><br><span class="line">        maxsum = max(maxsum, presum)</span><br><span class="line">        dp[i][<span class="number">2</span>] = maxsum</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># M在右边</span></span><br><span class="line">    presum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)<span class="number">-1</span>, len(A)-M<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        presum += A[i]</span><br><span class="line">    maxsum = presum</span><br><span class="line">    dp[len(A)-M][<span class="number">3</span>] = maxsum</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)-M<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        presum -= A[i+M]</span><br><span class="line">        presum += A[i]</span><br><span class="line">        maxsum = max(maxsum, presum)</span><br><span class="line">        dp[i][<span class="number">3</span>] = maxsum</span><br><span class="line">        </span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 取最大组合</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(L, len(A)-M+<span class="number">1</span>):</span><br><span class="line">        res = max(res, dp[i<span class="number">-1</span>][<span class="number">0</span>] + dp[i][<span class="number">3</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(M, len(A)-L+<span class="number">1</span>):</span><br><span class="line">        res = max(res, dp[i<span class="number">-1</span>][<span class="number">1</span>] + dp[i][<span class="number">2</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之驼峰式匹配</title>
      <link href="/passages/leetcode-zhi-tuo-feng-shi-pi-pei/"/>
      <url>/passages/leetcode-zhi-tuo-feng-shi-pi-pei/</url>
      
        <content type="html"><![CDATA[<p>Camelcase Matching</p><a id="more"></a><h3 id="Camelcase-Matching"><a href="#Camelcase-Matching" class="headerlink" title="Camelcase Matching"></a>Camelcase Matching</h3><ul><li>code with Python</li><li>title number：1023</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li><p>如果可以将小写字母插入模式串<code>pattern</code>中得到带查询项<code>query</code>，则称<strong>待查询项与给定模式串匹配</strong></p></li><li><p>给定待查询列表<code>queries</code>和模式串<code>pattern</code>，返回由布尔值组成的答案列表。</p></li><li><p><code>answer[i]=True</code>表示匹配成功，否则为匹配失败</p></li><li><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：queries &#x3D; [&quot;FooBar&quot;,&quot;FooBarTest&quot;,&quot;FootBall&quot;,&quot;FrameBuffer&quot;,&quot;ForceFeedBack&quot;], pattern &#x3D; &quot;FB&quot;</span><br><span class="line">输出：[true,false,true,true,false]</span><br><span class="line">解释：</span><br><span class="line">&quot;FooBar&quot; 可以这样生成：&quot;F&quot; + &quot;oo&quot; + &quot;B&quot; + &quot;ar&quot;。</span><br><span class="line">&quot;FootBall&quot; 可以这样生成：&quot;F&quot; + &quot;oot&quot; + &quot;B&quot; + &quot;all&quot;.</span><br><span class="line">&quot;FrameBuffer&quot; 可以这样生成：&quot;F&quot; + &quot;rame&quot; + &quot;B&quot; + &quot;uffer&quot;.</span><br></pre></td></tr></table></figure><ul><li>需要注意的是最后一个，由于只能插入小写字母，所以无法通过在<code>FB</code>上插入字母得到<code>ForceFeedBack</code></li></ul></li></ul><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>双指针<ul><li>我们将两个指针<code>i, j</code>分别指向模式串和待查询串的第一个字母</li><li>当指针指向的两个字母相同时，同时将两个指针向后移动一个位置</li><li>当指针指向的两个字母不相同时，移动指向查询串的<code>j</code></li><li>直到<code>j</code>超出了查询串的范围，此时判断模式串是否遍历完毕（<code>True</code>）</li><li>当模式串提前遍历完时可提前退出</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">camelMatch</span><span class="params">(self, queries: List[str], pattern: str)</span> -&gt; List[bool]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(pattern, query)</span>:</span></span><br><span class="line">        i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> j &lt; len(query):</span><br><span class="line">            <span class="keyword">if</span> i &lt; len(pattern) <span class="keyword">and</span> pattern[i] == query[j]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> query[j] &gt;=<span class="string">'a'</span> <span class="keyword">and</span> query[j] &lt;= <span class="string">'z'</span>:</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> i == len(pattern)</span><br><span class="line">    </span><br><span class="line">    ans = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> query <span class="keyword">in</span> queries:</span><br><span class="line">        ans.append(isValid(pattern, query))</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之飞地的数量</title>
      <link href="/passages/leetcode-zhi-fei-di-de-shu-liang/"/>
      <url>/passages/leetcode-zhi-fei-di-de-shu-liang/</url>
      
        <content type="html"><![CDATA[<p>Number of Enclaves</p><a id="more"></a><h3 id="Number-of-Enclaves"><a href="#Number-of-Enclaves" class="headerlink" title="Number of Enclaves"></a>Number of Enclaves</h3><ul><li>code with Python</li><li>title number：1020</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li><p>给定一个二维数组，每个单元格为<code>0</code>（海）或<code>1</code>（陆地）</p></li><li><p>移动是指在陆地上从一个地方走到另一个地方（四个方向）或者离开网格的边界</p></li><li><p>返回网格中<strong>无法</strong>在任意次数的移动中离开网络边界的<strong>陆地单元格</strong>的数量</p></li><li><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[[0, 0, 0, 0],</span><br><span class="line"> [1, 0, 1, 0],</span><br><span class="line"> [0, 1, 1, 0],</span><br><span class="line"> [0, 0, 0, 0]]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">有三个1被0包围，另外在边界上的1并没有被包围</span><br></pre></td></tr></table></figure></li></ul><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>典型的连通区域问题，可以使用<code>DFS</code>进行解决</li><li>具体而言：<ul><li>遍历整个矩阵</li><li>如果遍历到<code>0</code>，不予理会</li><li>如果遍历到<code>1</code>，将其加到<code>temp</code></li><li>不断拓展边界（上下左右四个方向）</li><li>在深度优先搜索的过程中碰到了边界，则证明可以逃脱，将累计的<code>temp</code>清空</li><li>如果深度优先搜索后无法到达边界，则证明无法逃脱，将<code>temp</code>加到<code>cnt</code>中</li><li>最终返回<code>cnt</code>即可</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.temp = <span class="number">0</span></span><br><span class="line">        self.meetEdge = <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numEnclaves</span><span class="params">(self, A: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        m, n = len(A), len(A[<span class="number">0</span>])</span><br><span class="line">        visited =set()</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, j)</span>:</span></span><br><span class="line">            <span class="comment"># 到达边界或已访问过</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= m <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> j &gt;= n <span class="keyword">or</span> (i, j) <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            visited.add((i, j))</span><br><span class="line">            <span class="keyword">if</span> A[i][j] == <span class="number">1</span>:</span><br><span class="line">                self.temp += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> i == m<span class="number">-1</span> <span class="keyword">or</span> j == <span class="number">0</span> <span class="keyword">or</span> j == n<span class="number">-1</span>:</span><br><span class="line">                self.meetEdge = <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">            dfs(i + <span class="number">1</span>, j)</span><br><span class="line">            dfs(i - <span class="number">1</span>, j)</span><br><span class="line">            dfs(i, j - <span class="number">1</span>)</span><br><span class="line">            dfs(i, j + <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                dfs(i, j)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> self.meetEdge:</span><br><span class="line">                    cnt += self.temp</span><br><span class="line">                <span class="comment"># 重置</span></span><br><span class="line">                self.meetEdge = <span class="literal">False</span></span><br><span class="line">                self.temp = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure><br><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li>消除法，对上面方法的优化</li><li>具体而言<ul><li>从矩阵边界开始进行深度优先搜索（搜索到的只能是<strong>非飞地</strong>）</li><li>如果碰到<code>1</code>就将其变为<code>0</code></li><li>如果遇到<code>0</code>则跳过</li><li>最后遍历整个矩阵，统计剩下的<code>1</code>的个数即可</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numEnclaves</span><span class="params">(self, A: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    m, n = len(A), len(A[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, j)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= m <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> j &gt;= n <span class="keyword">or</span> A[i][j] == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        A[i][j] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        dfs(i + <span class="number">1</span>, j)</span><br><span class="line">        dfs(i - <span class="number">1</span>, j)</span><br><span class="line">        dfs(i, j + <span class="number">1</span>)</span><br><span class="line">        dfs(i, j - <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 从边界开始进行dfs</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        dfs(i, <span class="number">0</span>)</span><br><span class="line">        dfs(i, n - <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">        dfs(<span class="number">0</span>, j)</span><br><span class="line">        dfs(m - <span class="number">1</span>, j)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 统计最终数组中1的个数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> A[i][j] == <span class="number">1</span>:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之链表中的下一个更大节点</title>
      <link href="/passages/leetcode-zhi-lian-biao-zhong-de-xia-yi-ge-geng-da-jie-dian/"/>
      <url>/passages/leetcode-zhi-lian-biao-zhong-de-xia-yi-ge-geng-da-jie-dian/</url>
      
        <content type="html"><![CDATA[<p>Next Greater Node In Linked List</p><a id="more"></a><h3 id="Next-Greater-Node-In-Linked-List"><a href="#Next-Greater-Node-In-Linked-List" class="headerlink" title="Next Greater Node In Linked List"></a>Next Greater Node In Linked List</h3><ul><li><p>code with Python</p></li><li><p>title number：1019</p></li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li><p>给出一个以头结点<code>head</code>为第一个节点的链表。链表中的节点编号依次为<code>node_1, node_2, node_3, ...</code></p></li><li><p>每个节点都可能有下一个更大值：</p><ul><li>对于<code>node_i</code>，如果其<code>next_latger(node_i)</code>是<code>node_j.val</code>，则<code>j &gt; i</code>且<code>node_j.val &gt; node_i.val</code>，而且<code>j</code>是可能的选项中最小的那个。</li><li>若<code>j</code>不存在，则<code>next_larger(node_i)</code>返回<code>0</code></li></ul></li><li><p>返回整个数组的每个元素对应的<strong>下一个最大值</strong></p></li><li><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：[2, 1, 5]</span><br><span class="line">输出：[5, 5, 0]</span><br><span class="line">解释：</span><br><span class="line">2的next_larger是5</span><br><span class="line">1的next_larger是5</span><br><span class="line">5的next_larger不存在，返回0</span><br></pre></td></tr></table></figure></li></ul><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>最开始的想法是，对于结点<code>i</code>将其后面的结点排序，取第一个大于结点<code>i</code>的值的结点值，这样的时间复杂度为<code>O(n^2)</code>，并且因为是链表，不容易进行排序操作</li><li>这里介绍一种数据结构，<strong>单调栈</strong><ul><li>栈中的元素满足单调性</li><li>在插入新元素时，出栈最少的元素以保持栈中元素的单调性</li></ul></li><li>例如：<ul><li>栈中元素自栈顶到栈底依次为<code>[1, 2, 4, 5]</code>，现插入元素<code>3</code></li><li>为了保持栈中元素的单调性需出栈<code>1, 2</code>，最后将<code>3</code>插入栈中，得到<code>[3, 4, 5]</code>的单调栈</li></ul></li><li>在这里如何使用呢<ul><li>遍历链表，维护一个单调栈，单调栈的每个元素为<code>(结点下标, 对应链表节点值)</code></li><li>按单调递减栈的入栈顺序，如果出现当前遍历到的结点值比栈顶值大，则将栈中元素出栈，并更新<code>res</code>值</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nextLargerNodes</span><span class="params">(self, head)</span>:</span></span><br><span class="line">    res, st = [], []</span><br><span class="line">    <span class="comment"># 遍历链表</span></span><br><span class="line">    <span class="keyword">while</span> head:</span><br><span class="line">        <span class="comment"># 插入当前头指针指向的结点的值，并通过出栈操作维护单调性</span></span><br><span class="line">        <span class="keyword">while</span> len(st) &gt; <span class="number">0</span> <span class="keyword">and</span> head.val &gt; st[<span class="number">-1</span>][<span class="number">1</span>]:</span><br><span class="line">            res[st.pop()[<span class="number">0</span>]] = head.val</span><br><span class="line">        st.append((len(res), head.val))</span><br><span class="line">        <span class="comment"># 没有符合条件的元素</span></span><br><span class="line">        res.append(<span class="number">0</span>)</span><br><span class="line">        head = head.next</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之可被K整除的最小整数</title>
      <link href="/passages/leetcode-zhi-ke-bei-k-zheng-chu-de-zui-xiao-zheng-shu/"/>
      <url>/passages/leetcode-zhi-ke-bei-k-zheng-chu-de-zui-xiao-zheng-shu/</url>
      
        <content type="html"><![CDATA[<p>Smallest Integer Divisible by K</p><a id="more"></a><h3 id="Smallest-Integer-Divisible-by-K"><a href="#Smallest-Integer-Divisible-by-K" class="headerlink" title="Smallest Integer Divisible by K"></a>Smallest Integer Divisible by K</h3><ul><li>code with Python</li><li>title number：1015</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li><p>给定正整数<code>K</code>，你需要找出可被<code>K</code>整除的、仅包含数字<code>1</code>的最小正整数<code>N</code></p></li><li><p>返回<code>N</code>的长度，如果不存在这样的<code>N</code>，就返回<code>-1</code></p></li><li><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：1</span><br><span class="line">输出：1</span><br><span class="line">解释：最小的答案是 N &#x3D; 1，其长度为1</span><br><span class="line"></span><br><span class="line">输入：2</span><br><span class="line">输出：-1</span><br><span class="line">解释：不存可被2乘除的正整数N</span><br><span class="line"></span><br><span class="line">输入：3</span><br><span class="line">输出：3</span><br><span class="line">解释：最小的答案是111，长度为3</span><br></pre></td></tr></table></figure></li></ul><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li><p>最直接的想法就是从小到达遍历，判断是否能整除</p></li><li><p>根据题目给出的信息，可以从<code>1, 11, 111, 1111...</code>中不断尝试。但是该何时跳出循环呢</p></li><li><p>举几个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入2， 1 % 2 &#x3D; 1， 11 % 2 &#x3D; 1， 好像没有什么特点</span><br><span class="line"></span><br><span class="line">输入6， 1 % 6 &#x3D; 1， 11 % 6 &#x3D; 5， 111 % 6 &#x3D; 3， 1111 % 6 &#x3D; 1， 11111 % 6 &#x3D; 5，陷入了循环153</span><br></pre></td></tr></table></figure></li><li><p>总得来说</p><ul><li>我们从<code>1, 11, 111, ...</code>中依次尝试</li><li>当余数出现之前出现过的数，则陷入了循环，则跳出循环返回<code>-1</code></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">smallestRepunitDivByK</span><span class="params">(self, K: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> L % <span class="number">10</span> <span class="keyword">in</span> [<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    </span><br><span class="line">    seen = set()</span><br><span class="line">    </span><br><span class="line">    mode = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, K+<span class="number">1</span>):</span><br><span class="line">        mod = (mod*<span class="number">10</span> + <span class="number">1</span>) % K</span><br><span class="line">        <span class="keyword">if</span> mod <span class="keyword">in</span> seen:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> mod == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        seed.add(mod)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之最佳观光组合</title>
      <link href="/passages/leetcode-zhi-zui-jia-guan-guang-zu-he/"/>
      <url>/passages/leetcode-zhi-zui-jia-guan-guang-zu-he/</url>
      
        <content type="html"><![CDATA[<p>Best Sightseeing Pair</p><a id="more"></a><h3 id="Best-Sightseeing-Pair"><a href="#Best-Sightseeing-Pair" class="headerlink" title="Best Sightseeing Pair"></a>Best Sightseeing Pair</h3><ul><li>code with Python</li><li>title number：1014</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li><p>给定正整数数组<code>A</code>，<code>A[i]</code>表示第<code>i</code>个观光景点的评分，并且两个景点<code>i</code>和<code>j</code>之间的距离为<code>j-i</code></p></li><li><p>一对景点组成的观光组合的得分为<code>(A[i] + A[j] + i + j)</code>：景点的评分之和减去两者之间的距离</p></li><li><p>返回一对观光经典能取得的最高分</p></li><li><p>示例：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[8,1,5,2,6]</span><br><span class="line">输出：11</span><br><span class="line">解释：i &#x3D; 0, j &#x3D; 2, A[i] + A[j] + i - j &#x3D; 8 + 5 + 0 - 2 &#x3D; 11</span><br></pre></td></tr></table></figure><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>最直接的思路就是穷举所有的组合，计算其相应得分，最后返回最高得分</li><li><strong>必然超时</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxScoreSightseeingPair</span><span class="params">(self, A: List[int])</span> -&gt; int:</span></span><br><span class="line">    n = len(A)</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, n):</span><br><span class="line">            res = max(res, A[i] + A[j] + i - j)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><br><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li><p>对于得分的计算，我们可以分为两组，即<code>A[i]+i</code>和<code>A[j]-j</code></p></li><li><p>对于每个<code>A[j]-j</code>，我们都去选取前面最大的<code>A[i]+i</code>即可实现结果最大</p></li><li><p>对于第二个子任务（选取数组<code>A</code>前<code>i</code>项的最大值）可以使用动态规划实现</p></li><li><p><strong>状态表示</strong>：<code>dp[]</code></p><ul><li><strong>集合</strong>：前<code>i</code>项所有的<code>A[i]+i</code>的值</li><li><strong>属性</strong>：最大值</li></ul></li><li><p><strong>状态计算</strong></p><ul><li>比较前<code>i-1</code>个中的最大值与当前<code>A[i]+i</code>的大小，取较大值即可</li></ul></li><li><p>常规的，我们使用长为<code>i+1</code>的数组简化操作</p></li><li><p>同时我们发现，<code>dp[i]</code>只与<code>dp[i-1]</code>有关，所以可以仅使用一个变量来存储<code>dp[i-1]</code>即可</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxScoreSightseeingPair</span><span class="params">(self, A: List[int])</span> -&gt; int:</span></span><br><span class="line">    n = len(A)   </span><br><span class="line">    pre = A[<span class="number">0</span>] + <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        res = max(res, pre + A[i] - i)</span><br><span class="line">        pre = max(pre, A[i] + i)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之在D天内送达包裹的能力</title>
      <link href="/passages/leetcode-zhi-zai-d-tian-nei-song-da-bao-guo-de-neng-li/"/>
      <url>/passages/leetcode-zhi-zai-d-tian-nei-song-da-bao-guo-de-neng-li/</url>
      
        <content type="html"><![CDATA[<p>Capacity To Ship Packages Within D Days</p><a id="more"></a><h3 id="Capacity-To-Ship-Packages-Within-D-Days"><a href="#Capacity-To-Ship-Packages-Within-D-Days" class="headerlink" title="Capacity To Ship Packages Within D Days"></a>Capacity To Ship Packages Within D Days</h3><ul><li>code with Python</li><li>title number：1011</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>传送带上的包裹必须在<code>D</code>天内从一个港口运送到另一个港口</li><li>传送带上的第<code>i</code>个包裹的重量为<code>weights[i]</code>。</li><li>每天，我们都会按给出的重量往传送带上装载包裹。装载的重量不会超过船的最大运载重量</li><li>返回能在<code>D</code>天内将传送带上的所有包裹送达的船的最低运载能力</li></ul><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li><p><strong>货物必须按照给定的顺序装运</strong></p></li><li><p>看一个示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：weights &#x3D; [1,2,3,4,5,6,7,8,9,10], D &#x3D; 5</span><br><span class="line">输出：15</span><br><span class="line">解释：</span><br><span class="line">船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：</span><br><span class="line">第 1 天：1, 2, 3, 4, 5</span><br><span class="line">第 2 天：6, 7</span><br><span class="line">第 3 天：8</span><br><span class="line">第 4 天：9</span><br><span class="line">第 5 天：10</span><br></pre></td></tr></table></figure></li><li><p>给定的列表并没有很特殊的地方，我们可以进行一下列表的转化</p><ul><li>将列表中的元素进行合并，直至列表中元素与给定天数相同</li><li>这时，新构建的列表中元素的最大值即为所求<strong>最小运载能力</strong> </li></ul></li><li><p>上面的例子，初始列表中最大值为<code>10</code>，这样我们可以选择将前面的<code>4</code>个元素进行合并，这样可以得到一个<code>7</code>个元素的列表（因为只能按顺序装货，此时仅能将前4个合并以得到更少的元素）</p></li><li><p>既然如此，就要<strong>提高每天搬运的上限</strong>。</p></li><li><p>我们意识到每天的搬运上限是有取值范围的，即<code>[一天搬一袋时的上限, 一天全部搬完的上限]</code>，对应到上述例子中就是<code>[10, 50]</code></p></li><li><p>这样就转化为<strong>在指定范围内查找合适的数值</strong>的问题，面对查找问题，就可以用<strong>二分查找</strong>来解决了</p></li><li><p>只需要通过二分查找不断缩小查找的范围，然后找到<strong>恰好能<code>D</code>天搬运完</strong>的每日半圆上限（即为我们的<strong>最小每日搬运上限</strong>）即可</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shipWithinDays</span><span class="params">(self, weights: List[int], D: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_days</span><span class="params">(weights, limit)</span>:</span></span><br><span class="line">        <span class="comment"># 根据上限判断能搬完的天数</span></span><br><span class="line">        r = <span class="number">0</span></span><br><span class="line">        record = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> weights:</span><br><span class="line">            <span class="comment"># 合并元素</span></span><br><span class="line">            <span class="keyword">if</span> r+w &lt;= limit:</span><br><span class="line">                r += w</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            record.append(r)</span><br><span class="line">            r = w</span><br><span class="line">        record.append(r)</span><br><span class="line">        <span class="keyword">return</span> len(record)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 左右边界</span></span><br><span class="line">    left = max(weights)</span><br><span class="line">    right = sum(weights)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> left == right:</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        mid = (left+right)//<span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        result = get_days(weights, mid)</span><br><span class="line">        <span class="keyword">if</span> result &gt; D:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之骑士拨号器</title>
      <link href="/passages/leetcode-zhi-qi-shi-bo-hao-qi/"/>
      <url>/passages/leetcode-zhi-qi-shi-bo-hao-qi/</url>
      
        <content type="html"><![CDATA[<p>Knight Dialer</p><a id="more"></a><h3 id="Knight-Dialer"><a href="#Knight-Dialer" class="headerlink" title="Knight Dialer"></a>Knight Dialer</h3><ul><li>code with Python</li><li>title number：935</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li><p>国际象棋中的骑士可以按下图的方式移动</p><img src="/.top//knight.png" style="zoom:40%;"></li><li><p>这一次，我们将其实放在电话拨号盘上，接下来骑士将会跳<code>N-1</code>步，每一步必须从一个数字跳到另一个数字</p><img src="/.top//keypad.png" style="zoom:40%;"></li><li><p>骑士每次落到一个键上都会拨出对应的数字，总共按下<code>N</code>位数字。</p></li><li><p>求一共可以拨出多少种不同的号码（因为答案很大，所以输出需要模<code>10^9+7</code>）</p></li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li><strong>深度优先遍历</strong></li><li>对于每一个号码，可以转移的状态是确定的，做以下处理<ul><li>使用数组<code>jump</code>记录每个数字的转移状态，<code>jump[i]</code>即数字<code>i</code>可以转移的状态</li></ul></li><li>这样问题就编程，从<code>0</code>开始的所有路径···从<code>9</code>开始的所有路径</li><li>但是这种暴力遍历必然存在很多重复的计算，超时</li></ul><br><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><ul><li><p><strong>状态表示</strong>：<code>f(start, n)</code></p><ul><li><strong>集合</strong>：从<code>start</code>开始跳<code>n-1</code>步可以得到的数字的个数</li><li><strong>属性</strong>：个数之和</li></ul></li><li><p><strong>状态计算</strong></p><ul><li><p><code>f(start, n)</code>只与上一个可直接跳到<code>start</code>的数字有关</p><p>$$f(start, n) = \sum f(x, n-1), x是可直接跳到start的数字$$</p></li></ul></li><li><p>所以要先进行处理，使用数组<code>move</code>保存转移关系</p><ul><li>例如，当<code>start=0</code>时，可以由<code>6</code>或<code>8</code>直接跳到，所以<code>move[0]=[6, 8]</code></li></ul></li><li><p>所求即为<code>f(0, n) + ... f(9, n)</code></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">knightDialer</span><span class="params">(self, N)</span>:</span></span><br><span class="line">    MOD = <span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span></span><br><span class="line">    </span><br><span class="line">    moves = [[<span class="number">4</span>, <span class="number">6</span>], [<span class="number">6</span>, <span class="number">8</span>], [<span class="number">7</span>, <span class="number">9</span>], [<span class="number">4</span>, <span class="number">8</span>], [<span class="number">3</span>, <span class="number">9</span>, <span class="number">0</span>], [], [<span class="number">1</span>, <span class="number">7</span>, <span class="number">0</span>], [<span class="number">2</span>, <span class="number">6</span>], [<span class="number">1</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">4</span>]]</span><br><span class="line">    </span><br><span class="line">    dp = [<span class="number">1</span>] * <span class="number">10</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> hops <span class="keyword">in</span> xrange(N<span class="number">-1</span>):</span><br><span class="line">        dp2 = [<span class="number">0</span>]*<span class="number">10</span></span><br><span class="line">        <span class="keyword">for</span> node, count <span class="keyword">in</span> enumerate(dp):</span><br><span class="line">            <span class="keyword">for</span> nei <span class="keyword">in</span> moves[node]:</span><br><span class="line">                dp2[nei] += count</span><br><span class="line">                dp2[nei] %= MOD</span><br><span class="line">        dp = dp2</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> sum(dp) % MOD</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之排序数组</title>
      <link href="/passages/leetcode-zhi-pai-xu-shu-zu/"/>
      <url>/passages/leetcode-zhi-pai-xu-shu-zu/</url>
      
        <content type="html"><![CDATA[<p>Sort an Array</p><a id="more"></a><h3 id="Sort-an-Array"><a href="#Sort-an-Array" class="headerlink" title="Sort an Array"></a>Sort an Array</h3><ul><li>code with Python</li><li>title number：912</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个整数数组<code>nums</code>，将该数组升序排序</li></ul><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>考察最基本的排序算法</li><li>排序算法可以分为多类，有不同的划分标准：稳定性、内外排序、时空复杂度等</li><li>下面依次实现常见的多种排序算法</li><li><strong>选择排序</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortArray</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">                nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><ul><li><strong>冒泡排序</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortArray</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n-c):</span><br><span class="line">            <span class="keyword">if</span> nums[i<span class="number">-1</span>] &gt; nums[i]:</span><br><span class="line">                nums[i<span class="number">-1</span>], nums[i] = nums[i], nums[i<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><ul><li><strong>插入排序</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortArray</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i<span class="number">-1</span>] &gt; nums[i]:</span><br><span class="line">            nums[i<span class="number">-1</span>], nums[i] = nums[i], nums[i<span class="number">-1</span>]</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><ul><li><strong>希尔排序</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortArray</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">   gap = n // <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> gap:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(gap, n):</span><br><span class="line">            <span class="keyword">while</span> i - gap &gt;= <span class="number">0</span> <span class="keyword">and</span> nums[i-gap] &gt; nums[i]:</span><br><span class="line">                nums[i - gap], nums[i] = nums[i], nums[i - gap]</span><br><span class="line">                i -= gap</span><br><span class="line">        gap //= <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><ul><li><strong>归并排序</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(left, right)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; len(left) <span class="keyword">and</span> j &lt; len(right):</span><br><span class="line">        <span class="keyword">if</span> left[i] &lt;= right[j]:</span><br><span class="line">            res.append(left[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res.append(right[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    res += left[i:]</span><br><span class="line">    res += right[j:]</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortArray</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    mid = len(nums) // <span class="number">2</span></span><br><span class="line">    <span class="comment"># 分</span></span><br><span class="line">    left = merge_sort(nums[:mid])</span><br><span class="line">    right = merge_sort(nums[mid:])</span><br><span class="line">    <span class="comment"># 合并</span></span><br><span class="line">    <span class="keyword">return</span> merge(left, right)</span><br></pre></td></tr></table></figure><ul><li><strong>快速排序</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortArray</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quick</span><span class="params">(left, right)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> left &gt;= right:</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line">        pivot = left</span><br><span class="line">        i = left</span><br><span class="line">        j = right</span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[j] &gt; nums[pivot]:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[i] &lt;= nums[pivot]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        nums[pivot], nums[j] = nums[j], nums[pivot]</span><br><span class="line">        quick(left, j - <span class="number">1</span>)</span><br><span class="line">        quick(j + <span class="number">1</span>, right)</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> quick(<span class="number">0</span>, n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>堆排序</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortArray</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">    <span class="comment"># 调整堆</span></span><br><span class="line">    <span class="comment"># 迭代写法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">adjust_heap</span><span class="params">(nums, startpos, endpos)</span>:</span></span><br><span class="line">        newitem = nums[startpos]</span><br><span class="line">        pos = startpos</span><br><span class="line">        childpos = pos * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> childpos &lt; endpos:</span><br><span class="line">            rightpos = childpos + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> rightpos &lt; endpos <span class="keyword">and</span> nums[rightpos] &gt;= nums[childpos]:</span><br><span class="line">                childpos = rightpos</span><br><span class="line">            <span class="keyword">if</span> newitem &lt; nums[childpos]:</span><br><span class="line">                nums[pos] = nums[childpos]</span><br><span class="line">                pos = childpos</span><br><span class="line">                childpos = pos * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        nums[pos] = newitem</span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="comment"># 建堆</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(n // <span class="number">2</span>)):</span><br><span class="line">        adjust_heap(nums, i, n)</span><br><span class="line">    <span class="comment"># 调整堆</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        nums[<span class="number">0</span>], nums[i] = nums[i], nums[<span class="number">0</span>]</span><br><span class="line">        adjust_heap(nums, <span class="number">0</span>, i)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><ul><li><strong>基数排序</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortArray</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> []</span><br><span class="line">    _max = max(nums)</span><br><span class="line">    <span class="comment"># 最大位数</span></span><br><span class="line">    maxDigit = len(str(_max))</span><br><span class="line">    bucketList = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">    <span class="comment"># 从低位开始排序</span></span><br><span class="line">    div, mod = <span class="number">1</span>, <span class="number">10</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(maxDigit):</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            bucketList[num % mod // div].append(num)</span><br><span class="line">        div *= <span class="number">10</span></span><br><span class="line">        mod *= <span class="number">10</span></span><br><span class="line">        idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> bucketList[j]:</span><br><span class="line">                nums[idx] = item</span><br><span class="line">                idx += <span class="number">1</span></span><br><span class="line">            bucketList[j] = []</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><ul><li><strong>桶排序</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortArray</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    _min = min(nums)</span><br><span class="line">    _max = max(nums)</span><br><span class="line">    <span class="comment"># 需要桶个数</span></span><br><span class="line">    bucketNum = (_max - _min) // bucketSize + <span class="number">1</span></span><br><span class="line">    buckets = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(bucketNum)]</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="comment"># 放入相应的桶中</span></span><br><span class="line">        buckets[(num - _min) // bucketSize].append(num)</span><br><span class="line">    res = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> bucket <span class="keyword">in</span> buckets:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> bucket: <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> bucketSize == <span class="number">1</span>:</span><br><span class="line">            res.extend(bucket)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 当都装在一个桶里,说明桶容量大了</span></span><br><span class="line">            <span class="keyword">if</span> bucketNum == <span class="number">1</span>:</span><br><span class="line">                bucketSize -= <span class="number">1</span></span><br><span class="line">            res.extend(bucket_sort(bucket, bucketSize))</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之RLE迭代器</title>
      <link href="/passages/leetcode-zhi-rle-die-dai-qi/"/>
      <url>/passages/leetcode-zhi-rle-die-dai-qi/</url>
      
        <content type="html"><![CDATA[<p>RLE Iterator</p><a id="more"></a><h3 id="RLE-Iterator"><a href="#RLE-Iterator" class="headerlink" title="RLE Iterator"></a>RLE Iterator</h3><ul><li>code with Python</li><li>title number：900</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li><p>编写一个遍历游程编码序列的迭代器</p></li><li><p>迭代器由<code>RLEIterator(int[] A)</code>初始化，其中<code>A</code>是某个序列的游程编码</p><ul><li>对于所有偶数<code>i</code>，<code>A[i]</code>告诉我们在序列中重复非负整数值<code>A[i+1]</code>的次数</li></ul></li><li><p>迭代其支持一个函数<code>next(int n)</code>，它耗尽接下来的<code>n</code>个元素<code>(n&gt;=1)</code>，并返回以这种方式耗去的最后一个元素。如果没有剩余的元素可供耗尽，则<code>next</code>返回<code>-1</code></p></li><li><p>例如，我们以 <code>A = [3,8,0,9,2,5]</code> 开始，这是序列 <code>[8,8,8,5,5]</code> 的游程编码。这是因为该序列可以读作 “三个八，零个九，两个五”。</p></li><li><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：[&quot;RLEIterator&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;], [[[3,8,0,9,2,5]],[2],[1],[1],[2]]</span><br><span class="line">输出：[null,8,8,5,-1]</span><br><span class="line">解释：</span><br><span class="line">RLEIterator 由 RLEIterator([3,8,0,9,2,5]) 初始化。</span><br><span class="line">这映射到序列 [8,8,8,5,5]。</span><br><span class="line">然后调用 RLEIterator.next 4次。</span><br><span class="line"></span><br><span class="line">.next(2) 耗去序列的 2 个项，返回 8。现在剩下的序列是 [8, 5, 5]。</span><br><span class="line">.next(1) 耗去序列的 1 个项，返回 8。现在剩下的序列是 [5, 5]。</span><br><span class="line">.next(1) 耗去序列的 1 个项，返回 5。现在剩下的序列是 [5]。</span><br><span class="line">.next(2) 耗去序列的 2 个项，返回 -1。 这是由于第一个被耗去的项是 5，但第二个项并不存在。由于最后一个要耗去的项不存在，我们返回 -1。</span><br></pre></td></tr></table></figure></li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li><p>编码中两个数表示一种状态，例如<code>3, 8 -&gt; 三个八</code>，第一个是元素个数，第二个是元素值</p></li><li><p>在调用<code>next()</code>时，不改变数组的值，而是维护两个变量<code>i, q</code>，<code>i</code>表示迭代器当前指向的元素是<code>A[i+1]</code>，<code>q</code>表示它已经被删除的次数，<code>q</code>的值不会大于<code>A[i]</code></p></li><li><p>调用<code>next(n)</code>时，即删除<code>n</code>个元素，相对与当前的元素<code>A[i+1]</code>，我们还可以删除的次数为<code>D=A[i]-q</code></p><ul><li>如果<code>n &gt; D</code>，那么我们会删除所有的<code>A[i+1]</code>，并迭代下一个元素，即<code>n-=D, i+=2, q=0</code></li><li>如果<code>n &lt;= D</code>，那么我们删除的最后一个元素为<code>A[i+1]</code>，即<code>q+=D, return A[i+1]</code></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RLEIterator</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, A: List[int])</span>:</span></span><br><span class="line">        self.A = A</span><br><span class="line">        self.i = <span class="number">0</span></span><br><span class="line">        self.q = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">while</span> self.i &lt; len(self.A):</span><br><span class="line">            <span class="keyword">if</span> self.q + n &gt; self.A[self.i]:</span><br><span class="line">                n -= self.A[self.i] - self.q</span><br><span class="line">                self.q = <span class="number">0</span></span><br><span class="line">                self.i += <span class="number">2</span>   </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.q += n</span><br><span class="line">                <span class="keyword">return</span> self.A[self.i+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之鸡蛋掉落</title>
      <link href="/passages/leetcode-zhi-ji-dan-diao-luo/"/>
      <url>/passages/leetcode-zhi-ji-dan-diao-luo/</url>
      
        <content type="html"><![CDATA[<p>Super Egg Drop</p><a id="more"></a><h3 id="Super-Egg-Drop"><a href="#Super-Egg-Drop" class="headerlink" title="Super Egg Drop"></a>Super Egg Drop</h3><ul><li>code with Python</li><li>title number：887</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li><p>你有<code>K</code>个鸡蛋，可以使用移动从<code>1</code>到<code>N</code>的<code>N</code>层楼的建筑</p></li><li><p>每个鸡蛋功能相同，且摔碎之后不能再用</p></li><li><p>存在楼层<code>F</code>，满足<code>0 &lt;= F &lt;= N</code>任何从高于<code>F</code>的楼层落下的鸡蛋会碎，低于<code>F</code>的楼层落下的鸡蛋不会碎</p></li><li><p>每次移动，可以取一个鸡蛋从任一楼层扔下，来测试确切的<code>F</code>的值</p></li><li><p>无论<code>F</code>的值如何，请计算<strong>确定F的值的最小移动次数为多少</strong></p></li><li><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：K &#x3D; 1, N &#x3D; 2</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">鸡蛋从1楼掉落，如果碎了，则F &#x3D; 0</span><br><span class="line">否则，鸡蛋从二楼掉落，如果碎了，则F &#x3D; 1；如果没碎，则F &#x3D; 2</span><br><span class="line">因此最坏的情况下需要移动两次才能确定</span><br></pre></td></tr></table></figure></li></ul><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li><p>动态规划</p></li><li><p><strong>最直接的想法</strong></p></li><li><p><strong>状态表示</strong></p></li><li><p><strong>集合</strong>：有<code>i</code>个鸡蛋，<code>j</code>层楼，测试出<code>F</code>的需要的次数的集合</p><ul><li><strong>属性</strong>：最小值</li></ul></li><li><p><strong>状态计算</strong></p></li><li><p>状态转移方程为：<code>dp[i][j] = min(dp[i-1][j-1], dp[i][N-j]+1)</code></p><ul><li>前者表示在第<code>j</code>层楼扔下去，碎了，下次只有<code>i-1</code>个鸡蛋，测试<code>j</code>层之下的<code>j-1</code>层楼即可</li><li>后者表示在第<code>j</code>层楼扔下去，没碎，下次只有<code>i-1</code>个鸡蛋，测试<code>j</code>层之上的<code>N-j</code>层楼即可</li></ul></li><li><p><strong>这种方式的时间复杂度太高，相当于穷举</strong></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">superEggDrop</span><span class="params">(self, K: int, N: int)</span> -&gt; int:</span></span><br></pre></td></tr></table></figure><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li>还是动态规划，转化一下想法</li><li><strong>状态表示</strong><ul><li>有<code>i</code>个鸡蛋，扔<code>j</code>次</li><li><strong>集合</strong>：测试出<code>F</code>需要的次数的集合</li><li><strong>属性</strong>：最小值</li></ul></li><li><strong>状态计算</strong><ul><li><code>dp[i][j] = dp[i-1][j-1] + dp[i][j-1]+1</code><ul><li>前者表示扔了一次之后，碎了，还剩<code>j-1</code>次机会</li><li>后者表示扔了一次之后，没碎，还剩<code>j-1</code>次机会</li></ul></li><li>因为<code>dp[i][j]</code>只与<code>dp[][j-1]</code>有关，所以可以简化为一维数组，遍历时倒序遍历即可</li><li><code>dp[i] = dp[i-1] + dp[i]+1</code></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">superEggDrop</span><span class="params">(self, k: int, N: int)</span> -&gt; int:</span></span><br><span class="line">    dp = [<span class="number">0</span>]*(K+<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> dp[<span class="number">-1</span>] &lt; N:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(K, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            dp[i] = dp[i] + dp[i<span class="number">-1</span>]+<span class="number">1</span></span><br><span class="line">        cnt += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之石子游戏</title>
      <link href="/passages/leetcode-zhi-shi-zi-you-xi/"/>
      <url>/passages/leetcode-zhi-shi-zi-you-xi/</url>
      
        <content type="html"><![CDATA[<p>Stone Game</p><a id="more"></a><h3 id="Stone-Game"><a href="#Stone-Game" class="headerlink" title="Stone Game"></a>Stone Game</h3><ul><li>code with Python</li><li>title number：877</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li><p><code>A</code>和<code>B</code>用几堆石子做游戏。石子的<strong>堆数是偶数</strong>，石子堆<strong>排成一行</strong>，每堆有<strong>正整数</strong>颗石子<code>piles[i]</code></p></li><li><p>以谁手中的石子最多来决定胜负。石子总数为奇数，没有平局</p></li><li><p>两人轮流进行，每回合玩家从行的开始或结束处取走整堆石头，直到取完</p></li><li><p>假设两个都采取最佳方案，当<code>A</code>获胜时返回<code>True</code>，当<code>B</code>获胜时返回<code>False</code></p></li><li><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：[5,3,4,5]</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">    亚历克斯先开始，只能拿前 5 颗或后 5 颗石子 。</span><br><span class="line">    假设他取了前 5 颗，这一行就变成了 [3,4,5] 。</span><br><span class="line">    如果李拿走前 3 颗，那么剩下的是 [4,5]，亚历克斯拿走后 5 颗赢得 10 分。</span><br><span class="line">    如果李拿走后 5 颗，那么剩下的是 [3,4]，亚历克斯拿走后 4 颗赢得 9 分。</span><br><span class="line">    这表明，取前 5 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 true 。</span><br></pre></td></tr></table></figure></li></ul><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>博弈问题，因为这道题的限制比较多，可以通过分析得出结论</li><li>因为石子堆是偶数堆，而<code>A</code>是先手，所以他可以做到取所有序号为偶数的堆（第一次取最后一堆），也可以做到取所有序号为奇数的堆（第一次取第一堆）</li><li>既然如此，<code>B</code>是没有选择权的，只能被动的选择</li><li>只需要计算所有奇数堆和所有偶数堆哪个大选择哪个即可</li><li>所以，在本题的情境中，<strong><code>A</code>立于不败之地</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stoneGame</span><span class="params">(self, piles: List[int])</span> -&gt; bool:</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><br><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li><p>博弈问题，两者都会选择最有利于自己的方案，不过这道题的限制太多（<strong>先手必胜</strong>），我们将其推广到更<strong>通用</strong>的情况来分析</p><blockquote><p>A和B面前有一排石头堆，用一个数组piles表示，piles[i]表示第i堆石子有多少个。</p><p>轮流拿石头，一次拿一堆，但是<strong>只能</strong>拿走最左边或者最右边的石头堆。所有石头被拿完后，<strong>谁拥有的石头多，谁获胜</strong></p></blockquote></li><li><p><strong>状态表示</strong>：<code>dp[i][j]</code></p><ul><li>想要使用动态规划，首先要抽象出总问题与子问题之间的关系<ul><li><code>[i, ..., j]</code>之间先手和后手能获得的最高分数</li><li>每个状态要存储两个值，我们使用对象来存储</li></ul></li><li><strong>集合</strong>：第<code>i</code>到第<code>j</code>个石堆先手和后手的可能的得分的集合</li><li><strong>属性</strong>：先手和后手得分的<strong>最大值</strong></li></ul></li><li><p><strong>状态计算</strong></p><ul><li><p>对于每一个状态，只有两个选择：选择最左边的石堆，选择最右边的石堆。我们可以穷举出所有状态</p></li><li><p>故：以先手选择取左边还是右边的石堆作为集合划分标准</p></li><li><p><strong>如果先手选择左边的石堆</strong>，则：</p><ul><li><code>dp[i][j].first = piles[i] + dp[i+1][j].second</code><ul><li>在<code>[i, ... j]</code>是先手，则在下一步<code>[i+1, ..., j]</code>就变成了后手</li></ul></li><li><code>dp[i][j].second = dp[i+1][j].first</code><ul><li>在<code>[i, ... j]</code>是后手，则在<code>[i+1, ..., j]</code>就变成了先手</li></ul></li></ul></li><li><p><strong>如果先手选择右边的石堆</strong>，则：</p><ul><li><code>dp[i][j].first = piles[j] + dp[i][j-1].second</code><ul><li>在<code>[i, ... j]</code>是先手，则在下一步<code>[i, ..., j-1]</code>就变成了后手</li></ul></li><li><code>dp[i][j].first = dp[i][j-1].first</code><ul><li>在<code>[i, ... j]</code>是后手，则在<code>[i, ..., j]</code>就变成了先手</li></ul></li></ul></li></ul></li><li><p><strong>初始化</strong></p><ul><li>如果只有一堆石头，即<code>i==j</code>时，先手得到该堆石头，后手什么都没有<ul><li><code>dp[i][j].first = piles[i]</code></li><li><code>dp[i][j].second = 0</code></li></ul></li></ul></li><li><p><strong>所求</strong></p><ul><li><code>dp[0][n-1]</code>中<code>first</code>与<code>second</code>的大小关系</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init</span> <span class="title">__</span><span class="params">(self, first, second)</span>:</span></span><br><span class="line">    self.first = first</span><br><span class="line">    self.second = second</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stoneGame</span><span class="params">(self, piles: List[int])</span> -&gt; bool:</span></span><br><span class="line">    len_ = len(piles)</span><br><span class="line">dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len_)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len_)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len_):</span><br><span class="line">        dp[i][i].first = piles[i]</span><br><span class="line">        dp[i][i].second = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 斜着遍历数组    </span></span><br><span class="line">     <span class="keyword">for</span> i <span class="keyword">in</span> range(len_<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>):<span class="comment"># (len-2, 0)</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len_):<span class="comment"># (i+1, len-1)</span></span><br><span class="line">            left = piles[i] + dp[i+<span class="number">1</span>][j].second</span><br><span class="line">            right = piles[j] + dp[i][j<span class="number">-1</span>].second</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> left &gt; right:</span><br><span class="line">                dp[i][j].first = left</span><br><span class="line">                dp[i][j].second = dp[i+<span class="number">1</span>][j].first</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][j].first = right</span><br><span class="line">                dp[i][j].second = dp[i][j<span class="number">-1</span>].first</span><br><span class="line">    </span><br><span class="line">    res = dp[<span class="number">0</span>][n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">if</span> res.first &gt; res.second:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之爱吃香蕉的珂珂</title>
      <link href="/passages/leetcode-zhi-ai-chi-xiang-jiao-de-ke-ke/"/>
      <url>/passages/leetcode-zhi-ai-chi-xiang-jiao-de-ke-ke/</url>
      
        <content type="html"><![CDATA[<p>Koko Eating Bananas</p><a id="more"></a><h3 id="Koko-Eating-Bananas"><a href="#Koko-Eating-Bananas" class="headerlink" title="Koko Eating Bananas"></a>Koko Eating Bananas</h3><ul><li>code with Python</li><li>title number：875</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li><p>珂珂喜欢吃香蕉，这里有<code>N</code>堆香蕉，第<code>i</code>堆中有<code>piles[i]</code>根香蕉。警卫已经离开，将在<code>H</code>小时候返回</p></li><li><p>珂珂可以决定自己的吃香蕉速度<code>K</code>（每小时<code>K</code>根）</p></li><li><p>每小时选择一堆香蕉，吃掉其中的<code>K</code>根香蕉。如果该堆少于<code>K</code>根则吃掉整堆的香蕉，并且在该小时内不能吃其他堆的香蕉</p></li><li><p>返回珂珂可以在<code>H</code>小时内吃掉所有香蕉的<strong>最小速度<code>K</code></strong></p></li><li><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：piles &#x3D; [3, 6, 7, 11], H &#x3D; 8</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure></li></ul><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li><p>直觉上，不断进行尝试，从令<code>K = 最大堆的香蕉数开始尝试</code>，如果可行，则减小<code>1</code>，如果不行则返回上一次的结果。一次类推，计算出刚好不行的临界值即可</p></li><li><p>或者假设珂珂吃的特别慢，从<code>K = 1</code>开始，不断提高速度，直到刚刚可以在规定时间内吃完</p></li><li><p>但是使用二分查找能有效减小时间复杂度（题目的相关标签中也有提示使用二分查找）</p><ul><li>由于只能每个小时选择其中一堆吃，所以速度的最大值就是最大堆的香蕉数，最小值为1</li><li>每堆香蕉吃完的耗时 = 这对香蕉的数量 / 速度（不能整除时取上界）</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minEatingSpeed</span><span class="params">(self, piles: List[int], H: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cal_sum</span><span class="params">(self, piles, speed)</span>:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> pile <span class="keyword">in</span> piles:</span><br><span class="line">            res += (pile + speed - <span class="number">1</span>) // speed</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    left = <span class="number">1</span></span><br><span class="line">    right = max(piles)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        mid = (left + right) &gt;&gt; <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> cal_sum(piles, mid) &gt; H:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid</span><br><span class="line">    <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><p><strong>绝大多数在递增递减区间中搜索目标值的问题都可以转化为二分查找问题</strong></p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之单词的压缩编码</title>
      <link href="/passages/leetcode-zhi-dan-ci-de-ya-suo-bian-ma/"/>
      <url>/passages/leetcode-zhi-dan-ci-de-ya-suo-bian-ma/</url>
      
        <content type="html"><![CDATA[<p>Short Encoding of Words</p><a id="more"></a><h3 id="Short-Encoding-of-Words"><a href="#Short-Encoding-of-Words" class="headerlink" title="Short Encoding of Words"></a>Short Encoding of Words</h3><ul><li>code with Python</li><li>title number：820</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li><p>给定一个单词列表，讲这个列表编码称一个索引字符串<code>S</code>与索引列表<code>A</code></p></li><li><p>通过每个索引，我们可以通过从字符串<code>S</code>中索引的位置开始读取字符串，直到<code>#</code>结束，以此来恢复我们的单词列表</p></li><li><p>返回给单词列表进行编码的最小字符串长度</p></li><li><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：words &#x3D; [&#39;time&#39;, &#39;me&#39;, &#39;bell&#39;]</span><br><span class="line">输出：10</span><br><span class="line">说明：S &#x3D; &#39;time#bell#&#39;, indexes &#x3D; [0, 2, 5]</span><br></pre></td></tr></table></figure></li></ul><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>解读一下上面给出的例子，对于<code>time</code>和<code>me</code>拥有相同的后缀，所以可以不用重复存储，而只需要记录起始位置为<code>[0, 2]</code>就可以恢复原来的字符序列</li><li>由于这种共享后缀的特性我们联想到了后缀树，而之前我们做过关于前缀树（字典树）的题目<a href="http://www.zivblog.top/passages/leetcode-zhi-shi-xian-trie/" target="_blank" rel="noopener">实现Trie</a></li><li>而只需要将字符串逆序存储，原来的共同后缀就变为了共同前缀，也就可以使用前缀树解决了</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">self.lookup = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, word: str)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Inserts a word into the trie.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">tree = self.lookup</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> word:</span><br><span class="line"><span class="keyword">if</span> a <span class="keyword">not</span> <span class="keyword">in</span> tree:</span><br><span class="line">                <span class="comment"># 新节点</span></span><br><span class="line">                tree[a] = &#123;&#125;</span><br><span class="line">            tree = tree[a]</span><br><span class="line">        <span class="comment"># 设置单词的结束标志</span></span><br><span class="line">        tree[<span class="string">"#"</span>] = <span class="string">"#"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, word: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Returns if the word is in the trie.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">tree = self.lookup</span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> a <span class="keyword">not</span> <span class="keyword">in</span> tree:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">            tree = tree[a]</span><br><span class="line">        <span class="keyword">if</span> <span class="string">"#"</span> <span class="keyword">in</span> tree:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">startsWith</span><span class="params">(self, prefix: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Returns if there is any word in the trie that starts with the given prefix.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        tree = self.lookup</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> prefix:</span><br><span class="line">            <span class="keyword">if</span> a <span class="keyword">not</span> <span class="keyword">in</span> tree:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            tree = tree[a]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minimumLengthEncoding</span><span class="params">(self, word: List[str])</span> -&gt; int:</span></span><br><span class="line">len_ = <span class="number">0</span></span><br><span class="line">    trie = Trie()</span><br><span class="line">    </span><br><span class="line">    words = set(words)</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">        <span class="comment"># 插入的是字符串逆序</span></span><br><span class="line">        trie.insert(word[::<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">        <span class="keyword">if</span> trie.startsWith(word[::<span class="number">-1</span>]):</span><br><span class="line">            len_ += len(word) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之在系统中查找重复文件</title>
      <link href="/passages/leetcode-zhi-zai-xi-tong-zhong-cha-zhao-chong-fu-wen-jian/"/>
      <url>/passages/leetcode-zhi-zai-xi-tong-zhong-cha-zhao-chong-fu-wen-jian/</url>
      
        <content type="html"><![CDATA[<p>Find Duplicate File in System</p><a id="more"></a><h3 id="Find-Duplicate-File-in-System"><a href="#Find-Duplicate-File-in-System" class="headerlink" title="Find Duplicate File in System"></a>Find Duplicate File in System</h3><ul><li>code with Python</li><li>title number：609</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li><p>给定一个目录信息列表，包括目录路径以及目录中的所有包含内容的文件</p></li><li><p>找到文件系统中的所有重复文件组的路径</p></li><li><p>一组重复的文件至少包含<strong>两个完全相同内容的文件</strong></p></li><li><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入列表格式为：</span><br><span class="line">&quot;root&#x2F;d1&#x2F;d2&#x2F;...&#x2F;dm f1.txt(f1_content) f2.txt(f2_content) ... fn.txt(fn_content)&quot;</span><br><span class="line">表示有n个文件：f1.txt, f2.txt ... fn.txt </span><br><span class="line">内容分别为：f1_content, f2_content ... fn_content</span><br><span class="line">输出为一个列表，包含文件路径及文件名</span><br></pre></td></tr></table></figure></li><li><p>对输出顺序无要求</p></li><li><p>同意目录中没有没有同名文件或目录</p></li></ul><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>使用字典存储<ul><li><code>key</code>为文件内容，<code>value</code>为文件路径列表，遍历一遍列表</li><li>输出时要输出<code>value</code>列表长度大于<code>2</code>的</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findDuplicate</span><span class="params">(self, paths: List[str])</span> -&gt; List[List[str]]:</span></span><br><span class="line">dict_ = collections.defaultdict(list)</span><br><span class="line">    <span class="keyword">for</span> path <span class="keyword">in</span> paths:</span><br><span class="line">        splits = path.split(<span class="string">" "</span>)</span><br><span class="line">        folder, files = splits[<span class="number">0</span>], splits[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">            <span class="comment"># 以左括号划分</span></span><br><span class="line">            name, content = file.split(<span class="string">'('</span>)</span><br><span class="line">            dict[content] += [folder+<span class="string">'/'</span>+name]</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> dict_.values():</span><br><span class="line">        <span class="keyword">if</span> len(value) &gt;= <span class="number">2</span>:</span><br><span class="line">            result.append(value)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之朋友圈</title>
      <link href="/passages/leetcode-zhi-peng-you-quan/"/>
      <url>/passages/leetcode-zhi-peng-you-quan/</url>
      
        <content type="html"><![CDATA[<p>Friend Circles</p><a id="more"></a><h3 id="Friend-Circles"><a href="#Friend-Circles" class="headerlink" title="Friend Circles"></a>Friend Circles</h3><ul><li>code with Python</li><li>title number：547</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li><p>班上有<code>N</code>名学生，其中有一些人是朋友，有一些不是</p></li><li><p>他们的友谊具有传递性，即<code>A</code>与<code>B</code>是朋友，<code>B</code>与<code>C</code>是朋友，则<code>A</code>与<code>C</code>也是朋友</p></li><li><p>给定一个<code>N*N</code>的矩阵，表示班级中学生之间的朋友关系。如果<code>M[i][j]=1</code>，则表示第<code>i</code>个学生与第<code>j</code>个学生互为朋友</p></li><li><p>输出所有一直的朋友圈总数</p></li><li><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：[[1, 1, 0],</span><br><span class="line">  [1, 1, 0],</span><br><span class="line">  [0, 0, 1]]</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">第1个和第2个学生互为朋友，是一个朋友圈</span><br><span class="line">第3个学生自己在一个朋友圈</span><br></pre></td></tr></table></figure></li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>可以当作连通区域问题解决，具体可参考<a href="http://www.zivblog.top/passages/leetcode-zhi-dao-yu-shu-liang/" target="_blank" rel="noopener">岛屿数量</a>和<a href="http://www.zivblog.top/passages/leetcode-zhi-bei-wei-rao-de-qu-yu/" target="_blank" rel="noopener">被围绕的区域</a></li><li>使用深度搜索查找矩阵中的连通区域</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findCircleNum</span><span class="params">(self, M: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(M, visited, i)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(M)):</span><br><span class="line">            <span class="keyword">if</span> M[i][j] == <span class="number">1</span> <span class="keyword">and</span> visited[j] == <span class="number">0</span>:</span><br><span class="line">                visited[j] = <span class="number">1</span></span><br><span class="line">                dfs(M, visited, j)</span><br><span class="line">                </span><br><span class="line">    visited = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(M))]</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(M)):</span><br><span class="line">        <span class="keyword">if</span> visited[i] == <span class="number">0</span>:</span><br><span class="line">            dfs(M, visited, i)</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><br><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li>使用并查集统计连通块数量</li><li>使用一个大小为<code>N</code>的<code>parent</code>数组，遍历整个图，每个结点都遍历所有相邻点，并将相邻点指向该节点，设置成一个<code>parent</code>数组结点决定的单独组，即<code>union</code>过程</li><li>对于新节点，寻找其父亲，如果父亲结点一样，则在同一个组内</li><li>如果父亲节点不同，则仍需要合并，故将其父亲节点合并</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findCircleNum</span><span class="params">(self, M: List[List[int]])</span> -&gt; int:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(parent, i)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> parent[i] == <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> find(parent, parent[i])</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(parent, x, y)</span>:</span></span><br><span class="line">        x_set = find(parent, x)</span><br><span class="line">        y_set = find(parent, y)</span><br><span class="line">        <span class="keyword">if</span> x_set != y_set:</span><br><span class="line">            parent[x_set] = y_set</span><br><span class="line">    </span><br><span class="line">    parent = [<span class="number">-1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(M))]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(M)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(M)):</span><br><span class="line">            <span class="keyword">if</span> M[i][j] == <span class="number">1</span> <span class="keyword">and</span> i != j:</span><br><span class="line">                union(parent, i, j)</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(parent)):</span><br><span class="line">        <span class="keyword">if</span> parent[i] == <span class="number">-1</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><ul><li>实际尝试中，并查集的时间复杂度更高</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之零钱兑换Ⅱ</title>
      <link href="/passages/leetcode-zhi-ling-qian-dui-huan-ii/"/>
      <url>/passages/leetcode-zhi-ling-qian-dui-huan-ii/</url>
      
        <content type="html"><![CDATA[<p>Coin Change Ⅱ</p><a id="more"></a><h3 id="Coin-Change-Ⅱ"><a href="#Coin-Change-Ⅱ" class="headerlink" title="Coin Change Ⅱ"></a>Coin Change Ⅱ</h3><ul><li>code with Python</li><li>title number：518</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li><p>给定不同面额的硬币和一个总金额，计算有多少中凑成总金额的硬币组合数</p></li><li><p>每种面额的硬币都有无限个</p></li><li><p>示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：amount &#x3D; 5，coins &#x3D; [1, 2, 5]</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">5 &#x3D; 5</span><br><span class="line">5 &#x3D; 2 + 2 + 1</span><br><span class="line">5 &#x3D; 2 + 1 + 1 + 1</span><br><span class="line">5 &#x3D; 1 + 1 + 1 + 1 + 1</span><br></pre></td></tr></table></figure></li></ul><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li><p>很明显的完全背包问题的变体，使用动态规划解决</p></li><li><p><strong>状态表示</strong>：$f(i, j)$</p><ul><li><strong>集合</strong>：使用前<code>i</code>种硬币凑出金额<code>j</code>的方法数</li><li><strong>属性</strong>：总数（求和）</li></ul></li><li><p><strong>状态计算</strong></p><ul><li><p>以前<code>i</code>种硬币中第<code>i</code>个硬币是否使用作为集合分割标准</p></li><li><p>第<code>i</code>种硬币不用，$f(i, j) = f(i-1, j)$</p></li><li><p>第<code>i</code>中硬币选用，<code>k</code>是满足<code>j &gt;= k*coin[i]</code>的最大值</p><p>$f(i, j) = f(i-1, j-1<em>coin[i]) + f(i-1, j-2</em>coin[i])+…f(i-1, j-k*coin[i])$</p></li><li><p>综上：<br>$$<br>f(i, j) = f(i-1,j) + f(i-1, j-1<em>coin[i]) + f(i-1, j-2</em>coin[i])+…f(i-1, j-k*coin[i])<br>$$</p><ul><li>令<code>j = j-coin[i]</code>，则</li></ul><p>$$<br>f(i, j-coin[i]) = f(i-1,j-coin[i]) + f(i-1, j-2<em>coin[i])+…f(i-1, j-k</em>coin[i])<br>$$</p></li></ul></li></ul><pre><code>- 结合两式，可得到$$f(i, j) = f(i, j-coin[i]) + f(i-1, j)$$</code></pre><ul><li>所求即为，$f(len(coins), amount)$</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span><span class="params">(self, amount: int, coins: List[int])</span> -&gt; int:</span></span><br><span class="line">    n = len(coins)</span><br><span class="line">    dp = [[<span class="number">0</span>]*(amount+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>):</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, amount+<span class="number">1</span>):</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">            <span class="keyword">if</span> j &gt;= coins[i<span class="number">-1</span>]:</span><br><span class="line">                dp[i][j] = dp[i][j] + dp[i][j-coins[i<span class="number">-1</span>]]</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><ul><li>使用<code>dp[i]</code>表示组成金额<code>i</code>的总组合数</li><li>对于小于最小硬币面值的金额，跳过</li><li>每个金额遍历一遍硬币，进行更新</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span><span class="params">(self, amount: int, coins: List[int])</span> -&gt; int:</span></span><br><span class="line">    n = len(coins)</span><br><span class="line">    dp = [<span class="number">0</span>]*(amount+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(coin, amount):</span><br><span class="line">            dp[j] = dp[j] + dp[j-coin]</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之最长回文子序列</title>
      <link href="/passages/leetcode-zhi-zui-chang-hui-wen-zi-xu-lie/"/>
      <url>/passages/leetcode-zhi-zui-chang-hui-wen-zi-xu-lie/</url>
      
        <content type="html"><![CDATA[<p>Longest Palindromic Subsequence</p><a id="more"></a><h3 id="Longest-Palindromic-Subsequence"><a href="#Longest-Palindromic-Subsequence" class="headerlink" title="Longest Palindromic Subsequence"></a>Longest Palindromic Subsequence</h3><ul><li>code with Python</li><li>title number：516</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li><p>给定一个字符串<code>s</code>找到其中最长的回文子序列</p></li><li><p>假设<code>s</code>的最大长度为<code>1000</code></p></li><li><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;bbbab&quot;</span><br><span class="line">输出：4</span><br><span class="line">解释：可能的最长子序列为&quot;bbbb&quot;</span><br></pre></td></tr></table></figure></li></ul><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li><p>注意”子序列“与”子串“的区别，子序列并不要求序列中的元素在原字符串中相邻</p></li><li><p>对于找子序列问题，关键词在于”<strong>延伸</strong>“</p><ul><li>如果一个子序列是回文子序列，那么在其<strong>左右分别加上一个相同的字符</strong>，它还是一个回文子序列。此时回文子序列长度要<strong>+2</strong></li><li>如果 一个子序列不是回文子序列，或者在其左右加上不同的字符，则得到的不是回文子序列，此时回文子序列长度不变，取<code>[i][j-1]</code>和<code>[i+1][j]</code>的较大值</li></ul></li><li><p>根据上述分析，我们得到了整体问题与子问题之间的关系，可以用<strong>动态规划</strong>来解决了</p></li><li><p>按照惯例，下面进行动态规划式的分析</p></li><li><p><strong>状态表示</strong>：$f(i, j)$表示子串<code>s[i:j]</code>之间所有回文子序列的集合</p><ul><li><strong>集合</strong>：在子串<code>s[i:j]</code>的所有回文子序列的集合</li><li><strong>属性</strong>：最长的回文子序列</li></ul></li><li><p><strong>状态计算</strong></p><ul><li><p>以子串的第一个字符<code>s[i]</code>和最后一个字符<code>s[j]</code>是否相同作为分割标准</p></li><li><p>如果两者相同，则为子串<code>s[i+1, j-1]</code>中的最长回文子串长度加2，即$f(i, j) = f(i+1, j-1) + 2$</p></li><li><p>如果两者不相同，则为子串<code>s[i+1, j-1]</code>分别加上其中一个字符所产生的最长子序列中的较大值，即$f(i, j) = max[f(i+1, j), f(i, j-1)]$</p></li><li><p>综上，<br>$$<br>f(i, j) = \begin{cases}f(i+1, j-1), s[i]==s[j]\max[f(i+1, j), f(i, j-1)], s[i!=s[j]\end{cases}<br>$$</p></li></ul></li><li><p>所求即为，$f(0, len(str))$</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestPalindromeSubseq</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">    n = len(s)</span><br><span class="line">    dp = [[<span class="number">0</span>]*(n) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">    <span class="keyword">if</span> s == s[::<span class="number">-1</span>]:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        dp[i][i] = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>] + <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][j] = max(dp[i+<span class="number">1</span>][j], dp[i][j<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之一和零</title>
      <link href="/passages/leetcode-zhi-yi-he-ling/"/>
      <url>/passages/leetcode-zhi-yi-he-ling/</url>
      
        <content type="html"><![CDATA[<p>Ones and Zeroes</p><a id="more"></a><h3 id="Ones-and-Zeroes"><a href="#Ones-and-Zeroes" class="headerlink" title="Ones and Zeroes"></a>Ones and Zeroes</h3><ul><li>code with Python</li><li>title number：474</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li><p>假设你分别支配着<strong>m个0和n个1</strong>，另外还有一个<strong>仅包含0和1字符串的数组</strong></p></li><li><p>现在的任务是，使用给定的m个0和n个1，找到能拼接出存在于数组中的字符串的最大数量</p></li><li><p>每个0和1至多被使用一次</p></li><li><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：Array &#x3D; &#123;&quot;10&quot;, &quot;0001&quot;, &quot;111001&quot;, &quot;1&quot;, &quot;0&quot;&#125;, m &#x3D; 5, n &#x3D; 3</span><br><span class="line">输出：4</span><br><span class="line">解释：总共有4个字符串可以通过5个0和3个1拼出</span><br><span class="line"></span><br><span class="line">输入：Array &#x3D; &#123;&quot;10&quot;, &quot;1&quot;, &quot;0&quot;&#125;, m &#x3D; 1, n &#x3D; 1</span><br><span class="line">输出：2</span><br><span class="line">解释：只能拼出“10”，之后0,1就被使用完了</span><br></pre></td></tr></table></figure></li></ul><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li><p>本题可以转化为<strong>01背包问题</strong>，经典的01背包问题介绍见<a href="http://www.zivblog.top/passages/biao-zhun-01-bei-bao-wen-ti/" target="_blank" rel="noopener">这里</a></p></li><li><p>转化后的问题</p><blockquote><p>把0和1的个数视为背包的容量，将每个字符串视为装进背包的物品</p><p>不同之处，这里的背包分为两部分，分别用来装0或1</p></blockquote></li><li><p><strong>状态表示</strong>，$f(i, j , k)$</p><ul><li><strong>集合</strong>：输入字符串在自区间<code>[0, i]</code>能够使用<code>j</code>个<code>0</code>和<code>k</code>个<code>1</code>表示字符串数</li><li><strong>属性</strong>：可被表示的字符串的最大数量</li></ul></li><li><p><strong>状态计算</strong></p><ul><li><p>以第<code>i</code>个字符串是否使用01表示为分割标准</p></li><li><p>若第<code>i</code>个字符串被表示，$f(i-1, j-第i个字符串0的个数, k-当前字符串1的个数) + 1$</p></li><li><p>若第<code>i</code>个自负串不被表示，$f(i-1, j, k)$</p></li><li><p>综上<br>$$<br>f(i , j , k) = max[f(i-1, j, k), f(i-1, j-当前字符串使用0的个数, k-当前字符串使用1的个数)]<br>$$</p></li></ul></li><li><p>最终所求即为：$f(len, m, n)$</p></li><li><p>另外，我们一般多设置一行，即用来处理第0个字符串为空串的情况，初始化为0</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMaxForm</span><span class="params">(self, strs: List[str], m: int, n: int)</span> -&gt; int:</span></span><br><span class="line">    len_ = len(strs)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 注意三维数组的初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_dp</span><span class="params">(len_, m, n)</span>:</span></span><br><span class="line">        dp = [<span class="number">0</span>]*(len_+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len_+<span class="number">1</span>):</span><br><span class="line">            dp[i] = [<span class="number">0</span>]*(m+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m+<span class="number">1</span>):</span><br><span class="line">                dp[i][j] = [<span class="number">0</span>]*(n+<span class="number">1</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countZeroAndOne</span><span class="params">(str_)</span>:</span></span><br><span class="line">        ones, zeroes = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(str_)):</span><br><span class="line">            <span class="keyword">if</span> str_[i] == <span class="string">"0"</span>:</span><br><span class="line">                zeroes += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> str_[i] == <span class="string">"1"</span>:</span><br><span class="line">                ones += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ones, zeroes           </span><br><span class="line">    dp = make_dp(len_, m, n)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len_+ <span class="number">1</span>):</span><br><span class="line">        ones, zeroes = countZeroAndOne(strs[i<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(n+<span class="number">1</span>):</span><br><span class="line">                dp[i][j][k] = dp[i<span class="number">-1</span>][j][k]</span><br><span class="line">                <span class="keyword">if</span> j &gt;= zeroes <span class="keyword">and</span> k &gt;= ones:</span><br><span class="line">                    dp[i][j][k] = max(dp[i<span class="number">-1</span>][j][k], dp[i<span class="number">-1</span>][j-zeroes][k-ones] + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> dp[len_][m][n]</span><br></pre></td></tr></table></figure><ul><li>我们知道，动态规划实质上是一种填表的过程，所谓状态压缩，就是根据状态之间的相关性，通过遍历顺序上的调整，节省掉一种到多重状态的表示，体现在dp数组上就是数组的维度下降</li><li>以下分析来自<a href="https://leetcode-cn.com/problems/ones-and-zeroes/solution/pythonjie-jue-zhi-duo-wei-bei-bao-by-admin_user/" target="_blank" rel="noopener">题解区</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">以给定的示例为例：</span><br><span class="line">Array &#x3D; &#123;&quot;10&quot;, &quot;0001&quot;, &quot;111001&quot;, &quot;1&quot;, &quot;0&quot;&#125;, m &#x3D; 5, n &#x3D; 3</span><br><span class="line"></span><br><span class="line">初始化背包：</span><br><span class="line">dp   0列    1列     2列     3列  </span><br><span class="line">0行   0      0       0      0</span><br><span class="line">1行   0      0       0      0</span><br><span class="line">2行   0      0       0      0</span><br><span class="line">3行   0      0       0      0</span><br><span class="line">4行   0      0       0      0       </span><br><span class="line">5行   0      0       0      0</span><br><span class="line">（行表示背包0的可容纳大小，列表示背包1的可容纳大小）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">对于第一个串“10”：</span><br><span class="line">可容纳的背包 （√表示可容纳 x表示不可容纳）</span><br><span class="line">dp   0列    1列       2列     3列  </span><br><span class="line">0行   ×      ×       ×      ×</span><br><span class="line">1行   ×      √       √      √</span><br><span class="line">2行   ×      √       √      √</span><br><span class="line">3行   ×      √       √      √</span><br><span class="line">4行   ×      √       √      √       </span><br><span class="line">5行   ×      √       √      √</span><br><span class="line"></span><br><span class="line">对于可容纳的背包要依次遍历，不放，则查看原旧背包容量　　放，则　1（当前01串）+ 变小的 旧背包容量 　-&gt; 取最大值</span><br><span class="line">dp   0列    1列     2列     3列  </span><br><span class="line">0行   0      0       0      0</span><br><span class="line">1行   0      1       1      1</span><br><span class="line">2行   0      1       1      1</span><br><span class="line">3行   0      1       1      1</span><br><span class="line">4行   0      1       1      1       </span><br><span class="line">5行   0      1       1      1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">对于第二个串“0001”</span><br><span class="line">可容纳的背包 （√表示可容纳 x表示不可容纳）</span><br><span class="line">dp   0列    1列       2列     3列  </span><br><span class="line">0行   ×      ×       ×      × </span><br><span class="line">1行   ×      ×       ×      × </span><br><span class="line">2行   ×      ×       ×      × </span><br><span class="line">3行   ×      √       √      √</span><br><span class="line">4行   ×      √       √      √       </span><br><span class="line">5行   ×      √       √      √</span><br><span class="line"></span><br><span class="line">对于可容纳的背包要依次遍历， 不放，则查看原旧背包容量   放，则 1（当前01串）+ 变小的 旧背包容量  -&gt; 取最大值</span><br><span class="line">dp   0列    1列     2列     3列  </span><br><span class="line">0行   0      0       0      0</span><br><span class="line">1行   0      1       1      1</span><br><span class="line">2行   0      1       1      1</span><br><span class="line">3行   0      1       1      1    </span><br><span class="line">4行   0      1       2      2       </span><br><span class="line">5行   0      1       2      2  &lt;-- max（原本背包价值1【不放】， 1+旧背包dp[5-3][3-1]【放】）</span><br></pre></td></tr></table></figure><ul><li>分析上述过程，我们发现，当前行的值只与上一行的值有关，所以，我们可以使用滚动数组，也可以从后向前赋值，此时dp数组只需要有两维即可</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMaxForm</span><span class="params">(self, strs: List[str], m: int, n: int)</span> -&gt; int:</span></span><br><span class="line">    dp = [[<span class="number">0</span>]*(n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m+<span class="number">1</span>)]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countZeroAndOne</span><span class="params">(str_)</span>:</span></span><br><span class="line">        ones, zeroes = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(str_)):</span><br><span class="line">            <span class="keyword">if</span> str_[i] == <span class="string">"0"</span>:</span><br><span class="line">                zeroes += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> str_[i] == <span class="string">"1"</span>:</span><br><span class="line">                ones += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ones, zeroes  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> str_ <span class="keyword">in</span> strs:</span><br><span class="line">        ones, zeroes = countZeroAndOne(str_)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m, zeroes<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n, ones<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                dp[i][j] = max(dp[i][j], dp[i-zeroes][j-ones] + <span class="number">1</span>)</span><br><span class="line">                </span><br><span class="line">    <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周知识总结（5-4-5-10）</title>
      <link href="/passages/zhou-zhi-shi-zong-jie-5-4-5-10/"/>
      <url>/passages/zhou-zhi-shi-zong-jie-5-4-5-10/</url>
      
        <content type="html"><![CDATA[<p>周知识总结</p><a id="more"></a><h3 id="5月4日"><a href="#5月4日" class="headerlink" title="5月4日"></a>5月4日</h3><h4 id="进行模型评估时，主要有哪些验证方法？试比较其优劣"><a href="#进行模型评估时，主要有哪些验证方法？试比较其优劣" class="headerlink" title="进行模型评估时，主要有哪些验证方法？试比较其优劣"></a>进行模型评估时，主要有哪些验证方法？试比较其优劣</h4><ul><li>在进行机器学习时，我们通常把样本分为训练集和测试集，训练集用于训练模型，测试集用于评估模型。在样本划分和模型验证的过程中，有不同的抽样方法和验证方法。</li><li><strong>Holdout检验</strong><ul><li>将原始的样本集合随机划分成训练集和验证集两部分（两部分占用的比例由使用者指定）</li><li>缺点是在验证集上计算出来的最后评估指标与原始分组有很大关系，有很大的随机性</li></ul></li><li><strong>交叉检验</strong><ul><li><code>k-fold</code>：将全部样本划分成k个大小相等的样本自己，依次遍历这k个子集，每次把当前子集作为验证集，其余所有子集作为训练集，进行模型的训练和估，最后将k次评估指标的平均值作为最终的评估指标。通常，k=10</li><li>留一验证：每次留下一个样本作为验证集，其余所有样本作为测试集。如果样本数为n的话，则需要依次对n个样本进行遍历。</li><li>留一验证的时间开销极大。</li></ul></li><li><strong>自助法</strong><ul><li>当样本集比较小的时候，将样本进行划分会导致用于训练的样本进一步减少。</li><li>自助法是基于自助采样的检验方法。对于总数为n个样本集合，进行n次又放回的随机抽样，得到大小为n个训练集。</li><li>采样过程中可能会有样本被重复选择，也会有样本没有被抽取过，这些<strong>没有被抽取过的样本</strong>作为验证集</li></ul></li></ul><br><br><h3 id="5月5日"><a href="#5月5日" class="headerlink" title="5月5日"></a>5月5日</h3><h4 id="在自助法的随机采样过程中，当n趋于无穷大时，最终有多少数据未被抽取过？"><a href="#在自助法的随机采样过程中，当n趋于无穷大时，最终有多少数据未被抽取过？" class="headerlink" title="在自助法的随机采样过程中，当n趋于无穷大时，最终有多少数据未被抽取过？"></a>在自助法的随机采样过程中，当n趋于无穷大时，最终有多少数据未被抽取过？</h4><ul><li><p>一个样本在一次抽取中未被抽中的概率为$1-\frac{1}{n}$，进行n次抽样均为抽中的概率为$(1-\frac{1}{n})^n$，当n趋于无穷大的时候$lim_{n-&gt;∞}(1- \frac{1}{n})^n$</p></li><li><p>因为<br>$$<br>lim_{n-&gt;∞}(1+\frac{1}{n})=e<br>$$</p></li><li><p>所以<br>$$<br>lim_{n-&gt;∞}(1- \frac{1}{n})^n = lim_{n-&gt;∞}(\frac{1}{(1+\frac{1}{n-1})^n}) = \frac{1}{e} = 0.36<br>$$</p></li><li><p>即，有大约36%的样本从未被选择过，可以作为验证集</p></li></ul><br><br><h3 id="5月6日"><a href="#5月6日" class="headerlink" title="5月6日"></a>5月6日</h3><h4 id="超参数有哪些调优方法？"><a href="#超参数有哪些调优方法？" class="headerlink" title="超参数有哪些调优方法？"></a>超参数有哪些调优方法？</h4><ul><li><strong>网格搜索</strong><ul><li>通过查找搜索范围内所有的点来确定最优值。</li><li>如果采用较大的搜索范围以及较小的步长，网格搜索有很大概率查找到全局最优值</li><li>但是这种搜索方案十分消耗计算资源和时间，特别是当需要调优的超参数比较多的时候。</li><li>因此在实际使用中，一般会使用较广的搜索范围和较大的步长，来寻找全局最优值的可能位置；然后会逐渐缩小搜索范围和步长，来寻找更为精确的最优值</li></ul></li><li><strong>随机搜索</strong><ul><li>主体思想与网格搜索比较相似，只是不再测试上界和下界之间的所有值，而是在搜索范围内随机选取样本点。</li><li>如果选取的样本点足够多的时候，也能大概率找到全局最优值或其近似值</li><li>速度上比网格搜索更快，但是结果是无法保证的</li></ul></li><li><strong>贝叶斯优化</strong><ul><li>之前两种方法，在测试新点的时候会忽略之前一个点的信息，而贝叶斯优化算法则充分利用了之前的信息。</li><li>通过对目标函数形状进行学习，找到使目标函数向全局最优值提升的参数。</li><li>具体来说，它会首先根据先验分布，假设一个搜集函数；然后，每一次使用新的采样点来测试目标函数时，利用这个信息来更新目标函数的先验分布；最后，算法测试由后验分布给出的全局最优值最可能出现的位置的点。</li></ul></li></ul><br><br><h3 id="5月7日"><a href="#5月7日" class="headerlink" title="5月7日"></a>5月7日</h3><h4 id="逻辑回归和线性回归的区别？"><a href="#逻辑回归和线性回归的区别？" class="headerlink" title="逻辑回归和线性回归的区别？"></a>逻辑回归和线性回归的区别？</h4><ul><li>逻辑回归处理的是分类问题，线性回归处理的是回归问题</li><li>逻辑回归中，因变量取值是一个二元分布，模型学习得出的是$E[y|x;θ]$，给定自变量和超参数后，得到因变量的期望，并根据该期望来处理预测分类任务</li><li>线性回归中，求解的是$y’ = θ^Tx$，是对我们假设的真实关系的一个近似$y=θ^Tx + \eta$，其中$\eta$是误差</li><li>而两者也有一定的相同之处，我们可以认为二者都使用了极大似然估计来对训练样本进行建模。<ul><li>线性回归使用的最小二乘法可以认为是在自变量x与超参数θ确定，y服从正态分布的假设下，使用极大似然估计的一个简化</li><li>逻辑回归中对似然函数$L(θ)=\prod_{i=1}^n P(y_i|x;θ)=\prod_{i=1}^n(\pi(x_i))^{y_i}(1-\pi(x_i))^{1-y_i}$的学习就使用了极大似然估计</li></ul></li><li>另外，两者在求解超参数的过程中，都可以使用梯度下降的方法</li></ul><br><br><h3 id="5月8日"><a href="#5月8日" class="headerlink" title="5月8日"></a>5月8日</h3><h4 id="使用逻辑回归处理多分类问题，有哪些常见做法？"><a href="#使用逻辑回归处理多分类问题，有哪些常见做法？" class="headerlink" title="使用逻辑回归处理多分类问题，有哪些常见做法？"></a>使用逻辑回归处理多分类问题，有哪些常见做法？</h4><ul><li><p>使用什么办法来处理多分类的问题取决于具体问题的定义</p></li><li><p>如果<strong>一个样本之对应一个标签</strong>，我们可以假设每个样本属于不同标签的概率服从与几何分布，使用多项逻辑回归来进行分类<br>$$<br>h_{θ} = \lceil \begin{align}p(y=1|x;θ)\p(y=2|x;θ)\……<br>\p(y=k|x;θ)<br>\end{align}\rceil = \frac{1}{\sum^k_{j=1} e^{θ^T_jx}}[\begin{array} pp(y=1|x;θ)\p(y=2|x;θ)\……<br>\p(y=k|x;θ)\end{array}]<br>$$</p></li><li><p>如果<strong>一个样本对应多个标签</strong>，我们可以训练<code>k</code>个二分类器的逻辑回归分类器，第<code>i</code>分类器用以区分每个样本是否可以归为第<code>i</code>类。在训练第<code>i</code>个分类器时，可以把样本标签分为<strong>第i类标签</strong>和<strong>非第i类标签</strong></p></li></ul><br><br><h3 id="5月9日"><a href="#5月9日" class="headerlink" title="5月9日"></a>5月9日</h3><h4 id="决策树有哪些常用的启发函数？"><a href="#决策树有哪些常用的启发函数？" class="headerlink" title="决策树有哪些常用的启发函数？"></a>决策树有哪些常用的启发函数？</h4><ul><li><p>决策树的目标时从一组样本数据中，根据不同的特征和属性，建立一棵树形的分类结构。我们希望它能尽可能的拟合数据，同时限制其复杂度以保证可泛化。</p></li><li><p>常用的决策树有<code>ID3</code>、<code>CD4.5</code>、<code>CART</code>等，它们使用的启发式函数各不相同</p></li><li><p><code>ID3</code>——最大信息增益</p><ul><li><p>对于样本集合D，类别数为K，则数据集的经验熵为<br>$$<br>H(D)=-\sum^K_{k=1}\frac{|C_k|}{|D|}log_2\frac{|C_k|}{|D|}<br>$$</p></li><li><p>某个特征A对于数据集D的经验条件熵<code>H(D|A)</code>为<br>$$<br>H(D|A) = \sum_{i=1}^n\frac{|D_i|}{|D|}H(D_i)<br>$$</p></li><li><p>而信息增益为二者之差</p></li></ul><p>$$<br>g(D, A) = H(D) - H(D|A)<br>$$</p><ul><li>在决策树的每个将要被划分的结点上，我们选则信息增益最大的特征作为标准来划分当前结点中的样本</li></ul></li><li><p><code>C4.5</code>——最大信息增益比</p><ul><li><p>特征A对于数据集D的信息增益比为<br>$$<br>g_R(D, A) = \frac{g(D, A)}{H_A(D)}<br>$$</p></li><li><p>其中，$H_A(D)$称为数据集D关于A的取值熵<br>$$<br>H_A(D)=-\sum_{i=1}^n\frac{|D_i|}{D}log_2\frac{D_i}{D}<br>$$</p></li><li><p>在该决策树算法中，每次划分结点中的样本时，选择使信息增益比最大的特征作为标准</p></li></ul></li><li><p><code>CART</code>——最大基尼质数</p><ul><li><p>基尼指数表示的是数据的纯度，与信息熵含义类似<br>$$<br>Gini(D)=1-\sum_{k=1}^n (\frac{|C_k|}{|D|})^2<br>$$</p></li><li><p>特征<code>A</code>对应的基尼指数表示为<br>$$<br>Gini(D|A) = \sum_{i=1}^n\frac{|D_i|}{|D|}Gini(D_i)<br>$$</p></li></ul></li><li><p><code>CART</code>在每一次迭代中选择基尼指数最小的特征及其对应的切分点对样本集进行划分</p></li><li><p>结合上述的描述，我么可以总结出</p><ul><li><code>ID3</code>会倾向于取值较多的特征，因为信息增益反映的是给定条件后不确定性减小的程度，特征取之越多就意味着确定性越高</li><li><code>C4.5</code>实际上是对<code>ID3</code>的优化，引入信息增益比，一定程度上对取值比较多的特征进行惩罚</li><li>从样本类型来看，<code>ID3</code>只能处理离散型变量，而<code>C4.5</code>和<code>CART</code>可以处理连续型变量</li><li>从应用角度来说，<code>ID3</code>和<code>C4.5</code>只能用于分类任务，而<code>CART (classification and Regression Tree)</code>可以用于分类和回归任务</li></ul></li></ul><br><br><h3 id="5月10日"><a href="#5月10日" class="headerlink" title="5月10日"></a>5月10日</h3><h4 id="如何对决策树进行剪枝？"><a href="#如何对决策树进行剪枝？" class="headerlink" title="如何对决策树进行剪枝？"></a>如何对决策树进行剪枝？</h4><ul><li>如果任由决策树生长，虽然在训练集上会表现的很好，但是会十分缺乏泛化能力</li><li>剪枝算法分为两类：预剪枝和后剪枝</li><li><strong>预剪枝</strong><ul><li>核心思想是在树中结点进行扩展之前，先计算当前的划分能否带来模型泛化能力的提升，如果不能，则不再继续生长子树。一般有一下策略：</li><li>当树达到一定深度时，停止生长</li><li>当到达当前结点的样本数量小于某个阈值时，停止生长</li><li>计算每次分裂对测试集的准确度的提升，当提升程度小于指定阈值时，停止生长</li></ul></li><li><strong>后剪枝</strong><ul><li>允许决策树完全生长，然后自底向上进行剪枝</li><li>剪枝过程自底向上，计算是否删除当前子树，使用一个叶节点代替</li><li>后剪枝也能通过在测试集上的准确率进行判断，如果准确率提升，则进行剪枝。</li><li>相比于预剪枝，后剪枝得到的决策树会有更强的泛化能力，相对应的，也会花费更多的时间</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 周知识总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Artificial Intelligence </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之四数相加Ⅱ</title>
      <link href="/passages/leetcode-zhi-si-shu-xiang-jia-ii/"/>
      <url>/passages/leetcode-zhi-si-shu-xiang-jia-ii/</url>
      
        <content type="html"><![CDATA[<p>4 Sum Ⅱ</p><a id="more"></a><h3 id="4-Sum-Ⅱ"><a href="#4-Sum-Ⅱ" class="headerlink" title="4 Sum Ⅱ"></a>4 Sum Ⅱ</h3><ul><li>code with Python</li><li>title number：454</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li><p>给定四个列表<code>A, B, C, D</code>，计算<strong>有多少</strong>个元组<code>(i, j, k, l)</code>，使得<code>A[i]+B[j]+C[k]+D[l]=0</code></p></li><li><p>所有的列表长度相同，且长度不超过<code>500</code></p></li><li><p>示例：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">A = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">B = [<span class="number">-2</span>, <span class="number">-1</span>]</span><br><span class="line">C = [<span class="number">-1</span>, <span class="number">2</span>]</span><br><span class="line">D = [<span class="number">0</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">两个元组如下:</span><br><span class="line">1. (0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0</span><br><span class="line">2. (1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0</span><br></pre></td></tr></table></figure></li></ul><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li><p>按照常规的思路，遍历每种可能需要四层遍历，时间复杂度极高</p></li><li><p>核心思想是用空间换时间</p><ul><li>将四个数组分为两组（例如：(A, B), (C, D)），先对求第一组中元素所有可能的和，使用字典存储，方面统计其出现的次数</li><li>再对第二组中元素所有可能的和，并得到的和是否与第一组中的和可以相加为<code>0</code>，若有，则取其出现的次数作为结果</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fourSumCount</span><span class="params">(self, A: List[int], B: List[int], C: List[int], D: List[int])</span> -&gt; int:</span></span><br><span class="line">    mapper = &#123;&#125;</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> A:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> B:</span><br><span class="line">            mapper[i+j] = mapper.get(i+j, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> C:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> D:</span><br><span class="line">            res += mapper.get(<span class="number">-1</span>*(i+j), <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之两数相加Ⅱ</title>
      <link href="/passages/leetcode-zhi-liang-shu-xiang-jia-ii/"/>
      <url>/passages/leetcode-zhi-liang-shu-xiang-jia-ii/</url>
      
        <content type="html"><![CDATA[<p>Add Two Numbers Ⅱ</p><a id="more"></a><h3 id="Add-Two-Numbers-Ⅱ"><a href="#Add-Two-Numbers-Ⅱ" class="headerlink" title="Add Two Numbers Ⅱ"></a>Add Two Numbers Ⅱ</h3><ul><li>code with Python</li><li>title number：455</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给订两个非空链表来表示两个数。数字的最高位位于链表开始位置，每个节点只存储一位数字，将两数相加，返回一个新的链表</li><li>除了数字<code>0</code>之外，两个数组均不会以<code>0</code>开头</li></ul><br><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><ul><li>因为第一个结点表示的是最高位，而加法运算需要从低位开始，所以很容易想到借助栈来进行计算</li><li>另外要注意加法的进位即可</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">    <span class="comment"># 将链表转化为列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">L2S</span><span class="params">(l: ListNode)</span> -&gt; List:</span></span><br><span class="line">        stack , c = [], l</span><br><span class="line">        <span class="keyword">while</span> c:</span><br><span class="line">            stack.append(c.val)</span><br><span class="line">            c = c.next</span><br><span class="line">        <span class="keyword">return</span> stack</span><br><span class="line">    </span><br><span class="line">    stack1, stack2 = L2S(l1), L2S(l2)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将两个列表补齐到相同长度，方便处理</span></span><br><span class="line">    diff = abs(len(stack1) - len(stack2))</span><br><span class="line">    stack1 = ([<span class="number">0</span>]*diff + stack1 <span class="keyword">if</span> len(stack1) &lt; len(stack2) <span class="keyword">else</span> stack1)</span><br><span class="line">    stack2 = ([<span class="number">0</span>]*diff + stack2 <span class="keyword">if</span> len(stack2) &lt; len(stack1) <span class="keyword">else</span> stack2)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 对应相加</span></span><br><span class="line">    stack3 = [x+y <span class="keyword">for</span> x, y <span class="keyword">in</span> zip(stack1, stack2)]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算进位</span></span><br><span class="line">    up = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, val <span class="keyword">in</span> enumerate(stack3[::<span class="number">-1</span>]):</span><br><span class="line">        index = len(stack3) - i - <span class="number">1</span></span><br><span class="line">        up, stack3[index] = divmod(val + carry, <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">if</span> carry <span class="keyword">and</span> index == <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 最高位进位</span></span><br><span class="line">            stack3 = [<span class="number">1</span>] + stack3</span><br><span class="line">        <span class="keyword">elif</span> carry:</span><br><span class="line">            <span class="comment"># 进位</span></span><br><span class="line">            stack3[index - <span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 转化为链表存储</span></span><br><span class="line">    result  = ListNode(<span class="number">0</span>)</span><br><span class="line">    c = result</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> stack3:</span><br><span class="line">        c.next = ListNode(i)</span><br><span class="line">        c = c.next</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result.next</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之分割等和子集</title>
      <link href="/passages/leetcode-zhi-fen-ge-deng-he-zi-ji/"/>
      <url>/passages/leetcode-zhi-fen-ge-deng-he-zi-ji/</url>
      
        <content type="html"><![CDATA[<p>Partition Equal Subset Sum</p><a id="more"></a><h3 id="Partition-Equal-Subset-Sum"><a href="#Partition-Equal-Subset-Sum" class="headerlink" title="Partition Equal Subset Sum"></a>Partition Equal Subset Sum</h3><ul><li>code with Python</li><li>title number：416</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个<strong>只包含正整数的非空数组</strong>，判断是否能够将这个数组分割成两个子集，使得两个子集的元素和相等</li><li>每个数组中的元素不会超过100，数组的大小不会超过200</li></ul><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li><p>可以看出，这是一道<code>01</code>背包问题的变种，为什么说这是一道<code>01</code>背包问题呢？我们来分析一下</p><ul><li>先看一下<code>01</code>背包问题的描述：</li></ul><blockquote><p>一个可装载重量为 W 的背包和 N 个物品，每个物品有重量和价值两个属性。其中第 i 个物品的重量为 wt[i]，价值为 val[i]，现在让你用这个背包装物品，最多能装的价值是多少</p></blockquote><ul><li>再来看一下这个问题，我们可以转化为：</li></ul><blockquote><p>先对数组所有元素求和，得到<code>sum</code></p><p>给一个可装载重量为 <code>sum / 2</code> 的背包和 <code>N</code> 个物品，每个物品的重量为 <code>nums[i]</code>。现在让你装物品，是否存在一种装法，能够恰好将背包装满？</p></blockquote></li><li><p>这样，我们直接使用之前的动态规划的分析框架进行分析</p></li><li><p><strong>状态表示</strong>：$f(i, j)$</p><ul><li><strong>集合</strong>：前<code>i</code>个物品，当前容量为<code>j</code>的情况下的所有选法</li><li><strong>属性</strong>：能够恰好将背包装满</li></ul></li><li><p><strong>状态计算</strong></p><ul><li>以第<code>i</code>个元素是否选取作为分割标准，分割集合</li><li>若选取第<code>i</code>个元素，$f(i , j) = f(i-1, j-nums[i])$</li><li>若不选取第<code>i</code>个元素，$f(i, j) = f(i-1, j)$</li><li>即，$f(i, j) = f(i-1, j) | f(i-1, j-nums[i])$</li></ul></li><li><p>所求即为$f(n, sum/2)$，即前<code>n</code>个元素能够凑成<code>sum/2</code>，剩余的自然也是<code>sum/2</code></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canPartition</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">    sum_ = sum(nums)</span><br><span class="line">    <span class="keyword">if</span> sum_ % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    sum_ = sum_ // <span class="number">2</span></span><br><span class="line">    <span class="comment"># 多加一行一列，便于处理</span></span><br><span class="line">    dp = [[<span class="literal">False</span>]*(sum_+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(nums))]</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, sum_+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> nums[<span class="number">0</span>] == i:</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(sum_+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> j &gt;= nums[i]:</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j] <span class="keyword">or</span> dp[i<span class="number">-1</span>][j-nums[i]]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之常数时间内插入删除和获取随机元素</title>
      <link href="/passages/leetcode-zhi-chang-shu-shi-jian-nei-cha-ru-shan-chu-he-huo-qu-sui-ji-yuan-su/"/>
      <url>/passages/leetcode-zhi-chang-shu-shi-jian-nei-cha-ru-shan-chu-he-huo-qu-sui-ji-yuan-su/</url>
      
        <content type="html"><![CDATA[<p>Insert Delete GetRandom O(1)</p><a id="more"></a><h3 id="Insert-Delete-GetRandom-O-1"><a href="#Insert-Delete-GetRandom-O-1" class="headerlink" title="Insert Delete GetRandom O(1)"></a>Insert Delete GetRandom O(1)</h3><ul><li>code with Python</li><li>titile number：380</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>设计以个支持在平均时间复杂度<code>O(1)</code>下，执行以下操作的数据结构：<ul><li><code>insert(val)</code>：当元素<code>val</code>不存在时，向集合中插入该项</li><li><code>remove(val)</code>：元素<code>val</code>存在时，从集合中移除该项</li><li><code>getRandom()</code>：随机返回现有集合中的一项，每个元素应该有相同道德概率被返回</li></ul></li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>题目要求即思路，说一下几个要点<ul><li>存储结构：组合使用哈希表和数组</li><li>插入操作：用哈希表判断元素是否存在，数组记录值（插入的元素添加到数组末尾），哈希表记录索引</li><li>删除操作：用哈希表来定位，把数组最后一个元素取下来顶替被删除元素位置</li><li>取随机数：随机从数组中挑选一个元素</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize your data struct here</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.d = &#123;&#125;</span><br><span class="line">        self.l = []</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, val: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Inserts a value to the set. Returns true if the set did not already contain the specified element.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">    <span class="keyword">if</span> val <span class="keyword">in</span> self.d:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.d[val] = len(self.l)</span><br><span class="line">            self.l.append(val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, val: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Removes a value from the set. Returns true if the set contained the specified element.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">in</span> self.d:</span><br><span class="line">            self.d[self.l[<span class="number">-1</span>]] = self.d[val]</span><br><span class="line">            self.l[self.d.pop(val)] = self.l[<span class="number">-1</span>]</span><br><span class="line">            self.pop()</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRandom</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Get a random element from the set.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.l[random.randint(<span class="number">0</span>, len(self.l)<span class="number">-1</span>)]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之有序矩阵中第k小的元素</title>
      <link href="/passages/leetcode-zhi-you-xu-ju-zhen-zhong-di-k-xiao-de-yuan-su/"/>
      <url>/passages/leetcode-zhi-you-xu-ju-zhen-zhong-di-k-xiao-de-yuan-su/</url>
      
        <content type="html"><![CDATA[<p>Kth Smallest Element in a Sorted Matrix</p><a id="more"></a><h3 id="Kth-Smallest-Element-in-a-Sorted-Matrix"><a href="#Kth-Smallest-Element-in-a-Sorted-Matrix" class="headerlink" title="Kth Smallest Element in a Sorted Matrix"></a>Kth Smallest Element in a Sorted Matrix</h3><ul><li>code with Python</li><li>title number：378</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个<code>N*N</code>的矩阵，其中<strong>每行</strong>和<strong>每列</strong>元素均按<strong>升序</strong>排序，找到矩阵中第<code>K</code>小的元素</li><li>注意是排序后的第<code>k</code>小元素，而不是第<code>k</code>个不同的元素</li><li>示例：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">matrix &#x3D; [[1, 3, 5],</span><br><span class="line">  [10, 11, 13],</span><br><span class="line">  [12, 13, 15]]</span><br><span class="line">k &#x3D; 8</span><br><span class="line"></span><br><span class="line">返回  13</span><br></pre></td></tr></table></figure><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>直觉上可以遍历读取整个矩阵，再进行排序，最后读取第<code>k</code>个元素即可</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span><span class="params">(self, matrix: List[List[int]], k: int)</span> -&gt; int:</span></span><br><span class="line">    arr = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(matrix):</span><br><span class="line">        arr.extend(matrix[i])</span><br><span class="line">    </span><br><span class="line">    arr.sort()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> arr[k<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><br><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li>既然使用了排序算法，那么可以更进一步</li><li>利用排序算法，<strong>大顶堆</strong></li><li>但是使用排序算法显然没有利用<strong>有序矩阵</strong>这一信息</li><li>下面介绍一下<strong>值域二分法</strong><ul><li>首先，根据矩阵的性质，我们的矩阵元素的值域为<code>[l, r]</code>，其中<code>l = matrxi[0][0], r = matrix[-1][1]</code></li><li>于是，我们就可以对该区间进行二分，<code>mid = (l+r) / 2</code></li><li>统计矩阵中小于<code>mid</code>的元素个数，记为<code>less_mid</code></li><li>如果<code>less_mid &lt; k</code>，那么<code>[l , mid]</code>之间包含的元素小于<code>k</code>，即第<code>k</code>个元素一定不在其中，而一定在<code>[mid, r]</code>中，此时将<code>l = mid</code></li><li>如果<code>less_mid &gt;= k</code>，那么<code>[l, mid]</code>中的元素个数大于等于<code>k</code>，即第<code>k</code>小的元素一定在<code>[l, mid]</code>中，此时<code>r = mid</code></li></ul></li><li>只与如何统计小于等于<code>mid</code>的元素个数，利用矩阵本身的性质，从左下角开始枚举</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getLowCnt</span><span class="params">(self, matrix, row, col, mid)</span>:</span></span><br><span class="line">    i, j = row<span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &lt; col:</span><br><span class="line">        <span class="comment"># 若当前值小于mid，则该列中，当前值上方的元素均小于mid</span></span><br><span class="line">        <span class="keyword">if</span> matrix[i][j] &lt;= mid:</span><br><span class="line">            cnt = cnt + i + <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> cnt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span><span class="params">(self, matrix: List[List[int]], k: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="comment"># k恒为有效值，无需判断</span></span><br><span class="line">    row, col = len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line">    l, r = matrix[<span class="number">0</span>][<span class="number">0</span>], matrix[<span class="number">-1</span>][<span class="number">-1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> l &lt; r:</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.getLowCnt(matrix, row, col, mid) &lt; k:</span><br><span class="line">            l = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            r = mid</span><br><span class="line">    <span class="keyword">return</span> l</span><br></pre></td></tr></table></figure><ul><li><strong>思路二应重点掌握</strong></li><li><strong>但从提交结果来看，第一种的时空复杂度更低</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之水壶问题</title>
      <link href="/passages/leetcode-zhi-shui-hu-wen-ti/"/>
      <url>/passages/leetcode-zhi-shui-hu-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>Water and Jug Problem</p><a id="more"></a><h3 id="Water-and-Jug-Problem"><a href="#Water-and-Jug-Problem" class="headerlink" title="Water and Jug Problem"></a>Water and Jug Problem</h3><ul><li>code with Python</li><li>title number：365</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li><p>BFS</p></li><li><p>有两个容量分别为<code>x</code>升和<code>y</code>升的水壶以及无线多的水</p></li><li><p>判断是否能通过使用这两个水壶，得到恰好为<code>z</code>升的水</p></li><li><p>允许的操作：</p><ul><li><p>装满任意一个水壶</p></li><li><p>清空任意一个水壶</p></li><li><p>从一个水壶向另一个水壶倒水，知道装满或倒空</p></li></ul></li></ul><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>将两个水壶视作两个<strong>状态</strong>，对水壶的操作视作<strong>改变状态</strong></li><li>初始状态为<code>(0, 0)</code>，目标状态为<code>(z, any)</code>或<code>(any, z)</code></li><li>每一时刻的状态由<code>x</code>和<code>y</code>决定<ul><li>把<code>X</code>壶的水灌进<code>Y</code>壶，直至灌满或倒空</li><li>把<code>Y</code>壶的水灌进<code>X</code>壶，直至灌满或倒空</li><li>把<code>X</code>壶灌满</li><li>把<code>Y</code>壶灌满</li><li>把<code>X</code>壶倒空</li><li>把<code>Y</code>壶倒空</li></ul></li><li>通过其中一个示例来模拟该过程</li></ul><blockquote><p>输入：x = 3, y= 5, z = 4<br>输出：True</p><p>(0, 0) -&gt; (0, 5) -&gt; (3, 2) -&gt; (0, 2) -&gt; (2, 0) -&gt; (2, 5) -&gt; (3, 4) -&gt; True</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canMeasureWater</span><span class="params">(self, x: int, y : int, z: int)</span> -&gt; bool:</span></span><br><span class="line">    <span class="keyword">if</span> x + y &lt; z:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    queue = [(<span class="number">0</span>, <span class="number">0</span>)]</span><br><span class="line">    seen = set((<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> len(queue) &gt; <span class="number">0</span>:</span><br><span class="line">        a, b = queue.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> a == z <span class="keyword">or</span> b == z <span class="keyword">or</span> a + b == z:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        states = set()</span><br><span class="line">        <span class="comment"># 当前所有可能得到的的状态</span></span><br><span class="line">        states.add((x, b))</span><br><span class="line">        states.add((a, y))</span><br><span class="line">        states.add((<span class="number">0</span>, b))</span><br><span class="line">        states.add((a, <span class="number">0</span>))</span><br><span class="line">states.add((min(x, b+a), <span class="number">0</span> <span class="keyword">if</span> b &lt; x - a <span class="keyword">else</span> b- (x-a)))</span><br><span class="line">        states.add((<span class="number">0</span> <span class="keyword">if</span> a + b &lt; y <span class="keyword">else</span> a - (y - b), min(b+a, y)))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> state <span class="keyword">in</span> states:</span><br><span class="line">            <span class="keyword">if</span> state <span class="keyword">in</span> seen:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            queue.append(state)</span><br><span class="line">            seen.add(state)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li><p>数学方法：求最大公约数</p></li><li><p>先介绍一个定理，<strong>裴蜀定理</strong></p><blockquote><p>对任意两个整数<code>a</code>、<code>b</code>，设<code>d</code>是它们的最大公约数，那么关于<code>x</code>和<code>y</code>的线性方程<code>ax+by=m</code>，有整数解<code>(x, y)</code>当且仅当<code>m</code>是<code>d</code>的整数倍</p></blockquote></li><li><p>用示例一演示该定理的使用：</p><blockquote><p>x = 3, y = 5, z= 4</p><p>3*3 - 1*5 = 4      -&gt;    3*x - 1*y = z</p><p>具体过程为：</p><p>倒满a（<strong>1</strong>）<br>将a倒到b<br>再次倒满a（<strong>2</strong>）<br>再次将a倒到b（a这个时候还剩下1升）<br>倒空b（<strong>-1</strong>）<br>将剩下的1升倒到b<br>将a倒满（<strong>3</strong>）<br>将a倒到b<br>b此时正好是4升 </p></blockquote></li><li><p>我们只需计算出<code>x</code>和<code>y</code>的最大公约数，再判断<code>z</code>是否是该最大公约数的整数倍即可</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canMeasureWater</span><span class="params">(self, x: int, y: int, z: int)</span> -&gt; bool:</span></span><br><span class="line">    <span class="keyword">if</span> x + y &lt; z:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> z == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> y == z</span><br><span class="line">    <span class="keyword">if</span> y == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> x == z</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getGCD</span><span class="params">(x, y)</span>:</span></span><br><span class="line">        min_ =  min(a, b)</span><br><span class="line">        <span class="keyword">while</span> min_:</span><br><span class="line">            <span class="keyword">if</span> a % min_ == <span class="number">0</span> <span class="keyword">and</span> b % min_ == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> min_</span><br><span class="line">            min_ -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> z % getGCD(x, y) == <span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之递增的三元子序列</title>
      <link href="/passages/leetcode-zhi-di-zeng-de-san-yuan-zi-xu-lie/"/>
      <url>/passages/leetcode-zhi-di-zeng-de-san-yuan-zi-xu-lie/</url>
      
        <content type="html"><![CDATA[<p>Increasing Triplet Subsequence</p><a id="more"></a><h3 id="Increasing-Triplet-Subsequence"><a href="#Increasing-Triplet-Subsequence" class="headerlink" title="Increasing Triplet Subsequence"></a>Increasing Triplet Subsequence</h3><ul><li>code with Python</li><li>title number：334</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li><p>给定一个未排序的子数组，判断数组中是否存在长度为<code>3</code>的递增子序列</p></li><li><p>所谓递增子数组，定义如下：</p><blockquote><p>如果存在这样的 i, j, k,  且满足 0 ≤ i &lt; j &lt; k ≤ n-1，<br>使得 arr[i] &lt; arr[j] &lt; arr[k] ，返回 true ; 否则返回 false 。</p></blockquote></li><li><p>要求算法复杂度为<code>O(n)</code>，空间复杂度为<code>O(1)</code></p></li></ul><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li><p>由于时空复杂度的限制，暴力算法就不用考虑了</p></li><li><p>再者，结合之前的经验，<strong>子序列 != 子串</strong>。所以，满足条件的三个元素不一定连续，也不适合使用滑动窗口的思想</p></li><li><p>我们的目的是<strong>依次</strong>找到三个变量，这三个变量的大小是递增的，即可</p></li><li><p>所以，我们的做法是，遍历，维护三个变量<code>min_one, min_two, min_thr</code>,分别对应最小值，第二小值，第三小值。</p></li><li><p>只要我们能够在遍历的过程中将这三个变量填满，即认为可以找到满足条件的子序列</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">increaseTriplet</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) &lt; <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    min_one, min_two, min_thr = float(<span class="string">"inf"</span>), float(<span class="string">"inf"</span>), float(<span class="string">"inf"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt;= min_one:</span><br><span class="line">            min_one = nums[i]</span><br><span class="line">        <span class="keyword">elif</span> nums[i] &lt;= min_two:</span><br><span class="line">            min_two = nums[i]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            min_thr = nums[i]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> min_one != float(<span class="string">"inf"</span>) <span class="keyword">and</span> min_two != float(<span class="string">"inf"</span>) <span class="keyword">and</span> min_thr != float(<span class="string">"inf"</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周知识总结（4.27-5.3）</title>
      <link href="/passages/zhou-zhi-shi-zong-jie-4-27-5-3/"/>
      <url>/passages/zhou-zhi-shi-zong-jie-4-27-5-3/</url>
      
        <content type="html"><![CDATA[<p>文章部分内容来自《百面机器学习》</p><a id="more"></a><h3 id="4月27日"><a href="#4月27日" class="headerlink" title="4月27日"></a>4月27日</h3><h4 id="为什么评估标准对于机器学习很重要？"><a href="#为什么评估标准对于机器学习很重要？" class="headerlink" title="为什么评估标准对于机器学习很重要？"></a>为什么评估标准对于机器学习很重要？</h4><ul><li>只有选择与问题相匹配的评估方法，才能快速地发现模型选择或训练过程中出现的问题，迭代地对模型进行优化。</li><li>模型评估主要分为离线评估和在线评估两个阶段。针对分类、排序、回归、序列预测等不同类型的机器学习问题，评估指标的选择也有所不同。</li><li>知道每种评估指标的精确定义、有针对性地选择合适的评估指标、根据评估指标的反馈进行模型调整。</li></ul><br><br><h3 id="4月28日"><a href="#4月28日" class="headerlink" title="4月28日"></a>4月28日</h3><h4 id="简要分析准确率作为评估标准的优劣？"><a href="#简要分析准确率作为评估标准的优劣？" class="headerlink" title="简要分析准确率作为评估标准的优劣？"></a>简要分析准确率作为评估标准的优劣？</h4><ul><li><p><strong>准确率（Accuracy）</strong></p><ul><li>指正确分类的样本占总样本个数的比例</li></ul><p>$$<br>Accuracy = \frac{n_{correct}}{n_{total}}<br>$$</p><ul><li>准确率是分类问题中最简单、最直接的评价标准。但是存在明显的缺陷：</li><li>例如当负样本占99%时，分类器将所有的样本都预测成负样本也能获得99%的准确率。也即是当不同类别的样本不均衡时，占比大的样本会模型造成很大的影响。</li><li>相对应的，我们可以采取更为有效的<strong>平均准确率</strong>（即每个类别下的样本准确率的算数平均）作为模型评估的指标</li></ul></li></ul><br><br><h3 id="4月29日"><a href="#4月29日" class="headerlink" title="4月29日"></a>4月29日</h3><h4 id="试对比精确率与召回率？"><a href="#试对比精确率与召回率？" class="headerlink" title="试对比精确率与召回率？"></a>试对比精确率与召回率？</h4><ul><li>精确率是指<strong>分类正确的正样本个数</strong>占<strong>分类器判定为正样本的样本个数的比例</strong></li></ul><p>$$<br>Precision = \frac{n_{分类为正且正确}}{n_{判定为正}}<br>$$</p><ul><li>召回率是指<strong>分类正确的正样本个数</strong>占<strong>真正的正样本个数的比例</strong></li></ul><p>$$<br>Recall = \frac{n_{分类为正且正确}}{n_{实际为正}}<br>$$</p><ul><li><p>两种指标既矛盾又统一：</p><ul><li>为了提高<code>Precision</code>，分类器需要尽量在“更有把握”的时候才会将样本预测为正样本；但此时会由于过于保守而漏掉许多“没有把握”的正样本，导致<code>Recall</code>值降低</li><li>可以认为<strong>召回率越低越保守，从而精确率会越高</strong></li></ul></li><li><p>有时可以通过结合两种指标来进行分析，例如：P-R曲线</p><ul><li><p>即横轴是召回率，纵轴是精确率</p></li><li><p>对于该曲线来说，线上的每一个点都表示在某一阈值下，模型将大于该阈值的结果判定为正样本，小于该阈值的判定为负样本，以此计算得到的精确率和召回率</p></li><li><p>整条曲线是通过将阈值从高到低移动而形成的</p><img src="/.top//1.png" style="zoom:70%;"></li><li><p>可见，当召回率接近0时，模型A的精确率高达90%，模型B的精确率高达100%；</p></li><li><p>这表明，模型预测为正样本的样本确实是真正的正样本</p></li></ul></li><li><p>还有一种指标叫做<code>F1-score</code>，同样是结合了定义为：<br>$$<br>F1score = \frac{2*precision*recall}{precision+recall}<br>$$</p></li></ul><br><br><h3 id="4月30日"><a href="#4月30日" class="headerlink" title="4月30日"></a>4月30日</h3><h4 id="试分析平方差误差带来的问题？"><a href="#试分析平方差误差带来的问题？" class="headerlink" title="试分析平方差误差带来的问题？"></a>试分析平方差误差带来的问题？</h4><ul><li>平方差误差，定义为：</li></ul><p>$$<br>RMSE = \sqrt{\frac{\sum_{i=1}^n (y_i - y^*_i)^2}{n}}<br>$$</p><ul><li><p>一般来说，RMSE用于反映回归模型预测值与真实值的偏离程度，如果存在个别偏离程度非常大的离群点，即使离群点的数量非常少，也会让该指标变得很差。</p></li><li><p>如何处理该问题呢？</p><ul><li>若认为利群点应该剔除，则在数据预处理的过程中将离群的“噪声”过滤掉</li><li>若认为离群点对于当前场景是合理的存在，则调整模型，将离群点建模进去</li><li>找到更合适的指标来评估模型，例如平均绝对百分比误差（<code>Mean Absolute Percent Error, MAPE</code>）</li></ul><p>$$<br>MAPE = \sum_{i=1}^n |\frac{y_i - y^<em>_i}{y_i}|</em>\frac{100}{n}<br>$$</p><ul><li>相比于<code>RMSE</code>，<code>MAPE</code>将每个点的误差进行了归一化，降低了个别利群点带来的绝对误差的影响</li></ul></li></ul><br><br><h3 id="5月1日"><a href="#5月1日" class="headerlink" title="5月1日"></a>5月1日</h3><h4 id="什么是ROC曲线？"><a href="#什么是ROC曲线？" class="headerlink" title="什么是ROC曲线？"></a>什么是ROC曲线？</h4><ul><li><code>ROC</code>曲线是<code>Receiver Operating Characteristic Curve</code>的简称<ul><li>横坐标为假阳性率，<code>FPR</code>，$FPR = \frac{FP}{N} = \frac{N个负样本中被预测为正样本的隔宿}{真实的负样本的个数}$</li><li>纵坐标为真阳性率，<code>TPR</code>，$TPR = \frac{TP}{P}=\frac{P个正样本中被预测为正样本的个数}{真实的正样本的数量}$</li></ul></li><li>ROC曲线是通过不断移动分类器的“截断点（分类标准）”来生成曲线的关键点</li><li>当截断点选择为正无穷时，模型把全部样本预测为负例，此时<code>FP</code>和<code>TP</code>都为<code>0</code>，<code>FPR</code>和<code>TPR</code>也都为<code>0</code>，即曲线的第一个坐标。</li><li>依次调整截断点，即可得到整条曲线</li></ul><br><h4 id="什么事AUC？"><a href="#什么事AUC？" class="headerlink" title="什么事AUC？"></a>什么事AUC？</h4><ul><li><code>AUC</code>，<code>Area Under ROC</code>，故名思义，指的是<code>ROC</code>曲线下的面积。</li><li>该值能够量化的反映使用<code>ROC</code>衡量出的模型性能</li><li><code>AUC</code>越大，说明分类器越可能把真正的正样本预测出来，即分类器 性能越好</li></ul><br><br><h3 id="5月2日"><a href="#5月2日" class="headerlink" title="5月2日"></a>5月2日</h3><h4 id="ROC曲线与P-R曲线的对比？"><a href="#ROC曲线与P-R曲线的对比？" class="headerlink" title="ROC曲线与P-R曲线的对比？"></a>ROC曲线与P-R曲线的对比？</h4><ul><li>两种曲线都是用来评估分类和排序模型的指标。</li><li>相比于<code>P-R</code>曲线，<code>ROC</code>曲线能够在正负样本的分布发生变化时，保持形状不变。即<code>ROC</code>曲线能够尽量降低不同测试集带来的干扰，更加客观的衡量模型本身的性能</li><li>所以<code>ROC</code>曲线的使用场景更多</li></ul><br><br><h3 id="5月3日"><a href="#5月3日" class="headerlink" title="5月3日"></a>5月3日</h3><h4 id="余弦相似度与欧式距离的比较？"><a href="#余弦相似度与欧式距离的比较？" class="headerlink" title="余弦相似度与欧式距离的比较？"></a>余弦相似度与欧式距离的比较？</h4><ul><li>在机器学习问题中，通常将特征表示为向量的形式，所以在分析两个向量之间的相似性时常常使用余弦相似度来表示</li></ul><p>$$<br>cos(A, B) = \frac{A \cdot B}{||A||_2||B||_2}<br>$$</p><ul><li><p>余弦相似度关注的是两个向量之间的角度关系，并不关注其绝对大小</p></li><li><p>如果两个文本的内容相近，但是长度相差很大，此时如果使用词频或者词向量作为特征，它们在特征空间中的欧式距离会很大。但是用余弦相似度，就能比较正确地反映真实的相似度关系</p></li><li><p>如果向量的模长是经过<strong>归一化</strong>的，此时欧氏距离与余弦相似度得到的结果是相同的</p></li><li><p>总得来说，<strong>欧式距离体现数值上的绝对差异</strong>，<strong>余弦相似度体现方向上的相对差异</strong>，两种方法并没有高下之分。具体应用要依照实际场景选择。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之奇偶链表</title>
      <link href="/passages/leetcode-zhi-qi-ou-lian-biao/"/>
      <url>/passages/leetcode-zhi-qi-ou-lian-biao/</url>
      
        <content type="html"><![CDATA[<p>Odd Even Linked List</p><a id="more"></a><h3 id="Odd-Even-Linked-List"><a href="#Odd-Even-Linked-List" class="headerlink" title="Odd Even Linked List"></a>Odd Even Linked List</h3><ul><li>code with Python</li><li>title number：328</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个单链表，把所有的奇数结点和偶数结点分别排在一起</li><li>这里的奇数偶数结点指的是<strong>结点编号的奇偶性</strong></li><li>请使用<strong>原地算法</strong>完成</li></ul><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>首先想到的是，遍历一遍链表<ul><li>将奇数结点放到一起</li><li>将偶数结点放到一起</li><li>最后将两个子链表拼接起来</li></ul></li><li>但题目要求的是<strong>原地算法</strong>，所以要转化思路</li></ul><br><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li>遍历一次，同时修改两个结点，具体而言：<ul><li>设置三个指针，<code>odd、even、evenhead</code>，分别用于知识奇数子链的结尾、偶数子链的结尾、偶数子链的开头</li><li>具体实现见代码</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">oddEvenList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    </span><br><span class="line">    odd, evenhead, even = head, head.next, head.next</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> even != <span class="literal">None</span> <span class="keyword">and</span> even.next != <span class="literal">None</span>:</span><br><span class="line">        odd.next = even.next</span><br><span class="line">        odd = odd.next</span><br><span class="line">        even.next = odd.next</span><br><span class="line">        even = even.next</span><br><span class="line">    odd.next = evenhead</span><br><span class="line">    <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之零钱兑换</title>
      <link href="/passages/leetcode-zhi-ling-qian-dui-huan/"/>
      <url>/passages/leetcode-zhi-ling-qian-dui-huan/</url>
      
        <content type="html"><![CDATA[<p>Coin Change</p><a id="more"></a><h3 id="Coin-Change"><a href="#Coin-Change" class="headerlink" title="Coin Change"></a>Coin Change</h3><ul><li>code with Python</li><li>title number：322</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定不同面额的硬币<code>coins</code>和一个总金额<code>amount</code></li><li>计算可以凑成总金额所需的最少的硬币个数，每种硬币可以无限量使用</li><li>若没有凑成总金额的方案，则返回<code>-1</code></li></ul><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>本题十分类似于之前的<a href="http://www.zivblog.top/passages/leetcode-zhi-wan-quan-ping-fang-shu/" target="_blank" rel="noopener">完全平方数</a></li><li>贪心策略在这里是行不通的</li></ul><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li>动态规划</li><li><strong>状态表示</strong>：$f(i)$<ul><li><strong>集合</strong>：组成<code>i</code>块钱可行的硬币组合的集合</li><li><strong>属性</strong>：集合中使用硬币数<strong>最少</strong>的方案</li></ul></li><li><strong>状态计算</strong><ul><li>类似于完全背包问题，每种面额的硬币可以无限使用<ul><li>完全背包问题是在有限空间下求最大价值</li><li>本题是在给定金额下求最小硬币数</li></ul></li><li>以第最后一种硬币取不取为集合分割标准</li><li>最后一种硬币不取，则<code>f(i)</code></li><li>最后一种硬币取，则<code>f(i-coni[j]) + 1</code></li><li>即，$f(i) = min(f(i), f(i-coins[j])+1)$</li></ul></li><li>最终答案为：$f(amount)$</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(self, coins: List[int], amount: int)</span> -&gt; int:</span></span><br><span class="line"><span class="comment"># 多申请一个空间，方便处理 </span></span><br><span class="line">dp = [amount+<span class="number">1</span>]*(amount+<span class="number">1</span>)</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, amount+<span class="number">1</span>):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(len(coins)):</span><br><span class="line">            <span class="keyword">if</span> i &gt; coins[j]:</span><br><span class="line">                dp[i] = min(dp[i], dp[i-coins[j]]+<span class="number">1</span>)</span><br><span class="line">                </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span> <span class="keyword">if</span> dp[<span class="number">-1</span>]==amount+<span class="number">1</span> <span class="keyword">else</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之最佳买卖股票时机含冷冻期</title>
      <link href="/passages/leetcode-zhi-zui-jia-mai-mai-gu-piao-shi-ji-han-leng-dong-qi/"/>
      <url>/passages/leetcode-zhi-zui-jia-mai-mai-gu-piao-shi-ji-han-leng-dong-qi/</url>
      
        <content type="html"><![CDATA[<p>Best Time to Buy and Sell Stock with Cooldown</p><a id="more"></a><h3 id="Best-Time-to-Buy-and-Sell-Stock-with-Cooldown"><a href="#Best-Time-to-Buy-and-Sell-Stock-with-Cooldown" class="headerlink" title="Best Time to Buy and Sell Stock with Cooldown"></a>Best Time to Buy and Sell Stock with Cooldown</h3><ul><li>code with Python</li><li>title number：309</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个整数数组，其中第<code>i</code>个元素代表了第<code>i</code>天的股票价格</li><li>设计一个算法计算出最大利润。</li><li>在满足约束条件下，你可以尽可能地完成更多的交易</li><li>注意：<ul><li>不能多次参与多笔交易</li><li>卖出股票后，无法在第二天买入股票（冷冻期为<code>1</code>天）</li></ul></li><li>例如：<ul><li>输入：<code>[1, 2, 3, 0, 2]</code></li><li>输出：<code>3</code></li><li>解释：对应的交易状态为<code>[买入, 卖出, 冷冻期, 买入, 卖出]</code></li></ul></li></ul><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li><p>股票问题即动态规划问题</p></li><li><p>相比与最简单的股票问题，当前问题存在<code>卖出股票后有一天的时间不允许买入股</code></p></li><li><p>因此当前状态变为了三种，即<code>[卖出、不操作、买入]</code>。所以使用三维的数组，<code>dp[i][k][0]或dp[i][k][1]</code>，其中<code>i</code>为第<code>i</code>天，<code>k = [0:不操作, 1:卖出, 2:买入]</code>，最后一维<code>[0:当前不持有物品, 1:当前持有物品]</code></p></li><li><p><strong>状态表示</strong>：$f(i, k, 0/1)$</p><ul><li><strong>集合</strong>：第<code>i</code>天所有买卖股票方案的利润的集合</li><li><strong>属性</strong>：所有方案下取得的最大利润</li></ul></li><li><p><strong>状态计算</strong></p><ul><li>有<strong>六种</strong>状态（其中有<strong>两种</strong>情况不可能存在）</li><li>当前<strong>不操作</strong>且<strong>无物品</strong>，$f(i, 0 ,0)$<ul><li>前一天不操作且无物品，$f(i-1, 0, 0)$</li><li>前一天卖出物品，$f(i-1, 1, 0)$</li><li>所以，$f(i, 0, 0) = max[f(i-1, 0, 0), f(i-1, 1, 0)]$</li></ul></li><li>当前<strong>不操作</strong>且<strong>有物品</strong><ul><li>前一天不操作且有物品，$f(i-1, 0, 1)$</li><li>前一天买入后持有物品，$f(i-1, 2, 1)$</li><li>所以，$f(i, 0, 1) = max[f(i-1, 0, 1), f(i-1, 2, 1)]$</li></ul></li><li>当前<strong>卖出</strong>后<strong>无物品</strong><ul><li>前一天买入物品，$f(i-1, 2, 1)+prices[i]$</li><li>前一天持有物品，$f(i-1, 0, 1)+pries[i]$</li><li>所以，$f(i, 1, 0) = max[f(i-1,2,1)+prices[i], f(i-1, 0, 1)+prices[i]]$</li></ul></li><li>当前<strong>买入</strong>后<strong>有物品</strong><ul><li>前一天不进行操作且不持有物品，$f(i-1, 0, 0)-prices[i]$</li><li>所以，$f(i, 2, 1) = f(i-1, 0, 0) - prices[i]$</li></ul></li><li>当前卖出后持有物品<ul><li><strong>该状态不存在</strong></li></ul></li><li>当前买入后不持有物品<ul><li><strong>该状态不存在</strong></li></ul></li></ul></li><li><p>最后一天一定为<strong>不操作无物品</strong>和<strong>卖出物品后无物品</strong>的最大值，即：</p></li></ul><p>$$<br>max[f(len(prices)-1, 0, 0), f(len(prices)-1, 1, 0)]<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_dp</span><span class="params">(n)</span>:</span></span><br><span class="line">        dp = [<span class="number">0</span>]*(n+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>):</span><br><span class="line">            dp[i] = [<span class="number">0</span>]*<span class="number">3</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">                dp[i][j] = [<span class="number">0</span>]*<span class="number">2</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> dp</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> len(prices) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    dp = make_dp(len(prices))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 初始化</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">2</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>] = -float(<span class="string">'inf'</span>)</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>] = -float(<span class="string">'inf'</span>)</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>] = -float(<span class="string">'inf'</span>)</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">2</span>][<span class="number">0</span>] = -float(<span class="string">'inf'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(prices)):</span><br><span class="line">        dp[i][<span class="number">0</span>][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line">        dp[i][<span class="number">0</span>][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">2</span>][<span class="number">1</span>])</span><br><span class="line">        dp[i][<span class="number">1</span>][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">2</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>][<span class="number">1</span>]) + prices[i]</span><br><span class="line">        dp[i][<span class="number">2</span>][<span class="number">1</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>][<span class="number">0</span>]-prices[i]</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> max(dp[len(prices)<span class="number">-1</span>][<span class="number">0</span>][<span class="number">0</span>], dp[len(prices)<span class="number">-1</span>][<span class="number">1</span>][<span class="number">0</span>])</span><br></pre></td></tr></table></figure><ul><li>使用<code>Python</code>解决该题的时候，注意在创建多维数组时的方式</li><li>如果使用<code>list comprehension</code>会产生浅拷贝的问题，即<code>dp = [[[0]*(len(prices)+1)]*3]*2</code>的方式建数组</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之完全平方数</title>
      <link href="/passages/leetcode-zhi-wan-quan-ping-fang-shu/"/>
      <url>/passages/leetcode-zhi-wan-quan-ping-fang-shu/</url>
      
        <content type="html"><![CDATA[<p>Perfect Squares</p><a id="more"></a><h3 id="Perfect-Squares"><a href="#Perfect-Squares" class="headerlink" title="Perfect Squares"></a>Perfect Squares</h3><ul><li>code with Python</li><li>title number：279</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个正整数<code>n</code>，找到若干平方数，使这些完全平方数的和等于<code>n</code>，输出使用的完全平方数的个数</li><li>使组成和的完全平方数的个数最少，完全平方数可重复使用</li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li><p>首先说一下，一开始的想法是</p><ul><li>生成一个完全平方数的列表，然后从中挑选尽可能大的数来用</li></ul></li><li><p>但是这种想法是有问题的，虽然直觉上觉得每次取尽可能大的数会减少使用的数字的数量，这种想法的缺陷是会在后期使用<strong>多次</strong>的较小的数字，从而直接将使用的数字个数变多</p></li><li><p>例如：</p><ul><li>对于<code>n = 12</code>，使用这种算法得到的序列为<code>[9, 1, 1, 1]</code></li><li>而实际上<code>[4, 4, 4]</code>的序列才是最合适的</li></ul></li><li><p>贴一下代码吧，<strong>但是不要用</strong></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numSquares</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gen_square_list</span><span class="params">(n)</span>:</span></span><br><span class="line">        <span class="comment"># 生成合适的完全平方素列表，返回降序列表</span></span><br><span class="line">        square, i = [], <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i*i &lt;= n:</span><br><span class="line">            square.append(i*i)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> square[::<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    result, i = [], <span class="number">0</span></span><br><span class="line">    square = gen_square_list(n)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> n &gt;= square[i]:</span><br><span class="line">            result.append(square[i])</span><br><span class="line">            n -= square[i]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i += <span class="number">1</span>         </span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><br><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li>暴力解法<ul><li>完全平方数列表 + <code>n</code></li><li>求出所有的组合，取其中最短的组合</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numSquares</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gen_square_list</span><span class="params">(n)</span>:</span></span><br><span class="line">        <span class="comment"># 生成合适的完全平方素列表，返回降序列表</span></span><br><span class="line">        square, i = [], <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i*i &lt;= n:</span><br><span class="line">            square.append(i*i)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> square[::<span class="number">-1</span>]</span><br><span class="line">    square = gen_square_list(n)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumSquares</span><span class="params">(n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n <span class="keyword">in</span> square:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        min_num = float(<span class="string">'inf'</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> square:</span><br><span class="line">            <span class="keyword">if</span> n &lt; s:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            new_num = minNumSquare(n - s) + <span class="number">1</span></span><br><span class="line">            min_num = min(min_num, new_num)</span><br><span class="line">        <span class="keyword">return</span> min_num</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> minNumSquares(n)</span><br></pre></td></tr></table></figure><ul><li>在题目没有给出范围时，使用暴力解法通常是会超时的</li><li>毫无意外，超时了</li></ul><br><h4 id="思路三"><a href="#思路三" class="headerlink" title="思路三"></a>思路三</h4><ul><li><p>使用暴力枚举之所以会超时是因为我们在其中进行了多次的重复计算，所以<strong>动态规划</strong>登场</p></li><li><p>在使用动态规划之前，我们需要预先计算小于给定数字的<strong>完全平方数列表</strong></p></li><li><p><strong>状态表示</strong>（$f(i)$）</p><ul><li><strong>集合</strong>：数字<code>i</code>的平方数组合方案使用平方数的个数集合</li><li><strong>属性</strong>：集合中使用平方数<strong>最少</strong>的方案</li></ul></li><li><p><strong>状态计算</strong></p><ul><li><p>以是否使用小于等于<code>i</code>的最大平方数作为集合的划分标准</p></li><li><p>假设符合条件的最后一个数字为<code>k</code></p></li><li><p>若使用最后一个数字，则表达式为<code>f(i)</code></p></li><li><p>若不使用最后一个数字，则表达式为<code>f(i-k)</code></p></li><li><p>综上，状态计算表达式为：$f(i) = min(f(i), f(i-k)+1)$</p></li></ul></li><li><p>结果即$f(n)$，即数字<code>n</code>的平方数组合中使用平方数最少的个数</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numSquares</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">    square_nums = [i**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, int(math.sqrt(n))+<span class="number">1</span>)]</span><br><span class="line">    <span class="comment"># 这里多申请一个位置，用于处理n-k==0的情况</span></span><br><span class="line">    dp = [float(<span class="string">'inf'</span>)] * (len(n)+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> square_nums:</span><br><span class="line">            <span class="keyword">if</span> i &lt; s:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            dp[i] = min(dp[i], dp[i-s] + <span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><br><h4 id="思路四"><a href="#思路四" class="headerlink" title="思路四"></a>思路四</h4><ul><li>贴一个比较有趣的解法，是一个基于数学定理的解法，来自<a href="https://leetcode-cn.com/problems/perfect-squares/solution/wan-quan-ping-fang-shu-by-leetcode/" target="_blank" rel="noopener">本题的题解区</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之搜索二维矩阵Ⅱ</title>
      <link href="/passages/leetcode-zhi-sou-suo-er-wei-ju-zhen-ii/"/>
      <url>/passages/leetcode-zhi-sou-suo-er-wei-ju-zhen-ii/</url>
      
        <content type="html"><![CDATA[<p>Search a 2D Matrix Ⅱ</p><a id="more"></a><h3 id="Search-a-2D-Matrix-Ⅱ"><a href="#Search-a-2D-Matrix-Ⅱ" class="headerlink" title="Search a 2D Matrix Ⅱ"></a>Search a 2D Matrix Ⅱ</h3><ul><li>code with Python</li><li>title number：240</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>编写一个高效的算法来搜索一个<code>m*n</code>的矩阵中的一个目标值</li><li>矩阵具有以下的特性：<ul><li>每行的元素从左到右升序排列</li><li>每列的元素从上到下升序排列</li></ul></li></ul><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>不巧，该题目在准备研究生初试的时候遇到过</li><li>说一下思路：<ul><li>第一行中的每个位置的元素都是对应列中最小的元素</li><li>最后一行的元素从右向左遍历，如果<code>target</code>大于当前值，则行号<code>+1</code>；如果<code>target</code>小于当前值，则列号<code>-1</code></li><li>直到找到<code>target</code>，返回<code>True</code>，或遍历完没发现对应元素，返回<code>False</code></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span><span class="params">(self, matrix, target)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">    :type target: int</span></span><br><span class="line"><span class="string">    :rtype: bool</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> len(matrix) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    i, j = len(matrix)<span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &lt; len(matrix[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">if</span> matrix[i][j] == target:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># target大于当前元素，列号+1</span></span><br><span class="line">        <span class="keyword">if</span> matrix[i][j] &lt; target:</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="comment"># target小于当前元素，行号-1</span></span><br><span class="line">        <span class="keyword">if</span> matrix[i][j] &gt; target:</span><br><span class="line">            i -= <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之除自身以外数组的乘积</title>
      <link href="/passages/leetcode-zhi-chu-zi-shen-yi-wai-shu-zu-de-cheng-ji/"/>
      <url>/passages/leetcode-zhi-chu-zi-shen-yi-wai-shu-zu-de-cheng-ji/</url>
      
        <content type="html"><![CDATA[<p>Product of Array Except Self</p><a id="more"></a><h3 id="Product-of-Array-Except-Self"><a href="#Product-of-Array-Except-Self" class="headerlink" title="Product of Array Except Self"></a>Product of Array Except Self</h3><ul><li>code with Python</li><li>title number：238</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li><p>给定一个长度为<code>n</code>的整数数组<code>nums</code>，其中<code>n &gt; 1</code>，返回输出数组<code>output</code>，其中<code>output[i]</code>等于<code>nums</code>中除<code>nums[i]</code>之外其余个元素的乘积</p></li><li><p>不允许使用除法</p></li><li><p>请尝试在<strong>常数空间复杂度</strong>内完成这个题目</p></li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>常规思路为双重遍历<ul><li>第一轮遍历进行数组的遍历</li><li>第二轮遍历除当前元素以外的数组，并进行计算</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">productExceptSelf</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">    output = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        temp = nums[:i]+nums[i+<span class="number">1</span>:]</span><br><span class="line">        temp_product = temp[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(temp)):</span><br><span class="line">            temp_product *= temp[j]</span><br><span class="line">        output.append(temp_product)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure><ul><li>意料之中，超时</li></ul><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li><p>由于输出数组中每个位置的值都要用到其他元素只对数组进行一次遍历完成该任务是不可能的，我们的工作是尽可能的减少遍历的次数</p><ul><li>我们正向进行一次遍历，维护一个数组，第<code>i</code>项代表前<code>i</code>个元素的乘积</li><li>之后再反向遍历一次数组，同样维护一个数组，第<code>i</code>项代表前<code>i</code>个元素的乘积</li><li>之后再将两个数组相乘，即为结果</li></ul></li><li><p>这种做法本质上就是分别计算了第<code>i</code>个元素前面和后面的乘积，最后再结合</p></li><li><p>事实上，并不需要使用第二个数组，在进行第二遍遍历的时候，只需要对第一个数组的对应位置进行修改即可</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">productExceptSelf</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">    output = [<span class="number">0</span>]*len(nums)</span><br><span class="line">    temp = <span class="number">1</span></span><br><span class="line">    <span class="comment"># 正向遍历</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        output[i] = temp</span><br><span class="line">        temp *= nums[i]</span><br><span class="line">    </span><br><span class="line">    temp, n = <span class="number">1</span>, len(nums)<span class="number">-1</span></span><br><span class="line">    <span class="comment"># 反向遍历</span></span><br><span class="line">    <span class="keyword">while</span> n &gt;= <span class="number">0</span>:</span><br><span class="line">        output[n] *= temp</span><br><span class="line">        temp *= nums[n]</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之二叉树的最近公共祖先</title>
      <link href="/passages/leetcode-zhi-er-cha-shu-de-zui-jin-gong-gong-zu-xian/"/>
      <url>/passages/leetcode-zhi-er-cha-shu-de-zui-jin-gong-gong-zu-xian/</url>
      
        <content type="html"><![CDATA[<p>Lowest Common Ancestor of a Binary Tree</p><a id="more"></a><h3 id="Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="Lowest Common Ancestor of a Binary Tree"></a>Lowest Common Ancestor of a Binary Tree</h3><ul><li>code with Python</li><li>title number：236</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一棵二叉树，找到树中两个指定结点的<strong>最近公共祖先</strong></li><li>结点<code>p</code>和<code>q</code>为不同结点，并且<strong>必定存在</strong>于给定的二叉树中</li><li><strong>最近公共祖先</strong><ul><li>对于有根数<code>T</code>的两个结点<code>p</code>、<code>q</code>，最近公共祖先表示为一个结点<code>x</code>，满足<code>x</code>是<code>p</code>、<code>q</code>的祖先，并且<code>x</code>的深度尽可能大</li><li>一个节点可以是自己的祖先</li></ul></li></ul><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>二叉树树是一种递归的数据结构，所以解决二叉树问题<strong>递归</strong>应该是我们首先需要想到的解决方法</li><li>不错，这里介绍的是一种递归方法<ul><li>在当前结点的左右子树中分别查找<code>p</code>和<code>q</code>，如果<code>p</code>没有在左子树中，那么它一定在右子树中，反之依然</li><li>分别查找左右子树，返回查找到的结点</li></ul></li><li>这种方法的原理在于：<ul><li>树是一种递归数据结构</li><li><code>p</code>和<code>q</code>是不同的结点，并且必定存在于一个结点的左右子树中</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: <span class="string">'TreeNode'</span>, p: <span class="string">'TreeNode'</span>, q: <span class="string">'TreeNode'</span>)</span> -&gt; 'TreeNode':</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> root == p <span class="keyword">or</span> root == q:</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    <span class="comment"># 分别去左右子树中找</span></span><br><span class="line">    left = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">    right = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 左子树中没找到，找右子树</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> left:</span><br><span class="line">        <span class="keyword">return</span> right</span><br><span class="line">    <span class="comment"># 右子树中没找到，找左子树</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> right:</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    <span class="comment"># 分别一个，返回当前子树的root</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周知识总结（4-20-2-26）</title>
      <link href="/passages/zhou-zhi-shi-zong-jie-4-20-2-26/"/>
      <url>/passages/zhou-zhi-shi-zong-jie-4-20-2-26/</url>
      
        <content type="html"><![CDATA[<p>主要内容来自《百面机器学习》</p><a id="more"></a><h3 id="4月20日"><a href="#4月20日" class="headerlink" title="4月20日"></a>4月20日</h3><ul><li>对于一个机器学习问题，数据和特征往往决定了结果的上限，而模型、算法的选择及优化则在逐步接近这个上线</li></ul><h4 id="两种常用的数据类型"><a href="#两种常用的数据类型" class="headerlink" title="两种常用的数据类型"></a>两种常用的数据类型</h4><ul><li>结构化数据<ul><li>可以看作关系型数据库的一张表，每列都有定义，称之为特征；每行表示一个样本</li></ul></li><li>非结构化数据<ul><li>主要包括文本、图像、音频、视频数据，最大的特点是其包含的信息无法使用一个简单的数值表示，也没有清晰的类别定义且每条数据的大小各不相同</li></ul></li></ul><br><h4 id="为什么要进行特征归一化？"><a href="#为什么要进行特征归一化？" class="headerlink" title="为什么要进行特征归一化？"></a>为什么要进行特征归一化？</h4><ul><li>特征归一化主要是为了消除特征之间的纲量影响</li><li>直观来说，如果要分析一个人的身高和体重对健康的影响，身高的单位为米，体重的单位为千克。那么两个特征的数值范围就会有较大的差别，身高[1.6, 1.8]，体重[50, 100]。如果直接使用这种样本，那么结果一定会倾向与数值差别比较大的体重特征。</li><li>想要更为准确的结果，就需要进行特征归一化</li><li><strong>另一角度来说</strong>，在学习速率相同的情况下，两个取值范围不同的特征的下降速度是不同的，这就会导致在进行梯度下降时花费更多的时间才能达到最优解</li></ul><br><h4 id="常用特征归一化的方法？"><a href="#常用特征归一化的方法？" class="headerlink" title="常用特征归一化的方法？"></a>常用特征归一化的方法？</h4><ul><li><p>数值类型的特征做归一化可以将所有的特征都统一到一个<strong>大致相同的数值区间</strong>内。</p></li><li><p><strong>线性函数归一化（Min-Max Scaling）</strong></p><ul><li>对原始数据进行线性变换，使结果映射到<code>[0, 1]</code>的范围内</li></ul><p>$$<br>X_{norm} = \frac{X - X_{min}}{X_{max} - X_{min}}<br>$$</p></li><li><p><strong>零均值归一化（Z-Score Normalization）</strong></p><ul><li>将原始数据映射到均值为<code>0</code>，标准差为<code>1</code>的分布上</li></ul><p>$$<br>z = \frac{x - \mu}{\delta}<br>$$</p></li></ul><br><h4 id="什么样的模型需要进行归一化呢？"><a href="#什么样的模型需要进行归一化呢？" class="headerlink" title="什么样的模型需要进行归一化呢？"></a>什么样的模型需要进行归一化呢？</h4><ul><li>数据归一化并不是万能的，通过梯度下降法求解的模型通常是需要归一化的</li><li>包括：线性回归、逻辑回归、支持向量机、神经网络等</li><li>一个典型的无需进行数据归一化的模型是：<strong>决策树</strong></li></ul><br><br><h3 id="4月21日"><a href="#4月21日" class="headerlink" title="4月21日"></a>4月21日</h3><h4 id="类别特征一般有什么处理方式？"><a href="#类别特征一般有什么处理方式？" class="headerlink" title="类别特征一般有什么处理方式？"></a>类别特征一般有什么处理方式？</h4><ul><li>类别型的特征，是指一般只在<strong>有限的选项内取值</strong>的特征</li><li>类别性特征原始输入通常是字符串的形式，对于大多数模型来说，无法直接处理。常见的处理方法如下</li><li><strong>序号编码（Ordinal Encoding）</strong><ul><li>通常用于处理类别间具有大小关系的数据，例如成绩，可以分为高、中、低三档，分别以3、2、1表示</li></ul></li><li><strong>独热编码（One-hot Encoding）</strong><ul><li>通常用于处理类别间不具大小关系的特征，例如血型，表示成一个4维的稀疏向量</li></ul></li><li><strong>二进制编码（Binary Encoding）</strong><ul><li>分为两步，显示用序号编码给每个类别赋予一个类别<code>ID</code>，然后将类别<code>ID</code>对应的二进制用作特征表示</li></ul></li></ul><br><br><h3 id="4月22日"><a href="#4月22日" class="headerlink" title="4月22日"></a>4月22日</h3><h4 id="什么是组合特征？"><a href="#什么是组合特征？" class="headerlink" title="什么是组合特征？"></a>什么是组合特征？</h4><ul><li>为了提高复杂关系的拟合能力，在特征工程中常常会把一阶离散特征两两组合，构成高阶组合特征。简言之，提高表达能力</li><li>但是随意的进行特征的组合也会带来许多问题，而且并不是所有的特征组合都是有意义的，我们需要找到一种有效的方法来帮助我们找到对应有效的特征组合。</li></ul><br><h4 id="基于决策树的特征组合寻找方法？"><a href="#基于决策树的特征组合寻找方法？" class="headerlink" title="基于决策树的特征组合寻找方法？"></a>基于决策树的特征组合寻找方法？</h4><ul><li>根据原始输入和标签构建决策树</li><li>每一条从根节点到叶节点的路径都可以看作一种特征组合方式</li></ul><p><img src="%E5%91%A8%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%884-20-2-26%EF%BC%89%5C1.png" alt=""></p><ul><li>若样本为<code>[年龄:28, 性别:女, 用户类型:免费, 物品类型:护肤]</code>，则得到的变为<code>(1, 1, 0, 0)</code>。即同时满足<code>(1)</code>、<code>(2)</code>，但不满足<code>(3)</code>、<code>(4)</code></li></ul><br><br><h3 id="4月23日"><a href="#4月23日" class="headerlink" title="4月23日"></a>4月23日</h3><h4 id="如何进行文本数据表示？"><a href="#如何进行文本数据表示？" class="headerlink" title="如何进行文本数据表示？"></a>如何进行文本数据表示？</h4><ul><li><p>文本数据是一种重要的非结构话数据，如何有效进行文本数据的表示意义深远。</p></li><li><p>文本数据的表示并不能单独的来看</p></li><li><p><strong>词袋模型（Bag of Words）</strong></p><ul><li>最基础的文本表示模型就是词袋模型</li><li>将每篇文章看成一袋词，并<strong>忽略每个词出现的顺序</strong></li><li>具体而言， 将整段文本以词为单位切分开，真个文章可以表示成一个长向量，向量中的每一维表示一个单词。</li></ul></li><li><p><strong>TF-IDF</strong></p><ul><li><p>用于计算每个词在文本中的重要程度<br>$$<br>TF-IDF = \frac{单词t在文档d中出现的频率}{log \frac{文章总数}{包含单词t的文章总数+1}}<br>$$</p></li><li><p>计算得到每个词的权值放入词袋模型中对应单词的位置</p></li><li><p>直观来说，如果一个单词在非常多的文章中出现，那么该单词就是一个比较通用的词汇，并不具有特殊性</p></li></ul></li><li><p><strong>N-gram</strong></p><ul><li>有时候将文章进行单词级别的划分并不是很合理（例如英文中的词组）</li><li>可以将连续出现的<code>n</code>个词组成的词组作为一个单独特征放到向量表示中去，即<code>N-gram</code>模型</li></ul></li><li><p><strong>主题模型（Topic Model）</strong></p><ul><li>用于从文本库中发现有代表性的主题</li></ul></li><li><p><strong>词嵌入模型（Word Embedding）</strong></p><ul><li>词嵌入模型能够将词向量化，核心思想是讲每个词都映射成低维空间上的一个稠密向量</li><li>由于词嵌入将每个词映射成为一个<code>K</code>维的向量，一个文章如果有<code>N</code>个词，就可以用一个<code>N*K</code>维的矩阵来表示这篇文档，但这样太过底层。</li><li>通常的做法是在此基础上加工出更高层的特征，而深度学习模型正好为我们提供了一种自动地进行特征工程的方式，网络中的每层都相当于对应不同层次的抽象特征</li><li>常见的模型有<code>CBOW</code>、<code>Skip-gram</code>。其中前者是根据上下问预测当前词的生成概率；后者是通过当前词来预测上下文中各词的生成概率</li></ul></li></ul><br><br><h3 id="4月24日"><a href="#4月24日" class="headerlink" title="4月24日"></a>4月24日</h3><h4 id="分析Word2Vec和LDA的区别和联系？"><a href="#分析Word2Vec和LDA的区别和联系？" class="headerlink" title="分析Word2Vec和LDA的区别和联系？"></a>分析<code>Word2Vec</code>和<code>LDA</code>的区别和联系？</h4><ul><li><code>LDA</code>是利用文档中单词的共现关系对单词按主题聚类，也可以理解为对“文档-单词”矩阵进行分解，得到“文档-主题”和“主题-单词”两个概率分布。</li><li>而<code>Word2Vec</code>其实是对“上下文-单词”矩阵进行学习，其中上下文由周围的几个单词组成，由此得到的词向量表示更多地融入了上下文共现的特征。换句话说，如果两个<code>Word2Vec</code>向量的相似度较高，那么它们可能经常在同样的上下文中出现</li></ul><br><h4 id="主题模型和词嵌入模型的区别？"><a href="#主题模型和词嵌入模型的区别？" class="headerlink" title="主题模型和词嵌入模型的区别？"></a>主题模型和词嵌入模型的区别？</h4><ul><li>上述分析仅为<code>LDA</code>和<code>Word2Vec</code>两者之间的区别，并不能繁华为两类模型之间的区别</li><li>具体来说，两种模型的主要区别还是模型本身。<ul><li>主题模型是一种基于概率图模型的生成式模型，其似然函数可以协程若干条概率连乘的形式，其中包括需要预测的隐含变量</li><li>词嵌入模型一般表达为神经网络的形式，似然函数定义在网络的输出之上，需要通过学习网络的权重以得到单词的稠密向量表示</li></ul></li></ul><br><br><h3 id="4月25日"><a href="#4月25日" class="headerlink" title="4月25日"></a>4月25日</h3><h4 id="当模型缺少训练数据时，该如何处理呢？"><a href="#当模型缺少训练数据时，该如何处理呢？" class="headerlink" title="当模型缺少训练数据时，该如何处理呢？"></a>当模型缺少训练数据时，该如何处理呢？</h4><ul><li>一个模型所能提供的信息一般来源于两个方面<ul><li>一是训练数据中蕴含的信息</li><li>二是在模型形成过程中，人们提供的先验信息</li></ul></li><li>当训练数据不足时，先验信息缺乏，需要更多的先验信息。</li><li>先验信息可以作用在模型上：例如对模型采用特定的内在结构，条件假设或其他约束条件</li><li>先验信息可以作用在数据集上，即根绝特定的先验假设去调整、变换或扩展训练数据，让其展示出更多的信息</li></ul><br><br><h3 id="4月26日"><a href="#4月26日" class="headerlink" title="4月26日"></a>4月26日</h3><h4 id="具体而言，当一个图片分类模型缺少数据时，如何处理？"><a href="#具体而言，当一个图片分类模型缺少数据时，如何处理？" class="headerlink" title="具体而言，当一个图片分类模型缺少数据时，如何处理？"></a>具体而言，当一个图片分类模型缺少数据时，如何处理？</h4><ul><li>训练数据不足带来的问题主要表现在过拟合方面，即模型在训练样本上的效果可能不错，但在测试集上的泛化效果不佳。</li><li>一是<strong>基于模型</strong>的方法，主要是采用降低过拟合风险的措施，包括简化模型（如将非线性模型简化为线性模型）、添加约束项以缩小假设空间（如<code>L1/L2</code>正则项）、集成学习、<code>Dropout</code>超参数等；</li><li>二是<strong>基于数据</strong>的方法，主要通过数据扩充（<code>Data Augmentation</code>），即根据一些先验知识，在保持特定信息的前提下，对原始数据进行适当变换以达到扩充数据集的效<ul><li>在保持图像类别不变的前提下，可以对训练集中的每幅图像进行以下变换。<ul><li>一定程度内的随机旋转、平移、缩放、裁剪、填充、左右翻转等，这些<br>变换对应着同一个目标在不同角度的观察结果。</li><li>对图像中的像素添加噪声扰动，比如椒盐噪声、高斯白噪声等。</li><li>颜色变换。</li><li>改变图像的亮度、清晰度、对比度、锐度等</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 周知识总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Artificial Intelligence </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之二叉搜索树中第K小元素</title>
      <link href="/passages/leetcode-zhi-er-cha-sou-suo-shu-zhong-di-k-xiao-yuan-su/"/>
      <url>/passages/leetcode-zhi-er-cha-sou-suo-shu-zhong-di-k-xiao-yuan-su/</url>
      
        <content type="html"><![CDATA[<p>Kth Smallest Element in a BST</p><a id="more"></a><h3 id="Kth-Smallest-Element-in-a-BST"><a href="#Kth-Smallest-Element-in-a-BST" class="headerlink" title="Kth Smallest Element in a BST"></a>Kth Smallest Element in a BST</h3><ul><li>code with Python</li><li>title number：230</li></ul><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><ul><li><p>给定一棵二叉搜索树，查找其中第<code>k</code>个最小的元素</p></li><li><p><code>k</code>总是有效的</p></li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>回顾一下，二叉搜索树的特点如下：<ul><li>左子树若不空，则左子树中所有节点的值都小于根节点的值</li><li>右子树若不空，则右子树中所有结点的值都大于根节点的值</li><li>左右子树也符合该特点</li></ul></li><li>根据二叉搜索树的特点，如果对二叉搜索树进行一次中序遍历可以得到一个升序数组，然后取数组的第<code>k</code>个元素即可</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span><span class="params">(self, root: TreeNode, k: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorder</span><span class="params">(root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        inorder(root.left)</span><br><span class="line">        res.append(root.val)</span><br><span class="line">        inorder(root.right)</span><br><span class="line"></span><br><span class="line">    res = []</span><br><span class="line">    </span><br><span class="line">    inorder(root)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res[k<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之求众数Ⅱ</title>
      <link href="/passages/leetcode-zhi-qiu-zhong-shu-ii/"/>
      <url>/passages/leetcode-zhi-qiu-zhong-shu-ii/</url>
      
        <content type="html"><![CDATA[<p>Majority Element Ⅱ</p><a id="more"></a><h3 id="Majority-Element-Ⅱ"><a href="#Majority-Element-Ⅱ" class="headerlink" title="Majority Element Ⅱ"></a>Majority Element Ⅱ</h3><ul><li>code with Python</li><li>title number：229</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个大小为<code>n</code>的数组，找出其中所有出现次数超过$\frac{1}{3}$次的元素</li><li>要求算法的时间复杂度为$O(n)$，空间复杂度为$O(1)$</li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>首先从分析一下从题目中得到的信息：<ul><li>存在数组中没有没有符合条件的数的情况，即返回空集</li><li>最多存在两个满足条件的数（显然）</li></ul></li><li>投票算法（摩尔投票，即对候选者与其他人对抗的过程）<ul><li>本题特别之处在于，需要设置两个候选值（至多两个满足条件的元素）</li><li>对于候选者<code>cand1</code>和<code>cand2</code>：<ul><li>如果投<code>cand1</code>，<code>cand1</code>加一票</li><li>如果投<code>cand2</code>，<code>cand2</code>加一票</li><li>如果投其他元素，<code>cand1</code>和<code>cand2</code>各减一票</li></ul></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">    cand1, vote1 = <span class="literal">None</span>, <span class="number">0</span></span><br><span class="line">    cand2, vote2 = <span class="literal">None</span>, <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    res = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        <span class="keyword">if</span> cand1 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> cand2 != nums[i]:</span><br><span class="line">            cand1 = nums[i]</span><br><span class="line">            vote1 = <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> cand2 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> cand1 != nums[i]:</span><br><span class="line">            cand2 = nums[i]</span><br><span class="line">            vote2 = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> cand1 == nums[i]:</span><br><span class="line">                vote1 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> cand2 == nums[i]:</span><br><span class="line">                vote2 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                vote1 -= <span class="number">1</span></span><br><span class="line">                vote2 -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> vote1 == <span class="number">0</span>:</span><br><span class="line">                    cand1 = <span class="literal">None</span></span><br><span class="line">                <span class="keyword">if</span> vote2 == <span class="number">0</span>:</span><br><span class="line">                    cand2 = <span class="literal">None</span></span><br><span class="line">    <span class="comment"># 重新遍历判断</span></span><br><span class="line">vote1 ， vote2 = <span class="number">0</span>， <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> cand1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> cand1 == nums[i]:</span><br><span class="line">                vote1 += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> cand2 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> cand2 == nums[i]:</span><br><span class="line">                vote2 += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> vote1 &gt; len(nums)//<span class="number">3</span>:</span><br><span class="line">        res.append(cand1)</span><br><span class="line">    <span class="keyword">if</span> vote2 &gt; len(nums)//<span class="number">3</span>:</span><br><span class="line">        res.append(cand2)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><ul><li><p>以下解释帮助理解</p><ul><li>根据上面的信息，我们可以找出数组中出现次数最多的两个数，然后判断这两个数是否符合条件即可</li><li>如此一来，我们每次从数组中拿走三个不同的数，最后剩下的一定是出现次数最多的两个数，再判断这两个数是否合法即可。</li><li>分为三种情况：(将数组分为三组，<code>A</code>、<code>B</code>、其他，<code>A</code>、<code>B</code>为出现次数最多的两个数）<ul><li>三个数中包含<code>A</code>和<code>B</code>。则三部分分别减去1，不影响最终结果</li><li>三个数中只包含<code>A</code>和<code>B</code>其中一个，假设是<code>A</code>。则<code>A</code>和<code>其他</code>分别减<code>1</code>减<code>2</code>，注意，即使这里<code>A</code>减去了1，但仍是出现次数最多的前两名</li><li>三个数中不包含<code>A</code>和<code>B</code>，则<code>其他</code>减去2，仍不改变最终的结果</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之最大正方形</title>
      <link href="/passages/leetcode-zhi-zui-da-zheng-fang-xing/"/>
      <url>/passages/leetcode-zhi-zui-da-zheng-fang-xing/</url>
      
        <content type="html"><![CDATA[<p>Maximal Square</p><a id="more"></a><h3 id="Maximal-Square"><a href="#Maximal-Square" class="headerlink" title="Maximal Square"></a>Maximal Square</h3><ul><li>code with Python</li><li>title number：221</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个由<code>0</code>和<code>1</code>组成的二维矩阵</li><li>在矩阵内找到之包含<code>1</code>的最大正方形，返回其面积</li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>一开始想到了连通区域问题，但仔细一想并不可行，连通区域问题只需要进行<code>DFS</code>即可，而当前问题对连通区域的形状有要求，并不适合</li><li>暴力解法：<ul><li>遍历每一个点，求以当前点为右下角点的正方形的最大面积</li><li>由于是正方形，所以我们只需要记录以当前点为右下角点的正方形的最大边长即可</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maximalSquare</span><span class="params">(self, matrix: List[List[str]])</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> len(matrix) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 存储以当前位置结尾的连续数字一的个数</span></span><br><span class="line">    width = [[<span class="number">0</span>]*len(matrix[<span class="number">0</span>]) <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(matrix))]</span><br><span class="line">    <span class="comment"># 记录最大边长</span></span><br><span class="line">    int max_side = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> range(len(matrix)):</span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>])):</span><br><span class="line">            <span class="keyword">if</span> matrix[row][col] == <span class="string">'1'</span>:</span><br><span class="line">                <span class="keyword">if</span> col == <span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># 第一列，只能为1</span></span><br><span class="line">                    width[row][col] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">                    width[row][col] = width[row][col<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">                    </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                width[row][col] = <span class="number">0</span></span><br><span class="line">                </span><br><span class="line">            cur_width = width[row][col]</span><br><span class="line">            <span class="comment">#向上扩展行</span></span><br><span class="line">            up_row = row</span><br><span class="line">            <span class="keyword">while</span> up_row &gt;= <span class="number">0</span>:</span><br><span class="line">height = row - up_row + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> width[up_row][col] &lt;= max_side || height &gt; cur_width:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="comment"># 最大边长受高和长的限制，</span></span><br><span class="line">                max_side = max(height, max_side)</span><br><span class="line">                up_row -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> max_side * max_side</span><br></pre></td></tr></table></figure><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li><p><strong>动态规划</strong></p><ul><li>在思路一中，我们求每个点的最大边长时并没哟欧考虑之前的解，而事实上是可以用到的，所以动态规划他来了</li></ul></li><li><p><strong>状态表示</strong>：$f(i, j)$</p><ul><li><strong>集合</strong>：以点<code>matrix[i][j]</code>为右下角点的正方形的边长的集合</li><li><strong>属性</strong>：集合中边长的最大值</li></ul></li><li><p><strong>状态计算</strong>：</p><ul><li><p>当前的点有三个方向可以到达：上方、左边、左上角（当前点是右下角。所以右边和下边对当前点没有影响）。以此作为标准划分集合，<strong>在当前点为<code>1</code>的时候</strong>:</p></li><li><p>当左上角的最大边长不为<code>0</code>时，当前点的最大边长可以表示为$f(i, j) = f(i-1, j-1)+1$</p></li><li><p>当左边的最大边长不为<code>0</code>时，当前点的最大边长可以表示为$f(i ,j) = f(i-1, j) + 1$</p></li><li><p>当上面的最大边长不为<code>0</code>时，当前点的最大边长可以表示为$f(i, j) = f(i , j-1) + 1$</p></li><li><p>而当前点最终的最大边长受这三者中最短的最大边长的限制，于是：<br>$$<br>f(i, j) = min[f(i-1, j-1), f(i-1, j), f(i ,j-1)]+1<br>$$</p></li></ul></li></ul><ul><li>代码方面，我们可以<strong>多申请一行和一列</strong>，这样<strong>第一行和第一列就不需要特殊处理了</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maximalSquare</span><span class="params">(self, matrix: List[List[str]])</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> len(matrix) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    dp = [[<span class="number">0</span>]*len(matrix[<span class="number">0</span>])+<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(matrix)+<span class="number">1</span>)]</span><br><span class="line">    </span><br><span class="line">    max_side = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> range(<span class="number">1</span>, len(matrix)+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> range(<span class="number">1</span>, len(matrix[<span class="number">0</span>])+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> matrix[row<span class="number">-1</span>][col<span class="number">-1</span>] == <span class="string">'0'</span>:</span><br><span class="line">                dp[row][col] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[row][col] = min(dp[row][col<span class="number">-1</span>], min(dp[row<span class="number">-1</span>][col], dp[row<span class="number">-1</span>][col<span class="number">-1</span>]))+<span class="number">1</span></span><br><span class="line">                max_side = max(dp[row][col], max_side)</span><br><span class="line">        print(dp)</span><br><span class="line">    <span class="keyword">return</span> max_side * max_side</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之数组中第K个最大元素</title>
      <link href="/passages/leetcode-zhi-shu-zu-zhong-di-k-ge-zui-da-yuan-su/"/>
      <url>/passages/leetcode-zhi-shu-zu-zhong-di-k-ge-zui-da-yuan-su/</url>
      
        <content type="html"><![CDATA[<p>Kth Largest Element in an Array</p><a id="more"></a><h3 id="Kth-Largest-Element-in-an-Array"><a href="#Kth-Largest-Element-in-an-Array" class="headerlink" title="Kth Largest Element in an Array"></a>Kth Largest Element in an Array</h3><ul><li>code with Python</li><li>title number：215</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li><p>在<strong>未排序</strong>的数组中找到第<strong>K</strong>个最大的元素。</p></li><li><p>注意，你要找到的是数组排序后的第K个最大的元素，而不是第K个不同的元素（即降序排序后的第K个元素）</p></li><li><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：[3, 2, 1, 5, 6, 4] 和 k &#x3D; 2</span><br><span class="line">输出：5</span><br><span class="line"></span><br><span class="line">输入：[3, 2, 3, 1, 2, 4, 5, 5, 6] 和 k &#x3D; 4</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure></li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>直接调用<code>sort()</code>进行原地排序，返回排序后的降序序列的第K个元素</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">    nums.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> nums[k<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li>联想到排序算法中的<strong>堆排序</strong>，我们可以使用<strong>小顶堆</strong>来优化该算法的时间复杂度</li><li>利用对存储前K个最大的数，最后返回堆顶的元素即可<ul><li>当<code>i &lt; k</code>时，压数据进堆</li><li>当<code>i &gt;= k</code>时，比较<code>nums[i]</code>和堆顶元素的大小，如果大于，则使用<code>heapreplace()</code>进行替换，否则跳过</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> heappush, heapreplace</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">    heap = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        <span class="keyword">if</span> i &lt; k:</span><br><span class="line">            heappush(heap.nums[i])</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> i &gt;= k:</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; heap[<span class="number">0</span>]:</span><br><span class="line">                heapreplace(heap, nums[i])</span><br><span class="line">    <span class="keyword">return</span> heap[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之添加与搜索单词</title>
      <link href="/passages/leetcode-zhi-tian-jia-yu-sou-suo-dan-ci/"/>
      <url>/passages/leetcode-zhi-tian-jia-yu-sou-suo-dan-ci/</url>
      
        <content type="html"><![CDATA[<p>Add and Search Word</p><a id="more"></a><h3 id="Add-and-Search-Word"><a href="#Add-and-Search-Word" class="headerlink" title="Add and Search Word"></a>Add and Search Word</h3><ul><li>code with Python</li><li>title number：211</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li><p>又是一道数据结构的设计题</p></li><li><p>设计一个支持一下两种操作的数据结构</p><ul><li>添加单词</li><li>搜索单词</li></ul></li><li><p>所有单词仅由小写字母组成</p></li><li><p>示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">addWord(&quot;bad&quot;)</span><br><span class="line">addWord(&quot;dad&quot;)</span><br><span class="line">addWord(&quot;mad&quot;)</span><br><span class="line">search(&quot;pad&quot;) -&gt; false</span><br><span class="line">search(&quot;bad&quot;) -&gt; true</span><br><span class="line">search(&quot;.ad&quot;) -&gt; true</span><br><span class="line">search(&quot;b..&quot;) -&gt; true</span><br></pre></td></tr></table></figure></li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>观察上面的示例，如果没有正则符号<code>.</code>（匹配除换行符之外的任意单字符），我们可以使用数组直接存储单词，在查找的时候线性查找即可</li><li>不过加入<code>.</code>之后也比较好处理，因为在判断时只需要将<code>.</code>对应的字符认为时匹配到了即可</li><li>之前做过一道<strong><a href="http://www.zivblog.top/passages/leetcode-zhi-shi-xian-trie/" target="_blank" rel="noopener">前缀树</a></strong>的设计题，我们这里可以使用前缀树进行优化</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDictionary</span>:</span></span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.lookup = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addWord</span><span class="params">(self, word: str)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Adds a word into the data structure.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        tree = self.lookup</span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> word:</span><br><span class="line">            tree = tree.setdefault(a, &#123;&#125;)</span><br><span class="line">        tree[<span class="string">"#"</span>] = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, word: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(word, tree)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> word:</span><br><span class="line">                <span class="keyword">if</span> <span class="string">"#"</span> <span class="keyword">in</span> tree:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> word[<span class="number">0</span>] == <span class="string">"."</span>:</span><br><span class="line">                <span class="keyword">for</span> t <span class="keyword">in</span> tree:</span><br><span class="line">                    <span class="keyword">if</span> helper(word[<span class="number">1</span>:], tree[t]):</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> word[<span class="number">0</span>] <span class="keyword">in</span> tree:</span><br><span class="line">                <span class="keyword">if</span> helper(word[<span class="number">1</span>:], tree[word[<span class="number">0</span>]]):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> helper(word, self.lookup)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your WordDictionary object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = WordDictionary()</span></span><br><span class="line"><span class="comment"># obj.addWord(word)</span></span><br><span class="line"><span class="comment"># param_2 = obj.search(word)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之最长公共子序列</title>
      <link href="/passages/leetcode-zhi-zui-chang-gong-gong-zi-xu-lie/"/>
      <url>/passages/leetcode-zhi-zui-chang-gong-gong-zi-xu-lie/</url>
      
        <content type="html"><![CDATA[<p>Longest Common Subsequence</p><a id="more"></a><h3 id="Longest-Common-Subsequence"><a href="#Longest-Common-Subsequence" class="headerlink" title="Longest Common Subsequence"></a>Longest Common Subsequence</h3><ul><li>code with Python</li><li>title numbber：1143</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定两个字符串<code>text1</code>和<code>text2</code>，返回这两个字符串的最长公共子序列</li><li>若两个自负串没有公共子序列，则返回0</li><li>值得注意的是：<ul><li>子序列与子串的最大区别在于：子序列并不要求序列中的元素相邻</li></ul></li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li><p>动态规划</p></li><li><p>对于两个字符串<code>text1</code>，<code>text2</code></p></li><li><p><strong>状态表示</strong>：$f(i, j)$</p><ul><li><strong>集合</strong>：所有两个字符串<code>A[0, i]</code>和<code>B[0, j]</code>的公共子序列的集合</li><li><strong>属性</strong>：集合中的最长子序列</li></ul></li><li><p><strong>状态计算</strong></p><ul><li><p>我们以<strong>字符串的最后一个字符是否包含在公共子序列</strong>中作为集合的划分标准</p></li><li><p>可以划分为<code>4</code>种情况：</p></li><li><p><strong>两个字符串的最后一个字符均包含在公共字序列中</strong>（即两个字符串的最后一个字符相同），即除去最后一个字符的最长公共子序列的长度加一，可以表示为$f(i-1, j-1)+1$</p></li><li><p><strong>两个字符串的最后一个字符都不再公共子序列中</strong>，即除去最后一个字符的最长公共子序列的长度，$f(i-1, j-1)$</p></li><li><p><strong>字符串<code>A[0, i]</code>的最后一个字符包含在公共字序列中，字符串<code>B[0, j]</code>的最后一个字符不包含在公共字序列中</strong></p></li><li><p><strong>字符串<code>B[0, j]</code>的最后一个字符包含在公共字序列中，字符串<code>A[0, i]</code>的最后一个字符不包含在公共字序列中</strong></p></li><li><p>事实上最后两种比较<strong>难以</strong>精确表示</p></li><li><p>前面我们也说过，虽然状态表示要求不重不漏，但是在<strong>求最值</strong>时可以适当重复</p></li><li><p>我们可以使用<code>f(i, j-1)</code>和<code>f(i-1, j)</code>来近似的表示上面的两种情况（准确的说时包含上面的两种情况），而且<code>f(i-1, j-1)</code>包含在这两种情况中</p></li><li><p>故<code>f(i,j) = max[f(i, j-1), f(i-1, j)]</code>，并且第一种情况仅在<code>A[i]==B[i]</code>的时候才会存在</p></li></ul></li><li><p>题目所求即为$f[len(text1), len(text2)]$，</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence</span><span class="params">(self, text1: str, text3: str)</span> -&gt; int:</span></span><br><span class="line">    <span class="comment"># 在前面添加了全为0的一行和一列</span></span><br><span class="line">    dp = [<span class="number">0</span>]*(len(text2)+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(text1)+<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(text1)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(text2)):</span><br><span class="line">            <span class="keyword">if</span> text1[i] != text2[j]:</span><br><span class="line">                dp[i][j] = max(dp[i+<span class="number">1</span>][j], dp[i][j+<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j] + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之长度最小的子数组</title>
      <link href="/passages/leetcode-zhi-chang-du-zui-xiao-de-zi-shu-zu/"/>
      <url>/passages/leetcode-zhi-chang-du-zui-xiao-de-zi-shu-zu/</url>
      
        <content type="html"><![CDATA[<p>Minimum Size  Subarray Sum</p><a id="more"></a><h3 id="Minimum-Size-Subarray-Sum"><a href="#Minimum-Size-Subarray-Sum" class="headerlink" title="Minimum Size  Subarray Sum"></a>Minimum Size  Subarray Sum</h3><ul><li>code with Python</li><li>title number：209</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个含有<code>n</code>个正整数的数组和一个正整数<code>s</code>，找出该数组中满足其和大于等于<code>s</code>的长度最小的连续子数组</li><li>返回满足条件的子数组的长度</li><li>若不存在符合条件的连续子数组，返回0</li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>暴力解法</li><li>穷举所有可能的子数组，在子数组和满足条件的情况下更新<code>min_size</code></li><li>返回最终的<code>min_size</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minSubArrayLen</span><span class="params">(self, s: int, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    min_size = len(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, len(nums)):</span><br><span class="line">            sum_ = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(i, j+<span class="number">1</span>):</span><br><span class="line">                sum_ += nums[k]</span><br><span class="line">            <span class="keyword">if</span> sum_ &gt;= s:</span><br><span class="line">                min_size = min(min_size, j-i+<span class="number">1</span>)</span><br><span class="line">                    </span><br><span class="line">    <span class="keyword">return</span> min_size</span><br></pre></td></tr></table></figure><ul><li>遍历所有的子数组的时间复杂度为$O(n^2)$，计算子数组的时间复杂度为$O(n)$</li><li>整个算法的时间复杂度为$O(n^3)$，提交超时</li></ul><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li>优化后的暴力解法</li><li>可优化的部分为<strong>对子数组的求和</strong>：<ul><li>使用一个与数组等长的数组<code>sums</code>来存储前<code>i</code>个元素的和</li><li>这样，求<code>num[i:j]</code>的和就是<code>sums[j] - sums[i] + nums[j]</code></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minSubArrayLen</span><span class="params">(self, s: int, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    min_size = float(<span class="string">'inf'</span>)</span><br><span class="line">    </span><br><span class="line">    sums = [<span class="number">0</span>]*len(nums)</span><br><span class="line">    sums[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">        sums[i] = sums[i<span class="number">-1</span>] + nums[i]</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, len(nums)):</span><br><span class="line">            sum_ = sums[j] - sums[i] + nums[i]</span><br><span class="line">            <span class="keyword">if</span> sum_ &gt;= s:</span><br><span class="line">                min_size = min(min_size, j-i+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> min_size==float(<span class="string">'inf'</span>) <span class="keyword">else</span> min_size</span><br></pre></td></tr></table></figure><ul><li>仍是超时。。。。。</li></ul><h4 id="思路三"><a href="#思路三" class="headerlink" title="思路三"></a>思路三</h4><ul><li>滑动窗口，所有查找连续子数组的都可以考虑滑动窗口<ul><li>左指针从左向右遍历，若当前连续子数组满足条件后，尝试向右移动指针使当前连续子数组尽可能短</li><li>之后再加移动右指针，加上下一个值</li><li>重复上述过程</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minSubArry</span><span class="params">(self, s: int, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    l = total = <span class="number">0</span></span><br><span class="line">    ans = float(<span class="string">'inf'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        total += nums[r]</span><br><span class="line">        <span class="keyword">while</span> total &gt;= s:</span><br><span class="line">            ans = min(ans, r-l+<span class="number">1</span>)</span><br><span class="line">            total -= nums[l]</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> ans == float(<span class="string">'inf'</span>) <span class="keyword">else</span> ans</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之实现Trie</title>
      <link href="/passages/leetcode-zhi-shi-xian-trie/"/>
      <url>/passages/leetcode-zhi-shi-xian-trie/</url>
      
        <content type="html"><![CDATA[<p>Implement Trie(Prefix Tree)</p><a id="more"></a><h3 id="Implement-Trie-Prefix-Tree"><a href="#Implement-Trie-Prefix-Tree" class="headerlink" title="Implement Trie (Prefix Tree)"></a>Implement Trie (Prefix Tree)</h3><ul><li>code with Python</li><li>title number：208</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li><p>实现前缀树，包含<code>insert</code>，<code>search</code>，<code>startWith</code>这三个操作</p></li><li><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Trie trie &#x3D; new Trie();</span><br><span class="line"></span><br><span class="line">trie.insert(&quot;apple&quot;);</span><br><span class="line">trie.search(&quot;apple&quot;);   &#x2F;&#x2F; 返回 true</span><br><span class="line">trie.search(&quot;app&quot;);     &#x2F;&#x2F; 返回 false</span><br><span class="line">trie.startsWith(&quot;app&quot;); &#x2F;&#x2F; 返回 true</span><br><span class="line">trie.insert(&quot;app&quot;);   </span><br><span class="line">trie.search(&quot;app&quot;);     &#x2F;&#x2F; 返回 true</span><br></pre></td></tr></table></figure></li><li><p>前缀树，又称字典树：</p><ul><li>是一种树形结构，是哈希树的变种，典型的应用是统计、排序和保存带昂的数据。</li><li>优点是可以利用字符串的公共前缀来减少查询时间</li></ul></li><li><p>前缀树有三个基本特性：</p><ul><li>根节点不包含字符，除根节点之外每个节点只包含一个字符</li><li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串</li><li>每个结点的所有子节点包含的字符都不相同</li></ul></li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>题目很直接，实现前缀树的几个功能</li><li>初始化<ul><li>前缀树又称字典树，所以存储结构初始化为字典</li></ul></li><li>插入<ul><li>每个结点是一个字典，不断迭代存入字符串中的元素</li></ul></li><li>搜索<ul><li>若有字母不再树中，则查找失败</li><li>遍历完当前字符串遇<strong>到结束标志</strong>才表示当前字符串存在（未遇到结束符则是前缀）</li><li>同时结束标志也用来区分是字符串存在于树中，还是当前字符串仅为前缀</li></ul></li><li>判断是否有以给定字符串为前缀的字符串<ul><li>迭代查找当前字符串，并且不是一个完整单词</li><li>即搜索完该前缀并未到达结束符</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">self.lookup = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, word: str)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Inserts a word into the trie.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">tree = self.lookup</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> word:</span><br><span class="line"><span class="keyword">if</span> a <span class="keyword">not</span> <span class="keyword">in</span> tree:</span><br><span class="line">                <span class="comment"># 新节点</span></span><br><span class="line">                tree[a] = &#123;&#125;</span><br><span class="line">            tree = tree[a]</span><br><span class="line">        <span class="comment"># 设置单词的结束标志</span></span><br><span class="line">        tree[<span class="string">"#"</span>] = <span class="string">"#"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, word: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Returns if the word is in the trie.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">tree = self.lookup</span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> a <span class="keyword">not</span> <span class="keyword">in</span> tree:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">            tree = tree[a]</span><br><span class="line">        <span class="keyword">if</span> <span class="string">"#"</span> <span class="keyword">in</span> tree:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">startsWith</span><span class="params">(self, prefix: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Returns if there is any word in the trie that starts with the given prefix.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        tree = self.lookup</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> prefix:</span><br><span class="line">            <span class="keyword">if</span> a <span class="keyword">not</span> <span class="keyword">in</span> tree:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            tree = tree[a]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>标准完全背包问题</title>
      <link href="/passages/biao-zhun-wan-quan-bei-bao-wen-ti/"/>
      <url>/passages/biao-zhun-wan-quan-bei-bao-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>标准完全背包问题</p><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><ul><li>有<code>N</code>种物品和一个容量是<code>V</code>的背包，每种物品都有<strong>无限件</strong>可用</li><li>第<code>i</code>种物品的体积是$v_i$，价值是$w_i$</li><li>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大</li><li>返回最大价值</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>我们使用<a href="http://www.zivblog.top/passages/dong-tai-gui-hua/" target="_blank" rel="noopener">闫式DP分析法</a>给出的框架进行分析</p></li><li><p>首先，应该明确所有的情况有$2^N$种（每件物品选或不选）,且该问题为最大值问题</p></li><li><p><strong>状态表示</strong>：$f(i, j)$</p><ul><li><strong>集合</strong>：所有只从前<code>i</code>个物品中选，总体积不大于<code>j</code>的方案的集合</li><li><strong>属性</strong>：最大价值</li></ul></li><li><p><strong>状态计算</strong></p><ul><li>与零一背包不同，本题中每个物品是无限的，所以不能以<strong>第<code>i</code>件物品放不放</strong>为分类标准对集合进行二分类</li><li>事实上，应该是<code>k</code>分类，第<code>i</code>件物品放<code>0</code>件、<code>1</code>件、…<code>k</code>件（$k*v_i &lt;= V$）</li><li>于是针对每一中情况，取<code>max</code>，表达式如下：</li></ul><p>$$<br>f(i, j) = max[f(i-1, j), f(i-1, j-v_i)+w_i, … f(i-1, j-k<em>v_i)+k</em>w_i]<br>$$</p><ul><li>表达式看起来比较难实现，我们再来看：</li></ul><p>$$<br>f(i, j-v_i) = max[f(i-1, j-v_i), … f(i-1, j-(k+1)<em>v_i)+(k+1)</em>w_i]<br>$$</p><ul><li>两个表达式相比较，<code>式一 = max(f(i-1, j), 式二+w_i)</code></li><li>故状态转移方程为：</li></ul><p>$$<br>f(i ,j) = max[f(i-1, j), f(i-1, j-v_i)+w_i]<br>$$</p></li><li><p>最终结果即为：$f(N, V)$</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backpack</span><span class="params">(self, N: int, V: int, v: List[int], w: List[int])</span> -&gt; int:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    N: 物品数</span></span><br><span class="line"><span class="string">    V: 背包体积</span></span><br><span class="line"><span class="string">    v: 物品体积列表</span></span><br><span class="line"><span class="string">    w: 物品价值列表</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    dp = [[<span class="number">0</span>]*(N+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(N+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, N+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, V+<span class="number">1</span>):</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">            <span class="keyword">if</span> j &gt;= v[i]:</span><br><span class="line">                dp[i][j] = max(dp[i][j], dp[i][j-v[i]]+w[i])</span><br><span class="line">    <span class="keyword">return</span> dp[N][V]</span><br></pre></td></tr></table></figure><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><ul><li>上述写法由于是按背包体积从小到大的顺序进行的，所以要判断当前背包能否装下一个物品</li><li><strong>优化</strong>：从可装下物品的背包体积开始循环</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backpack</span><span class="params">(self, N: int, V: int, v: List[int], w: List[int])</span> -&gt; int:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    N: 物品数</span></span><br><span class="line"><span class="string">    V: 背包体积</span></span><br><span class="line"><span class="string">    v: 物品体积列表</span></span><br><span class="line"><span class="string">    w: 物品价值列表</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    dp = [<span class="number">0</span>]*(N+<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, N+<span class="number">1</span>):</span><br><span class="line">j = v[i]</span><br><span class="line">        <span class="keyword">while</span> j &lt;= V:</span><br><span class="line">            dp[j] = max(dp[j], dp[j-v[i]]+w[i])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> dp[V]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次Leetcode春季编程大赛</title>
      <link href="/passages/ji-yi-ci-leetcode-chun-ji-bian-cheng-da-sai/"/>
      <url>/passages/ji-yi-ci-leetcode-chun-ji-bian-cheng-da-sai/</url>
      
        <content type="html"><![CDATA[<p>记一次Leetcode春季编程大赛</p><a id="more"></a><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li>leetcode上的题目近期刷了100道左右，心想参加一下比赛试试水，可惜可惜，只做出了两道简单题。</li><li>简单题十几分钟就做完了，后面几道题看着有思路却总是调试不成功。</li><li>革命尚未成功，同志仍需努力，加油！</li></ul><br><h3 id="拿硬币"><a href="#拿硬币" class="headerlink" title="拿硬币"></a>拿硬币</h3><ul><li><p>桌上有 <code>n</code> 堆力扣币，每堆的数量保存在数组 <code>coins</code> 中。我们每次可以选择任意一堆，拿走其中的一枚或者两枚，求拿完所有力扣币的最少次数。</p></li><li><p>示例一</p><blockquote><p>输入：<code>[4,2,1]</code></p><p>输出：<code>4</code></p><p>解释：第一堆力扣币最少需要拿 2 次，第二堆最少需要拿 1 次，第三堆最少需要拿 1 次，总共 4 次即可拿完。</p></blockquote></li><li><p>示例二</p><blockquote><p>输入：<code>[2,3,10]</code></p><p>输出：<code>8</code></p></blockquote></li><li><p>限制</p><blockquote><p><code>1 &lt;= n &lt;= 4</code><br><code>1 &lt;= coins[i] &lt;= 10</code></p></blockquote></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCount</span><span class="params">(self, coins: List[int])</span> -&gt; int:</span></span><br><span class="line">        count = <span class="number">0</span>       </span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">if</span> coin &lt;= <span class="number">2</span>:</span><br><span class="line">                count += <span class="number">1</span>     </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">while</span> coin &gt; <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">if</span> coin - <span class="number">2</span> &gt;= <span class="number">0</span>:</span><br><span class="line">                        coin -= <span class="number">2</span></span><br><span class="line">                        count += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        coin -= <span class="number">1</span></span><br><span class="line">                        count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><ul><li>实际上，代码还可以优化</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCount</span><span class="params">(self, coins: List[int])</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            res += (coin+<span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><br><br><h3 id="传递信息"><a href="#传递信息" class="headerlink" title="传递信息"></a>传递信息</h3><p>小朋友 A 在和 ta 的小伙伴们玩传信息游戏，游戏规则如下：</p><ol><li>有 n 名玩家，所有玩家编号分别为 0 ～ n-1，其中小朋友 A 的编号为 0</li><li>每个玩家都有固定的若干个可传信息的其他玩家（也可能没有）。传信息的关系是单向的（比如 A 可以向 B 传信息，但 B 不能向 A 传信息）。</li><li>每轮信息必须需要传递给另一个人，且信息可重复经过同一个人</li></ol><p>给定总玩家数 <code>n</code>，以及按 <code>[玩家编号,对应可传递玩家编号]</code> 关系组成的二维数组 <code>relation</code>。返回信息从小 A (编号 0 ) 经过 <code>k</code> 轮传递到编号为 n-1 的小伙伴处的方案数；若不能到达，返回 0。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：<code>n = 5, relation = [[0,2],[2,1],[3,4],[2,3],[1,4],[2,0],[0,4]], k = 3</code></p><p>输出：<code>3</code></p><p>解释：信息从小 A 编号 0 处开始，经 3 轮传递，到达编号 4。共有 3 种方案，分别是 0-&gt;2-&gt;0-&gt;4， 0-&gt;2-&gt;1-&gt;4， 0-&gt;2-&gt;3-&gt;4。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：<code>n = 3, relation = [[0,2],[2,1]], k = 2</code></p><p>输出：<code>0</code></p><p>解释：信息不能从小 A 处经过 2 轮传递到编号 2</p></blockquote><p><strong>限制：</strong></p><ul><li><code>2 &lt;= n &lt;= 10</code></li><li><code>1 &lt;= k &lt;= 5</code></li><li><code>1 &lt;= relation.length &lt;= 90, 且 relation[i].length == 2</code></li><li><code>0 &lt;= relation[i][0],relation[i][1] &lt; n 且 relation[i][0] != relation[i][1]</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numWays</span><span class="params">(self, n: int, r: List[List[int]], k: int)</span> -&gt; int:</span></span><br><span class="line">        now = [<span class="number">1</span>]+[<span class="number">0</span>]*(n<span class="number">-1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            snow = [<span class="number">0</span>]*n</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> r:</span><br><span class="line">                a, b = x[<span class="number">0</span>], x[<span class="number">1</span>]</span><br><span class="line">                snow[b] += now[a]</span><br><span class="line">            now = snow</span><br><span class="line">        <span class="keyword">return</span> now[n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><br><br><h3 id="剧情触发时间"><a href="#剧情触发时间" class="headerlink" title="剧情触发时间"></a>剧情触发时间</h3><p>在战略游戏中，玩家往往需要发展自己的势力来触发各种新的剧情。一个势力的主要属性有三种，分别是文明等级（<code>C</code>），资源储备（<code>R</code>）以及人口数量（<code>H</code>）。在游戏开始时（第 0 天），三种属性的值均为 0。</p><p>随着游戏进程的进行，每一天玩家的三种属性都会对应<strong>增加</strong>，我们用一个二维数组 <code>increase</code> 来表示每天的增加情况。这个二维数组的每个元素是一个长度为 3 的一维数组，例如 <code>[[1,2,1],[3,4,2]]</code> 表示第一天三种属性分别增加 <code>1,2,1</code> 而第二天分别增加 <code>3,4,2</code>。</p><p>所有剧情的触发条件也用一个二维数组 <code>requirements</code> 表示。这个二维数组的每个元素是一个长度为 3 的一维数组，对于某个剧情的触发条件 <code>c[i], r[i], h[i]</code>，如果当前 <code>C &gt;= c[i]</code> 且 <code>R &gt;= r[i]</code> 且 <code>H &gt;= h[i]</code> ，则剧情会被触发。</p><p>根据所给信息，请计算每个剧情的触发时间，并以一个数组返回。如果某个剧情不会被触发，则该剧情对应的触发时间为 -1 。</p><p><strong>示例 1：</strong></p><blockquote><p>输入： <code>increase = [[2,8,4],[2,5,0],[10,9,8]]</code> <code>requirements = [[2,11,3],[15,10,7],[9,17,12],[8,1,14]]</code></p><p>输出: <code>[2,-1,3,-1]</code></p><p>解释：</p><p>初始时，C = 0，R = 0，H = 0</p><p>第 1 天，C = 2，R = 8，H = 4</p><p>第 2 天，C = 4，R = 13，H = 4，此时触发剧情 0</p><p>第 3 天，C = 14，R = 22，H = 12，此时触发剧情 2</p><p>剧情 1 和 3 无法触发。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入： <code>increase = [[0,4,5],[4,8,8],[8,6,1],[10,10,0]]</code> <code>requirements = [[12,11,16],[20,2,6],[9,2,6],[10,18,3],[8,14,9]]</code></p><p>输出: <code>[-1,4,3,3,3]</code></p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入： <code>increase = [[1,1,1]]</code> <code>requirements = [[0,0,0]]</code></p><p>输出: <code>[0]</code></p></blockquote><p><strong>限制：</strong></p><ul><li><code>1 &lt;= increase.length &lt;= 10000</code></li><li><code>1 &lt;= requirements.length &lt;= 100000</code></li><li><code>0 &lt;= increase[i] &lt;= 10</code></li><li><code>0 &lt;= requirements[i] &lt;= 100000</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><br><br><h3 id="最小跳跃次数"><a href="#最小跳跃次数" class="headerlink" title="最小跳跃次数"></a>最小跳跃次数</h3><p>为了给刷题的同学一些奖励，力扣团队引入了一个弹簧游戏机。游戏机由 <code>N</code> 个特殊弹簧排成一排，编号为 <code>0</code> 到 <code>N-1</code>。初始有一个小球在编号 <code>0</code> 的弹簧处。若小球在编号为 <code>i</code> 的弹簧处，通过按动弹簧，可以选择把小球向右弹射 <code>jump[i]</code> 的距离，或者向左弹射到任意左侧弹簧的位置。也就是说，在编号为 <code>i</code> 弹簧处按动弹簧，小球可以弹向 <code>0</code> 到 <code>i-1</code> 中任意弹簧或者 <code>i+jump[i]</code> 的弹簧（若 <code>i+jump[i]&gt;=N</code> ，则表示小球弹出了机器）。小球位于编号 0 处的弹簧时不能再向左弹。</p><p>为了获得奖励，你需要将小球弹出机器。请求出最少需要按动多少次弹簧，可以将小球从编号 <code>0</code> 弹簧弹出整个机器，即向右越过编号 <code>N-1</code> 的弹簧。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：<code>jump = [2, 5, 1, 1, 1, 1]</code></p><p>输出：<code>3</code></p><p>解释：小 Z 最少需要按动 3 次弹簧，小球依次到达的顺序为 0 -&gt; 2 -&gt; 1 -&gt; 6，最终小球弹出了机器。</p></blockquote><p><strong>限制：</strong></p><ul><li><code>1 &lt;= jump.length &lt;= 10^6</code></li><li><code>1 &lt;= jump[i] &lt;= 10000</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque <span class="comment"># append(left), pop(left), extend</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minJump</span><span class="params">(self, s: List[int])</span> -&gt; int:</span></span><br><span class="line">        mi = <span class="number">1</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        dp = [<span class="number">0</span>]*(n<span class="number">-1</span>)+[<span class="number">1</span>]</span><br><span class="line">        st = deque([(<span class="number">1</span>, n<span class="number">-1</span>), (<span class="number">0</span>, n)])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> i + s[i] &gt;= n:</span><br><span class="line">                dp[i] = <span class="number">1</span></span><br><span class="line">                st = deque([(<span class="number">1</span>, i), (<span class="number">0</span>, n)])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                x = i+s[i]</span><br><span class="line">                l, r = <span class="number">0</span>, len(st)<span class="number">-1</span></span><br><span class="line">                <span class="keyword">while</span> l+<span class="number">1</span>&lt;r:</span><br><span class="line">                    mi = (l+r)//<span class="number">2</span></span><br><span class="line">                    <span class="keyword">if</span> st[mi][<span class="number">1</span>] &gt; x:</span><br><span class="line">                        r = mi</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        l = mi</span><br><span class="line">                now = min(dp[x], st[l][<span class="number">0</span>]+<span class="number">1</span>) + <span class="number">1</span></span><br><span class="line">                dp[i]=now</span><br><span class="line">                <span class="keyword">while</span> st[<span class="number">0</span>][<span class="number">0</span>]&gt;dp[i]:</span><br><span class="line">                    st.popleft()</span><br><span class="line">                st.appendleft((dp[i], i))</span><br><span class="line">        print(dp)</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><br><br><h3 id="二叉树任务调度"><a href="#二叉树任务调度" class="headerlink" title="二叉树任务调度"></a>二叉树任务调度</h3><p>任务调度优化是计算机性能优化的关键任务之一。在任务众多时，不同的调度策略可能会得到不同的总体执行时间，因此寻求一个最优的调度方案是非常有必要的。</p><p>通常任务之间是存在依赖关系的，即对于某个任务，你需要先<strong>完成</strong>他的前导任务（如果非空），才能开始执行该任务。<strong>我们保证任务的依赖关系是一棵二叉树，</strong>其中 <code>root</code> 为根任务，<code>root.left</code> 和 <code>root.right</code> 为他的两个前导任务（可能为空），<code>root.val</code> 为其自身的执行时间。</p><p>在一个 CPU 核执行某个任务时，我们可以在任何时刻暂停当前任务的执行，并保留当前执行进度。在下次继续执行该任务时，会从之前停留的进度开始继续执行。暂停的时间可以不是整数。</p><p>现在，系统有<strong>两个</strong> CPU 核，即我们可以同时执行两个任务，但是同一个任务不能同时在两个核上执行。给定这颗任务树，请求出所有任务执行完毕的最小时间。</p><p><strong>示例 1：</strong></p><blockquote><img src="/.top//ZivBlog\source\_posts\记一次Leetcode春季编程大赛\1.png" alt="image.png" style="zoom:70%;"><p>输入：root = [47, 74, 31]</p><p>输出：121</p><p>解释：根节点的左右节点可以并行执行31分钟，剩下的43+47分钟只能串行执行，因此总体执行时间是121分钟。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><img src="/.top//ZivBlog\source\_posts\记一次Leetcode春季编程大赛\2.png" alt="image.png" style="zoom:70%;"><p>输入：root = [15, 21, null, 24, null, 27, 26]</p><p>输出：87</p></blockquote><p><strong>示例 3：</strong></p><blockquote><img src="/.top//3.png" alt="image.png" style="zoom:70%;"><p>输入：root = [1,3,2,null,null,4,4]</p><p>输出：7.5</p></blockquote><p><strong>限制：</strong></p><ul><li><code>1 &lt;= 节点数量 &lt;= 1000</code></li><li><code>1 &lt;= 单节点执行时间 &lt;= 1000</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimalExecTime</span><span class="params">(self, root: TreeNode)</span> -&gt; float:</span></span><br><span class="line">        <span class="comment"># def visit(node=root) :</span></span><br><span class="line">        <span class="comment">#     if node is None :</span></span><br><span class="line">        <span class="comment">#         return 0</span></span><br><span class="line">        <span class="comment">#     node.sum = visit(node.left)+visit(node.right)+node.val</span></span><br><span class="line">        <span class="comment">#     return node.sum</span></span><br><span class="line">        <span class="comment"># visit()</span></span><br><span class="line">            </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">get_value</span><span class="params">(node=root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> node.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> node.val, node.val</span><br><span class="line">            <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="literal">None</span> :</span><br><span class="line">                minv, maxv = get_value(node.right)</span><br><span class="line">                <span class="keyword">return</span> minv+node.val, maxv+node.val</span><br><span class="line">            <span class="keyword">if</span> node.right <span class="keyword">is</span> <span class="literal">None</span> :</span><br><span class="line">                minv, maxv = get_value(node.left)</span><br><span class="line">                <span class="keyword">return</span> minv+node.val, maxv+node.val</span><br><span class="line">            </span><br><span class="line">            minv_left,  maxv_left  = get_value(node.left)</span><br><span class="line">            minv_right, maxv_right = get_value(node.right)</span><br><span class="line">            </span><br><span class="line">            maxv = maxv_left+maxv_right+node.val</span><br><span class="line">            <span class="keyword">if</span> minv_right &gt; maxv_left :</span><br><span class="line">                minv = minv_right-maxv_left</span><br><span class="line">            <span class="keyword">elif</span> minv_left &gt; maxv_right :</span><br><span class="line">                minv = minv_left - maxv_right</span><br><span class="line">            <span class="keyword">else</span> :</span><br><span class="line">                minv = <span class="number">0.</span></span><br><span class="line">            <span class="keyword">return</span> minv+node.val, maxv</span><br><span class="line">        </span><br><span class="line">        minv, maxv = get_value()</span><br><span class="line">        <span class="keyword">return</span> (maxv+minv)/<span class="number">2</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之数字范围按位与</title>
      <link href="/passages/leetcode-zhi-shu-zi-fan-wei-an-wei-yu/"/>
      <url>/passages/leetcode-zhi-shu-zi-fan-wei-an-wei-yu/</url>
      
        <content type="html"><![CDATA[<p>Bitwise AND of Numbers Range</p><a id="more"></a><h3 id="Bitwise-AND-of-Numbers-Range"><a href="#Bitwise-AND-of-Numbers-Range" class="headerlink" title="Bitwise AND of Numbers Range"></a>Bitwise AND of Numbers Range</h3><ul><li>code with Python</li><li>title number：201</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定范围<code>[m, n]</code>，其中<code>0 &lt;= m &lt;= n &lt;= 2147483647</code></li><li>返回此范围内所有的数字的按位与（包含两个端点<code>m</code>，<code>n</code>）</li><li>解释：范围内所有的数字依次进行<strong>按位与</strong>运算</li><li>例如：<code>[5, 7]</code>，即<code>5 &amp; 6 &amp; 7=4</code>，返回4</li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li><p>最直接的想法就是<strong>遍历区间范围内的所有数字，依次进行与运算</strong></p></li><li><p>但是这种方式的<strong>时间复杂度太高</strong>，我们需要通过观察发现某种<strong>规律</strong></p></li><li><p>先看上面的例子：<code>[5, 7]</code>，转化为二进制为：</p><ul><li><code>101, 110, 111</code>，结果是<code>1</code></li></ul></li><li><p>来看一个例子：<code>[7, 8]</code>，转化为二进制为：</p><ul><li><code>111, 1000</code>，结果为<code>0</code></li><li>可以发现，<strong>当<code>m</code>的位数大于<code>n</code>的位数时，结果必定为<code>0</code></strong></li></ul></li><li><p>接下来看一个区间内数字的二进制位数都相同的情况，<code>[20, 23]</code></p><ul><li><code>10100, 10101, 10110, 10111</code>，结果为<code>16 -&gt; 10000</code></li><li>对<code>m</code>和<code>n</code>做差，<code>23-20=3 -&gt; 100</code>，即从<code>20</code>到<code>23</code>的过程中要加三次<code>1</code>，所以倒数第一位或倒数第二位必定会有<code>0</code>，那么后两位相与必定为<code>0</code>。更进一步，倒数第三位只存在两种情况，原来为<code>0</code>变为<code>1</code>，或原来为<code>1</code>变为<code>0</code>，这样来说，相与也必定是<code>0</code></li><li>所以，<strong>结果的后bin(n-m)位必定为0</strong></li></ul></li><li><p>仍是上面的例子，我们现在已经知道了结果的位数，和后<code>bin(m-n)</code>位的情况，现在只需要确定前几位的情况即可。</p></li><li><p>而在区间内所有数字位数确定的情况下，并不会有对最高位的进位</p></li><li><p>也就是前<code>len(bin(n))-len(bin(n-m))</code>位的结果等于<code>m &amp; n</code>的前<code>len(bin(n))-len(bin(n-m))</code>的结果</p></li><li><p>总结一下</p><ul><li>如果<code>bin(n) &gt; bin(m)</code>，解果为<code>0</code></li><li>计算<code>bin(n-m)</code>的位数<code>len_sub</code></li><li>计算<code>n &amp; m</code>的结果</li><li>将<code>n &amp; m</code>后<code>bin(n-m)</code>位替换为0即可，或者说是将<code>n &amp; m</code>结果的前<code>len(n)-len_sub</code>位和<code>len_sub</code>个<code>0</code>相加即为结果</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rangeBitwiseAnd</span><span class="params">(self, m: int, n: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> len(bin(n)) &gt; len(bin(m)):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> m == n:</span><br><span class="line">        <span class="keyword">return</span> m</span><br><span class="line">    sub = len(bin(n-m)[<span class="number">2</span>:])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> int(bin(m&amp;n)[<span class="number">2</span>: -sub] + <span class="string">'0'</span>*sub, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><ul><li>可能描述的并不是很容易理解，有疑问可以<strong>邮件问我</strong>或者<strong>看官网题解区的帖子</strong></li></ul><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li>只需查找这个区间数字的第<code>i</code>位全为<code>1</code>，那么结构一定是前<code>i</code>位</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rangeBitwiseAnd</span><span class="params">(self, m: int, n: int)</span> -&gt; int:</span></span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> m != n:</span><br><span class="line">        m &gt;&gt;= <span class="number">1</span></span><br><span class="line">        n &gt;&gt;= <span class="number">1</span></span><br><span class="line">        cnt += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> m &lt;&lt; cnt</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之岛屿数量</title>
      <link href="/passages/leetcode-zhi-dao-yu-shu-liang/"/>
      <url>/passages/leetcode-zhi-dao-yu-shu-liang/</url>
      
        <content type="html"><![CDATA[<p>Number of Islands</p><a id="more"></a><h3 id="Number-of-Islands"><a href="#Number-of-Islands" class="headerlink" title="Number of Islands"></a>Number of Islands</h3><ul><li>code with Python</li><li>title number：200</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个有<code>1</code>（陆地）和<code>0</code>（水）组成的二维网格，计算其中岛屿的数量</li><li>岛屿：<ul><li>被水包围</li><li>通过水平或垂直方向上相邻的陆地连接而成</li><li>可以认为给定网格的四个边均被水包围</li></ul></li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li><p>连通区域问题，可参考<a href="http://www.zivblog.top/passages/leetcode-zhi-bei-wei-rao-de-qu-yu/" target="_blank" rel="noopener">被围绕的区域</a></p></li><li><p>双循环查找起始位置，对于为1的位置使用<strong>DFS</strong>进行搜索</p></li><li><p>已访问位置需要标记，由于不同岛屿之间无关，可以直接将已经访问过的位置置为<code>0</code></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numIslands</span><span class="params">(self, grid: List[List[str]])</span> -&gt; int:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(grid, i, j)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> grid[i][j] != <span class="string">'1'</span> <span class="keyword">or</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= len(grid) <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> j &gt;= len(grid[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        dfs(grid, i, j+<span class="number">1</span>)</span><br><span class="line">        dfs(grid, i. j<span class="number">-1</span>)</span><br><span class="line">        dfs(grid, i+<span class="number">1</span>, j)</span><br><span class="line">        dfs(grid, i<span class="number">-1</span>, j)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> grid:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(grid)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(grid[<span class="number">0</span>])):</span><br><span class="line">            <span class="keyword">if</span> grid[i][j] == <span class="string">'1'</span>:</span><br><span class="line">                dfs(grid, i, j)</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周知识总结（4.13~4.19）</title>
      <link href="/passages/zhou-zhi-shi-zong-jie-4-13-4-19/"/>
      <url>/passages/zhou-zhi-shi-zong-jie-4-13-4-19/</url>
      
        <content type="html"><![CDATA[<p>周知识总结</p><a id="more"></a><h3 id="4月13日"><a href="#4月13日" class="headerlink" title="4月13日"></a>4月13日</h3><h4 id="试简述Adaboost算法？"><a href="#试简述Adaboost算法？" class="headerlink" title="试简述Adaboost算法？"></a>试简述Adaboost算法？</h4><ul><li><p>Boosting类算法包含两个基本问题：</p><ul><li>每一轮如何改变数据的权值或概率分布？</li><li>如何将若分类器合成一个强分类器？</li></ul></li><li><p>针对两个问题，Adaboost有自己的解决方案：</p></li><li><p>每一轮如何改变数据权值或概率分布？</p><ul><li>一开始，每个样本的权值是一样的，在每一轮开始时，<strong>提高上一轮弱分类器错误分类样本的权值</strong>，同时<strong>降低那些被正确分类样本的权值</strong></li></ul></li><li><p>如何将弱分类器组合成一个强分类器？</p><ul><li>Adaboost采用加权表决的方式。</li><li><strong>加大分类错误率小的基学习器的权值</strong>，使其在表决中起到更大的作用，同时<strong>减小分类错误率大的基学习器的权值</strong></li></ul></li><li><p>总得来说，Adaboost的一大特点是：</p><ul><li>不改变数据，通过<strong>不断改变数据权值的分布</strong>，使数据在基学习器的学习中骐达不同的作用</li></ul></li></ul><br><br><h3 id="4月14日"><a href="#4月14日" class="headerlink" title="4月14日"></a>4月14日</h3><h4 id="试简述梯度提升决策树GBDT？"><a href="#试简述梯度提升决策树GBDT？" class="headerlink" title="试简述梯度提升决策树GBDT？"></a>试简述梯度提升决策树GBDT？</h4><ul><li>GBDT是以决策树为基学习器，采用Boosting策略的一种集成学习模型</li><li>与提升树的区别：<ul><li>残差的计算不同，提升树使用的是真正的残差，梯度提升树用当前模型的负梯度来模拟残差</li></ul></li></ul><br><h4 id="提升树（Boosting-Tree）"><a href="#提升树（Boosting-Tree）" class="headerlink" title="提升树（Boosting Tree）"></a>提升树（Boosting Tree）</h4><ul><li><p>以决策树为基学习器，对分类问题使用二叉分类树，对回归问题使用二叉回归树</p></li><li><p>解决回归问题时，通过不断拟合残差得到新的树</p></li><li><p>提升树模型可表示为决策树的加法模型：<br>$$<br>f_M(x)=\sum_{m=1}^MT(x;\Theta_m)<br>$$</p></li><li><p>首先初始化提升树 <code>f_0(x)=0</code>，则第 m 步的模型为<br>$$<br>f_m(x)=f_{m-1}(x)+T(x;\Theta_m)<br>$$</p></li><li><p>然后通过最小化损失函数决定下一个决策树的参数<br>$$<br>\hat{\Theta}<em>m=\arg \underset{\Theta_m}{min} \sum</em>{i=1}^NL(y_i, f_{m-1}(x_i) + T(x_i; \Theta_m))<br>$$</p></li></ul><br><h4 id="梯度提升算法"><a href="#梯度提升算法" class="headerlink" title="梯度提升算法"></a>梯度提升算法</h4><ul><li>当损失函数为平方损失或指数损失时，每一步的优化是很直观的；但对于一般的损失函数而言，不太容易——梯度提升正是针对这一问题提出的算法；</li><li>梯度提升是梯度下降的近似方法，其关键是利用损失函数的<strong>负梯度作为残差的近似值</strong>，来拟合下一个决策树。</li></ul><br><br><h3 id="4月15日"><a href="#4月15日" class="headerlink" title="4月15日"></a>4月15日</h3><h4 id="梯度提升树（GBDT）"><a href="#梯度提升树（GBDT）" class="headerlink" title="梯度提升树（GBDT）"></a>梯度提升树（GBDT）</h4><ul><li><p>GBDT的核心在于：<strong>每一棵树学的是之前所有树结论和的残差</strong>，这个残差就是一个加预测值后能得真实值的累加量</p></li><li><p>首先这是个迭代算法，每一轮迭代，把当前所有学习器的<strong>加权平均</strong>结果作为这一轮的函数值，然后求得针对某一个损失函数对于当前所有学习器的参数的一个<strong>梯度</strong>，然后利用某个弱学习器（LR，Logistic LR等）算法来拟合这个梯度，最后，利用查找的方式找到<strong>权重</strong>。其实，就是利用简单模型拟合不同迭代轮数的梯度。</p></li><li><p>梯度增强可跟梯度下降对比，梯度下降的最终预测式也可写成加和的形式，每一轮梯度的值和学习率共同叠加形成最终结果。这和构造弱学习器的加权平均联系起来看，每个梯度的值可以认为是个弱学习器，<strong>学习速率就是权重</strong>。</p></li><li><p>理解了梯度增强，梯度增强决策树就容易理解了，就是<strong>用决策树来当作弱学习器</strong>，去<strong>拟合梯度增强过程中的梯度</strong>。然后融合到整个梯度增强的过程中。</p></li><li><p>最终，<strong>梯度增强决策树就是每一轮迭代都拟合一个新的决策树</strong>，来表达当前的梯度，然后跟前面所有的决策树进行叠加。</p></li></ul><br><br><h3 id="4月16日"><a href="#4月16日" class="headerlink" title="4月16日"></a>4月16日</h3><h4 id="试简述ReLU相比Sigmoid的优势？"><a href="#试简述ReLU相比Sigmoid的优势？" class="headerlink" title="试简述ReLU相比Sigmoid的优势？"></a>试简述ReLU相比Sigmoid的优势？</h4><ul><li><strong>避免梯度消失</strong><ul><li><code>sigmoid</code>函数在输入取绝对值非常大的正值或负值时会出现<strong>饱和</strong>现象——在图像上表现为变得很平，此时函数会对输入的微小变化不敏感——从而造成梯度消失；</li><li><code>ReLU</code> 的导数始终是一个常数——负半区为 0，正半区为 1——所以不会发生梯度消失现象</li></ul></li><li><strong>减缓过拟合</strong><ul><li><code>ReLU</code> 在负半区的输出为 0。一旦神经元的激活值进入负半区，那么该激活值就不会产生梯度/不会被训练，造成了网络的稀疏性——<strong>稀疏激活</strong></li><li>这有助于减少参数的相互依赖，缓解过拟合问题的发生</li></ul></li><li><strong>加速计算</strong><ul><li><code>ReLU</code> 的求导不涉及浮点运算，所以速度更快</li></ul></li></ul><h3 id="4月17日"><a href="#4月17日" class="headerlink" title="4月17日"></a>4月17日</h3><h4 id="为什么-L1-和-L2-正则化可以防止过拟合？"><a href="#为什么-L1-和-L2-正则化可以防止过拟合？" class="headerlink" title="为什么 L1 和 L2 正则化可以防止过拟合？"></a>为什么 L1 和 L2 正则化可以防止过拟合？</h4><ul><li>L1 &amp; L2 正则化会使模型偏好于<strong>更小的权值</strong>。</li><li>更小的权值意味着<strong>更低的模型复杂度</strong>；添加 L1 &amp; L2 正则化相当于为模型添加了某种<strong>先验</strong>，限制了参数的分布，从而降低了模型的复杂度。</li><li>模型的复杂度降低，意味着模型对于噪声与异常点的抗干扰性的能力增强，从而提高模型的泛化能力。——直观来说，就是对训练数据的拟合刚刚好，不会过分拟合训练数据（比如异常点，噪声）——**奥卡姆剃刀原理</li></ul><h3 id="4月18日"><a href="#4月18日" class="headerlink" title="4月18日"></a>4月18日</h3><h4 id="Dropout-与-Bagging-的不同"><a href="#Dropout-与-Bagging-的不同" class="headerlink" title="Dropout 与 Bagging 的不同"></a>Dropout 与 Bagging 的不同</h4><ul><li><p>在神经网络上使用<code>Dropout</code>，相当于通过数据共享提供了一种连接的Bagging集成——在训练时随机使一些神经元失效，整个过程中相当于训练多个不同的模型；在测试时使用全部的神经元相当于一种变相的集成。</p></li><li><p>在 Bagging 的情况下，所有模型都是独立的；而在 Dropout 的情况下，所有模型<strong>共享参数</strong>，其中每个模型继承父神经网络参数的不同子集。</p></li><li><p>在 Bagging 的情况下，每一个模型都会在其相应训练集上训练到收敛。而在 Dropout 的情况下，通常大部分模型都没有显式地被训练；取而代之的是，在单个步骤中我们训练一小部分的子网络，参数共享会使得剩余的子网络也能有好的参数设定。</p></li></ul><h3 id="4月19日"><a href="#4月19日" class="headerlink" title="4月19日"></a>4月19日</h3><h4 id="正则化过程中，为何只对权重做正则惩罚，而不对偏置做权重惩罚？"><a href="#正则化过程中，为何只对权重做正则惩罚，而不对偏置做权重惩罚？" class="headerlink" title="正则化过程中，为何只对权重做正则惩罚，而不对偏置做权重惩罚？"></a>正则化过程中，为何只对权重做正则惩罚，而不对偏置做权重惩罚？</h4><ul><li>在神经网络中，参数包括每一层仿射变换的<strong>权重</strong>和<strong>偏置</strong>，我们通常只对权重做惩罚而不对偏置做正则惩罚。</li><li>精确拟合偏置所需的数据通常比拟合权重少得多。每个权重会指定两个变量如何相互作用。我们需要在各种条件下观察这两个变量才能良好地拟合权重。</li><li>而每个偏置仅控制一个单变量。这意味着，我们不对其进行正则化也不会导致太大的方差。另外，正则化偏置参数可能会导致明显的欠拟合。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 周知识总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Artificial Intelligence </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周知识总结（4.6~4.12）</title>
      <link href="/passages/zhou-zhi-shi-zong-jie-4-6-4-12/"/>
      <url>/passages/zhou-zhi-shi-zong-jie-4-6-4-12/</url>
      
        <content type="html"><![CDATA[<p>周知识总结</p><a id="more"></a><h3 id="4月6日"><a href="#4月6日" class="headerlink" title="4月6日"></a>4月6日</h3><h4 id="验证集的作用是什么？"><a href="#验证集的作用是什么？" class="headerlink" title="验证集的作用是什么？"></a>验证集的作用是什么？</h4><ul><li>防止过拟合的方法，除了加入正则化项以外，还有一种方式叫做<strong>提前停止</strong></li><li>在训练集和测试集之外，还会使用<strong>验证集</strong>来进行模型选择（验证集可以从训练数据中选择一部分）</li><li>每次迭代时，把新得到的模型在验证集上进行测试，并计算错误率。</li><li>如果在<strong>验证集</strong>上错误率不再下降，则停止迭代（即提前停止）</li></ul><br><br><h3 id="4月7日"><a href="#4月7日" class="headerlink" title="4月7日"></a>4月7日</h3><h4 id="方差与偏差的作用是什么？"><a href="#方差与偏差的作用是什么？" class="headerlink" title="方差与偏差的作用是什么？"></a>方差与偏差的作用是什么？</h4><ul><li><strong>偏差</strong>：指的是一个模型在不同训练集上的平均性能和最优性能的差异，可以用来衡量一个模型的拟合能力</li><li>偏差越大，模型的拟合能力越差</li><li><strong>方差</strong>：方差指一个模型在不同训练集上的差异，可以用来衡量一个模型是否容易过拟合</li><li>方差越大，模型越不稳定，越容易过拟合</li><li>实际操作中，利用偏差和方差来分析模型比较难于实现<ul><li>一般来说，当一个模型在训练集上错误率比较高时，认为模型拟合能力不够，<strong>偏差比较高</strong></li><li>当一个模型在训练集上错误率比较低，在验证集上错误率比较高，则说明模型过拟合，<strong>方差</strong>比较高</li></ul></li></ul><br><br><h3 id="4月8日"><a href="#4月8日" class="headerlink" title="4月8日"></a>4月8日</h3><h4 id="简述特征学习的两种方式？"><a href="#简述特征学习的两种方式？" class="headerlink" title="简述特征学习的两种方式？"></a>简述特征学习的两种方式？</h4><ul><li><p>特征学习具体来说可以分为两种：特征选择、特征抽取</p></li><li><p><strong>特征选择</strong>：是选取原始特征集中的一个有效子集，使得使用该子集训练出来的模型准确率更高</p><ul><li>一种比较直接的特征选择方法是<strong>子集搜索</strong>，即暴力尝试所有的子集在模型上的效果，选择最优的子集</li></ul></li><li><p><strong>特征抽取</strong>：构造一个新的特征空间，并将原始特征投影在新的空间中</p><ul><li>特征抽取可以分为监督和无监督的方法</li><li>监督的特征学习的目标是抽取对特定任务有效的特征，例如<strong>线性判别分析</strong></li><li>无监督的特征学习与特定任务无关，一般是为了减少冗余信息，例如<strong>主成分分析</strong></li></ul></li><li><p>总之，两者的共同目的都是使用数据中较少的特征来表示原始特征中的大部分相关信息，去掉噪声信息，并进而提高计算效率和减少维度灾难</p></li></ul><br><h4 id="多分类线性判别函数有哪些设计方法？"><a href="#多分类线性判别函数有哪些设计方法？" class="headerlink" title="多分类线性判别函数有哪些设计方法？"></a>多分类线性判别函数有哪些设计方法？</h4><ul><li><strong>“一对其余”</strong>：把<code>C</code>分类转化为多个“一对其余”的二分类问题，需要<code>C</code>个判别函数</li><li><strong>“一对一”</strong>：把<code>C</code>分类问题转化为<code>C(C-1)/2</code>个“一对一”的二分类问题，需要<code>C(C-1)/2</code>个二分类问题</li><li><strong>“<code>argmax</code>”</strong>：预测结果是一个长度为<code>C</code>的向量，选择其中数值最大的一维作为预测类别</li></ul><br><br><h3 id="4月9日"><a href="#4月9日" class="headerlink" title="4月9日"></a>4月9日</h3><h4 id="神经网络从哪两个方面模拟大脑？"><a href="#神经网络从哪两个方面模拟大脑？" class="headerlink" title="神经网络从哪两个方面模拟大脑？"></a>神经网络从哪两个方面模拟大脑？</h4><ul><li>网络获取的知识是通过学习来获取的</li><li>内部神经元的链接强度（突触权重）用于存储获取的知识</li></ul><br><h4 id="激活函数需要具备那些性质？"><a href="#激活函数需要具备那些性质？" class="headerlink" title="激活函数需要具备那些性质？"></a>激活函数需要具备那些性质？</h4><ul><li>连续并可导的非线性函数。可导的激活函数可以直接利用数值优化的方法来学习网络参数</li><li>激活函数及其导函数的值域要在一个合适的区间内，不能太大也不能太小，否则会影响训练的效率和稳定性</li><li>激活函数及其导数要尽可能的简单，有利于提高网络计算效率</li></ul><br><h4 id="常用的神经网络结构有哪些？"><a href="#常用的神经网络结构有哪些？" class="headerlink" title="常用的神经网络结构有哪些？"></a>常用的神经网络结构有哪些？</h4><ul><li><p><strong>前馈网络</strong></p><ul><li>前馈网络中各个神经元按照接受信息的先后分为不同的组，每一个组可以看作一个神经层。</li><li>每层神经元只接受前一层神经元的输出，并输出到下一层神经元，整个网络中的信息是朝一个方向传播，没有反向的信息传播。</li><li>包括：全连接前馈网络和卷积神经网络等</li></ul></li><li><p><strong>反馈网络</strong></p><ul><li>反馈网络中神经元不但可以接受其他神经元的信号，还能接收自己的反馈信号</li><li>与前馈神经元相比，，反馈网络中的神经元具有记忆功能，可以单向传播也可以双向传播</li><li>包括：循环神经网络、Hopfield网络、玻尔兹曼机等</li></ul></li><li><p><strong>图网络</strong></p><ul><li>图网络是定义在图数据结构上的神经网络，图中每个节点都是一个或一组神经元构成，每个节点可以收到来自相邻节点或自身的信息</li><li>包括：图卷积神经网络、消息传递网络（MPNN）</li></ul></li></ul><br><br><h3 id="4月10日"><a href="#4月10日" class="headerlink" title="4月10日"></a>4月10日</h3><h4 id="什么是OOV问题？"><a href="#什么是OOV问题？" class="headerlink" title="什么是OOV问题？"></a>什么是OOV问题？</h4><ul><li><code>OOV</code>即<code>Out Of Vocabulary</code>，也就是序列中出现了词表之外的词，或称为<strong>未登陆词</strong></li><li>或者说是测试集和验证集上出现了训练集中没有出现过的词</li><li>一般的解决方案：<ul><li>设置一个词频阈值，只有高于该阈值的词才会加入词表</li><li>所有低于阈值的词替换为<code>UNK</code>（特殊符号）</li></ul></li><li>在神经网络中，一般有以下几种处理<code>UNK</code>的思路<ul><li>为其分配一个随机初始化的embedding，并参与训练</li><li>把<code>UNK</code>初始化为一个全为0的向量，不参与训练</li><li>每次都把<code>UNK</code>初始化为一个新的随即向量，不参与训练</li></ul></li></ul><br><br><h3 id="4月11日"><a href="#4月11日" class="headerlink" title="4月11日"></a>4月11日</h3><h4 id="集成学习有哪些基本策略？（接3-31）"><a href="#集成学习有哪些基本策略？（接3-31）" class="headerlink" title="集成学习有哪些基本策略？（接3-31）"></a>集成学习有哪些基本策略？（接<a href="http://www.zivblog.top/passages/mei-ri-yi-wen-4-10/" target="_blank" rel="noopener">3-31</a>）</h4><ul><li><p><strong>Boosting方法</strong></p><ul><li><strong>基本思路</strong>：<ul><li>先从<strong>初始训练集</strong>训练一个基学习器；初始训练集中各样本的权重是相同的；</li><li>根据上一个基学习器的表现，<strong>调整样本权重</strong>，使分类错误的样本得到更多的关注；</li><li>基于调整后的样本分布，训练下一个基学习器；</li><li>测试时，对各基学习器<strong>加权</strong>得到最终结果</li></ul></li><li><strong>特点</strong>：<ul><li>每次学习都会使用全部训练样本<br></li></ul></li></ul></li><li><p><strong>Stacking方法</strong></p><ul><li><p>基本思路**：</p><ul><li><p>先从初始训练集训练 <code>T</code> 个<strong>不同的初级学习器</strong>;</p></li><li><p>利用每个初级学习器的<strong>输出</strong>构建一个<strong>次级数据集</strong>，该数据集依然使用初始数据集的标签；</p></li><li><p>根据新的数据集训练<strong>次级学习器</strong>；</p></li><li><p><strong>多级学习器</strong>的构建过程类似。</p><blockquote><p>周志华-《机器学习》中没有将 Stacking 方法当作一种集成策略，而是作为一种<strong>结合策略</strong>，比如<strong>加权平均</strong>和<strong>投票</strong>都属于结合策略。</p></blockquote></li></ul></li><li><p>为了降低过拟合的风险，一般会利用<strong>交叉验证</strong>的方法使不同的初级学习器在<strong>不完全相同的子集</strong>上训练</p></li></ul></li></ul><br><ul><li><p><strong>Bagging方法</strong></p><ul><li><p><strong>基本思路</strong>：</p><ul><li><p>利用<strong>自助采样法</strong>对训练集随机采样，重复进行 <code>T</code> 次;</p></li><li><p>基于每个采样集训练一个基学习器，并得到 <code>T</code> 个基学习器；</p></li><li><p>预测时，集体<strong>投票决策**</strong>。</p><blockquote><p><strong>自助采样法</strong>：对 m 个样本的训练集，有放回的采样 m 次；此时，样本在 m 次采样中始终没被采样的概率约为 <code>0.368</code>，即每次自助采样只能采样到全部样本的 <code>63%</code> 左右。</p></blockquote><p>$$<br>lim_{m-&gt;无穷}(1-\frac{1}{m})^{m} -&gt; \frac{1}{e} \approx 0.368<br>$$</p></li></ul></li><li><p><strong>特点</strong>：</p><ul><li><p>训练每个基学习器时只使用一部分样本；</p></li><li><p>偏好<strong>不稳定</strong>的学习器作为基学习器；</p><blockquote><p>所谓不稳定的学习器，指的是对<strong>样本分布</strong>较为敏感的学习器</p></blockquote></li></ul></li></ul></li></ul><br><br><h3 id="4月12日"><a href="#4月12日" class="headerlink" title="4月12日"></a>4月12日</h3><h4 id="为什么选择决策树作为集成学习的基学习器？"><a href="#为什么选择决策树作为集成学习的基学习器？" class="headerlink" title="为什么选择决策树作为集成学习的基学习器？"></a>为什么选择决策树作为集成学习的基学习器？</h4><ul><li><p>决策数的表达能力和泛化能力，可以通过剪枝来快速进行调整</p></li><li><p>决策树可以方便的将样本的权重整合到训练过程中</p></li><li><p>决策树是一种不稳定的学习器（易受样本扰动的影响）</p></li><li><p>另外，<strong>神经网络</strong>也属于不稳定的学习器，也可以作为基学习器</p></li></ul><br><h4 id="为什么不稳定的学习器更适合作为基学习器？"><a href="#为什么不稳定的学习器更适合作为基学习器？" class="headerlink" title="为什么不稳定的学习器更适合作为基学习器？"></a>为什么不稳定的学习器更适合作为基学习器？</h4><ul><li>不稳定的学习器易受样本分布的影响（方差大），很好的引入了随机性，这有助于在集成学习的时候提升模型的泛化能力</li><li>为了更好的引入随机性，有时会随机选择一个<strong>属性子集</strong>中的最优分裂属性，而不是全局最优（例如随机森林）</li></ul><br><h4 id="Bagging或Boosting中能否使用线性分类器作为基学习器？"><a href="#Bagging或Boosting中能否使用线性分类器作为基学习器？" class="headerlink" title="Bagging或Boosting中能否使用线性分类器作为基学习器？"></a>Bagging或Boosting中能否使用线性分类器作为基学习器？</h4><ul><li>Bagging中<strong>不推荐</strong>使用线性分类器作为基学习器<ul><li>线性分类器是稳定的学习器（方差小），对数据不敏感</li><li>可能因为bagging的采样，导致在训练中难以收敛，使分类器集成时偏差更大</li></ul></li><li>Boosting中<strong>可以</strong>使用线性分类器作为基学习器<ul><li>Boosting主要通过降低<strong>偏差</strong>来提升模型的性能，而线性分类器本身方差小，二者具有一定的相性（更合适）</li><li>XGBoost中就支持用线性分类器作为基学习器</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 周知识总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Artificial Intelligence </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周知识总结（3.30~4.5）</title>
      <link href="/passages/zhou-zhi-shi-zong-jie-3-30-4-5/"/>
      <url>/passages/zhou-zhi-shi-zong-jie-3-30-4-5/</url>
      
        <content type="html"><![CDATA[<p>周知识总结</p><a id="more"></a><h3 id="3月30日"><a href="#3月30日" class="headerlink" title="3月30日"></a>3月30日</h3><h4 id="强化学习的主要特点？"><a href="#强化学习的主要特点？" class="headerlink" title="强化学习的主要特点？"></a>强化学习的主要特点？</h4><ul><li>强化学习的学习器并不是学习怎样做，而是在尝试的过程中学习到在特定的情境下选择哪种行动可以得到最大的回报</li><li>主要包含四个元素：agent、环境状态、行动、奖励</li><li>强化学习的三个重要特点如下：<ul><li>基本是以闭环的形式</li><li>不会直接指示选择哪种行动</li><li>一系列的action和reward会影响之后较长的时间</li></ul></li></ul><br><h4 id="强化学习与监督学习的区别？"><a href="#强化学习与监督学习的区别？" class="headerlink" title="强化学习与监督学习的区别？"></a>强化学习与监督学习的区别？</h4><ul><li>监督学习实在标签的指导下，学习一个输入与输出之间的映射关系</li><li>强化学习在没有任何标签的情况下，先尝试做一些行为得到一个结果，通过这个结果是对的还是错的的反馈，调整之前的行为</li></ul><br><h4 id="强化学习与无监督学习的区别？"><a href="#强化学习与无监督学习的区别？" class="headerlink" title="强化学习与无监督学习的区别？"></a>强化学习与无监督学习的区别？</h4><ul><li>无监督学习通过对没有标签的训练数据进行学习，发现训练数据中隐藏的结构性知识，即一种模式</li><li>强化学习并没有明确数据概念，它并不知道结果，只有目标，即学习到从状态到行动的映射</li></ul><br><br><h3 id="3月31日"><a href="#3月31日" class="headerlink" title="3月31日"></a>3月31日</h3><h4 id="集成学习为什么会有效？"><a href="#集成学习为什么会有效？" class="headerlink" title="集成学习为什么会有效？"></a>集成学习为什么会有效？</h4><ul><li>不同的模型通常会在<strong>测试集</strong>上产生不同的误差；如果成员的误差是独立的，集成模型将显著地比其成员表现更好</li></ul><br><h4 id="集成学习有哪些基本策略？"><a href="#集成学习有哪些基本策略？" class="headerlink" title="集成学习有哪些基本策略？"></a>集成学习有哪些基本策略？</h4><ul><li><strong>Boosting方法</strong><ul><li>基于<strong>串行策略</strong>：基学习器之间存在依赖关系，新的学习器需要根据上一个学习器生成。</li></ul></li><li><strong>Stacking方法</strong><ul><li>基于<strong>并行策略</strong>：基学习器之间不存在依赖关系，可同时生成。</li></ul></li><li><strong>Bagging方法</strong><ul><li>基于<strong>串行策略</strong>：初级学习器与次级学习器之间存在依赖关系，初学习器的输出作为次级学习器的输入。</li></ul></li></ul><br><br><h3 id="4月1日"><a href="#4月1日" class="headerlink" title="4月1日"></a>4月1日</h3><h4 id="为什么需要迁移学习？"><a href="#为什么需要迁移学习？" class="headerlink" title="为什么需要迁移学习？"></a>为什么需要迁移学习？</h4><ul><li><p><strong>大数据与少标注的矛盾</strong>：虽然有大量的数据，但往往都是没有标注的，无法训练机器学习模型。人工进行数据标定太耗时</p></li><li><p><strong>大数据与弱计算的矛盾</strong>：普通人无法拥有庞大的数据量与计算资源。因此需要借助于模型的迁移</p></li><li><p><strong>普适化模型与个性化需求的矛盾</strong>：即使是在同一个任务上，一个模型也往往难以满足每个人的个性化需求，比如特定的隐私设置。这就需要在不同人之间做模型的适配</p></li><li><p><strong>特定应用（如冷启动）的需求</strong></p></li></ul><br><h4 id="迁移学习与传统机器学习有什么区别？"><a href="#迁移学习与传统机器学习有什么区别？" class="headerlink" title="迁移学习与传统机器学习有什么区别？"></a>迁移学习与传统机器学习有什么区别？</h4><table><thead><tr><th></th><th>迁移学习</th><th>传统机器学习</th></tr></thead><tbody><tr><td>数据分布</td><td>训练和测试数据不需要同分布</td><td>训练和测试数据同分布</td></tr><tr><td>数据标签</td><td>不需要足够的数据标注</td><td>足够的数据标注</td></tr><tr><td>建模</td><td>可以重用之前的模型</td><td>每个任务分别建模</td></tr></tbody></table><br><h4 id="迁移学习的基本思路有哪些？"><a href="#迁移学习的基本思路有哪些？" class="headerlink" title="迁移学习的基本思路有哪些？"></a>迁移学习的基本思路有哪些？</h4><ul><li><p><strong>基于样本迁移</strong></p><ul><li>根据一定的权重生成规则，对数据样本进行重用，来进行迁移学习</li></ul></li><li><p><strong>基于特征迁移</strong></p><ul><li>将通过特征变换的方式互相迁移，来减少源域与目标域之间的差距；或者将源域和目标域的数据特征变换到同一特征空间中</li></ul></li><li><p><strong>基于模型迁移</strong></p><ul><li>从源域和目标域中找到他们之间共享的参数信息,以实现迁移的方法</li></ul></li><li><p><strong>基于关系迁移</strong></p><ul><li>比较关注源域和目标域的样本之间的关系</li><li>如下图</li></ul><img src="/.top//1.jpg" style="zoom:35%;"></li></ul><br><br><h3 id="4月2日"><a href="#4月2日" class="headerlink" title="4月2日"></a>4月2日</h3><h4 id="简要描述先验概率和后验概率"><a href="#简要描述先验概率和后验概率" class="headerlink" title="简要描述先验概率和后验概率"></a>简要描述先验概率和后验概率</h4><ul><li><p>首先说明一下<strong>条件概率</strong>（似然概率）</p><ul><li>一个事件发生后另一个事件发生的概率</li><li>一般形式为<code>P(X|Y)</code>，表示事件<code>Y</code>发生的条件下事件<code>X</code>发生的概率</li></ul></li><li><p><strong>先验概率</strong></p><ul><li>事件发生前的预判概率</li><li>可以是基于历史数据的统计，可以由背景常识得出，也可以是人的主观观点给出。</li><li>一般都是<strong>单独事件</strong>发生的概率，如 <code>P(A)</code>、<code>P(B)</code>。</li></ul></li><li><p><strong>后验概率</strong></p><ul><li><p>基于先验概率求得的<strong>反向条件概率</strong>，形式上与条件概率相同（若 <code>P(X|Y)</code> 为正向，则 <code>P(Y|X)</code> 为反向）</p></li><li><p>贝叶斯公式如下<br>$$<br>P(Y|X) = \frac{P(X|Y)<em>P(Y)}{P(X)}P(Y|X) = \frac{P(X|Y)</em>P(Y)}{P(X)}<br>$$</p></li></ul></li></ul><br><br><h3 id="4月3日"><a href="#4月3日" class="headerlink" title="4月3日"></a>4月3日</h3><h4 id="简要描述熵、联合熵、条件熵、相对熵、交叉熵的作用"><a href="#简要描述熵、联合熵、条件熵、相对熵、交叉熵的作用" class="headerlink" title="简要描述熵、联合熵、条件熵、相对熵、交叉熵的作用"></a>简要描述熵、联合熵、条件熵、相对熵、交叉熵的作用</h4><ul><li><p><strong>熵</strong>：描述一个随机变量的不确定程度，不确定程度越大熵越大</p></li><li><p><strong>联合熵</strong>：描述一对随机变量平均所需要的信息量</p></li><li><p><strong>条件熵</strong>：已知随机变量X的条件下描述随机变量Y所需的信息量</p></li><li><p><strong>相对熵</strong>：衡量两个随机分布的差距（当两个分布相同时，相对熵为0）</p></li><li><p><strong>交叉熵</strong>：衡量估计模型与真实概率分布之间的差异（设计模型时我们希望交叉熵为0）</p><img src="/.top//2.png" style="zoom:50%;"></li></ul><br><h4 id="什么是互信息，互信息有什么作用？"><a href="#什么是互信息，互信息有什么作用？" class="headerlink" title="什么是互信息，互信息有什么作用？"></a>什么是互信息，互信息有什么作用？</h4><ul><li>互信息<code>I(X; Y)</code>表示在知道<code>Y</code>的情况下<code>X</code>不确定性的减少量，即<code>Y</code>透露了多少关于<code>X</code>的信息量</li><li>互信息值越大，表示两个汉字之间的结合越紧密，越有可能成词</li></ul><br><br><h3 id="4月4日"><a href="#4月4日" class="headerlink" title="4月4日"></a>4月4日</h3><h4 id="深度学习、神经网络、机器学习之间的关系"><a href="#深度学习、神经网络、机器学习之间的关系" class="headerlink" title="深度学习、神经网络、机器学习之间的关系"></a>深度学习、神经网络、机器学习之间的关系</h4><ul><li>首先，<strong>深度学习问题是机器学习问题的一种</strong>，指从有限样例中，通过算法总结出一般性的规律，并可以应用到新的位置数据上</li><li>其次，和传统的机器学习不同，深度学习采用的模型一般比较复杂。</li><li>神经网络是深度学习中比较常用的模型，因为它比较好的解决了贡献度分配问题（即各个组件的贡献度问题）</li><li>深度学习和神经网络并不等价，深度学习可以使用神经网络，也可以使用其他模型（例如深度信念网络，是一种概率图模型）</li></ul><br><br><h3 id="4月5日"><a href="#4月5日" class="headerlink" title="4月5日"></a>4月5日</h3><h4 id="模型中加入正则化项的目的是什么？"><a href="#模型中加入正则化项的目的是什么？" class="headerlink" title="模型中加入正则化项的目的是什么？"></a>模型中加入正则化项的目的是什么？</h4><ul><li>一个好的模型应当有一个比较小的期望错误，但由于不知道真实的数据分布和映射函数，实际上无法计算期望风险。</li><li>所以我们只能通过在给定训练集上计算<strong>经验风险</strong>（即训练集上的平均损失），来得到一个比较好的模型。</li><li>由于训练数据少或噪声或模型能力强等原因，容易造成模型在其他数据集上的泛化能力不强，即过拟合。</li><li>引入正则化项的目的是<strong>限制模型的能力</strong>，使其不要过度地最小化经验风险，从而一定程度上避免过拟合。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 周知识总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Artificial Intelligence </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周知识总结（3.23~3.29）</title>
      <link href="/passages/zhou-zhi-shi-zong-jie-3-23-3-29/"/>
      <url>/passages/zhou-zhi-shi-zong-jie-3-23-3-29/</url>
      
        <content type="html"><![CDATA[<p>周知识总结</p><a id="more"></a><h3 id="3月23日"><a href="#3月23日" class="headerlink" title="3月23日"></a>3月23日</h3><h4 id="激活函数有哪些性质？"><a href="#激活函数有哪些性质？" class="headerlink" title="激活函数有哪些性质？"></a>激活函数有哪些性质？</h4><ul><li><strong>非线性</strong>：当激活函数是线性的，一个两层的神经网络就可以逼近所有的函数，层数的增加并不会带来什么收益。</li><li><strong>可微性</strong>：当优化方法是基于梯度的时候，该性质必须得到满足。</li><li><strong>单调性</strong>：当激活函数是单调的，单层网络就能够保证是凸函数。</li><li><strong>f(x)≈x</strong>：当激活函数满足该性质是，如果参数的初始化是随机的较小值，那么神经网络的训练将会很高效，如果不满足这个性质，就需要详细地设置初始值</li><li><strong>输出值的范围</strong>：当激活函数的输出值是有限的时候，基于梯度的优化方法会更加稳定，因为特征的表示受有限权值的影响更显著；当激活函数的输出是无限的时候，模型的训练会更加高效，不过在这种情况下，一般需要更小的学习率</li></ul><br><h4 id="如何选择激活函数？"><a href="#如何选择激活函数？" class="headerlink" title="如何选择激活函数？"></a>如何选择激活函数？</h4><ul><li>在不确定的情况下，可以将大多数的激活函数都试试，最后看一下哪一种的表现更好</li><li>不过存在一些可以参考的指标的选择：<ul><li>如果输出是<code>0, 1</code>值，则输出层选择使用<code>Sigmoid</code>函数，然后其他单元都选择<code>ReLU</code>函数</li><li>如果在隐藏层不确定使用哪个激活函数，那么通常会使用<code>ReLU</code>激活函数；有时也会使用<code>Tanh</code>激活函数。<code>ReLU</code>有一个比较好的特点就是，当权值为负的时候，导数为0</li><li><code>Sigmoid</code>激活函数，除了输出层是一个二分类问题，其他基本不使用</li><li><code>Tanh</code>激活函数，几乎适用于所有场合</li><li><code>ReLU</code>激活函数，最常用的默认激活函数</li><li>如果遇到一些死的神经元，我们可以使用<code>Leaky ReLU</code>激活函数</li></ul></li></ul><br><br><h3 id="3月24日"><a href="#3月24日" class="headerlink" title="3月24日"></a>3月24日</h3><h4 id="使用ReLU激活函数的优点？"><a href="#使用ReLU激活函数的优点？" class="headerlink" title="使用ReLU激活函数的优点？"></a>使用ReLU激活函数的优点？</h4><ul><li>在区间变动很大的时候，<code>ReLU</code>激活函数的导数都会远大于<code>0</code>，在实践中，使用<code>ReLU</code>激活函数神经网络会学习的更快</li><li><code>sigmoid</code>和<code>tanh</code>函数的导数在正负饱和区的梯度会接近于<code>0</code>，会造成梯度弥散，而<code>ReLU</code>的大于<code>0</code>部分都为常数，不会产生梯度弥散现象</li><li>但是<code>ReLU</code>在负半区的梯度为<code>0</code>，此时神经元不会训练，产生<strong>稀疏性</strong>，使用<code>Leaky ReLU</code>可以避免该问题</li></ul><br><h4 id="调节Batch-Size对训练效果有何影响？"><a href="#调节Batch-Size对训练效果有何影响？" class="headerlink" title="调节Batch_Size对训练效果有何影响？"></a>调节Batch_Size对训练效果有何影响？</h4><ul><li><code>Batch size</code>太小，模型表现效果很差（error上升很快）</li><li>随着<code>Batch Size</code>的增大，处理相同数据量的速度越快</li><li>随着<code>Batch Size</code>，达到相同精读需要的<code>epoch</code>数量越来越多</li><li>由于上述两种因素的矛盾， <code>Batch_Size</code>增大到某个时候，达到时间上的最优。</li><li>由于最终收敛精度会陷入不同的局部极值，因此<code>Batch_Size</code>增大到某些时候，达到最终收敛精度上的最优</li></ul><br><br><h3 id="3月25日"><a href="#3月25日" class="headerlink" title="3月25日"></a>3月25日</h3><h4 id="什么是归一化、标准化、正则化？"><a href="#什么是归一化、标准化、正则化？" class="headerlink" title="什么是归一化、标准化、正则化？"></a>什么是归一化、标准化、正则化？</h4><ul><li><p><strong>归一化</strong>是讲数据映射到指定的范围，用于去除不同维度数据的量纲以及量纲单位。常见的映射范围有<code>[0, 1]</code>和<code>[-1, 1]</code></p></li><li><p><strong>标准化</strong>：将数据按比例缩放，使之落入一个小的特定空间。比如<code>Z-Score</code>，将数据的均值缩放到0，方差缩放到1</p></li><li><p><strong>正则化</strong>：引入魔心复杂度的惩罚项，放置模型学习能力过强导致过拟合</p></li></ul><br><h4 id="为什么要进行归一化？"><a href="#为什么要进行归一化？" class="headerlink" title="为什么要进行归一化？"></a>为什么要进行归一化？</h4><ul><li>为了后面数据处理的方便，归一化可以避免一些不必要的数值问题</li><li>为了程序运行时收敛加快</li><li>避免神经元饱和。即当神经圆的激活在接近1或0的时候会饱和，这些区域的梯度接近于0，反向传播的过程中，局部梯度会接近于0，导致无法更新参数</li><li>保证输出数据中数值小的不被吞食</li></ul><br><br><h3 id="3月26日"><a href="#3月26日" class="headerlink" title="3月26日"></a>3月26日</h3><h4 id="深度网络存在那些问题？有无解决方法"><a href="#深度网络存在那些问题？有无解决方法" class="headerlink" title="深度网络存在那些问题？有无解决方法"></a>深度网络存在那些问题？有无解决方法</h4><ul><li>网络越深，需要的训练样本越多</li><li>多层神经网络的参数优化是一个高阶非凸优化问题，经常得到收敛较差的局部解</li><li>梯度扩散问题，BP算法计算出的梯度随着深度向前而显著下降，导致前面网络参数更新很慢</li><li><strong>逐层贪婪训练</strong>，即训练网络的第一个隐藏层，再训练第二个，最后用这些训练好的网络参数值作为整体网络参数的初始值。经过预训练最终能得到比较好的局部最优解</li></ul><br><h4 id="什么是模型微调？模型微调有哪几种状态？"><a href="#什么是模型微调？模型微调有哪几种状态？" class="headerlink" title="什么是模型微调？模型微调有哪几种状态？"></a>什么是模型微调？模型微调有哪几种状态？</h4><ul><li><strong>微调</strong>：即用别人的参数、修改后的网络和自己的数据进行训练，使得参数适应自己的数据，这样一个过程，通常称之为微调</li><li>微调有三种状态：<ul><li>只预测，不训练。相对快、简单，针对那些应景训练好，现在要实际对未知数据进行标注的项目，非常高效</li><li>训练，但只训练最后的分类层。</li><li>完全训练，整个网络都参与训练。比较耗时，但预测精度也会提升不少。</li></ul></li></ul><br><h4 id="权重初始化需要注意的事项？"><a href="#权重初始化需要注意的事项？" class="headerlink" title="权重初始化需要注意的事项？"></a>权重初始化需要注意的事项？</h4><ul><li><p>不能全部初始化为0。请参考<a href="https://www.cnblogs.com/marsggbo/p/7462682.html" target="_blank" rel="noopener">这里</a></p></li><li><p>可以初始化为小的随机数，但不是随机数越小越好。</p></li><li><p>用<code>1/sqrt(n)</code>校准方差，<code>n</code>是输入值</p></li><li><p>稀疏初始化，即把所有权重矩阵都设为<code>0</code>，但是每个神经元都随机地连接到其下层的一个神经元</p></li><li><p>偏差（bias）是可以初始化为<code>0</code>的，通常建议的是使用<code>ReLU</code>单元以及下方公式<br>$$<br>w = np.random.randn(n) * \sqrt{\frac{2.0}{n}}<br>$$</p></li></ul><br><br><h3 id="3月27日"><a href="#3月27日" class="headerlink" title="3月27日"></a>3月27日</h3><h4 id="学习率的作用？"><a href="#学习率的作用？" class="headerlink" title="学习率的作用？"></a>学习率的作用？</h4><ul><li><p>在机器学习中，监督式学习通过顶一个模型，并根据训练集上的数据估计最优参数。</p></li><li><p>梯度下降法是一个被广泛使用的最小化模型误差的参数优化算法。</p></li><li><p>而<strong>学习率</strong>在迭代过程中会控制模型的学习进度。</p></li><li><p>在梯度下降法中，学习率一般是统一的。</p></li><li><p>但是也存在一些方法：在迭代优化的前期学习率较大，到后面逐步减小学习率的值。常见的有：分段常数衰减、多项式衰减、指数衰减、噪声线性余弦衰减等</p></li></ul><br><h4 id="模型中加入正则化项的目的是什么？"><a href="#模型中加入正则化项的目的是什么？" class="headerlink" title="模型中加入正则化项的目的是什么？"></a>模型中加入正则化项的目的是什么？</h4><ul><li>一个好的模型应当有一个比较小的期望错误，但由于不知道真实的数据分布和映射函数，实际上无法计算期望风险。</li><li>所以我们只能通过在给定训练集上计算<strong>经验风险</strong>（即训练集上的平均损失），来得到一个比较好的模型。</li><li>由于训练数据少或噪声或模型能力强等原因，容易造成模型在其他数据集上的泛化能力不强，即过拟合。</li><li>引入正则化项的目的是<strong>限制模型的能力</strong>，使其不要过度地最小化经验风险，从而一定程度上避免过拟合。</li></ul><br><br><h3 id="3月28日"><a href="#3月28日" class="headerlink" title="3月28日"></a>3月28日</h3><h4 id="卷积层和池化层有什么区别？"><a href="#卷积层和池化层有什么区别？" class="headerlink" title="卷积层和池化层有什么区别？"></a>卷积层和池化层有什么区别？</h4><ul><li><p>卷积层和池化层在结构上有一定的相似性，都是对感受域内的特征进行提取，但是其内在操作有一定的区别</p><table><thead><tr><th align="center"></th><th align="center">卷积层</th><th align="center">池化层</th></tr></thead><tbody><tr><td align="center"><strong>结构</strong></td><td align="center">零填充时输出维度不变，而通道数改变</td><td align="center">通常特征维度会降低，通道数不变</td></tr><tr><td align="center"><strong>稳定性</strong></td><td align="center">输入特征发生细微改变时，输出结果会改变</td><td align="center">感受域内的细微变化不影响输出结果</td></tr><tr><td align="center"><strong>作用</strong></td><td align="center">感受域内提取局部关联特征</td><td align="center">感受域内提取泛化特征，降低维度</td></tr><tr><td align="center"><strong>参数量</strong></td><td align="center">与卷积核尺寸、卷积核个数相关</td><td align="center">不引入额外参数</td></tr></tbody></table></li></ul><br><h4 id="CNN与RNN的区别？"><a href="#CNN与RNN的区别？" class="headerlink" title="CNN与RNN的区别？"></a>CNN与RNN的区别？</h4><table><thead><tr><th>类别</th><th>特点描述</th></tr></thead><tbody><tr><td>相同点</td><td>1、传统神经网络的扩展。<br>2、前向计算产生结果，反向计算模型更新。<br>3、每层神经网络横向可以多个神经元共存,纵向可以有多层神经网络连接。</td></tr><tr><td>不同点</td><td>1、CNN空间扩展，神经元与特征卷积；RNN时间扩展，神经元与多个时间输出计算<br>2、RNN可以用于描述时间上连续状态的输出，有记忆功能，CNN用于静态输出</td></tr></tbody></table><br><h4 id="为什么RNN训练的时候Loss波动比较大？"><a href="#为什么RNN训练的时候Loss波动比较大？" class="headerlink" title="为什么RNN训练的时候Loss波动比较大？"></a>为什么RNN训练的时候Loss波动比较大？</h4><ul><li>由于<code>RNN</code>特有的<code>memory</code>会影响后期其他的<code>RNN</code>的特点，梯度时大时小，<code>learning rate</code>没法个性化的调整，导致<code>RNN</code>在训练的过程中，<code>Loss</code>会震荡起伏</li><li>为了解决<code>RNN</code>的这个问题，在训练的时候，可以设置<strong>临界值</strong>，当梯度大于某个临界值，直接截断，用这个临界值作为梯度的大小，防止大幅震荡。</li></ul><br><br><h3 id="3月29日"><a href="#3月29日" class="headerlink" title="3月29日"></a>3月29日</h3><h4 id="如何通俗的理解GAN？"><a href="#如何通俗的理解GAN？" class="headerlink" title="如何通俗的理解GAN？"></a>如何通俗的理解GAN？</h4><ul><li><p><code>GAN</code>（<code>Generative Adversarial network</code>）</p></li><li><p><code>GAN</code>由生成器和判别器组成，生成器负责生成样本，判别器负责判断生成器生成的样本是否为真。</p></li><li><p>生成器要尽可能的迷惑判别器，而判别器要尽可能区分生成器生成的样本和真实样本</p></li><li><p>随着时间的进行，两者在相互博弈下都会越来越强</p></li></ul><br><h4 id="生成式模型和判别式模型的区别？"><a href="#生成式模型和判别式模型的区别？" class="headerlink" title="生成式模型和判别式模型的区别？"></a>生成式模型和判别式模型的区别？</h4><ul><li>对于机器学习模型，我们根据模型对数据的建模方式将模型分为两大类，<strong>生成式模型</strong>，<strong>判别式模型</strong></li><li>具体而言：<ul><li><strong>生成式模型</strong>：由数据学习联合概率分布<code>P(X, Y)</code>，然后由<code>P(Y|X) = P(X, Y)/P(X)</code>求出概率分布<code>P(Y|X)</code>作为预测的模型。该方法表示了给定输入<code>X</code>与输出<code>Y</code>之间的生成关系</li><li><strong>判别式模型</strong>：有数据直接学习决策函数或条件概率分布<code>P(Y|X)</code>作为预测模型。判别方法关心的是对于给定的输入<code>X</code>，应该预测什么样的输出<code>Y</code></li></ul></li><li>举一个生动点的例子，如果我们训练一个关于猫狗分类的模型<ul><li>对于判别式模型，只需要学习二者的差异即可。例如猫的体型会小一些等</li><li>对于生成式模型，则需要学习猫的样子，狗的样子。然后根据长相去区分</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 周知识总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Artificial Intelligence </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周知识总结（3.16~3.22）</title>
      <link href="/passages/zhou-zhi-shi-zong-jie-3-16-3-22/"/>
      <url>/passages/zhou-zhi-shi-zong-jie-3-16-3-22/</url>
      
        <content type="html"><![CDATA[<p>周知识总结</p><a id="more"></a><h3 id="3月16日"><a href="#3月16日" class="headerlink" title="3月16日"></a>3月16日</h3><h4 id="简述决策树中剪枝处理的作用及策略"><a href="#简述决策树中剪枝处理的作用及策略" class="headerlink" title="简述决策树中剪枝处理的作用及策略"></a>简述决策树中剪枝处理的作用及策略</h4><ul><li>剪枝处理是决策树学习算法用来解决过拟合问题的一种办法</li><li>在决策树算法中，为了尽可能的正确分类训练样本，结点会不断的进行划分，有时候可能会导致决策树的分支过多，以至于训练样本本身的特点被当作泛化特点，最终导致过拟合。</li><li>因此，需要采用剪枝的方法来去掉一些分支来降低过拟合的风险。</li><li>剪枝的策略一般分为两种：预剪枝和后剪枝</li><li><strong>预剪枝</strong>：在决策数生成的过程中，评估每个结点划分前和划分后的泛化性能，如果不能提升性能，则停止划分</li><li><strong>后剪枝</strong>：决策树构建完毕后，再自上而下的对非叶结点进行考察，若将此节点标记为叶节点能带来泛化性能的提升，则修改当前节点为叶节点，舍弃它的子节点</li></ul><br><h4 id="简述决策树的基本原理"><a href="#简述决策树的基本原理" class="headerlink" title="简述决策树的基本原理"></a>简述决策树的基本原理</h4><ul><li>决策树是一种分而治之的决策过程</li><li>一个困难的预测问题，通过树的分支结点，被划分为两个或多个较为简单的子集（子问题）。</li><li>不断根据规则分割数据集，随着树的深度不断增加，分支结点的子集越来越小，要处理的问题也越来越简化。当分支结点的深度或者问题的简单程度满足设定条件时，一棵用于解决该问</li></ul><br><br><h3 id="3月17日"><a href="#3月17日" class="headerlink" title="3月17日"></a>3月17日</h3><h4 id="试简述支持向量机中核函数的特点及作用"><a href="#试简述支持向量机中核函数的特点及作用" class="headerlink" title="试简述支持向量机中核函数的特点及作用"></a>试简述支持向量机中核函数的特点及作用</h4><ul><li><strong>核函数的特点</strong><ul><li>核函数的引入可以避免“维度灾难”，大大减小了计算量。因此可以快速有效的处理高维输入</li><li>无需直到线性变换函数的形式和参数</li><li>核函数的形式和参数的变化，会隐式地改变输入空间到特征空间的映射，进而对特征空间的性质产生影响，最终改变各种和方法的性能</li><li>核函数可以和不同的算法灵活结合</li></ul></li><li><strong>核函数的作用</strong><ul><li>在支持向量机中，引入核函数可以把原来坐标系中线性不可分的数据用核函数投影到另一个空间，尽量是的数据在新的空间里线性可分</li></ul></li></ul><br><h4 id="支持向量机为什么要引入对偶问题"><a href="#支持向量机为什么要引入对偶问题" class="headerlink" title="支持向量机为什么要引入对偶问题"></a>支持向量机为什么要引入对偶问题</h4><ul><li>对偶问题将原始问题中的不等式约束转化为了对偶问题中的等式约束，对偶问题一般来说更容易解决</li><li>由于拉格朗日表达式中有内积，可以很自然的使用核函数</li></ul><br><h4 id="试比较逻辑回归和支持向量机的异同"><a href="#试比较逻辑回归和支持向量机的异同" class="headerlink" title="试比较逻辑回归和支持向量机的异同"></a>试比较逻辑回归和支持向量机的异同</h4><ul><li><strong>相同点</strong><ul><li>LR和SVM都是<strong>分类算法</strong></li><li>LR和SVM都是<strong>监督学习</strong>算法</li><li>LR和SVM都是<strong>判别模型</strong></li><li>不考虑核函数，LR和SVM都是线性分类算法</li></ul></li><li><strong>不同点</strong><ul><li>LR采用log损失，SVM采用合页(hinge)损失</li><li>LR对异常值敏感，SVM对异常值不敏感</li><li>计算复杂度不同。对于<strong>海量数据</strong>，SVM的效率较低，LR效率比较高</li><li>对非线性问题处理方式不同。LR必须要构造特征，SVM还可以通过核函数解决</li><li>SVM的损失函数自带正则，而LR需要加入正则项</li><li>SVM会用核函数而LR一般不用核函数（计算量太大）</li></ul></li></ul><br><br><h3 id="3月18日"><a href="#3月18日" class="headerlink" title="3月18日"></a>3月18日</h3><h4 id="试简述极大似然估计"><a href="#试简述极大似然估计" class="headerlink" title="试简述极大似然估计"></a>试简述极大似然估计</h4><ul><li>极大似然估计的<strong>目的</strong>就是：利用已知的样本结果，反推最有可能（最大概率）导致这样结果的参数值</li><li>极大似然估计时建立在极大似然原理基础上的一个统计方法。极大似然估计提供了一种给定观察数据来评估模型参数的方法（“模型已定，参数未知”）。</li><li>所谓极大似然估计，是通过若干次实验，观察其结果，利用实验结果得到某个参数值能够使样本出现的概率为最大</li></ul><br><h4 id="试解释贝叶斯分类器的基本原理"><a href="#试解释贝叶斯分类器的基本原理" class="headerlink" title="试解释贝叶斯分类器的基本原理"></a>试解释贝叶斯分类器的基本原理</h4><ul><li><p>贝叶斯分类器通过相关概率已知情况下的<strong>误判损失</strong>来选择最优的类别分类</p></li><li><p>假设有<code>N</code>种可能的分类标记，记为<code>Y={c1, c2, c3, ...cn}</code></p></li><li><p>对于样本<code>x</code>，分别计算其属于第<code>i</code>类的概率<code>P(ci|x)</code></p></li><li><p>通过比较所有的概率，得到样本所属的最佳类别，将样本和类别带入贝叶斯公式计算<br>$$<br>P(c_i|\boldsymbol{x})=\frac{P(\boldsymbol{x}|c_i)P(c_i)}{P(\boldsymbol{x})}.<br>$$</p></li><li><p>其中<code>p(ci)</code>是先验概率，<code>p(x|ci)</code>为条件概率。根据求条件概率的方式不同，可以得到多重贝叶斯分类器</p></li><li><p>例如朴素贝叶斯，所谓<strong>朴素</strong>，即假设所有属性相互独立</p></li></ul><br><br><h3 id="3月19日"><a href="#3月19日" class="headerlink" title="3月19日"></a>3月19日</h3><h4 id="简述EM算法的基本思想"><a href="#简述EM算法的基本思想" class="headerlink" title="简述EM算法的基本思想"></a>简述EM算法的基本思想</h4><ul><li>EM算法，即最大期望算法（Expectation-Maximization algorithm， EM），该算法通过迭代进行极大似然估计的优化算法，用于对包含隐含变量或缺失数据的概率模型进行<strong>参数估计</strong></li><li>EM算法分为两个步骤，算法步骤是对两个步骤的交替计算<ul><li>第一步是计算期望（E），利用隐藏变量的现有估计值，计算其最大似然估计值</li><li>第二步是最大化（M），最大化在E步上求得的最大似然值来计算参数的值</li><li>之后M步上得到的参数将用于下一个E步的计算，这个过程不断交替进行</li></ul></li></ul><br><h4 id="比较聚类与分类的区别"><a href="#比较聚类与分类的区别" class="headerlink" title="比较聚类与分类的区别"></a>比较聚类与分类的区别</h4><ul><li><strong>聚类</strong>：<ul><li>聚类是把相似的东西放到一起，并不需要这一类到底是什么</li><li>聚类算法属于无监督学习</li></ul></li><li><strong>分类</strong>：<ul><li>分类之前，我们需要知道所有可能的类别，然后要根据数据的特征将数据分到最符合的类别中</li><li>分类算法一般都是监督学习算法</li></ul></li></ul><br><br><h3 id="3月20日"><a href="#3月20日" class="headerlink" title="3月20日"></a>3月20日</h3><h4 id="简述四种常见的聚类算法"><a href="#简述四种常见的聚类算法" class="headerlink" title="简述四种常见的聚类算法"></a>简述四种常见的聚类算法</h4><ul><li>k-means聚类、DBSCAN、层次聚类、SOM聚类</li></ul><h5 id="K-means聚类"><a href="#K-means聚类" class="headerlink" title="K-means聚类"></a>K-means聚类</h5><ul><li><p>以k为参数值，将数据集划分成<code>k</code>个簇，使簇内具有较高的相似度，二簇间的相似度较低</p></li><li><p>算法流程</p><ul><li><p>任意选择<code>k</code>个对象作为初始的簇中心，将个数据集中对象都划分到一个簇中</p></li><li><p>根据簇中对象的平均值，替换簇中心</p></li><li><p>根据新的簇中心，同时将每个对象划分到一个新的簇中</p></li><li><p>重复上述二三步，直至簇中心不再变化（或变化幅度小于阈值）</p></li></ul></li></ul><h5 id="DBSCAN"><a href="#DBSCAN" class="headerlink" title="DBSCAN"></a>DBSCAN</h5><ul><li>基于密度的聚类算法</li><li>算法步骤：<ul><li>确定半径和<code>minPoint</code></li><li>从初始结点开始，检查半径之内的点的数量是否大于<code>minPoint</code>（即密度）</li><li>若满足条件则将该点作为核心点，并将每个对象唯一的分配给已经确定了的中心点</li></ul></li><li>该算法比较大的优势是<strong>不需要指定类别数</strong></li></ul><h5 id="层次聚类"><a href="#层次聚类" class="headerlink" title="层次聚类"></a>层次聚类</h5><ul><li><p>根据层次分解的顺序可以分为<strong>自底向上的凝聚层次聚类</strong>和<strong>自顶向下的分裂层次聚类</strong></p></li><li><p>算法流程（基于最小距离的凝聚层次聚类算法）：</p><ul><li><p>将每个对象看作一类，计算两两之间的最小距离</p></li><li><p>将距离最小的两个类合并成一个新类</p></li><li><p>重新计算新类与所有类之间的距离</p></li><li><p>重复二三步直到所有类最后合并成一类</p></li></ul></li></ul><h5 id="SOM聚类算法"><a href="#SOM聚类算法" class="headerlink" title="SOM聚类算法"></a>SOM聚类算法</h5><ul><li><p>SOM是一种神经网络，包含输入层和输出层。可以实现从输入空间到输出平面的降维映射</p><ul><li>输入层对应一个高维的输入向量</li><li>输出层由一系列组织在二维网络网格上的有序结点构成</li></ul></li><li><p>算法流程</p><ul><li>网络初始化，对输出层每个节点权重赋初值</li><li>从输入样本中随机选取输入向量并且归一化，找到与输入向量距离最小的权重向量</li><li>定义获胜单元，在获胜单元的邻近区域调整权重使其向输入向量靠拢</li><li>提供新样本、进行训练</li><li>收缩邻域半径、减小学习率、重复，直到小于允许值，输出聚类结果</li></ul></li></ul><br><br><h3 id="3月21日"><a href="#3月21日" class="headerlink" title="3月21日"></a>3月21日</h3><h4 id="神经网络的为什么使用“深层”表示"><a href="#神经网络的为什么使用“深层”表示" class="headerlink" title="神经网络的为什么使用“深层”表示"></a>神经网络的为什么使用“深层”表示</h4><ul><li>深度神经网络是一种特征递进式的学习算法，浅层的神经元直接从输入数据中学习一些浅层的简单特征，而深层的特征是通过浅层的特征继续学习到的<strong>更高级的特征</strong>，从计算机的角度学习了更多的语义信息</li><li>深层的网络<strong>隐藏单元数量相对较少</strong>，隐藏层数目比较多，如果浅层的网络想要达到同样的计算结果则需要指数级增长的神经元数量才可以实现</li></ul><br><h4 id="为什么深层神经网络会难以训练"><a href="#为什么深层神经网络会难以训练" class="headerlink" title="为什么深层神经网络会难以训练"></a>为什么深层神经网络会难以训练</h4><ul><li><strong>梯度消失</strong><ul><li>通过隐藏层反向传播的时候，梯度会变得越来越小，故前面的网络层的学习会显著慢于后面的网络层，学习会“卡住”</li></ul></li><li><strong>梯度爆炸</strong><ul><li>梯度在网络更新的过程中不断累积，变成非常大的梯度，导致网络权重值的答复更新，使网络不稳定，在极端情况下，权重值甚至会溢出，导致权重无法更新</li></ul></li><li><strong>权重矩阵的退化</strong><ul><li>权重矩阵的退化会导致模型的有效自由度减少。即网络的可用自由度<strong>对学习中梯度范数的贡献不均衡</strong>，随着相乘矩阵的数量的增加，矩阵的乘积变得越来越退化</li></ul></li></ul><br><br><h3 id="3月22日"><a href="#3月22日" class="headerlink" title="3月22日"></a>3月22日</h3><h4 id="前向传播与反向传播的区别"><a href="#前向传播与反向传播的区别" class="headerlink" title="前向传播与反向传播的区别"></a>前向传播与反向传播的区别</h4><ul><li>前向传播作用于每一层的输入，通过逐层计算得到输出结果</li><li>反向传播作用于网络的输出，通过计算梯度由深到浅更新网络参数</li></ul><br><h4 id="神经网络更”深“具有什么意义"><a href="#神经网络更”深“具有什么意义" class="headerlink" title="神经网络更”深“具有什么意义"></a>神经网络更”深“具有什么意义</h4><ul><li>前提是在一定范围内，不能无限制的加深神经网络</li><li>在神经元数量相同的情况下，深层网络结构具有更大容量，分层组合带来的是指数级的表达空间，能够组合成更多不同类型的子结构，这样可以更容易地学习和表示各种特征</li><li>隐藏层增加意味着由激活函数带来的非线性变换的嵌套层数曾多，就能构造更复杂的映射关系</li></ul><br><h4 id="为什么需要非线性激活函数"><a href="#为什么需要非线性激活函数" class="headerlink" title="为什么需要非线性激活函数"></a>为什么需要非线性激活函数</h4><ul><li>假若神经网络中全部都是线性部件，那么线性的组合还是线性，与单独一个线性分类器无益</li><li>使用非线性激活函数，以便使网络更加强大，增加它的能力，使它可以学习复杂的事物，复杂的表单数据，以及表示输入输出之间非线性的复杂的任意函数映射</li><li>使用非线性激活函数，能够在输入输出之间简历非线性映射</li></ul>]]></content>
      
      
      <categories>
          
          <category> 周知识总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Artificial Intelligence </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之二叉树的右视图</title>
      <link href="/passages/leetcode-zhi-er-cha-shu-de-you-shi-tu/"/>
      <url>/passages/leetcode-zhi-er-cha-shu-de-you-shi-tu/</url>
      
        <content type="html"><![CDATA[<p>Binary Tree RIght Side View</p><a id="more"></a><h3 id="Binary-Tree-RIght-Side-View"><a href="#Binary-Tree-RIght-Side-View" class="headerlink" title="Binary Tree RIght Side View"></a>Binary Tree RIght Side View</h3><ul><li>code with Python</li><li>title number：199</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一棵二叉树，想想自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值</li><li>示例</li></ul><p>​    <img src="/.top//F:%5CZivBlog%5Csource_posts%5CLeetcode%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE%5C1.png" alt></p><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>转化为层次遍历，即取层次遍历中每层的最后一个结点</li><li>具体而言<ul><li>利用队列来存储结点</li><li>取每层的最后一个结点加入最终结果</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rightSideView</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    deque = [root]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> deque:</span><br><span class="line">        len_ = len(deque)</span><br><span class="line">        <span class="comment"># 仅将当前层的最后一个结点加入结果集中</span></span><br><span class="line">        res.append(deque[<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(len_):</span><br><span class="line">            cur = deque.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> cur.left:</span><br><span class="line">                deque.append(cur.left)</span><br><span class="line">            <span class="keyword">if</span> cur.right:</span><br><span class="line">                deque.append(cur.right)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之乘积最大子数组</title>
      <link href="/passages/leetcode-zhi-cheng-ji-zui-da-zi-shu-zu/"/>
      <url>/passages/leetcode-zhi-cheng-ji-zui-da-zi-shu-zu/</url>
      
        <content type="html"><![CDATA[<p>Maximum Product Subarray</p><a id="more"></a><h3 id="Maximum-Product-Subarray"><a href="#Maximum-Product-Subarray" class="headerlink" title="Maximum Product Subarray"></a>Maximum Product Subarray</h3><ul><li>code with Python</li><li>title number：152</li></ul><br><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个整数数组，找出数组中<strong>乘积最大的连续子数组</strong>，返回其乘积</li></ul><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>暴力破解， 穷举所有可能的连续子数组，使用一个变量来存储当前最大的连续子数组之积</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProduct</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    max_ = nums[<span class="number">0</span>]</span><br><span class="line">    temp = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        temp = nums[i]</span><br><span class="line">        max_ = max(temp, max_)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(nums)):</span><br><span class="line">            temp *= nums[j]</span><br><span class="line">            max_ = max(temp, max_)</span><br><span class="line">    <span class="keyword">return</span> max_</span><br></pre></td></tr></table></figure><ul><li>意料之中，超时了</li></ul><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li><p><a href="http://www.zivblog.top/passages/dong-tai-gui-hua/" target="_blank" rel="noopener">动态规划</a>分析框架，请参考这篇文章</p></li><li><p>这个题比较特殊，需要分别记录<strong>乘积最大</strong>和<strong>乘积最小</strong>的子数组的值。这是因为乘法运算中，一个负数很可以使一个很大的数变为很小的数</p></li><li><p><strong>状态表示</strong></p><ul><li><strong>集合定义</strong><ul><li>$f(i)$</li><li>以第<code>i</code>个元素为结尾的子数组的乘积的集合</li></ul></li><li><strong>属性</strong><ul><li>最大值</li><li>最小值</li></ul></li></ul></li><li><p><strong>状态计算</strong></p><ul><li>以第<code>i</code>个数为正数还是负数为划分依据</li><li>当第<code>i</code>个数为正数时，第<code>i</code>个数乘以以<code>i-1</code>个数为结尾的最大值即为当前最大值，即$f(i)<em>{max} = f(i-1)</em>{max} * nums[i]$；同时也要更新当前的最小值，即$f(i)<em>{min} = f(i-1)</em>{min}*nums[i]$</li><li>当第<code>i</code>个数为负数是，第<code>i</code>个数乘以以<code>i-1</code>个数为结尾的最小值即为当前最大值，即$f(i)<em>{max} = f(i-1)</em>{min}*nums[i]$；同时也要跟新当前的最小值，即$f(i)<em>{min} = f(i-1)</em>{max} * nums[i]$</li></ul></li><li><p>所求即为<code>dp_max</code>中的最大值</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProduct</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    dp_max, dp_min = [<span class="number">1</span>]*(n+<span class="number">1</span>), [<span class="number">1</span>]*(n+<span class="number">1</span>)</span><br><span class="line">    ans = float(<span class="string">'-inf'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> rnge(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        dp_max = max(dp_max[i<span class="number">-1</span>]*nums[i<span class="number">-1</span>], dp_min[i<span class="number">-1</span>]*num[i<span class="number">-1</span>], nums[i<span class="number">-1</span>])</span><br><span class="line">        dp_min = min(dp_max[i<span class="number">-1</span>]*nums[i<span class="number">-1</span>], dp_min[i<span class="number">-1</span>]*nums[i<span class="number">-1</span>], nums[i<span class="number">-1</span>])</span><br><span class="line">        </span><br><span class="line">        ans = max(ans, dp_max[i])</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><ul><li>我们发现，<code>dp[i]</code>只与<code>dp[i-1]</code>相关，因此我们并不需要两个动态规划数组，只需要<strong>两个额外的变量</strong>来记录即可</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProduct</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    dp_max, dp_min = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">    ans = float(<span class="string">'-inf'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> rnge(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        temp = dp_max</span><br><span class="line">        dp_max = max(dp_max*nums[i<span class="number">-1</span>], dp_min*nums[i<span class="number">-1</span>], nums[i<span class="number">-1</span>])</span><br><span class="line">        dp_min = min(temp*nums[i<span class="number">-1</span>], dp_min*nums[i<span class="number">-1</span>], nums[i<span class="number">-1</span>])</span><br><span class="line">        ans = max(ans, dp_max)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><ul><li>时间和空间上都有所优化</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>标准01背包问题</title>
      <link href="/passages/biao-zhun-01-bei-bao-wen-ti/"/>
      <url>/passages/biao-zhun-01-bei-bao-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>标准01背包问题</p><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><ul><li><p>有<code>N</code>件物品和一个容量是<code>V</code>的背包。<strong>每件物品只能使用一次</strong>。</p></li><li><p>第i件物品的体积是$v_i$，价值是$w_i$</p></li><li><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大，<strong>返回最大价值</strong></p></li></ul><br><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>我们使用<a href="http://www.zivblog.top/passages/dong-tai-gui-hua/" target="_blank" rel="noopener">闫式DP分析法</a>给出的框架进行分析</p></li><li><p>首先，应该明确所有的情况有$2^N$种（每件物品选或不选）,且该问题为最大值问题</p></li><li><p><strong>状态表示</strong>：$f(i, j)$</p><ul><li><strong>集合定义</strong>：所有只考虑前<code>i</code>个物品且总体积不超过<code>j</code>的选法的集合</li><li><strong>属性</strong>：上述集合中选法对应价值的<strong>最大值</strong></li></ul></li><li><p><strong>状态计算</strong>：根据最后一个不同点划分集合</p><ul><li>由于每个物品有两种选择，即选或不选，我们<strong>以第<code>i</code>个物品选不选</strong>作为集合划分标准</li><li><strong>选择</strong>第<code>i</code>个物品，则当前体积上限变为$j-V_i$，集合变为了<strong>所有只考虑前<code>i-1</code>个物品且总体积不超过$j-V_i$的选法的集合</strong>。根据集合定义，表达式为$f(i-1, j-v_i)+w_i$</li><li><strong>不选择</strong>第<code>i</code>个物品，则集合变为了<strong>所有只考虑前<code>i-1</code>个物品且总体积不超过<code>j</code>的选法的集合</strong>，根据集合定义，表达式为$f(i-1, j)$</li><li>综上，$f(i, j) = max[f(i-1, j-v_i)+w_i, f(i-1, j)]$</li></ul></li><li><p>所求即为$f(N, V)$：<strong>只考虑前<code>N</code>个物品且总体积不超过<code>V</code>的集合中的最大价值</strong></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backpack</span><span class="params">(self, v: List[int], w: List[int], N: int, V: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    v: n件物品对应的体积</span></span><br><span class="line"><span class="string">    w: n件物品对应的价值</span></span><br><span class="line"><span class="string">    N: 物品数量</span></span><br><span class="line"><span class="string">    V: 背包容量</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    f = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line">    <span class="comment"># 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, N+<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 遍历所有可能容积</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(V+<span class="number">1</span>):</span><br><span class="line">            f[i][j] = f[i<span class="number">-1</span>][j]</span><br><span class="line">            <span class="comment"># 只有在当前的背包空间大于最第i个物品所占空间时</span></span><br><span class="line">            <span class="keyword">if</span> j &gt;= v[i]:</span><br><span class="line">                f[i][j] = max(f[i][j], f[i<span class="number">-1</span>][j-v[i]]+w[i])</span><br><span class="line">    <span class="keyword">return</span> f[N][V]</span><br></pre></td></tr></table></figure><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><ul><li><p>所谓优化是针对代码进行的优化，并不是对算法本身的优化</p></li><li><p>由于我们的背包空间与第<code>i</code>个物品所占空间之间存在不确定关系，所以<strong>将物品所占空间从大到小遍历</strong>即可</p></li><li><p>另外，$f(i ,j)$只与$f(i-1, ~)$有关，所以可以省去一维，节省空间</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backpack</span><span class="params">(self, v: List[int], w: List[int], N: int, V: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    v: n件物品对应的体积</span></span><br><span class="line"><span class="string">    w: n件物品对应的价值</span></span><br><span class="line"><span class="string">    N: 物品数量</span></span><br><span class="line"><span class="string">    V: 背包容量</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    f = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line">    j = V</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, N+<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 空间从大到小遍历</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= v[i]:</span><br><span class="line">        f[j] = max(f[j], f[j-v[i]]+w[i])</span><br><span class="line">    j -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> f[V]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前中后缀表达式的转换及计算</title>
      <link href="/passages/qian-zhong-hou-zhui-biao-da-shi-de-zhuan-huan-ji-ji-suan/"/>
      <url>/passages/qian-zhong-hou-zhui-biao-da-shi-de-zhuan-huan-ji-ji-suan/</url>
      
        <content type="html"><![CDATA[<p>前中后缀表达式的转换及计算</p><a id="more"></a><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li>对于人类来讲，中缀表达式是有利于直观理解的，为什么要将中缀表达式转化为前、后缀表达式呢？在我看来，可能有以下几点原因：<ul><li>中缀表达式有运算符的优先级要求，而前、后缀表达式没有</li><li>中缀表达式通过括号提升某些运算的优先级，而前、后缀表达式通过调整运算符位置表示优先级</li><li>另外，前、后缀表达式只利用一个栈就能实现表达式的计算，相比于中缀表达式，更适合计算机运算</li></ul></li><li>下面分别介绍<strong>中缀表达式如何转化为前、后缀表达式</strong>，以及<strong>如何使用栈计算前、后缀表达式</strong></li></ul><br><h3 id="表达式的转换"><a href="#表达式的转换" class="headerlink" title="表达式的转换"></a>表达式的转换</h3><h4 id="中缀转前缀"><a href="#中缀转前缀" class="headerlink" title="中缀转前缀"></a>中缀转前缀</h4><ul><li>对于给定的中缀表达式，<strong>从右向左</strong>扫描</li><li>与操作数直接记录（<strong>从右向左</strong>记录）</li><li>与操作符：<ul><li><strong>栈空</strong>时，直接<strong>入栈</strong></li><li><strong>右括号</strong>，直接<strong>入栈</strong></li><li>其他情况，判断<strong>栈顶</strong>元素：<ul><li>栈顶元素为<strong>右括号</strong>，直接<strong>入栈</strong></li><li>当前元素优先级<strong>小于</strong>栈顶元素优先级，<strong>栈顶元素出栈</strong></li><li>当前元素优先级<strong>大于等于</strong>栈顶元素优先级，<strong>操作符入栈</strong></li><li>若栈顶元素为<strong>左括号</strong>，则<strong>栈中左右括号及其之间的元素全部出栈</strong></li></ul></li></ul></li></ul><br><h4 id="中缀转后缀"><a href="#中缀转后缀" class="headerlink" title="中缀转后缀"></a>中缀转后缀</h4><ul><li>对于给定的中缀表达式，<strong>从左向右</strong>扫描</li><li>操作数直接记录（<strong>从左向右</strong>记录）</li><li>遇操作符：<ul><li><strong>栈空</strong>时，直接<strong>入栈</strong></li><li><strong>左括号</strong>，直接<strong>入栈</strong></li><li>其他情况，判断<strong>栈顶</strong>元素：<ul><li>栈顶为<strong>左括号</strong>，操作符<strong>入栈</strong></li><li>当前运算符优先级<strong>小于等于</strong>栈顶运算符优先级，<strong>栈顶元素出栈</strong></li><li>当前运算符优先级<strong>大于</strong>栈顶运算符优先级，<strong>操作符入栈</strong></li><li>若栈顶为<strong>右括号</strong>，则栈中<strong>左右括号及其之间的元素全部出栈</strong></li></ul></li></ul></li><li>至扫描完毕</li></ul><br><h3 id="表达式计算"><a href="#表达式计算" class="headerlink" title="表达式计算"></a>表达式计算</h3><h4 id="计算前缀表达式"><a href="#计算前缀表达式" class="headerlink" title="计算前缀表达式"></a>计算前缀表达式</h4><ul><li>对于给定<strong>前缀表达式</strong><ul><li><strong>从右向左</strong>扫描</li><li>遇<strong>操作数</strong>入栈</li><li>遇<strong>操作符</strong>：<ul><li>出栈两个操作数，<strong>先出的在左，后出的在右</strong>，执行计算</li><li>结果入栈</li></ul></li><li>至扫描结束，栈顶元素即表达式结果</li></ul></li></ul><br><h4 id="计算后缀表达式"><a href="#计算后缀表达式" class="headerlink" title="计算后缀表达式"></a>计算后缀表达式</h4><ul><li><p>对于给定<strong>后缀表达式</strong></p><ul><li><p><strong>从左向右</strong>扫描</p></li><li><p>遇<strong>操作数</strong>入栈</p></li><li><p>遇<strong>操作符</strong>：</p><ul><li>出栈两个操作数，<strong>先出的在右，后出的在左</strong>，执行计算</li><li>结果入栈</li></ul></li><li><p>至扫描结束，栈顶元素即表达式结果</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之逆波兰表达式求值</title>
      <link href="/passages/leetcode-zhi-ni-bo-lan-biao-da-shi-qiu-zhi/"/>
      <url>/passages/leetcode-zhi-ni-bo-lan-biao-da-shi-qiu-zhi/</url>
      
        <content type="html"><![CDATA[<p>Evaluate Reverse Polish Notation</p><a id="more"></a><h3 id="Evaluate-Reverse-Polish-Notation"><a href="#Evaluate-Reverse-Polish-Notation" class="headerlink" title="Evaluate Reverse Polish Notation"></a>Evaluate Reverse Polish Notation</h3><ul><li>code with Python</li><li>title number：150</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>根据逆波兰表达式，求表达式的值</li><li>有效的运算符包括<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>，每个运算对象可以是整数，也可以是另一个逆波兰表达式</li><li>说明：<ul><li>整数除法只保留整数部分</li><li>给定的逆波兰表达式总是有效的，不存在除数为0或得不出有效数值的情况</li><li>所谓<strong>逆波兰表达式</strong>即：后缀表达式。</li></ul></li><li>关于前中后缀表达式的转化及计算，请见<a href="http://www.zivblog.top/passages/qian-zhong-hou-zhui-biao-da-shi-de-zhuan-huan-ji-ji-suan/" target="_blank" rel="noopener">这篇文章</a></li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>根据上面链接中的介绍，后缀表达式的计算需呀借助一个<strong>栈</strong>来进行，具体细节不再描述</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evalRPN</span><span class="params">(self, tokens: List[str])</span> -&gt; int:</span></span><br><span class="line">    stack = []</span><br><span class="line">    operator = [<span class="string">'+'</span>, <span class="string">'-'</span>, <span class="string">'*'</span>, <span class="string">'/'</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> tokens:</span><br><span class="line"><span class="comment"># 操作数，入栈</span></span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> operator:</span><br><span class="line">            stack.append(c)</span><br><span class="line">        <span class="comment"># 操作符，取栈中两个数并计算，注意顺序</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = int(stack.pop())</span><br><span class="line">            left = int(stack.pop())</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">'+'</span>:</span><br><span class="line">                stack.append(left+right)</span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">'-'</span>:</span><br><span class="line">                stack.append(left-right)</span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">'*'</span>:</span><br><span class="line">                stack.append(left*right)</span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">'/'</span>:</span><br><span class="line">                stack.append(left/right)</span><br><span class="line">    <span class="keyword">return</span> int(stack.pop())</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之目标和</title>
      <link href="/passages/leetcode-zhi-mu-biao-he/"/>
      <url>/passages/leetcode-zhi-mu-biao-he/</url>
      
        <content type="html"><![CDATA[<p>Target Sum</p><a id="more"></a><h3 id="Target-Sum"><a href="#Target-Sum" class="headerlink" title="Target Sum"></a>Target Sum</h3><ul><li>code with Python</li><li>title number：494</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li><p>给定一个非负整数数组<code>a1, a2, ... an</code>，和一个目标数<code>S</code></p></li><li><p>现有两个符号<code>+</code>和<code>-</code>，对数组中的任意一个整数，你都可以从<code>+</code>和<code>-</code>中选择一个符号添加到整数前面</p></li><li><p>返回可以使最终数组和为目标数的所有添加符号的<strong>方法数</strong></p></li><li><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums&#x3D;[1, 1, 1, 1, 1], S&#x3D;3</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">-1+1+1+1+1 &#x3D; 3</span><br><span class="line">+1-1+1+1+1 &#x3D; 3</span><br><span class="line">+1+1-1+1+1 &#x3D; 3</span><br><span class="line">+1+1+1-1+1 &#x3D; 3</span><br><span class="line">+1+1+1+1-1 &#x3D; 3</span><br></pre></td></tr></table></figure></li><li><p>注意：</p><ul><li>数组非空</li><li>数组和不超过1000</li></ul></li></ul><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><ul><li><p><strong>动态规划</strong>，我们使用之前介绍的<a href>闫式DP分析法</a>分析该问题</p></li><li><p>首先我们分析一下，在枚举的情况下，每一个数的后面我们都有两种选择，所以集合的规模是$2^{n}$</p></li><li><p>使用之前介绍的框架</p><ul><li><p><strong>状态表示</strong></p><ul><li><strong>集合是什么</strong>：$f(i, j)$，前<code>i</code>个元素经过计算为<code>j</code>的所有情况的集合</li><li><strong>属性</strong>：满足条件的序列个数</li></ul></li><li><p><strong>状态计算</strong></p><ul><li><p>由于每个位置只有两种选择（即<code>+</code>和<code>-</code>），所以我们可以以此来划分集合</p></li><li><p>集合可以划分为一下两部分，并根据最初对集合的定义分别得到两部分的表达式：</p><ul><li><p>最后一个元素前放置<code>+</code></p><blockquote><p>对于这种情况，已经确定最后一项是做加法，那么对于前<code>i-1</code>项的情况则变为：<strong>前i-1个元素经过计算为j-num[i]的集合</strong></p><p>根据定义，表示为$f(i-1, j-nums[i])$</p></blockquote></li><li><p>最后一个元素前放置<code>-</code></p><blockquote><p>对于这种情况，已经确定最后一项是做减法，那么对于前<code>i-1</code>项的情况则变为：<strong>前i-1个元素经过计算为j+nums[i]的集合</strong></p><p>根据定义，表示为$f(i-1, j+nums[i])$</p></blockquote></li></ul></li><li><p>综合起来，$f(i, j) = f(i-1, j+nums[i]) + f(i-1, j-nums[i])$</p></li></ul></li><li><p>根据定义，所求即为$f(len(nums), S)$，即包含所有元素和为<code>S</code>的情况的数目</p></li></ul></li><li><p><strong>朴素版本的代码</strong></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findTargetSumWays</span><span class="params">(self, nums: List[int], S: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># S的范围至多是[-s, s+1]</span></span><br><span class="line">    s = sum(nums)</span><br><span class="line">    <span class="comment"># 使用dict存储，&#123;i : j&#125;</span></span><br><span class="line">    dp = [dict() <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(nums))]   </span><br><span class="line">    <span class="keyword">if</span> nums[<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 加和减都可以</span></span><br><span class="line">        dp[<span class="number">0</span>][nums[<span class="number">0</span>]] = <span class="number">2</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 加或减</span></span><br><span class="line">        dp[<span class="number">0</span>][nums[<span class="number">0</span>]] = <span class="number">1</span></span><br><span class="line">        dp[<span class="number">0</span>][-nums[<span class="number">0</span>]] = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, length):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(-s, s+<span class="number">1</span>):</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>].get(j-nums[i], <span class="number">0</span>) + dp[i<span class="number">-1</span>].get(j+nums[i], <span class="number">0</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> dp[len(nums)<span class="number">-1</span>].get(S, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h4 id="优化后的代码"><a href="#优化后的代码" class="headerlink" title="优化后的代码"></a>优化后的代码</h4><ul><li>由于$f(i)$只与$f(i-1)$有关，所以我们可以优化代码结构————只需存储$f(i-1)$即可</li><li>待实现</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/passages/dong-tai-gui-hua/"/>
      <url>/passages/dong-tai-gui-hua/</url>
      
        <content type="html"><![CDATA[<p>动态规划</p><a id="more"></a><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li>先挂两个链接，都是质量非常高的资料，本文也参考了其中的内容<ul><li><a href="https://www.cxyxiaowu.com/8536.html" target="_blank" rel="noopener">动态规划</a></li><li><a href="https://www.bilibili.com/video/BV1X741127ZM" target="_blank" rel="noopener">闫式DP分析法</a></li></ul></li><li>借用严总的话来说，<strong>动态规划是一种基于经验的算法</strong>，了解了基本的算法思想后，需要接触<strong>各种类型的题目</strong>之后才能对与动态规划做到得心应手</li><li>下面给出的分析框架是对<strong>闫式DP分析法</strong>的总结</li><li>后面还会对各种类型DP问题结合经典题目进行分析（待施工）</li></ul><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><ul><li>本分析法主要是给出一套分析的框架，不同与常见算法书上的刻板描述，这里给出的分析方法结合<strong>集合</strong>的概念协助分析流程更为平滑</li><li>首先，我们要明确的是动态规划问题都是<strong>有限集合</strong>的最优化问题（求最值，求数量，判断是否存在）。不过较为特殊的是，集合虽然是有限的，但是集合规模一般很大，使用枚举的方式<strong>必定是行不通的</strong></li></ul><h4 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h4><ul><li>两个阶段<ul><li><strong>状态表示</strong>（一般用<code>f(i)</code>或<code>f(i, j)</code>等形式表示）（化零为整）<ul><li><strong>集合定义</strong><ul><li>该定义极为关键，贯穿整个问题分析的流程</li><li>比如<strong>01背包问题</strong>中，集合定义为：所有只考虑前<code>n</code>个物品且总体积不超过体积<code>V</code>的选法的<strong>集合</strong></li></ul></li><li><strong>属性</strong><ul><li>一般要求题目要求求什么，属性就是什么</li><li>比如<strong>01背包</strong>问题中，属性就是<strong>集合中符合条件的的最大值</strong></li></ul></li></ul></li><li><strong>状态计算</strong>（化整为零）<ul><li>寻找最后一个不同点（划分依据，即根据最后一个不同点对集合进行分类）</li><li>再对不同的子集进行表示，组合成为最终的动态规划表达式（状态转移公式）</li><li>要求状态计算过程中做到<strong>不重复</strong>和<strong>不遗漏</strong>。实际操作中，对不遗漏要求较高，在必要情况下可以重复（比如在求最值的情况下）</li></ul></li></ul></li><li>单单框架看下来比较抽象，可结合下面各种类型的动态规划题目进行巩固</li><li>另外，对于动态规划的所有优化都是针对代码时间复杂度或空间复杂度的优化（即对代码的等价变换），对于算法本身并不存在优化之说</li></ul><br><h3 id="经典题目分析"><a href="#经典题目分析" class="headerlink" title="经典题目分析"></a>经典题目分析</h3><h4 id="线性DP"><a href="#线性DP" class="headerlink" title="线性DP"></a>线性DP</h4><ul><li><a href="http://www.zivblog.top/passages/leetcode-zhi-cheng-ji-zui-da-zi-shu-zu/" target="_blank" rel="noopener">乘积最大子数组</a></li><li><a href="http://www.zivblog.top/passages/leetcode-zhi-zui-chang-gong-gong-zi-xu-lie/" target="_blank" rel="noopener">最长公共子序列</a></li><li><a href="http://www.zivblog.top/passages/leetcode-zhi-zui-da-zheng-fang-xing/" target="_blank" rel="noopener">最大正方形</a></li><li><a href="http://www.zivblog.top/passages/leetcode-zhi-wan-quan-ping-fang-shu/" target="_blank" rel="noopener">完全平方数</a></li><li><a href="http://www.zivblog.top/passages/leetcode-zhi-ji-dan-diao-luo/" target="_blank" rel="noopener">鸡蛋掉落</a></li><li>打家劫舍系列<ul><li><a href="http://www.zivblog.top/passages/Leetcode之打家劫舍/" target="_blank" rel="noopener">打家劫舍</a></li></ul></li><li>股票问题系列<ul><li><a href="http://www.zivblog.top/passages/Leetcode之买股票的最佳时机/" target="_blank" rel="noopener">买股票的最佳时机</a></li><li><a href="http://www.zivblog.top/passages/Leetcode之买股票的最佳时机Ⅱ/" target="_blank" rel="noopener">买股票的最佳时机Ⅱ</a></li><li><a href="http://www.zivblog.top/passages/leetcode-zhi-zui-jia-mai-mai-gu-piao-shi-ji-han-leng-dong-qi/" target="_blank" rel="noopener">最佳买卖股票时机含冷冻期</a></li></ul></li></ul><h4 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h4><ul><li><a href="http://www.zivblog.top/passages/leetcode-zhi-zui-chang-hui-wen-zi-xu-lie/" target="_blank" rel="noopener">最长回文子序列</a></li></ul><h4 id="背包DP"><a href="#背包DP" class="headerlink" title="背包DP"></a>背包DP</h4><ul><li><a href="http://www.zivblog.top/passages/leetcode-zhi-mu-biao-he/" target="_blank" rel="noopener">目标和</a>，01背包问题</li><li><a href="http://www.zivblog.top/passages/biao-zhun-01-bei-bao-wen-ti/" target="_blank" rel="noopener">标准01问题</a></li><li><a href="http://www.zivblog.top/passages/biao-zhun-wan-quan-bei-bao-wen-ti" target="_blank" rel="noopener">标准完全背包问题</a></li><li><a href="http://www.zivblog.top/passages/leetcode-zhi-ling-qian-dui-huan/" target="_blank" rel="noopener">零钱兑换</a></li><li><a href="http://www.zivblog.top/passages/leetcode-zhi-ling-qian-dui-huan-ii/" target="_blank" rel="noopener">零钱兑换Ⅱ</a></li><li><a href="http://www.zivblog.top/passages/leetcode-zhi-fen-ge-deng-he-zi-ji/" target="_blank" rel="noopener">分割等和子集</a>，变种01背包问题</li></ul><h4 id="树形DP"><a href="#树形DP" class="headerlink" title="树形DP"></a>树形DP</h4><ul><li>待施工</li></ul><h4 id="状态压缩DP"><a href="#状态压缩DP" class="headerlink" title="状态压缩DP"></a>状态压缩DP</h4><ul><li><a href="http://www.zivblog.top/passages/leetcode-zhi-qi-shi-bo-hao-qi/" target="_blank" rel="noopener">骑士拨号器</a></li></ul><h4 id="数位DP"><a href="#数位DP" class="headerlink" title="数位DP"></a>数位DP</h4><ul><li>待施工</li></ul><h4 id="计数型DP"><a href="#计数型DP" class="headerlink" title="计数型DP"></a>计数型DP</h4><ul><li>待施工</li></ul><h4 id="递推型DP"><a href="#递推型DP" class="headerlink" title="递推型DP"></a>递推型DP</h4><ul><li>待施工</li></ul><h4 id="概率DP"><a href="#概率DP" class="headerlink" title="概率DP"></a>概率DP</h4><ul><li>待施工</li></ul><h4 id="博弈性DP"><a href="#博弈性DP" class="headerlink" title="博弈性DP"></a>博弈性DP</h4><ul><li>待施工</li></ul><h4 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h4><ul><li>待施工</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之二叉树的前序遍历</title>
      <link href="/passages/leetcode-zhi-er-cha-shu-de-qian-xu-bian-li/"/>
      <url>/passages/leetcode-zhi-er-cha-shu-de-qian-xu-bian-li/</url>
      
        <content type="html"><![CDATA[<p>Binary Tree Preorder Traversal</p><a id="more"></a><h3 id="Binary-Tree-Preorder-Traversal"><a href="#Binary-Tree-Preorder-Traversal" class="headerlink" title="Binary Tree Preorder Traversal"></a>Binary Tree Preorder Traversal</h3><ul><li>code with Python</li><li>title number：144</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一棵二叉树，返回其按<strong>前序遍历</strong>得到的节点值列表</li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>前面的<a href="http://www.zivblog.top/passages/leetcode-zhi-er-cha-shu-de-zhong-xu-bian-li/" target="_blank" rel="noopener">二叉树的中序遍历</a>和<a href="http://www.zivblog.top/passages/leetcode-zhi-er-cha-shu-de-ceng-xu-bian-li/" target="_blank" rel="noopener">二叉树的层序遍历</a>中都使用到了一种名为<strong>颜色标记法</strong>的方法，这里先用该方法解题<ul><li>使用颜色标记结点的状态：新节点：白色；已访问结点：灰色</li><li>遇到白色结点，将其标记为灰色并将其右结点，左结点，自身（与前序恰好逆序，出栈后即为前序）入栈</li><li>遇到灰色结点，则输出结点值</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">    w, g = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    stack = [(root, w)]</span><br><span class="line">    res = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        node, color = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> color == w:</span><br><span class="line">            stack.append((node.right, w))</span><br><span class="line">            stack.append((node.left, w))</span><br><span class="line">            stack.append((node, g))</span><br><span class="line">        <span class="keyword">if</span> color == g:</span><br><span class="line">            res.append(node.val)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li>递归遍历，根-&gt;左-&gt;右</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">    res = []</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorder</span><span class="params">(root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        res.append(root.val)</span><br><span class="line">        preorder(root.left)</span><br><span class="line">        preorder(root.right)</span><br><span class="line">        </span><br><span class="line">    preorder(root)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="思路三"><a href="#思路三" class="headerlink" title="思路三"></a>思路三</h4><ul><li>迭代，借助栈</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">    res = []</span><br><span class="line">    stack = [root]<span class="comment"># 辅助栈</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        node = stack.pop()</span><br><span class="line">        res.append(node.val)</span><br><span class="line">        <span class="comment"># 入栈先右后左，出栈才是先左后右</span></span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            stack.append(node.right)</span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            stack.append(node.left)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之单词拆分</title>
      <link href="/passages/leetcode-zhi-dan-ci-chai-fen/"/>
      <url>/passages/leetcode-zhi-dan-ci-chai-fen/</url>
      
        <content type="html"><![CDATA[<p>Word Break</p><a id="more"></a><h3 id="Word-Break"><a href="#Word-Break" class="headerlink" title="Word Break"></a>Word Break</h3><ul><li>code with Python</li><li>title number：139</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li><p>给定一个非空字符串<strong>S</strong>和一个包含非空单词列表的字典<code>wordDict</code></p></li><li><p>判定S<strong>是否可以</strong>被空格拆分为一个或多个在字典中出现的单词</p></li><li><p>注意：</p><ul><li>拆分时可以重复使用字典中的单词</li><li>拆分时不能重复使用字符串中的字符，即单词之间无交集</li><li>可以认为字典中不存在重复单词</li></ul></li></ul><br><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li><p>我们使用了回溯法来解决<a href="http://www.zivblog.top/passages/leetcode-zhi-fen-ge-hui-wen-chuan/" target="_blank" rel="noopener">分割回文串</a>中的问题，这道题目虽然也是分割问题，但是与分割回文串还是存在区别的</p><ul><li>首先，可划分的子串是确定的（在<code>wordDict</code>中）</li><li>其次，只需要判断是否可行，而不用列举所有可能</li></ul></li><li><p>回溯法会重复计算有些位的可拆分情况，要解决该问题，可以使用<strong>记忆化回溯</strong>或者<strong>动态规划</strong></p></li><li><p>下面先介绍<strong>记忆化回溯</strong></p></li><li><p>所谓记忆化回溯，就是在回溯法的基础上，保存出现过的情况，避免重复计算，具体而言：</p><ul><li>定义回溯函数<code>back_track(s)</code></li><li>若<code>S</code>长度为0，则返回<code>true</code>，表示已经使用<code>wordDict</code>中的单词分割完</li><li>初始化当前字符串是否可以被分割<code>res=False</code></li><li>遍历索引<code>i</code>，遍历区间为<code>[1, n+1)</code><ul><li>如果<code>s[0:i-1]</code>在<code>wordDict</code>中：<code>res=back_track(s[i, n-1])或res</code>（保存遍历结束索引中，可以使用字符串切割完成的情况）</li></ul></li><li>返回<code>res</code></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span><span class="params">(self, s: str, wordDict: List[str])</span> -&gt; bool:</span></span><br><span class="line">    <span class="keyword">import</span> functools</span><br><span class="line">    <span class="comment"># 提升一个方法频繁用相同参数调用场景下的性能</span></span><br><span class="line"><span class="meta">    @functools.lru_cache(None)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">back_track</span><span class="params">(s)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        res = <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(n+<span class="number">1</span>)):</span><br><span class="line">            <span class="keyword">if</span> s[:i] <span class="keyword">in</span> wordDict:</span><br><span class="line">                <span class="comment"># 做或运算</span></span><br><span class="line">                res = back_track(s[i:]) <span class="keyword">or</span> res</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> back_track(s)</span><br></pre></td></tr></table></figure><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li><p>动态规划</p><ul><li><p>定义数组<code>dp[]</code>，<code>dp[i]</code>表示字符子串<code>s[0:i]</code>可以在<code>wordDict</code>中找到</p></li><li><p>初始化，除<code>dp[0]</code>外全部初始化为<code>False</code></p></li><li><p>这里建立的不是<code>dp[i]</code>和<code>dp[i-1]</code>的关系，而是<code>dp[i]</code>和<code>dp[i-len(word)]</code>的关系</p></li><li><p>终止，遍历完整个字符串</p></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span><span class="params">(self, s: str, wordDict: List[str])</span> -&gt; bool:</span></span><br><span class="line">    dp = [<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(s)+<span class="number">1</span>)]</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">True</span><span class="comment"># 第0个位置表示的是字符串中第一个字母前的位置</span></span><br><span class="line">    <span class="comment"># 第一个位置是第一个字符后的位置</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s)+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> wordDict:</span><br><span class="line">            <span class="keyword">if</span> dp[i-len(word)] &amp;&amp; len(word) &lt;= i:</span><br><span class="line">                <span class="keyword">if</span> s[i-len(word):i] == word:</span><br><span class="line">                    dp[i] = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> dp[len(s)] || <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之分割回文串</title>
      <link href="/passages/leetcode-zhi-fen-ge-hui-wen-chuan/"/>
      <url>/passages/leetcode-zhi-fen-ge-hui-wen-chuan/</url>
      
        <content type="html"><![CDATA[<p>Palindrome Partitioning</p><a id="more"></a><h3 id="Palindrome-Partitioning"><a href="#Palindrome-Partitioning" class="headerlink" title="Palindrome Partitioning"></a>Palindrome Partitioning</h3><ul><li>code with Python</li><li>title number：131</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li><p>给定一个字符串<code>S</code>，将<code>S</code>分割成一些子串，使每个子串都是回文串</p></li><li><p>返回<code>S</code>的所有分割方案（每个方案存储在一个列表中）</p></li><li><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;aab&quot;</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line"> [&#39;aa&#39;, &#39;b&#39;],</span><br><span class="line"> [&#39;a&#39;, &#39;a&#39;, b]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>从示例中可以发现，分割方案中必定存在<strong>每个子串均为一个字符</strong>的结果</p></li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>题目本质上是在求所有可能，即集合，可以使用回溯法</li><li>关于回溯法，已经做过多道类似的题目：<ul><li><a href="http://www.zivblog.top/passages/leetcode-zhi-zu-he-zong-he/" target="_blank" rel="noopener">组合总和</a></li><li><a href="http://www.zivblog.top/passages/leetcode-zhi-zu-he-zong-he-ii/" target="_blank" rel="noopener">组合总和Ⅱ</a></li><li><a href="http://www.zivblog.top/passages/leetcode-zhi-quan-pai-lie/" target="_blank" rel="noopener">全排列</a></li><li><a href="http://www.zivblog.top/passages/leetcode-zhi-quan-pai-lie-ii/" target="_blank" rel="noopener">全排列Ⅱ</a></li><li><a href="http://www.zivblog.top/passages/leetcode-zhi-zi-ji/" target="_blank" rel="noopener">子集</a></li><li><a href="http://www.zivblog.top/passages/leetcode-zhi-zi-ji-ii/" target="_blank" rel="noopener">子集Ⅱ</a></li></ul></li><li>具体而言<ul><li>不断切分字符串，并判断当前子串是否为回文串</li><li>若是，则继续切分其后面的子串</li><li>若否，则不再切分</li><li>直达整个字符串切分完毕，作为一种情况添加到结果集中</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, s: str)</span> -&gt; List[List[str]]:</span></span><br><span class="line">    res = []</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># tmp是当前回溯过程的一个结果</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(s, tmp)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            res.append(tmp)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s)+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 当前s为回文子串</span></span><br><span class="line">            <span class="keyword">if</span> s[:i] == s[:i][::<span class="number">-1</span>]:</span><br><span class="line">                <span class="comment"># 继续进行</span></span><br><span class="line">                helper(s[i:], tmp+[s[:i]])</span><br><span class="line">    helper(s, [])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之被围绕的区域</title>
      <link href="/passages/leetcode-zhi-bei-wei-rao-de-qu-yu/"/>
      <url>/passages/leetcode-zhi-bei-wei-rao-de-qu-yu/</url>
      
        <content type="html"><![CDATA[<p>Surrounded Regions</p><a id="more"></a><h3 id="Surrounded-Regions"><a href="#Surrounded-Regions" class="headerlink" title="Surrounded Regions"></a>Surrounded Regions</h3><ul><li>code with Python</li><li>title number：130</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li><p>给定一个二维矩阵，包含<code>X</code>和<code>O</code>两种符号</p></li><li><p>找到所有被<code>X</code>围绕的区域，并将这些区域里所有的<code>O</code>全部用<code>X</code>填充</p></li><li><p>示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[X, X, X, X],[[X, X, X, X],</span><br><span class="line"> [X, O, O, X],  ----&gt;     [X, X, X, X],</span><br><span class="line"> [X, X, O, X], [X, X, X, X],</span><br><span class="line"> [X, O, X, X]] [X, O, X, X]]</span><br></pre></td></tr></table></figure></li><li><p>说明：</p><ul><li>被围绕的区域不会存在于边界上，即<strong>边界上的<code>O</code></strong>都不会被填充为<code>X</code></li><li>任何不在边界上，<strong>不与边界上的<code>O</code>相连</strong>的<code>O</code>最终都会被填充为<code>X</code></li><li>相连是指两个元素在<strong>水平</strong>或<strong>垂直</strong>方向上相邻</li></ul></li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>根据题意，我们需要将所有<strong>除边界上的O和与边界连通的O之外的</strong>所有<code>O</code>全部置为<code>X</code></li><li>这涉及到二维数组的深度遍历（类似的题目见<a href="http://www.zivblog.top/passages/leetcode-zhi-dan-ci-sou-suo/" target="_blank" rel="noopener">单词搜索</a>）</li><li>并且为了方便操作，可以事先将所有位于边界上的<code>O</code>和与边界上<code>O</code>相连的<code>O</code>全部标记（比如使用<code>A</code>代替），然后在结束之后再改回来</li><li>所以这变成了一个<strong>寻找连通区域</strong>的问题，我们只需要找到与边界上<code>O</code>连通的<code>O</code>替换为<code>A</code>，最后将剩余的所有<code>O</code>都替换为<code>X</code>，将所有<code>A</code>替换为<code>O</code>即可</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(self, board: List[List[str]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    <span class="comment"># 只有一行或者只有一列</span></span><br><span class="line">    <span class="keyword">if</span> len(board) &lt;= <span class="number">2</span> <span class="keyword">or</span> len(board[<span class="number">0</span>]) &lt;= <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    row, col = len(board), len(board[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, j)</span>:</span></span><br><span class="line">        <span class="comment"># 深度搜索至边界</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= row <span class="keyword">or</span> j &gt;= col <span class="keyword">or</span> board[i][j] != <span class="string">'O'</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 替换</span></span><br><span class="line">        board[i][j] = <span class="string">'A'</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 继续遍历其邻接位置（四个方向）</span></span><br><span class="line">        dfs(i, j - <span class="number">1</span>)</span><br><span class="line">        dfs(i, j + <span class="number">1</span>)</span><br><span class="line">        dfs(i - <span class="number">1</span>, j)</span><br><span class="line">        dfs(i + <span class="number">1</span>, j)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从边界开始， 标记</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(row):</span><br><span class="line">        <span class="comment"># 从第一行和最后一行开始</span></span><br><span class="line">        dfs(i, <span class="number">0</span>)</span><br><span class="line">        dfs(i, col - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(col):</span><br><span class="line">        <span class="comment"># 从第一列和最后一列开始</span></span><br><span class="line">        dfs(<span class="number">0</span>, j)</span><br><span class="line">        dfs(row - <span class="number">1</span>, j)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(row):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(col):</span><br><span class="line">            <span class="keyword">if</span> board[i][j] == <span class="string">'O'</span>:</span><br><span class="line">                board[i][j] = <span class="string">'X'</span></span><br><span class="line">            <span class="keyword">if</span> board[i][j] == <span class="string">'A'</span>:</span><br><span class="line">                board[i][j] = <span class="string">'O'</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之求根到叶子节点数字之和</title>
      <link href="/passages/leetcode-zhi-qiu-gen-dao-xie-zi-jie-dian-shu-zi-zhi-he/"/>
      <url>/passages/leetcode-zhi-qiu-gen-dao-xie-zi-jie-dian-shu-zi-zhi-he/</url>
      
        <content type="html"><![CDATA[<p>Sum Root to Leaf Numbers</p><a id="more"></a><h3 id="Sum-Root-to-Leaf-Numbers"><a href="#Sum-Root-to-Leaf-Numbers" class="headerlink" title="Sum Root to Leaf Numbers"></a>Sum Root to Leaf Numbers</h3><ul><li>code with Python</li><li>title number：129</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个二叉树，每个结点存放一个<code>0~9</code>之间的数字</li><li>每条从根到叶节点的路径表示一个数字</li><li>例如：从根到叶子结点路径<code>1-&gt;2-&gt;3</code>代表数字<code>123</code></li><li>计算所有<strong>从根到叶子节点生成的数字之和</strong></li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>我们可以通过深度遍历得到每条路径，然后将其转化为数字，再求和。这是最直接的想法，但是这样的做法包含很多的冗余操作</li><li>可以发现，根据题意，路径长度每<strong>加一</strong>，之前得到的值就要<strong>乘十</strong></li><li>所以我们可以直接在遍历的过程中计算该数值</li><li>具体而言：<ul><li>深度遍历整棵树，每便利一层，则值为：当前节点值+10*之前的值</li><li>递归进行，在左右子树都为空时表示一条路径结束，将其添加到结果集中</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumNumbers</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root, val, res)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        val = <span class="number">10</span>*val + root.val</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 叶子节点，路径结束</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="comment"># 向res中添加截止前遍历过的路径之和</span></span><br><span class="line">            res.append(val+res[<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 递归</span></span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            dfs(root.left, val, res)</span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            dfs(root.right, val, res)</span><br><span class="line">    val = <span class="number">0</span></span><br><span class="line">    res = [<span class="number">0</span>]<span class="comment"># res[-1]存储最终结果</span></span><br><span class="line">    dfs(root, val, res)</span><br><span class="line">    <span class="keyword">return</span> res[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nvidia-smi命令详解</title>
      <link href="/passages/nvidia-smi-ming-ling-xiang-jie/"/>
      <url>/passages/nvidia-smi-ming-ling-xiang-jie/</url>
      
        <content type="html"><![CDATA[<p>nividi-smi</p><a id="more"></a><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p><code>nvidia-smi</code>使用来查看<code>GPU</code>的使用情况的</p><p><img src="/.top//nvidia-smi%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3%5C1.png" alt></p><p><img src="/.top//nvidia-smi%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3%5C2.png" alt></p><h4 id="图片一"><a href="#图片一" class="headerlink" title="图片一"></a>图片一</h4><ul><li>第一栏中<code>fan</code>参数的百分比值：表示的是风扇转速</li><li>第二栏中的<code>Temp</code>表示的是<code>GPU</code>的温度，单位为摄氏度</li><li>第三栏中的<code>Perf</code>表示的是性能状态，从<code>p0~p12</code>分别对应<code>max~min</code></li><li>第四栏中的<code>Pwr</code>表示的是能耗，<code>Persistence-M</code>有两个值<code>on/off</code>是持续模式的状态</li><li>第五栏中的<code>Bus-id</code>是涉及<code>GPU</code>总线的东西</li><li>第六栏中的<code>Memory-Usage</code>表示显存占用</li><li>第八栏中的上方是关于<code>ECC</code>的东西</li><li>第八栏中下方<code>Compute M</code>是计算模式</li></ul><h4 id="图片二"><a href="#图片二" class="headerlink" title="图片二"></a>图片二</h4><ul><li>分别显示每个进程对GPU的显存的使用率</li></ul><ul><li><p><strong>注意显存占用和GPU占用并不相同</strong></p><ul><li>显卡有GPU和显存等组成，两者的关系类似内存和CPU的关系</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事实</title>
      <link href="/passages/shi-shi/"/>
      <url>/passages/shi-shi/</url>
      
        <content type="html"><![CDATA[<p>用数据思考，避免情绪化决策</p><a id="more"></a><p>《事实：用数据思考，避免情绪化决策》 汉斯·罗杰斯</p><p>&emsp; &emsp;我希望这本书能够改变人们的一些思维方式，使得它们不要受非理性恐惧的困扰，并能够重新把他们的能量投入建设性的行为中。</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;————汉斯</p><p>&emsp;&emsp;人类总是有一些情绪化的本能，这些本能可能是进化的产物，也可能是耳熏目染之后的潜意识，不论如何，它们确实阻碍则我们去更好的认识这个世界。</p><br><h4 id="一分为二的本能"><a href="#一分为二的本能" class="headerlink" title="一分为二的本能"></a>一分为二的本能</h4><ul><li>人类总向把事情一分为二看待的冲动，而这两类又是互相对立、互相矛盾的。</li><li>例如：我们喜欢把世界上的国家分为社会主义国家和资本主义国家；把世界上的人分为穷人和富人。</li><li>如何防范一分为二的错误本能：<ul><li>避免只比较平均数，而是观察总体分布</li><li>避免之比较极端情况</li><li>避免只俯视，不仰视</li></ul></li></ul><br><h4 id="负面思维的本能"><a href="#负面思维的本能" class="headerlink" title="负面思维的本能"></a>负面思维的本能</h4><ul><li>我们对于坏事总会比好事更加关注</li><li>而媒体和社会活动家对于负面新闻会选择性地报道。</li><li>与我们自身而言，我们总是对自己经历过的不好的事记忆更深，同时还会因为有坏的事情发生，就不认为世界是在变好</li><li>如何防范负面思维的本能：<ul><li>认清我们更容易获得负面消息的事实，好消息的新闻价值不高</li><li>学会区分状态和趋势，同时相信事情可以同时不是好的，但也是在变得更好</li><li>认识到循序渐进的进步不会被当成新闻，而正式这种不断的进步让我们的社会变得更好</li></ul></li></ul><br><h4 id="直线思维的本能"><a href="#直线思维的本能" class="headerlink" title="直线思维的本能"></a>直线思维的本能</h4><ul><li>人们总倾向于相信事情是线性发展的</li><li>例如：看到一个人口增加的图就会想到人口会无限增加下去</li><li>如何避免直线思维的本能：<ul><li>不要做直线假设。很多事物的发展遵循的是S形曲线、滑梯曲线、驼峰曲线等规律</li></ul></li></ul><br><h4 id="恐惧的本能"><a href="#恐惧的本能" class="headerlink" title="恐惧的本能"></a>恐惧的本能</h4><ul><li>当我们陷入恐惧的时候，我们就无法看到现实。</li><li>我们总倾向于接受一些夸张的信息</li><li>如何避免恐惧的本能：<ul><li>我们需要更加理性，要计算真实的风险</li><li>认识到：你面临的真实风险，并不取决于它看起来多么吓人，而在于两个因素：危险的程度和发生的概率</li><li>采取行动之前，先让自己冷静下来</li></ul></li></ul><br><h4 id="规模错觉"><a href="#规模错觉" class="headerlink" title="规模错觉"></a>规模错觉</h4><ul><li>人们总是容易注意局部而忽略整体。我们总是会注意到一个单一的数字而误判它的重要性。</li><li>同时，我们还会系统性的高估了一些其他的比例</li><li>如何控制规模错觉：<ul><li>大的数字总是看起来很大，而单一的数字很容易误导我们，当我们看到单一数字的时候，一定要记得做对比。</li><li>二八原则</li><li>比例，更加关注比例而不是单一的数字</li></ul></li></ul><br><h4 id="以偏概全的本能"><a href="#以偏概全的本能" class="headerlink" title="以偏概全的本能"></a>以偏概全的本能</h4><ul><li>每个人都会在头脑中自动的进行演绎和归纳。但这种思维结构会让我们在遇到事情的事情倾向于将所有事情都归结为一类</li><li>一分为二的本能促使我们将世界分为“我们“和”它们“，而以偏概全的本能使得”我们“认为”他们“是完全一样的</li><li>如何避免以偏概全的本能：<ul><li>我们要经常性的质疑我们的分类方法</li><li>在同一类别中寻找不同</li><li>在不同类别中寻找相同</li><li>在不同类别中寻找不同</li><li>注意大多数</li><li>注意极端案例</li><li>不要假设别人是傻瓜</li></ul></li></ul><br><h4 id="相信命中注定的本能"><a href="#相信命中注定的本能" class="headerlink" title="相信命中注定的本能"></a>相信命中注定的本能</h4><ul><li>我们认为一些事物内在的属性将决定其命运，无论是人民、国家、宗教还是文化</li><li>如何控制命中注定的本能：<ul><li>注意追踪持续的提高，缓慢的改变也仍然是改变</li><li>及时更新你的知识</li><li>多与老年人对话</li></ul></li></ul><br><h4 id="单一视角的本能"><a href="#单一视角的本能" class="headerlink" title="单一视角的本能"></a>单一视角的本能</h4><ul><li>人们总倾向于认为所有的问题都有单一的原因和单一的解决方案</li><li>如何避免单一视角的本能：<ul><li>检查你的想法，多余不同意见的人讨论</li><li>不要相信你在自己的专业领域之外有什么真知灼见</li><li>避免在熟悉一种工具之后就倾向于使用该工具解决所有问题</li><li>关注数字，而且不仅仅关注数字</li><li>当心简单的想法和简单的解决方案</li></ul></li></ul><br><h4 id="归咎他人的本能"><a href="#归咎他人的本能" class="headerlink" title="归咎他人的本能"></a>归咎他人的本能</h4><ul><li>当坏事发生的时候，人们总是图找到一个清晰而简单的理由去责怪其他人</li><li>当好事发生的时候，这种本能也会被激发出来</li><li>如何控制归咎他人的本能：<ul><li>寻找原因，而不是寻找坏人</li><li>寻找系统，而不是寻找英雄</li></ul></li></ul><br><h4 id="情急生乱的本能"><a href="#情急生乱的本能" class="headerlink" title="情急生乱的本能"></a>情急生乱的本能</h4><ul><li>在我们感知到危险的时候，就立即采取行动</li><li>当这种本能被激活的时候，我们的大脑将会丧失思考的能力，而是顺从接收到的指令去行动</li><li>如何缓解情急生乱的本能：<ul><li>深呼吸</li><li>坚持了解基础数据</li><li>警惕那些带有偏见的预言家</li><li>小心过激的行动。通常循序渐进的方案会优于达到阔斧的行动</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书&amp;电影 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之路径总和Ⅱ</title>
      <link href="/passages/leetcode-zhi-lu-jing-zong-he-ii/"/>
      <url>/passages/leetcode-zhi-lu-jing-zong-he-ii/</url>
      
        <content type="html"><![CDATA[<p>Path Sum Ⅱ</p><a id="more"></a><h3 id="Path-Sum-Ⅱ"><a href="#Path-Sum-Ⅱ" class="headerlink" title="Path Sum Ⅱ"></a>Path Sum Ⅱ</h3><ul><li>code with Python </li><li>title number：113</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一棵二叉树，查找满足以下条件的路径<ul><li>路径从根节点到叶子节点</li><li>路径总和等于给定目标和</li></ul></li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>回溯法<ul><li>搜索所有路径，使用<code>temp_path</code>记录当前路径</li><li>在访问到叶节点时计算路径总和，若等于给定值则加入结果中</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pathSum</span><span class="params">(self, root: TreeNode, sum: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root, sum, temp)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="comment"># 到达叶节点，并且路径总和等于给定值</span></span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right <span class="keyword">and</span> sum-root.val == <span class="number">0</span>:</span><br><span class="line">            temp += [root.val]</span><br><span class="line">            res.append(temp)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        dfs(root.left, sum-root.val, temp+[root.val])</span><br><span class="line">        dfs(root.right, sum-root.val, temp+[root.val])</span><br><span class="line">    dfs(root, sum, [])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><ul><li>关于回溯法与深度优先搜索的区别，请参照<a href="http://www.zivblog.top/passages/hui-su-fa/" target="_blank" rel="noopener">回溯法</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之二叉树的锯齿形层次遍历</title>
      <link href="/passages/leetcode-zhi-er-cha-shu-de-ju-chi-xing-ceng-ci-bian-li/"/>
      <url>/passages/leetcode-zhi-er-cha-shu-de-ju-chi-xing-ceng-ci-bian-li/</url>
      
        <content type="html"><![CDATA[<p>Binary Tree Zigzag Level Order Traversal</p><a id="more"></a><h3 id="Binary-Tree-Zigzag-Level-Order-Traversal"><a href="#Binary-Tree-Zigzag-Level-Order-Traversal" class="headerlink" title="Binary Tree Zigzag Level Order Traversal"></a>Binary Tree Zigzag Level Order Traversal</h3><ul><li>code with Python</li><li>title number：103</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li><p>给定一个二叉树，返回起结点值的锯齿形层次遍历</p></li><li><p>即<strong>先从左往右</strong>，<strong>再从右往左</strong>进行下一层次遍历，一次类推，层与层之间交替进行</p></li><li><p>示例：</p><p><img src="/.top//Leetcode%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%5C1.png" alt></p></li><li><p>其锯齿形层次遍历为：<code>[[3], [20, 9], [15, 7]]</code></p></li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>按照<a href="http://www.zivblog.top/passages/leetcode-zhi-er-cha-shu-de-ceng-xu-bian-li/" target="_blank" rel="noopener">二叉树的层序遍历</a>的方法，求得正常情况下的层序遍历结果</li><li>再对结果进行后处理，即每隔一层逆置原来的遍历结果</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">zigzagLevelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    queue = [root]</span><br><span class="line">    res = []</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 得到常规的层序遍历结果</span></span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        len_ = len(queue)</span><br><span class="line">        res.append([])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len_):</span><br><span class="line">            node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> node.left: queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right: queue.append(node.right)</span><br><span class="line">            res[<span class="number">-1</span>].append(node.val)</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 调整</span></span><br><span class="line">    tag = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(res)):</span><br><span class="line">        <span class="keyword">if</span> tag:</span><br><span class="line">            res[i] = res[i][::<span class="number">-1</span>]</span><br><span class="line">            tag = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tag = <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li>上面的思路中进行<strong>后调整</strong>的做法，会额外的遍历一个结果集，并且需要对其中一半的层进行逆置，额外花费的很多时间</li><li>这里我们选择在存储一层结点的时候就按照<strong>正向</strong>或<strong>逆向</strong>方式存储，设置一个属性<code>tag</code>用于表示当前层是正向存储还是逆向存储</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">zigzagLevelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    queue, res = [root], []</span><br><span class="line">    tag = <span class="number">0</span><span class="comment"># 表示当前层正向or逆向存储</span></span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        res.append([])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">            node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> node.left: queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right: queue.append(node.right)</span><br><span class="line">            <span class="comment"># 正序 or 逆序</span></span><br><span class="line">            <span class="keyword">if</span> tag % <span class="number">2</span> ! = <span class="number">0</span>:</span><br><span class="line">                res[<span class="number">-1</span>].insert(<span class="number">0</span>, node.val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res[<span class="number">-1</span>].append(node.val)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之二叉树的层序遍历</title>
      <link href="/passages/leetcode-zhi-er-cha-shu-de-ceng-xu-bian-li/"/>
      <url>/passages/leetcode-zhi-er-cha-shu-de-ceng-xu-bian-li/</url>
      
        <content type="html"><![CDATA[<p>Binary Tree Level Order Traversal</p><a id="more"></a><h3 id="Binary-Tree-Level-Order-Traversal"><a href="#Binary-Tree-Level-Order-Traversal" class="headerlink" title="Binary Tree Level Order Traversal"></a>Binary Tree Level Order Traversal</h3><ul><li>code with Python</li><li>title number：102</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个二叉树，返回按<strong>层序遍历</strong>得到的结点值</li><li>返回的结果为嵌套列表，即<strong>每层的节点值</strong>分别用一个列表存储</li><li>层序遍历：即逐层的，从左往右访问所有节点</li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>层序遍历一棵树是树的基本操作，操作过程相当于<strong>BFS</strong><ul><li>利用以个队列来存储节点</li><li>每次遍历完一层之后判断当前队列中的结点数目（即下一层的结点数，出队该数量的结点，避免判断队列是否为空）</li></ul></li><li>具体操作：<ul><li>根节点入队</li><li>判断当前队列中有多少结点，一次出队并访问</li><li>判断其左右子树是否分别存在，存在则入队</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    queue = [root]</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        <span class="comment"># 当前层长度</span></span><br><span class="line">        len_ = len(queue)</span><br><span class="line">        res.append([])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len_):</span><br><span class="line">            node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            res[<span class="number">-1</span>].append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li>递归<ul><li>递归访问所有节点，对其左右子树也进行迭代访问</li><li>增加一个<code>depth</code>属性，用于标记结点所在的层数</li><li>将结点添加到其对应层的列表中</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">    res = []</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root, depth)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">if</span> len(res) == depth:</span><br><span class="line">            res.append([])</span><br><span class="line">        res[depth].append(root.val)</span><br><span class="line">        helper(root.left, depth + <span class="number">1</span>)</span><br><span class="line">        helper(root.right, depth + <span class="number">1</span>)</span><br><span class="line">    helper(root, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="思路三"><a href="#思路三" class="headerlink" title="思路三"></a>思路三</h4><ul><li>之前在<a href="http://www.zivblog.top/passages/leetcode-zhi-er-cha-shu-de-zhong-xu-bian-li/" target="_blank" rel="noopener">二叉树的中序遍历</a>提到过的<strong>颜色标记法</strong>，具体思路可看前文</li><li>在层序遍历中，需要加一个level属性用于标记层次</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">    w, g = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    stack = [(root, w, <span class="number">0</span>)]</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        node, color, level = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> node:</span><br><span class="line">            <span class="comment"># 结点未访问</span></span><br><span class="line">            <span class="keyword">if</span> color == w:</span><br><span class="line">                stack.append((node.right, w, level+<span class="number">1</span>))</span><br><span class="line">                stack.append((node.left, w, level+<span class="number">1</span>))</span><br><span class="line">                stack.append((node, g, level))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> len(res) == level:</span><br><span class="line">                    res.append([])</span><br><span class="line">                res[level].append(node.val)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之验证二叉搜索树</title>
      <link href="/passages/leetcode-zhi-yan-zheng-er-cha-sou-suo-shu/"/>
      <url>/passages/leetcode-zhi-yan-zheng-er-cha-sou-suo-shu/</url>
      
        <content type="html"><![CDATA[<p>Validate Binary Search Tree</p><a id="more"></a><h3 id="Validate-Binary-Search-Tree"><a href="#Validate-Binary-Search-Tree" class="headerlink" title="Validate Binary Search Tree"></a>Validate Binary Search Tree</h3><ul><li>code with Python</li><li>title number：098</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个二叉搜索树，判断其是否是一个有效的二叉搜索树</li><li>二叉搜索树特征如下：<ul><li>节点的左子树只包含<strong>小于</strong>当前节点的数</li><li>节点的右子树只包含<strong>大于</strong>当前节点的数</li><li>所有左子树和右子树自身也必须是二叉搜索树</li></ul></li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>根据二叉搜索树的性质，如果我们进行中序遍历，得到的应该是一个升序序列</li><li>因此，我们只需进行一次<strong>中序遍历</strong>，再对遍历得到的序列进行一次遍历<ul><li>如果存在相邻的两个元素为逆序，则不是二叉搜索树</li><li>否则，是二叉搜索树</li></ul></li><li>这个算法的主要优化点在<strong>遍历</strong>算法，可以尝试时间复杂度更低的，关于中序遍历，可以看<a href="http://www.zivblog.top/passages/leetcode-zhi-er-cha-shu-de-zhong-xu-bian-li/" target="_blank" rel="noopener">这道题</a>的解法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> root.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 中序遍历</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorder</span><span class="params">(root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        inorder(root.left)</span><br><span class="line">        res.append(root.val)</span><br><span class="line">        inorder(root.right)</span><br><span class="line">    inorder(root)</span><br><span class="line">    <span class="comment"># 判断是否有逆序对</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(res)<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> res[i] &gt;= res[i+<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li>最大最小值法<ul><li>由一个点的最大最小值来判断一个结点是否合法</li><li>从根节点进行<strong>DFS</strong>，然后计算每个节点应该的取值范围，如果当前节点不符合就返回 false</li><li>例如，<ul><li>左孩子的范围由<strong>父节点的左边界</strong>和<strong>父节点的值</strong>确定</li><li>右孩子的范围由<strong>父节点的值</strong>和<strong>父节点的右边界</strong>确定</li></ul></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root: TreeNode)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ds</span><span class="params">(root, min_, max_)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> root.val &lt;= min_ <span class="keyword">or</span> root.val &gt;= max_:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ds(root.left, min_, root.val) <span class="keyword">and</span> ds(root.right, root.val, max_)</span><br><span class="line">    <span class="keyword">return</span> ds(root, float(<span class="string">'-inf'</span>), float(<span class="string">"inf"</span>))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之不同的二叉搜索树</title>
      <link href="/passages/leetcode-zhi-bu-tong-de-er-cha-sou-suo-shu/"/>
      <url>/passages/leetcode-zhi-bu-tong-de-er-cha-sou-suo-shu/</url>
      
        <content type="html"><![CDATA[<p>Unique Binary Search Trees</p><a id="more"></a><h3 id="Unique-Binary-Search-Trees"><a href="#Unique-Binary-Search-Trees" class="headerlink" title="Unique Binary Search Trees"></a>Unique Binary Search Trees</h3><ul><li>code with Python</li><li>title number：096</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个整数<code>n</code>，求以<code>1~n</code>为节点组成的二叉搜索树有多少种</li><li>示例：<ul><li>输入：3</li><li>输出：5</li><li>具体而言：</li></ul></li></ul><img src="/.top//1.png" style="zoom:95%;"><ul><li>该题是<strong>不同的二叉搜索树Ⅱ</strong>的简化版，详细的思路讲解请看<a href="http://www.zivblog.top/passages/leetcode-zhi-bu-tong-de-er-cha-sou-suo-shu-ii/" target="_blank" rel="noopener">这里</a></li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>动态规划</li><li>定义<code>dp[i]</code>表示i个结点可以有多少种不同结构的二叉树</li><li>初始化<code>dp[1]=1</code></li><li>状态转移方程：<code>dp[n]=dp[0]*dp[n-1] + dp[1]*dp[n-2] + dp[n-1]*dp[0]</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numTrees</span><span class="params">(self, n)</span>:</span></span><br><span class="line">    dp = [<span class="number">1</span>]*(n+<span class="number">1</span>)</span><br><span class="line">    i = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= n:</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>):</span><br><span class="line">            res += dp[j] * dp[i-j<span class="number">-1</span>]</span><br><span class="line">        dp[i] = res</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之不同的二叉搜索树Ⅱ</title>
      <link href="/passages/leetcode-zhi-bu-tong-de-er-cha-sou-suo-shu-ii/"/>
      <url>/passages/leetcode-zhi-bu-tong-de-er-cha-sou-suo-shu-ii/</url>
      
        <content type="html"><![CDATA[<p>Unique Binary Search Trees Ⅱ</p><a id="more"></a><h3 id="Unique-Binary-Search-Trees-Ⅱ"><a href="#Unique-Binary-Search-Trees-Ⅱ" class="headerlink" title="Unique Binary Search Trees Ⅱ"></a>Unique Binary Search Trees Ⅱ</h3><ul><li>code with Python</li><li>title number：095</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li><p>给定一个整数，生成由<code>1, ..., n</code>为结点的<strong>二叉搜索树</strong></p></li><li><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：3</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">[1, null, 3, 2],</span><br><span class="line">[3, 2, null, 1],</span><br><span class="line">[3, 1, null, null, 2],</span><br><span class="line">[2, 1, 3],</span><br><span class="line">[1, null, 2, null, 3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>对应于以下五种不同结构的二叉搜索树</p><img src="/.top//1.png" style="zoom:100%;"></li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>首先，我们要了解<strong>二叉搜索树</strong>的一个比较好的性质，即在左右子树不为空时：<ul><li>左子树中的值均小于根节点的值</li><li>右子树中的值均大于根节点的值</li></ul></li><li>根据二叉树的性质，我们可以使用<strong>递归</strong>的方式来构建二叉搜索树<ul><li>遍历列表<code>1, ...,n</code>，尝试将每一个结点作为根节点，其左边的子列表作为左子树，右边的自列表作为右子树</li><li>对左右子树进行同样的处理</li><li>至列表只剩一个数或列表为空</li></ul></li><li>例如：把 1 作为根节点，[ ] 空作为左子树，[ 2 … n ] 的所有可能作为右子树；2 作为根节点，[ 1 ] 作为左子树，[ 3…n ] 的所有可能作为右子树</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span><span class="params">(self, n: int)</span> -&gt; List[TreeNode]:</span></span><br><span class="line">    <span class="comment"># n为0</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getAns</span><span class="params">(start, end)</span>:</span></span><br><span class="line">        ans = []</span><br><span class="line">  <span class="comment"># 子列表为空格</span></span><br><span class="line">        <span class="keyword">if</span> start &gt; end:</span><br><span class="line">            <span class="keyword">return</span> [<span class="literal">None</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历列表，尝试将每个元素都作为根结点</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(start, end+<span class="number">1</span>):</span><br><span class="line">            left_tree = getAns(start, i<span class="number">-1</span>)</span><br><span class="line">            right_tree = getAns(i+<span class="number">1</span>, end)</span><br><span class="line">            <span class="keyword">for</span> node_l <span class="keyword">in</span> left_tree:</span><br><span class="line">                <span class="keyword">for</span> node_r <span class="keyword">in</span> right_node:</span><br><span class="line">                    root = TreeNode(i)</span><br><span class="line">                    root.left = node_l</span><br><span class="line">                    root.right = node_r</span><br><span class="line">                    ans.append(root)</span><br><span class="line"><span class="keyword">return</span> ans</span><br><span class="line">                    </span><br><span class="line">    <span class="keyword">return</span> getAns(<span class="number">1</span>, n)</span><br></pre></td></tr></table></figure><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li>其实还可以用<strong>动态规划</strong>解决<ul><li>定义<code>dp[i][j]</code>表示第<code>i~j</code>个数字的所有可能情况，所以<code>dp[1][n]</code>即为结果集</li><li>初始化：若<code>i==j</code>则添加结点<code>val</code>，<code>i&gt;j</code>初始化为空列表，其他情况初始化为<code>[None]</code></li><li>状态转移方程，<code>dp[i][j] = dp[i+1][j]+...dp[j[j]]</code>（<code>i~j</code>之间每个值为顶点的情况之和）</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span><span class="params">(self, n: int)</span> -&gt; List[TreeNode]:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    dp = []</span><br><span class="line">    <span class="comment"># 初始化dp数组</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n+<span class="number">1</span>):</span><br><span class="line">        dp.append([])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i == j:</span><br><span class="line">                dp[i].append([TreeNode(i)])</span><br><span class="line">            <span class="keyword">elif</span> i &lt; j:</span><br><span class="line">                dp[i].append([])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i].append([<span class="literal">None</span>])</span><br><span class="line">                </span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = [<span class="literal">None</span>]</span><br><span class="line">    <span class="comment"># 反向遍历</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># i~j每个结点为顶点的情况</span></span><br><span class="line">            <span class="keyword">for</span> r <span class="keyword">in</span> range(i, j+<span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 边界判断</span></span><br><span class="line">                left = r+<span class="number">1</span> <span class="keyword">if</span> r &lt; j <span class="keyword">else</span> r</span><br><span class="line">                <span class="comment"># 左右子树的排列组合</span></span><br><span class="line">                <span class="keyword">for</span> x <span class="keyword">in</span> dp[i][r<span class="number">-1</span>]:</span><br><span class="line">                    <span class="keyword">for</span> y <span class="keyword">in</span> dp[left][j]：</span><br><span class="line">                    node = TreeNode(r)</span><br><span class="line">                    node.left = x</span><br><span class="line">                    node.right = y</span><br><span class="line">                        <span class="keyword">if</span> r == j:</span><br><span class="line">                            node.right = <span class="literal">None</span></span><br><span class="line">                        <span class="comment"># 添加结果</span></span><br><span class="line">                        dp[i][j].append(node)</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">1</span>][n]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之二叉树的中序遍历</title>
      <link href="/passages/leetcode-zhi-er-cha-shu-de-zhong-xu-bian-li/"/>
      <url>/passages/leetcode-zhi-er-cha-shu-de-zhong-xu-bian-li/</url>
      
        <content type="html"><![CDATA[<p>Binary Tree Inorder Traversal</p><a id="more"></a><h3 id="Binary-Tree-Inorder-Traversal"><a href="#Binary-Tree-Inorder-Traversal" class="headerlink" title="Binary Tree Inorder Traversal"></a>Binary Tree Inorder Traversal</h3><ul><li>code with Python</li><li>title number：094</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个二叉树，返回按照中序遍历得到的结点序列</li><li>二叉树结点</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br></pre></td></tr></table></figure><ul><li>请尝试使用迭代的方式解决该问题</li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>递归遍历，左-&gt;根-&gt;右</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorder</span><span class="params">(root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        inorder(root.left)</span><br><span class="line">    res.append(root.val)</span><br><span class="line">        inorder(root.right)</span><br><span class="line">        </span><br><span class="line">    inorder(root)   </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li>鉴于递归效率会比较低，现使用迭代（借助栈）解决<ul><li>使用栈存储结点</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">    res = []</span><br><span class="line">    stack = []<span class="comment"># 辅助栈</span></span><br><span class="line">    p = root<span class="comment"># 指针</span></span><br><span class="line">    <span class="comment"># p或栈为空时</span></span><br><span class="line">    <span class="keyword">while</span> p <span class="keyword">or</span> stack:</span><br><span class="line">        <span class="comment"># 左子树不断入栈</span></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            stack.append(p)</span><br><span class="line">            p = p.left</span><br><span class="line">            </span><br><span class="line">        p = stack.pop()</span><br><span class="line">        res.append(p.val)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 访问右子树</span></span><br><span class="line">        p = p.right</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="思路三"><a href="#思路三" class="headerlink" title="思路三"></a>思路三</h4><ul><li>在题解中看到了一种比较有趣的方法，作者为其取名<strong>颜色标记法</strong><ul><li>使用颜色标记结点的状态：新结点：白色；已访问结点：灰色。</li><li>遇到白色结点，将其标记为灰色并将其右结点，自身，左结点入栈（顺序与中序遍历恰好相反，在出栈时即为中序）</li><li>遇到灰色结点，则输出结点</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">    w, g = <span class="number">0</span>, <span class="number">1</span><span class="comment"># 白色&amp;灰色</span></span><br><span class="line">    res = []</span><br><span class="line">    stack = [(w, root)]</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        color, node = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> color == w:</span><br><span class="line">            stack.append((w, node.right))</span><br><span class="line">            stack.append((g, node))</span><br><span class="line">            stack.append((w, node.left))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res.append(node.val)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><ul><li>事实上，这种方法能推广到<code>前序</code>，<code>后续</code>，区别在于调整入栈时的顺序即可</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之反转链表Ⅱ</title>
      <link href="/passages/leetcode-zhi-fan-zhuan-lian-biao-ii/"/>
      <url>/passages/leetcode-zhi-fan-zhuan-lian-biao-ii/</url>
      
        <content type="html"><![CDATA[<p>Reverse Linked List Ⅱ</p><a id="more"></a><h3 id="Reverse-Linked-List-Ⅱ"><a href="#Reverse-Linked-List-Ⅱ" class="headerlink" title="Reverse Linked List Ⅱ"></a>Reverse Linked List Ⅱ</h3><ul><li>code with Python</li><li>title number：092</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li><p>给定一个链表和两个值表示链表中的两个位置</p></li><li><p>反转两个位置之间的链表</p></li><li><p>请使用一趟扫描完成反转</p></li><li><p>示例：</p><blockquote><p>输入：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; null, m=2, n=4</p><p>输出：1 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; null</p></blockquote></li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li><p>题目要求只能进行一趟扫描，主要的解题思路是：</p><ul><li>反转中间部分，再与其余两端不变的部分进行拼接</li></ul></li><li><p>参照上方的示例，</p><ul><li>对位置2~4之间的链表进行反转</li><li>再将1和5两段拼接上去</li><li>两个关键位置，即1和5需要用指针记下来</li></ul></li><li><p>注意不能直接返回<code>head</code>，当<code>m=1</code>时会出错，所以需要设置一个虚拟节点指向<code>head</code></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span><span class="params">(self, head: ListNode, m: int, n: int)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> m == n:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    </span><br><span class="line">    first = ListNode(<span class="number">0</span>)</span><br><span class="line">    first.next = head</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 记录拼接点</span></span><br><span class="line">    before_m, after_n = first, <span class="literal">None</span></span><br><span class="line">    <span class="comment"># 记录反转后的链表</span></span><br><span class="line">    between_mn_head, between_mn_end = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    cur_node = first</span><br><span class="line">    <span class="keyword">while</span> index &lt; n:</span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line">        cur_node == cur_node.next</span><br><span class="line"><span class="comment"># 找到位置m</span></span><br><span class="line">        <span class="keyword">if</span> index == m<span class="number">-1</span>:</span><br><span class="line">            before_m = cur_node</span><br><span class="line">        <span class="keyword">elif</span> index == m:</span><br><span class="line">            <span class="comment"># 当前的头是反转后的尾</span></span><br><span class="line">            between_mn_end = ListNode(cur_node.val)</span><br><span class="line">            between_mn_head = between_mn_end</span><br><span class="line">        <span class="keyword">elif</span> index &gt; m:</span><br><span class="line">            <span class="comment"># 需要反转的子链表</span></span><br><span class="line">            temp = between_mn_head</span><br><span class="line">            between_mn_head = ListNode(cur_node.val)</span><br><span class="line">            between_mn_head.next = temp</span><br><span class="line">            <span class="keyword">if</span> index == n:</span><br><span class="line">                after_n = cur_node.next</span><br><span class="line">    <span class="comment"># 拼接</span></span><br><span class="line">    between_mn_end.next = after_n</span><br><span class="line">    before_m.next = between_mn_head</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> first.next</span><br></pre></td></tr></table></figure><br><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li>2020.6.27更新</li><li>对比上面的方法，该方法不需要记录区间的前后两个位置</li><li>通过不断向区间的前驱位置插入节点的方式进行反转</li><li>通过循环遍历区间内部的节点</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span><span class="params">(self, head: ListNode, m: int, n: int)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    由于第一个节点也可能在区间内部，所以需要使用dummy节点</span></span><br><span class="line"><span class="string">    定位到指定区间位置 的 前一个位置</span></span><br><span class="line"><span class="string">    不断将后面的节点插入到区间前去节点的后面</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    </span><br><span class="line">    dummy_node = TreeNode(<span class="number">0</span>)</span><br><span class="line">    dummy_node.next = head</span><br><span class="line">    </span><br><span class="line">    pre = dummy_node</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 找到区间的前驱节点</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> ragne(<span class="number">1</span>, n):</span><br><span class="line">        pre = pre.next</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 交换区间的头部，会更新</span></span><br><span class="line">    part_head = pre.next</span><br><span class="line">    <span class="comment"># 交换区间的初始头部</span></span><br><span class="line">    head_ = pre.next</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m, n):</span><br><span class="line">        temp = head_.next</span><br><span class="line">        pre.next = temp.next</span><br><span class="line">        head_.next = part_head</span><br><span class="line">        temp.next = part_head</span><br><span class="line">        <span class="comment"># 更新头部</span></span><br><span class="line">        part_head = temp</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> dummy_node.next</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之解码方法</title>
      <link href="/passages/leetcode-zhi-jie-ma-fang-fa/"/>
      <url>/passages/leetcode-zhi-jie-ma-fang-fa/</url>
      
        <content type="html"><![CDATA[<p>Decode Ways</p><a id="more"></a><h3 id="Decode-Ways"><a href="#Decode-Ways" class="headerlink" title="Decode Ways"></a>Decode Ways</h3><ul><li>code with Python</li><li>title number：091</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li><p>一条包含字母<code>A</code>~<code>Z</code>的消息通过一下方式进行编码：</p><ul><li><code>A</code>-&gt; <code>1</code></li><li><code>B</code> -&gt; <code>2</code></li><li>…</li><li><code>Z</code> -&gt; <code>26</code></li></ul></li><li><p>给定一个只包含数字的非空字符串，计算该字符串的解码方法总数</p></li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li><p>小朋友，不知道你是否联想到了<strong>爬楼梯问题</strong></p></li><li><p>显然，这是一道<strong>动态规划</strong>的题目</p></li><li><p>分析一下：</p><ul><li>我们可能的编码一共有26种，可以分为两类：<ul><li><code>1~9</code>的一个数字的情况</li><li><code>10~26</code>的两个数字的情况</li></ul></li><li>划分子问题<ul><li>当前元素位一种可能</li><li>当前元素与前一个元素是否组成范围内（<code>10~26</code>）的两位数</li></ul></li></ul></li><li><p><code>dp[i]</code>表示到第<code>i</code>个位置时可能的解码方法总数</p></li><li><p>初始化：<code>dp[0]=0, dp[1]=1</code></p></li><li><p>状态转移方程：<code>dp[i] = dp[i-1]+dp[i-2]</code> ，即最后两个一起解码or单独一个解码</p></li><li><p>结束条件：<code>i == len(nums)-1</code>，即数组被遍历完</p></li><li><p>注意：</p><ul><li>当字符串以<code>0</code>开头时是无法解码的</li><li>当字符串以大于<code>2</code>的数组开头时是无法解码的</li><li>当前两位大于<code>26</code>时是无法解码的</li><li>在字符串中间碰到<code>0</code>的时候要判断前一位是否为<code>1</code>或<code>2</code>，否则返回<code>0</code></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numDecodings</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">'0'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> len(s) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    dp = [<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s)):</span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">'0'</span>:</span><br><span class="line">            <span class="comment"># 30以上</span></span><br><span class="line">            <span class="keyword">if</span> s[i<span class="number">-1</span>] != <span class="string">'1'</span> <span class="keyword">and</span> s[i<span class="number">-1</span>] != <span class="string">'2'</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">1</span>:</span><br><span class="line">                    dp.append(<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp.append(dp[i<span class="number">-2</span>])</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># 10~19</span></span><br><span class="line">        <span class="keyword">if</span> s[i<span class="number">-1</span>] == <span class="string">'1'</span>:</span><br><span class="line">            dp.append(dp[i<span class="number">-2</span>]+dp[i<span class="number">-1</span>])</span><br><span class="line">        <span class="comment"># 20~26</span></span><br><span class="line">        <span class="keyword">elif</span> s[i<span class="number">-1</span>] == <span class="string">'2'</span> <span class="keyword">and</span> s[i] &gt;= <span class="string">'1'</span> <span class="keyword">and</span> s[i]&lt;=<span class="string">'6'</span>:</span><br><span class="line">            dp.append(dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>])</span><br><span class="line">        <span class="comment"># 1~9</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dp.append(dp[i<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之子集Ⅱ</title>
      <link href="/passages/leetcode-zhi-zi-ji-ii/"/>
      <url>/passages/leetcode-zhi-zi-ji-ii/</url>
      
        <content type="html"><![CDATA[<p>Subset Ⅱ</p><a id="more"></a><h3 id="Subset-Ⅱ"><a href="#Subset-Ⅱ" class="headerlink" title="Subset Ⅱ"></a>Subset Ⅱ</h3><ul><li>code with Python</li><li>title number：090</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个可能包含重复元素的整数数组，返回该数组包含的所有可能的子集</li><li>结果中不能包含重复的子集</li></ul><h4 id="题目理解"><a href="#题目理解" class="headerlink" title="题目理解"></a>题目理解</h4><ul><li><p>输入中包含重复元素，而结果不允许有重复元素，根据之前的题目的经验，我们对数组进行<strong>排序</strong>，目的是将所有相同的元素聚集到一起，以便于进行去重操作</p></li><li><p>这是一道进阶版的递归or回溯的题目，下面的几种思路均基于递归</p></li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li><p>子集的最大长度即数组的长度，对于<strong>子集中每个位置</strong>枚举所有可能</p></li><li><p>以示例<code>[1, 2, 2]</code>为例，见下图</p><img src="/.top//1.png" style="zoom: 67%;"></li><li><p>见上图，由空集出发，每一条子路径代表一个解，并且我们要对包含的重复项进行去重操作</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subsetsWithDup</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">    nums.sort()</span><br><span class="line">n = len(nums)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, tmp)</span>:</span></span><br><span class="line">    res.append(tmp)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> i == n:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, n):</span><br><span class="line">            <span class="keyword">if</span> j &gt; i <span class="keyword">and</span> nums[j] == nums[j<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            dfs(j+<span class="number">1</span>, tmp+[nums[j]])</span><br><span class="line">    res = []</span><br><span class="line">    dfs(<span class="number">0</span>, [])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li><p>对数组中每个位置有两种操作：选择 or 不选择，以此构建树型结构</p></li><li><p>以示例<code>[1, 2, 2]</code>为例，见下图</p><img src="/.top//2.png" style="zoom:67%;"></li><li><p>见上图，由空集出发，这次我们只需要从叶节点中挑选（去除重复）结果即可</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subsetsWithDup</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">    nums.sort()</span><br><span class="line">    n = len(nums)</span><br><span class="line">    </span><br><span class="line">    res = [[]]</span><br><span class="line">    pre = []<span class="comment"># 保存重复数字对应的子集</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="comment"># 重复元素</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i]==nums[i<span class="number">-1</span>]:</span><br><span class="line">            pre = [tmp+[nums[i]] <span class="keyword">for</span> tmp <span class="keyword">in</span> pre]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pre = [tmp+[nums[i]] <span class="keyword">for</span> tmp <span class="keyword">in</span> res]</span><br><span class="line">            </span><br><span class="line">        res += pre</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="思路三"><a href="#思路三" class="headerlink" title="思路三"></a>思路三</h4><ul><li><p>对于数组中的每一个值（可能有多个相同值的元素），列举每个值的所有可能，构建树型结构</p></li><li><p>以示例<code>[1, 2, 2]</code>为例，见下图</p><img src="/.top//3.png" style="zoom:67%;"></li><li><p>见上图，</p><ul><li>元素<code>1</code>有两种可能，即选0个或1个</li><li>元素<code>2</code>有三种可能，即选0个或1个或2个</li></ul></li><li><p>所有的结果都在叶节点中，而且不包含重复项，即只需返回所有叶节点的集合即可</p></li><li><p>具体而言，我们可以先统计每个元素的个数，然后进行组合即可</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> copy <span class="keyword">import</span> copy</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subsetsWithDup</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">    dict = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> dict:</span><br><span class="line">            dict[i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dict[i] += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    res = [[]]</span><br><span class="line">    <span class="keyword">for</span> i, v <span class="keyword">in</span> dict.items():</span><br><span class="line">        tmp = res.copy()</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> res:</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(v):</span><br><span class="line">            tmp.append(j+[i]*(k+<span class="number">1</span>))</span><br><span class="line">        res = tmp</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之分割链表</title>
      <link href="/passages/leetcode-zhi-fen-ge-lian-biao/"/>
      <url>/passages/leetcode-zhi-fen-ge-lian-biao/</url>
      
        <content type="html"><![CDATA[<p>Partition List</p><a id="more"></a><h3 id="Partition-List"><a href="#Partition-List" class="headerlink" title="Partition List"></a>Partition List</h3><ul><li>code with Python</li><li>title number：086</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li><p>给定一个链表和一个特定值<code>x</code></p></li><li><p>对链表进行分割，使得所有小于<code>x</code>的结点都在大于或等于<code>x</code>的结点<strong>之前</strong></p></li><li><p>保留两个分区中每个结点的<strong>初始相对位置</strong></p></li><li><p>示例</p><blockquote><p>输入：<code>head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3</code></p><p>输出：<code>1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</code></p></blockquote></li></ul><h4 id="题目理解"><a href="#题目理解" class="headerlink" title="题目理解"></a>题目理解</h4><ul><li><p>值得注意的是，题目的要求并<strong>不是用给定元素来将链表分割为前小后大的两部分</strong></p></li><li><p>而是<strong>将所有小于给定值的元素移动到大于等于给定元素的前面</strong>。即只需要将小于的部分移动到链表的头部即可，并且不能改变<strong>相对位置</strong></p></li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li><p>因为要求相对位置不能改变，所以不能通过交换链表中结点的值来完成该要求</p></li><li><p>设置两个虚拟节点<code>head1, head2</code>（使用两个链表），将小于给定值的结点链接到<code>head1</code>后，将大于等与给定值的结点链接到<code>head2</code>后</p></li><li><p>最后将两个链表二放到链表一之后</p></li><li><p>注意将链表二最后一个结点的<code>next</code>置为<code>None</code></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, head: ListNode, x: int)</span> -&gt; ListNode:</span></span><br><span class="line">    head1 = ListNode(<span class="number">-1</span>)</span><br><span class="line">    head2 = ListNode(<span class="number">-1</span>)</span><br><span class="line">    </span><br><span class="line">    cur = head</span><br><span class="line">    cur1, cur2 = head1, head2</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> cur.val &lt; x:</span><br><span class="line">    cur1.next = cur</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur2.next = cur</span><br><span class="line">    cur2.next = <span class="literal">None</span></span><br><span class="line">    cur1.next = head2.next</span><br><span class="line">    <span class="keyword">return</span> head1.next</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之删除排序数组中的重复项Ⅱ</title>
      <link href="/passages/leetcode-zhi-shan-chu-pai-xu-shu-zu-zhong-de-chong-fu-xiang-ii/"/>
      <url>/passages/leetcode-zhi-shan-chu-pai-xu-shu-zu-zhong-de-chong-fu-xiang-ii/</url>
      
        <content type="html"><![CDATA[<p>Remove Duplicates from Sorted Array</p><a id="more"></a><h3 id="Remove-Duplicates-from-Sorted-Array"><a href="#Remove-Duplicates-from-Sorted-Array" class="headerlink" title="Remove Duplicates from Sorted Array"></a>Remove Duplicates from Sorted Array</h3><ul><li>code with Python</li><li>title number：080</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li><p>给定一个<strong>排序数组</strong>，原地删除重复出现的元素，使得每个元素最多出现两次（多于2个的，删除到剩2个，不足2个的不予删除）</p></li><li><p>返回移除后数组的新<strong>长度</strong></p></li><li><p>示例：</p><blockquote><p>nums = [1, 1, 1, 2, 2, 3]</p><p>函数应返回新长度5，并返回原数组的前五个元素为：1, 1, 2, 2, 3</p><p>无需考虑数组中超出新长度后面的元素</p></blockquote></li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>由于是排序之后的数组，所以相同的元素必定出现在一起</li><li>直接对数组中重复次数多于2的元素删除多余项<ul><li>使用单指针，用于遍历</li><li>使用一个计数变量<code>count</code>记录当前项的重复次数</li></ul></li><li>注意：直接在数组上删除了元素会导致数组长度变化，从而带来访问越界的问题。所以在每次删除元素之后要使<code>i--</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    <span class="comment"># 直接原地删除重复元素</span></span><br><span class="line">    i, count = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> i &lt; len(nums):</span><br><span class="line">        <span class="keyword">if</span> nums[i] == nums[i<span class="number">-1</span>]:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> count &gt; <span class="number">2</span>:</span><br><span class="line">                nums.pop(i)</span><br><span class="line"><span class="comment"># 防止数组越界</span></span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 新元素，重新计数</span></span><br><span class="line">            count = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> len(nums)</span><br></pre></td></tr></table></figure><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li>覆盖重复元素，便利列表，将符合数目要求个数的元素依次放到<strong>数组头部位置</strong><ul><li>使用双指针，<code>i</code>用于遍历数组，<code>j</code>用于指示最终符合条件子数组的尾部</li><li>使用计数变量<code>count</code>记录当前项的个数</li><li>返回<code>j</code></li></ul></li><li>并没有修改数组长度，只是使用符合条件的子数组覆盖掉了数组中的内容</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    j, count = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] == nums[i<span class="number">-1</span>]:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            count = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> count &lt;= <span class="number">2</span>:</span><br><span class="line">            nums[j] = nums[i]</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> j</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之单词搜索</title>
      <link href="/passages/leetcode-zhi-dan-ci-sou-suo/"/>
      <url>/passages/leetcode-zhi-dan-ci-sou-suo/</url>
      
        <content type="html"><![CDATA[<p>Word Search</p><a id="more"></a><h3 id="Word-Search"><a href="#Word-Search" class="headerlink" title="Word Search"></a>Word Search</h3><ul><li>code with Python</li><li>title number：079</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个二维网格和一个单词，判断该单词是否存在与网格中</li><li>所谓<strong>存在于网格中</strong>，即需要使用网格中相邻字母组成单词（上下相邻或左右相邻）</li><li>字母不允许被重复使用</li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li><p><strong>DFS</strong></p></li><li><p>首先应该明确，所谓相邻可以是<strong>左右相邻</strong>，也可以是<strong>上下相邻</strong>。并且这种相邻是<strong>双向的</strong>，也就是可以是从左到右，也可以是从右到左</p></li><li><p>其次，要明确符合单词首个单词的位置并非只有一个，所以要用一个双循环来查找所有的起始可能</p></li><li><p>再次，避免字母被重复使用，进行一次遍历，对使用过的字母进行<code>mask</code>操作，在进行完当前深度搜索之后再恢复</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exist</span><span class="params">(self, board: List[List[str]], word: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="comment"># 找到start point</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(board[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> self.helper(board, i, j, word, <span class="number">0</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, board, i, j, word, wordIndex)</span>:</span></span><br><span class="line">        <span class="comment"># 能够找到整个单词</span></span><br><span class="line">        <span class="keyword">if</span> wordIndex == len(word):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= len(board) <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> j &gt;= len(board[<span class="number">0</span>]) <span class="keyword">or</span> board[i][j] != word[wordIndex]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># mask当前位置的元素，防止重复使用</span></span><br><span class="line">        board[i][j] = <span class="string">'#'</span></span><br><span class="line"></span><br><span class="line">        found = self.helper(board, i+<span class="number">1</span>, j, word, wordIndex+<span class="number">1</span>)\</span><br><span class="line">        <span class="keyword">or</span> self.helper(board, i, j+<span class="number">1</span>, word, wordIndex+<span class="number">1</span>)\</span><br><span class="line">                <span class="keyword">or</span> self.helper(board, i<span class="number">-1</span>, j, word, wordIndex+<span class="number">1</span>)\</span><br><span class="line">                <span class="keyword">or</span> self.helper(board, i, j<span class="number">-1</span>, word, wordIndex+<span class="number">1</span>)</span><br><span class="line">                </span><br><span class="line">        board[i][j] = word[wordIndex]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> found</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之子集</title>
      <link href="/passages/leetcode-zhi-zi-ji/"/>
      <url>/passages/leetcode-zhi-zi-ji/</url>
      
        <content type="html"><![CDATA[<p>Subsets</p><a id="more"></a><h3 id="Subsets"><a href="#Subsets" class="headerlink" title="Subsets"></a>Subsets</h3><ul><li>code with Python</li><li>title number：078</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一组<strong>不含重复元素</strong>的整数数组，返回该数组所有的子集</li><li>空集是任何集合的子集</li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>求集合，而非求极值，所以我们选择<strong>回溯法</strong>而不是<strong>动态规划</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subsets</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">    res = []</span><br><span class="line">    length = len(nums)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(i, temp)</span>:</span></span><br><span class="line">        res.append(temp)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, length):</span><br><span class="line">            backtrack(j+<span class="number">1</span>, temp+[nums[j]])</span><br><span class="line">    backtrack(<span class="number">0</span>, [])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li>在评论区看到了一个比较有意思的解法</li><li>从后往前遍历，每遍历一个数，就将这个数加到当前结果集中所有已得子集上，组成新的子集</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Subsets</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">    res = [[]]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 反向遍历</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> sub <span class="keyword">in</span> res[:]:</span><br><span class="line">            res.append(sub+[nums[i]])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><ul><li>事实证明，正向遍历也是可以的</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Subsets</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">    res = [[]]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 反向遍历</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        <span class="keyword">for</span> sub <span class="keyword">in</span> res[:]:</span><br><span class="line">            res.append(sub+[nums[i]])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之颜色分类</title>
      <link href="/passages/leetcode-zhi-yan-se-fen-lei/"/>
      <url>/passages/leetcode-zhi-yan-se-fen-lei/</url>
      
        <content type="html"><![CDATA[<p>Sort Colors</p><a id="more"></a><h3 id="Sort-Colors"><a href="#Sort-Colors" class="headerlink" title="Sort Colors"></a>Sort Colors</h3><ul><li>code with Python</li><li>title number：075</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个包含红、白、蓝三种颜色，一共n个元素的数组，对其进行<strong>原地排序</strong></li><li>使得相同颜色的元素相邻，并且按照红、白、蓝的顺序排列</li><li>使用<code>0</code>、<code>1</code>、<code>2</code>表示三种颜色</li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li><p>比较直接的想法是，遍历数组，统计<code>0,1,2</code>的个数分别为<code>nums1, nums2, nums3</code></p></li><li><p>再次遍历数组，将数组中的元素按照每一种颜色的个数重置</p></li><li><p>数组需要遍历两遍</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortColors</span><span class="params">(self, nums: List[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">r, w, b = <span class="number">0</span>, <span class="number">0</span> , <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] == <span class="number">0</span>:</span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[i] == <span class="number">1</span>:</span><br><span class="line">            w += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            b += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(r):</span><br><span class="line">        nums[i] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(r, r+w):</span><br><span class="line">        nums[i] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(r+w, r+w+b):</span><br><span class="line">        nums[i] = <span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li><p>本题其实就是比较经典的<strong>荷兰国旗</strong>问题</p></li><li><p>对于这种问题，我们使用<strong>三指针</strong>解决，只需<strong>遍历数组一遍</strong></p></li><li><p>将数组分为三部分，只需将两侧的两部分排好序，中间部分自然就排好了</p></li><li><p>指针<code>cur</code>用于遍历数组，指针<code>pre</code>用于标识第一部分的尾部位置，指针<code>tail</code>用于标识第三部分的头部位置</p></li><li><p>事实上都无需将所有元素都遍历一遍，当<code>cur</code>和<code>tail</code>相遇之后，即可停止了</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortColors</span><span class="params">(self, nums: List[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    cur, pre, tail = <span class="number">0</span>, <span class="number">0</span>, len(nums)<span class="number">-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> cur &lt;= tail:</span><br><span class="line">        <span class="keyword">if</span> nums[cur] == <span class="number">0</span>:</span><br><span class="line">            nums[cur], nums[pre] = nums[pre], nums[cur]</span><br><span class="line">        pre += <span class="number">1</span></span><br><span class="line">            cur += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[cur] == <span class="number">2</span>:</span><br><span class="line">            nums[cur], nums[tail] = nums[tail], nums[cur]</span><br><span class="line">tail -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur += <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之矩阵置零</title>
      <link href="/passages/leetcode-zhi-ju-zhen-zhi-ling/"/>
      <url>/passages/leetcode-zhi-ju-zhen-zhi-ling/</url>
      
        <content type="html"><![CDATA[<p>Set Matrix Zeroes</p><a id="more"></a><h3 id="Set-Matrix-Zeroes"><a href="#Set-Matrix-Zeroes" class="headerlink" title="Set Matrix Zeroes"></a>Set Matrix Zeroes</h3><ul><li>code with Python</li><li>title number：073</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个<code>m*n</code>的矩阵，如果一个元素为0，则将其所在的行和列的所有元素都设为0</li><li>请使用<strong>原地</strong>算法</li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>最先想到的是暴力解决的方法<ul><li>即遍历整个矩阵，记录为<code>0</code>的元素的行号和列号（这需要使用<code>m+n</code>的额外空间）</li><li>再次遍历矩阵，判断当前元素是否与元素<code>0</code>同行或同列，若是，则置为<code>0</code></li></ul></li><li>如果使用<code>set</code>来存储为<code>0</code>元素的行列号，可以在矩阵不止一个<code>0</code>的时候省去一点空间</li><li>由于要求使用<strong>原地算法</strong>，这种方法不提倡使用</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setZeroes</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">rows, cols = set(), set()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>])):</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] == <span class="number">0</span>:</span><br><span class="line">                rows.add(i)</span><br><span class="line">                cols.add(j)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>])):</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> rows <span class="keyword">or</span> j <span class="keyword">in</span> cols:</span><br><span class="line">                matrix[i][j] = <span class="number">0</span></span><br></pre></td></tr></table></figure><ul><li>居然通过了，⊙﹏⊙b汗</li></ul><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li><p>这次仍是两次双循环遍历，不过省去了额外的空间</p><ul><li>遍历矩阵，对于为<code>0</code>的元素，我们将其所在行、列的<strong>非零</strong>元素设置为一个很小的数</li><li>再次遍历矩阵，将所有等于我们设置的“很小的数”的元素全部置为<code>0</code></li></ul></li><li><p>注意并不提倡直接对非0元素直接置零，这样会带来很多次额外的行列遍历</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setZeroes</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    modify = <span class="number">-1000000</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>])):</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>])):</span><br><span class="line">                    matrix[i][k] = modify <span class="keyword">if</span> matrix[i][k]!=<span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(len(matrix)):</span><br><span class="line">                    matrix[k][j] = modify <span class="keyword">if</span> matrix[i][k] !=<span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>])):</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] == modify:</span><br><span class="line">                matrix[i][j] = <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="思路三"><a href="#思路三" class="headerlink" title="思路三"></a>思路三</h4><ul><li>思路二虽然减少了空间的使用，虽然一定程度上减少了遍历的次数，但是还是会在当同一行或列中存在多个<code>0</code>的时候进行<strong>多次遍历</strong></li><li>改进思路如下：<ul><li>我们仅使用当前的行或列的<strong>第一个元素</strong>来表示该行或该列是否需要置0</li><li>由于第一行和第一列的标记重叠，所以需要一个额外的标记来表示第一列是否需要置<code>0</code>。同时第一行和第一列需要单独处理</li><li>这样，我们就将<strong>第一行和第一列</strong>用来完成<strong>思路一</strong>中的功能</li><li>最后，遍历第一行和第一列就可以完成矩阵的置零</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setZeroes</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    <span class="comment"># 表示第一列是否置零</span></span><br><span class="line">    is_col = <span class="literal">False</span></span><br><span class="line">    <span class="comment"># 判断第一列是否需要置零</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix)):</span><br><span class="line">        <span class="keyword">if</span> matrix[i][<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">            is_col = <span class="literal">True</span></span><br><span class="line">    <span class="comment"># 第二列开始</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(matrix[<span class="number">0</span>])):</span><br><span class="line">        <span class="keyword">if</span> matrix[i][j] == <span class="number">0</span>:</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">                matrix[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 遍历第一行第一列            </span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(matrix)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(matrix[<span class="number">0</span>])):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> matrix[i][<span class="number">0</span>] <span class="keyword">or</span> <span class="keyword">not</span> matrix[<span class="number">0</span>][j]:</span><br><span class="line">                matrix[i][j] = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 第一行置0</span></span><br><span class="line">    <span class="keyword">if</span> matrix[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>])):</span><br><span class="line">            matrix[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 第一列置零       </span></span><br><span class="line">    <span class="keyword">if</span> is_col:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix)):</span><br><span class="line">            matrix[i][<span class="number">0</span>] = <span class="number">0</span></span><br></pre></td></tr></table></figure><ul><li>代码比较长，但是时间复杂度很低（几乎没有重复操作）</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之不同路径</title>
      <link href="/passages/leetcode-zhi-bu-tong-lu-jing/"/>
      <url>/passages/leetcode-zhi-bu-tong-lu-jing/</url>
      
        <content type="html"><![CDATA[<p>Unique Path</p><a id="more"></a><h3 id="Unique-Path"><a href="#Unique-Path" class="headerlink" title="Unique Path"></a>Unique Path</h3><ul><li>code with Python</li><li>title number：062</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>一个机器人位于一个<code>m*n</code>的网格的左上角，机器人每次只能<strong>向下或向右移动一格</strong></li><li>机器人视图到达网格的右下角，计算有多少种<strong>不同的路径</strong></li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>这是一道典型的<strong>动态规划</strong>题目（与爬楼梯相同的解题思路）</li><li>按照动态规划的分析思路<ul><li>定义：<code>dp[i][j]</code>表示从起点到作为为<code>[i, j]</code>的位置最多的路径数</li><li>初始状态：<code>dp[0][j]</code>和<code>dp[i][0]</code>位于边界，均为1</li><li>状态转移方程：<code>dp[i][j] = dp[i-1][j]+dp[i][j-1]</code>，只能来自上面或左边</li><li>结束条件：<code>i==m and j==n</code></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m: int, n:int)</span> -&gt; int:</span></span><br><span class="line">    dp = [[<span class="number">1</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><ul><li>代码优化<ul><li>前面使用二维数组来表示到达一个位置的路径数，即当前位置的路径数=上方一格的路径数+左边一格的路径数</li><li>换个角度，使用一维数组表示，计算一行的数据的时候，直接将上一行搬下来，每一格子的数据等于其本身加上前一个格子的数据（本身其实就是位于其上方的数据）</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m: int, n: int)</span> -&gt; int:</span></span><br><span class="line">    dp = [<span class="number">1</span>]*n</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            dp[j] += dp[j<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> dp[n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li>通过分析我们可以得出，向下移动和向右移动的次数是一定的，分别为<code>m-1</code>和<code>n-1</code></li><li>所以，这变成了一个组合数学的题目，组合问题，<code>C(n-1, m+n-2)</code></li><li>实现该公式的计算即可</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m: int, n: int)</span> -&gt; int:</span></span><br><span class="line">    a = b = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n)；</span><br><span class="line">    a += i</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m, m+n<span class="number">-1</span>):</span><br><span class="line">        b *= i</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> b // a</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之第k个排列</title>
      <link href="/passages/leetcode-zhi-di-k-ge-pai-lie/"/>
      <url>/passages/leetcode-zhi-di-k-ge-pai-lie/</url>
      
        <content type="html"><![CDATA[<p>Permutation Sequence</p><a id="more"></a><h3 id="Permutation-Sequence"><a href="#Permutation-Sequence" class="headerlink" title="Permutation Sequence"></a>Permutation Sequence</h3><ul><li>code with Python</li><li>title number：060</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给出集合<code>[1, 2, ..., n]</code>，所有元素有<code>n!</code>中排列</li><li>按从小到大顺序列出所有排列，给定<code>n</code>个<code>k</code>，返回第<code>k</code>个排列</li><li><code>1=&lt;n=&lt;9, 1=&lt;k=&lt;n!</code></li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li><p>我们不可能通过列出所有的情况，然后再去找第<code>k</code>个</p></li><li><p>原因是，<code>n!</code>已经是极高的时间复杂度了，所以要寻找规律，减少计算的次数</p></li><li><p>观察给出的示例</p><blockquote><p>n = 3, k = 3</p><p>“123”，”132”</p><p>“213”，”231”</p><p>“312”，”321”</p></blockquote></li><li><p>可以观察到，以<code>1</code>开头的有<code>2!</code>个，以<code>2</code>开头的有<code>2!</code>个，以<code>3</code>开头的有<code>2!</code>个</p></li><li><p>经过推理我们可以得出，包含<code>n</code>个元素的数组组成的排列中，以每个数字开头的元素有<code>(n-1)!</code>个</p></li><li><p>因此，如果我们要找第<code>k</code>个元素，先用<code>k / (n-1)!</code>判断第<code>k</code>个元素落在以哪个元素开头的全排列中，即确定了第一位数字</p></li><li><p>接下来进行迭代，依次得到每一位数字，组合得到最终结果</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPermutation</span><span class="params">(self, n: int, k: int)</span> -&gt; str:</span></span><br><span class="line">    res = <span class="literal">None</span></span><br><span class="line">    candidates = [str(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> n != <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 计算n-1的阶乘</span></span><br><span class="line">        facto = math.factorial(n<span class="number">-1</span>)</span><br><span class="line"><span class="comment"># 落在以哪个元素为首的全排列中</span></span><br><span class="line">        i = math.ceil(k / facto) - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        res += candidatees[i]</span><br><span class="line">        candidates.pop(i)</span><br><span class="line">        </span><br><span class="line">        k -= facto * i</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之合并区间</title>
      <link href="/passages/leetcode-zhi-he-bing-qu-jian/"/>
      <url>/passages/leetcode-zhi-he-bing-qu-jian/</url>
      
        <content type="html"><![CDATA[<p>Merge Interval</p><a id="more"></a><h3 id="Merge-Interval"><a href="#Merge-Interval" class="headerlink" title="Merge Interval"></a>Merge Interval</h3><ul><li>code with Python</li><li>title numbe：056</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li><p>给出一个区间的集合，合并所有重叠的区间</p></li><li><p>示例：</p><blockquote><p>输入：<code>[[1,3],[2,6],[8,10],[15,18]]</code></p><p>输出：<code>[[1,6],[8,10],[15,18]]</code></p><p>解释：区间<code>[1,3]</code>和<code>[2,6]</code>重叠, 将它们合并为<code>[1,6]</code></p></blockquote></li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>通过示例可以明白，所谓重叠，即较大区间的的左端点小于等于较小区间的右端点（所谓较大较小指的是区间左右端点数值的大小）</li><li>所以为了简化操作，我们要对区间进行排序（按照左端点的大小排序）</li><li>排序过后对区间集合进行遍历，判断两个区间是否有重叠，如果有则合并，否则跳过</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, intervals: List[List[int]])</span> -&gt; List[List[int]]:</span></span><br><span class="line">    <span class="keyword">if</span> len(intervals) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> intervals</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#获取数组的左端点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_first</span><span class="params">(a)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 排序</span></span><br><span class="line">    intervals.sort(key=get_first)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 遍历并合并</span></span><br><span class="line">    res = [intervals[<span class="number">0</span>]]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(intervals)):</span><br><span class="line">        <span class="comment"># 合并</span></span><br><span class="line">        <span class="keyword">if</span> intervals[i][<span class="number">0</span>] &lt;= res[<span class="number">-1</span>][<span class="number">1</span>]:</span><br><span class="line">            res[<span class="number">-1</span>] = [res[<span class="number">-1</span>][<span class="number">0</span>], max(res[<span class="number">-1</span>][<span class="number">1</span>], intervals[i][<span class="number">1</span>])]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res.append(intervals[i])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>htop命令的内容含义</title>
      <link href="/passages/htop-ming-ling-de-shi-yong-ji-nei-rong-de-han-yi/"/>
      <url>/passages/htop-ming-ling-de-shi-yong-ji-nei-rong-de-han-yi/</url>
      
        <content type="html"><![CDATA[<p>htop命令的内容含义</p><a id="more"></a><h4 id="主要参数"><a href="#主要参数" class="headerlink" title="主要参数"></a>主要参数</h4><ul><li><p><code>PID</code>、<code>USER</code>、<code>PR</code>、<code>NI</code>、<code>VIRT</code>、<code>RES</code>、<code>SHR</code>、<code>S</code>、<code>%CPU</code>、<code>%MEM</code>、<code>TIME+</code>、<code>COMMAND</code></p></li><li><p><strong>PID</strong>：进程id，可以通过<code>kill PID</code>来关掉进程</p></li><li><p><strong>USER</strong>：该进程的拥有者</p></li><li><p><strong>PR</strong>：进程优先级</p></li><li><p><strong>NI</strong>：<code>nice</code>值，负值表示高优先级，正值表示低优先级</p></li><li><p><strong>VIRT</strong>：<code>virtual memory usage</code>，当前进程需要的虚拟内存，包括进程使用的库、代码、数据等</p></li><li><p><strong>RES</strong>：<code>resident memory usage</code>，当前进程使用的内存大小</p></li><li><p><strong>SHR</strong>：<code>share memory</code>，除了自身进程的共享内存，也包括其他进程的共享内存</p></li><li><p><strong>S</strong>：进程状态</p><ul><li><code>D</code>：不可中断的睡眠状态</li><li><code>R</code>：运行</li><li><code>S</code>：睡眠</li><li><code>T</code>：跟踪/停止</li><li><code>Z</code>：僵尸进程</li></ul></li><li><p><strong>%CPU</strong>：上次更新到现在的CPU占用百分比</p></li><li><p><strong>%MEM</strong>：进程使用的物理内存百分比</p></li><li><p>*<em>TIME+ *</em>：进程使用的<code>CPU</code>的时间总计，单位为秒</p></li><li><p><strong>COMMAND</strong>：当前进程执行的命令</p></li></ul><h5 id="默认仅显示以上的比较重要的内容，可以通过提示快捷键更改显示内容"><a href="#默认仅显示以上的比较重要的内容，可以通过提示快捷键更改显示内容" class="headerlink" title="默认仅显示以上的比较重要的内容，可以通过提示快捷键更改显示内容"></a>默认仅显示以上的比较重要的内容，可以通过提示快捷键更改显示内容</h5>]]></content>
      
      
      <categories>
          
          <category> 工具配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之跳跃游戏</title>
      <link href="/passages/leetcode-zhi-tiao-yue-you-xi/"/>
      <url>/passages/leetcode-zhi-tiao-yue-you-xi/</url>
      
        <content type="html"><![CDATA[<p>Jump Game</p><a id="more"></a><h3 id="Jump-Game"><a href="#Jump-Game" class="headerlink" title="Jump Game"></a>Jump Game</h3><ul><li>code with Python</li><li>title number：055</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li><p>给定一个数组，数组中元素均为<strong>非负整数</strong></p></li><li><p>你的初始位置位于数组的<strong>第一个位置</strong></p></li><li><p>数组中的每个元素代表你在该位置<strong>可以跳跃的最大长度</strong></p></li><li><p>判断你<strong>能否到达最后一个位置</strong></p></li><li><p>例如：对于数组<code>[2, 3, 1, 1, 4]</code>，即我们可以从位置0跳一步到达位置1，再从位置1跳三步到达最后一个位置</p></li><li><p>再如：对于数组<code>[3, 2, 1, 0, 4]</code>，我们发现不管怎么选都会到达位置<code>3</code>，而这个 位置的可允许最大跳跃长度为<code>0</code>，即无论如何我们都不能到达最后一个位置</p></li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>观察示例中不能到达的情况，产生以下想法：<ul><li>最朴素的情况就是每一个点都向前条一步，如果有一步跳不过去，那么就无法到达</li><li>也就是存在<code>nums[i]==0</code>，并且该位置无法跳过，则失败</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">    length = len(nums)</span><br><span class="line">    </span><br><span class="line">    index = <span class="number">0</span><span class="comment"># 记录可以到达的位置</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">    <span class="keyword">if</span> index &gt;= length<span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># i位置跳不过去</span></span><br><span class="line">        <span class="keyword">if</span> nums[i]==<span class="number">0</span> <span class="keyword">and</span> index &lt;= i:</span><br><span class="line">            retunn <span class="literal">False</span></span><br><span class="line">        index = i + nums[i] <span class="keyword">if</span> index &lt; i+nums[i] <span class="keyword">else</span> index</span><br></pre></td></tr></table></figure><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li>值得注意的一个点是：如果从当前点能到达某个位置<code>x</code>，那么位置<code>x</code>之前的所有位置均能到达</li><li>由此，我们可以基于<strong>贪心</strong>来设计一种思路（选择从当前位置能到达的最远位置）：<ul><li>设置一个点记录最远位置，初始化为<code>0</code></li><li>遍历数组，如果当前位置能到达，并且<code>当前位置+最大跳数&gt;最远距离</code>，则更新最远位置</li><li>比较最远位置与数组长度</li></ul></li><li>注意这里是只要能够到达最终位置即可，也就是只需找到任意一种满足条件的情况</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">    max_ = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, jump <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">        <span class="keyword">if</span> max_ &gt; i <span class="keyword">and</span> i+jump &gt; max_:</span><br><span class="line">            max_i = i + jump</span><br><span class="line">   <span class="keyword">return</span> max_i</span><br></pre></td></tr></table></figure><h4 id="思路三"><a href="#思路三" class="headerlink" title="思路三"></a>思路三</h4><ul><li>动态规划<ul><li>要判断从第一个位置能否到达最后一个位置，那么我们先判断从第二个位置能否到达最后一个位置</li><li>接着再判断从第一个位置能够到达第二个位置</li><li>依次执行</li></ul></li><li>定义：<code>dp[i]</code>表示从第i个坐标能跳到的最远位置，<code>dp[i-1]&gt;=i</code>表示可以到达位置<code>i</code></li><li>初始状态：<code>dp[i]=0</code></li><li>状态转移方程：<code>dp[i] = max(dp[i-1], i+nums[i])</code></li><li>结束条件：<code>i == length-1</code>时结束，判断<code>dp[length-1]</code>是否大于等于<code>length-1</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(nums))]</span><br><span class="line">    </span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">        <span class="keyword">if</span> dp[i<span class="number">-1</span>] &gt;= i:</span><br><span class="line">            dp[i] = max(dp[i<span class="number">-1</span>], i+nums[i])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> dp[i] &gt;= len(nums)<span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nohup的简单使用</title>
      <link href="/passages/nohup-de-jian-dan-shi-yong/"/>
      <url>/passages/nohup-de-jian-dan-shi-yong/</url>
      
        <content type="html"><![CDATA[<p>nohup</p><a id="more"></a><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li>事情的开始是一直蝙蝠。。。</li><li>在家连学校的vpn跑程序总是中断，请教了一位大佬，上网查了一些资料，整理成了这篇文章</li><li>用过的都说好</li></ul><h3 id="nohup和-amp-的区别"><a href="#nohup和-amp-的区别" class="headerlink" title="nohup和&amp;的区别"></a>nohup和&amp;的区别</h3><ul><li><strong>&amp;</strong>：<ul><li>在命令之后加<code>&amp;</code>表示在后台运行</li><li>不再接收输入，在终端中键入<code>Ctrl+C</code>，并<strong>不会</strong>打断程序的运行。</li><li>结果会输出到终端</li><li>但是在关闭session之后，<strong>会</strong>打断程序</li></ul></li><li><strong>nohup</strong>：<ul><li>表示不打断的运行程序</li><li>会自动将程序的输出存储到<code>nohup.out</code>中，不会输出到前台</li><li>使用<code>Ctrl+C</code><strong>会</strong>打断程序</li><li>关掉session，<strong>不会</strong>打断程序</li></ul></li></ul><h3 id="使用nohup和-amp-实现程序后台运行"><a href="#使用nohup和-amp-实现程序后台运行" class="headerlink" title="使用nohup和&amp;实现程序后台运行"></a>使用nohup和&amp;实现程序后台运行</h3><ul><li><p>一般在linux上执行程序都死在命令行下直接执行，但如果程序运行的时间比较长，而且存在网络不稳定该怎么办呢？</p></li><li><p>这时就需要使用借助<code>nohup</code>和其他命令来实现程序的后台运行</p><ul><li><code>nohup</code>：加在命令的前面，表示不挂断的运行命令</li><li><code>&amp;</code>：加在一个命令后面，表示这个命令放在后台执行</li></ul></li><li><p>例如：<code>nohup python3 main.py &amp;</code>，程序会在后台运行，并且将输出存储到<code>nohup.out</code>中</p></li></ul><h3 id="关闭后台程序"><a href="#关闭后台程序" class="headerlink" title="关闭后台程序"></a>关闭后台程序</h3><ul><li>当执行上述命令后，不能通过<code>Ctrl+C</code>中断程序，只能通过<code>kill</code></li></ul><p>命令打断程序</p><ul><li><p><strong>查看进程</strong></p><ul><li><code>jobs</code>：可以查看当前中断后台执行的任务</li><li><code>ps</code>：查看当前时刻的所有后台进程</li></ul></li><li><p><strong>关闭后台程序</strong></p><ul><li><p>使用上述命令查看到后台进程的<code>jobnum</code>或者<code>PID</code>之后</p></li><li><p>分别使用<code>kill %jobnum</code>或者<code>kill %PID</code>关闭进程</p></li></ul></li></ul><h3 id="前后台进程的切换"><a href="#前后台进程的切换" class="headerlink" title="前后台进程的切换"></a>前后台进程的切换</h3><ul><li><code>fg %jobnum</code>：将选中的后台进程切换为前台执行</li><li><code>Ctrl+Z</code>：将正在前台执行的命令放到后台，并且处于暂停状态</li><li><code>bg %jobnum</code>：将选中的后台进程切换为前台执行</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之实现x的n次幂</title>
      <link href="/passages/leetcode-zhi-shi-xian-x-de-n-ci-mi/"/>
      <url>/passages/leetcode-zhi-shi-xian-x-de-n-ci-mi/</url>
      
        <content type="html"><![CDATA[<p>Pow(x, n)</p><a id="more"></a><h3 id="Pow-x-n"><a href="#Pow-x-n" class="headerlink" title="Pow(x, n)"></a>Pow(x, n)</h3><ul><li>code with Python</li><li>title number：050</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>实现<code>pow(x, n)</code>，即计算<code>x</code>的<code>n</code>次幂</li><li><code>-100.0 &lt; x &lt; 100.0</code></li><li><code>n</code>是32位无符号整数，<code>[-2^31, 2^31-1]</code></li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li><p>由于是要我们实现<code>x</code>的<code>n</code>次幂，所以不能调用<code>Python</code>库中的函数</p></li><li><p>最简单的一种思路就是不断累乘，<code>n</code>为多少就乘多少次</p></li><li><p>很明显，这种思路必定会超时，简单实现一下</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x: float, n: int)</span> -&gt; float:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> / self.myPow(x, -n)</span><br><span class="line">    res = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</span><br><span class="line">        res *= x</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li><p>简单的递归</p></li><li><p>比如：</p><ul><li>对于<code>n</code>为偶数，想求<code>x^4</code>，可以转化为<code>(x^2)^2</code></li><li>对于<code>n</code>为奇数，想求<code>x^5</code>，可以转化为<code>x*(x^2)^2</code> </li></ul></li><li><p>由上面的启发，我们想到使用递归，具体思路如下</p><ul><li>假<code>n</code>除以二的结果为<code>a</code></li><li>那么<code>myPow(x, n) = myPow(x, a) * myPow(x, n-a)</code></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x: float, n: int)</span> -&gt; float:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> / self.myPow(x, -n)</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> self.myPow(x, n // <span class="number">2</span>) * self.myPow(x, n - n // <span class="number">2</span>)</span><br></pre></td></tr></table></figure><ul><li>可惜这种方法也超时了，原因是存在太多的重复计算</li></ul><h4 id="思路三"><a href="#思路三" class="headerlink" title="思路三"></a>思路三</h4><ul><li>在上面递归的基础上进行优化</li><li>为了减少每次递归是调用本身的次数，优化如下：<ul><li>如果<code>n</code>是偶数，我们将<code>n</code>折半，底数变为<code>x^2</code></li><li>如果<code>n</code>是奇数， 我们将<code>n</code>减去<code>1</code>，底数不变，得到的结果再乘上底数<code>x</code></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x: float, n: int)</span> -&gt; float:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> / self.myPow(x, -n)</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> self.myPow(x*x, n // <span class="number">2</span>) <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> x * self.myPow(x, n<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之字母异位词分组</title>
      <link href="/passages/leetcode-zhi-zi-mu-yi-wei-ci-fen-zu/"/>
      <url>/passages/leetcode-zhi-zi-mu-yi-wei-ci-fen-zu/</url>
      
        <content type="html"><![CDATA[<p>Group Anagrams</p><a id="more"></a><h3 id="Group-Anagrams"><a href="#Group-Anagrams" class="headerlink" title="Group Anagrams"></a>Group Anagrams</h3><ul><li>code with Python</li><li>title number：049</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个字符串数组，将字母异位词组合到一起</li><li><strong>异位词</strong>：指字母相同，但排列不同的字符串</li><li>所有输入均为小写，不考虑答案输出的顺序</li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>比较直观的想法是，对数组的每一项元素（字符串）进行排序，然后使用字典存储，结构为<code>{经过排序的字符串:[原字符串]}</code></li><li>遍历字典，取出所有<code>value</code>即可</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">groupAnagrams</span><span class="params">(self, strs: List[str])</span> -&gt; List[List[str]]:</span></span><br><span class="line">    hash_table = &#123;&#125;</span><br><span class="line">    res = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sort_str</span><span class="params">(str)</span>:</span></span><br><span class="line">        str = list(str)</span><br><span class="line">        str.sort()</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(str)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">        <span class="keyword">if</span> sort_str(s) <span class="keyword">in</span> hash_table:</span><br><span class="line">            hash_table[sort_str(s)].append(s)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            hash_table[sort_str(s)] = [s]</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> hash_table.keys():</span><br><span class="line">        res.append(hash_table[s])</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li>仍然是上面的思路，不过这次我们判断两个词是否是异位词的方式有所改变</li><li>参考<a href="http://zivblog.top/passages/桶排序">桶排序</a>的思路，设计一种方法<ul><li>我们建立一个长度为26的数组（26个字母），每个字母对应一个数组中的下标</li><li>每读一个词，遍历其所有字母，并且在相应位置出统计词中出现的字母的个数</li><li>如果两个词得到的数组相同，则说明两者之间可以通过交换顺序得到</li></ul></li><li>其余思路相同</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">groupAnagrams</span><span class="params">(self, strs: List[str])</span> -&gt; List[List[str]]:</span></span><br><span class="line">    <span class="comment"># 初始化字典</span></span><br><span class="line">    str_dict = collections.defaultdict(list)</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">        s_key = [<span class="number">0</span>]*<span class="number">26</span></span><br><span class="line">        <span class="comment"># 遍历词中的字母</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            s_key[ord(c)-ord(<span class="string">'a'</span>)] += <span class="number">1</span></span><br><span class="line">        str_dict[tuple(s_key)].append(s)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> str_dict.keys():</span><br><span class="line">            res.append(str_dict[key])</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>桶排序</title>
      <link href="/passages/tong-pai-xu/"/>
      <url>/passages/tong-pai-xu/</url>
      
        <content type="html"><![CDATA[<p>桶排序</p><a id="more"></a><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>桶排序（Bucket Sort）的原理十分容易理解，就是将数组分到有限数量的桶中，再顺序的从桶中取出，即可得到排序结果</li><li>桶排序有两个关键点<ul><li>待排序元素的值域的划分。即确定每个桶代表了什么，或者说是每个桶允许什么元素装入</li><li>排序算法的选择。即每个桶中的元素的排列规则</li></ul></li><li>下面通过两个例子理解桶排序使用时的具体细节</li></ul><h3 id="实例一"><a href="#实例一" class="headerlink" title="实例一"></a>实例一</h3><ul><li><p>假设我们现在有<code>n</code>个整数，并且知道整数的范围时<code>[0, max)</code>，现使用桶排序对这<code>n</code>个整数进行排序</p></li><li><p><strong>值域的划分</strong>：由于知道<code>n</code>个整数的范围是<code>[0, max)</code>，所以设置<code>max</code>个桶，每一个整数都会唯一的进入一个桶中</p></li><li><p><strong>排序算法的选择</strong>：由于每个桶中的数字都相同，不需要排序</p></li><li><p><strong>具体</strong>：</p><blockquote><p>设置一个长为<code>max</code>的数组<code>bucket</code>，数组中的每个位置是一个桶</p><p>遍历<code>n</code>个整数，将对应整数<code>x</code>放到<code>bucket</code>中对应下标的位置（统计值为<code>x</code>的元素的个数，即<code>bucket[x]+=1</code>）</p><p>遍历数组<code>bucket</code>，按照对应位置的值的大小，顺序取出对应个数的值</p></blockquote></li></ul><img src="/.top//1.png" style="zoom:75%;"><ul><li>如上图，得到的排序结果应为<code>[2, 3, 3, 3, 4, 4, 6, 6, 8, 9]</code></li></ul><h4 id="实例二"><a href="#实例二" class="headerlink" title="实例二"></a>实例二</h4><ul><li><p>现有数组<code>[-7, 51, 3, 121, -3, 32, 21, 43, 4, 25, 56, 77, 16, 22, 87, 56, -10, 68, 99, 70]</code>，试用桶排序完成对该数组的排序</p></li><li><p><strong>值域的划分</strong>：</p><ul><li>我们观察到，上述数组值域的范围比较大，直接申请大小与值域范围相同的数组势必会造成很多空间的浪费</li><li>故另辟蹊径，我们将每个桶可以容纳的元素设置一个范围，这里我们设置间隔为10</li><li>对此，我们需要设置一个映射规则，来更加方便的将元素放入对应的桶中</li></ul><p>$$<br>f(x)=\frac{x}{10}-c, (c=\frac{min}{10})<br>$$</p><ul><li>经计算可得，待排序数组中，<code>max=121, min=-10</code>，所以申请桶的个数为14个</li></ul><p>$$<br>\frac{max}{10}-\frac{min}{10}+1 = 12-(-1)+1=14<br>$$</p></li><li><p><strong>排序算法的选择</strong></p><ul><li>不同于前一个例子，桶中存放的将是不同的数字，所以需要寻找一个算法对桶中的元素进行排序。</li><li>该排序算法的选择，将直接影响整体的性能</li></ul></li><li><p><strong>排序结果为</strong></p><table><thead><tr><th>桶下标</th><th>桶中元素</th></tr></thead><tbody><tr><td>0</td><td>-7, 3,-10</td></tr><tr><td>1</td><td>3, 4</td></tr><tr><td>2</td><td>16</td></tr><tr><td>3</td><td>21, 25, 22</td></tr><tr><td>4</td><td>32</td></tr><tr><td>5</td><td>43</td></tr><tr><td>6</td><td>51, 56, 56</td></tr><tr><td>7</td><td>68</td></tr><tr><td>8</td><td>77, 70</td></tr><tr><td>9</td><td>87</td></tr><tr><td>10</td><td>99</td></tr><tr><td>11</td><td></td></tr><tr><td>12</td><td></td></tr><tr><td>13</td><td>121</td></tr></tbody></table></li><li><p>代码示例</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bucketSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    max, min = max(arr), min(arr)</span><br><span class="line">    bucketArr = [[] <span class="keyword">for</span> i <span class="keyword">in</span> range(max // <span class="number">10</span> - min//<span class="number">10</span> + <span class="number">1</span>)]</span><br><span class="line">    <span class="comment"># 遍历数组，添加到桶中</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">        index = i</span><br><span class="line">        bucketArr[index].append(i)</span><br><span class="line">    arr.clear()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 对每个桶中的元素排序</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> bucketArr:</span><br><span class="line">        i.sort()</span><br><span class="line">        arr.extend(i)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之旋转图像</title>
      <link href="/passages/leetcode-zhi-xuan-zhuan-tu-xiang/"/>
      <url>/passages/leetcode-zhi-xuan-zhuan-tu-xiang/</url>
      
        <content type="html"><![CDATA[<p>Rotate Image</p><a id="more"></a><h3 id="Rotate-Image"><a href="#Rotate-Image" class="headerlink" title="Rotate Image"></a>Rotate Image</h3><ul><li>code with Python</li><li>title number：048</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个n*n的二维矩阵用于表示一个图像</li><li>将图像顺时针旋转90度</li><li>必须原地旋转，不能使用额外的二维矩阵</li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li><p>由于是要原地旋转矩阵，我们需要找到<strong>矩阵旋转90度</strong>时，元素位置的变化规律</p></li><li><p>经过观察可以发现，我们只需要将第<code>i</code>行变成第<code>n-i-1</code>列即可</p></li><li><p>有个比较巧妙的方法，即利用对称轴旋转达到我们的目的</p><ul><li>先进行一次对角线为轴的翻转，然后再进行一次以水平对称线为轴的翻转，即可</li></ul><p><img src="/.top//Leetcode%E4%B9%8B%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F%5C1.png" alt> </p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    <span class="comment"># 先沿着对角线翻转</span></span><br><span class="line">    n = len(matrix)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> (i, n):</span><br><span class="line">            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]</span><br><span class="line">    <span class="comment"># 再沿横对称线翻转</span></span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> matrix:</span><br><span class="line">        m.reverse()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之全排列Ⅱ</title>
      <link href="/passages/leetcode-zhi-quan-pai-lie-ii/"/>
      <url>/passages/leetcode-zhi-quan-pai-lie-ii/</url>
      
        <content type="html"><![CDATA[<p>Permutations Ⅱ</p><a id="more"></a><h3 id="Permutations-Ⅱ"><a href="#Permutations-Ⅱ" class="headerlink" title="Permutations Ⅱ"></a>Permutations Ⅱ</h3><ul><li>code with Python</li><li>title number：047</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个<strong>可能包含重复数字</strong>的序列，返回其所有<strong>不重复</strong>的全排列</li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>由于序列中可能包含重复数字，所以要在生成全排列的时候去重</li><li>与前面的思路相同，先排序，每使用一个数字就将其<code>pop</code>出，防止重复使用</li><li>其他并没有特殊之处</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> copy <span class="keyword">import</span> copy</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permuteUnique</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">    nums.sort()</span><br><span class="line">    res = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(nums, pre_list)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt;= <span class="number">0</span>:</span><br><span class="line">            res.append(pre_list)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i <span class="number">-1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                p_list = pre_list.copy()</span><br><span class="line">                p_list.appen(nums[i])</span><br><span class="line">                left_num = nums.copy()</span><br><span class="line">                left_nums.pop(i)</span><br><span class="line">                print(<span class="string">'p_list is '</span>, p_list, <span class="string">'left_nums is '</span>, left_num)</span><br><span class="line">                backtrack(left_nums, p_list)</span><br><span class="line">    backtrack(nums, [])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><ul><li><code>print()</code>信息如下</li></ul><blockquote><p>p_list is  [1]  left_nums is  [1, 2] </p><p>p_list is  [1, 1] left_nums is  [2]</p><p>p_list is  [1, 1, 2] left_nums is  [] </p><p>p_list is  [1, 2] left_nums is  [1] </p><p>p_list is  [1, 2, 1] left_nums is  [] </p><p>p_list is  [2] left_nums is  [1, 1] </p><p>p_list is  [2, 1] left_nums is  [1] </p><p>p_list is  [2, 1, 1] left_nums is  [] </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之全排列</title>
      <link href="/passages/leetcode-zhi-quan-pai-lie/"/>
      <url>/passages/leetcode-zhi-quan-pai-lie/</url>
      
        <content type="html"><![CDATA[<p>Permutations</p><a id="more"></a><h3 id="Permutations"><a href="#Permutations" class="headerlink" title="Permutations"></a>Permutations</h3><ul><li>code with Python</li><li>title number：046</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个没有重复数字的序列，返回其所有可能的全排列</li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li><p>本题是求集合，并不是求极值，所以不适合使用动态规划</p></li><li><p>与前面的两道题（<a href="http://www.zivblog.top/passages/Leetcode之组合总和Ⅱ/" target="_blank" rel="noopener">题目一</a>，<a href="http://www.zivblog.top/passages/Leetcode之组合总和/" target="_blank" rel="noopener">题目二</a>）思路相同，使用<a href="http://www.zivblog.top/passages/回溯法/" target="_blank" rel="noopener">回溯法</a>，实际上就是对回溯决策树的遍历</p></li><li><p>主要问题就是明白三个问题对应什么</p><ul><li>路径：已经选择的数字</li><li>选择列表：当前可供选择的数字</li><li>结束条件：所有数字全部选择一遍</li></ul></li><li><p>因为是数字序列的全排列，所以每个数字只能用一次（不包含重复数字）</p></li><li><p>以数字序列<code>[1, 2, 3]</code>为例</p></li></ul><p><img src="/.top//Leetcode%E4%B9%8B%E5%85%A8%E6%8E%92%E5%88%97%5C1.png" alt></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">    res = []</span><br><span class="line">    length = len(nums)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(start)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start == length:</span><br><span class="line">            res.append(nums[:])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(start, length):</span><br><span class="line">            nums[start], nums[i] = nums[i], nums[start]</span><br><span class="line">            backtrack(start+<span class="number">1</span>)</span><br><span class="line">            nums[start], nums[i] = nums[i], nums[start]</span><br><span class="line">            </span><br><span class="line">        backtrack(<span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周知识总结（3.8~3.15）</title>
      <link href="/passages/zhou-zhi-shi-zong-jie-3-8-3.15/"/>
      <url>/passages/zhou-zhi-shi-zong-jie-3-8-3.15/</url>
      
        <content type="html"><![CDATA[<p>周知识总结</p><a id="more"></a><h3 id="3月8日"><a href="#3月8日" class="headerlink" title="3月8日"></a>3月8日</h3><h4 id="简述向量、标量、矩阵、张量的内涵以及它们之间的联系"><a href="#简述向量、标量、矩阵、张量的内涵以及它们之间的联系" class="headerlink" title="简述向量、标量、矩阵、张量的内涵以及它们之间的联系"></a>简述向量、标量、矩阵、张量的内涵以及它们之间的联系</h4><ul><li><strong>向量</strong><ul><li>又称矢量，是指具有大小和方向的量。在计算机中，向量具有多个维度，每个数表示向量在该维度上的值。例如: <code>[1, 2, 3, 4]</code></li></ul></li><li><strong>标量</strong><ul><li>与向量相对应，是一个单独的数</li></ul></li><li><strong>矩阵</strong><ul><li>指一组具有相同特征和维度的对象的集合，形式上表现为一个二维的表格。在意义上，一个对象是矩阵中的一行；一个特征是矩阵中的一列。</li></ul></li><li><strong>张量</strong><ul><li>通常是一个广义的矩阵，可以是一个更高维的结构，张量的维数叫做它的秩。在深度学习中经常见到张量，即<code>Tensor</code></li></ul></li><li><strong>联系</strong><ul><li>标量可以看作是0阶张量</li><li>向量可以看作是一阶张量</li></ul></li></ul><vr><h4 id="试归纳向量的范数"><a href="#试归纳向量的范数" class="headerlink" title="试归纳向量的范数"></a>试归纳向量的范数</h4><ul><li><p>向量的范数是用来衡量空间中向量的大小的量，常见的有以下计算方式：</p><ul><li><p><strong>向量的1范数</strong>：向量的各个元素的绝对值之和<br>$$<br>  \Vert\vec{x}\Vert_1=\sum_{i=1}^N\vert{x_i}\vert<br>$$</p></li><li><p><strong>向量的2范数</strong>：向量的每个元素的平方和在开平方<br>$$<br>\Vert\vec{x}\Vert_2=\sqrt{\sum_{i=1}^N{\vert{x_i}\vert}^2}<br>$$</p></li><li><p><strong>向量的负无穷范数</strong>：向量的所有元素中绝对值最小的</p></li></ul><p>$$<br>\Vert\vec{x}\Vert_{-\infty}=\min{|{x_i}|}<br>$$</p><ul><li><strong>向量的正无穷范数</strong>：向量的所有元素中绝对值最大的</li></ul><p>$$<br>\Vert\vec{x}\Vert_{+\infty}=\max{|{x_i}|}<br>$$</p></li></ul><ul><li>总得来说，向量的范数可以表示为：<br>$$<br>L_p=\Vert\vec{x}\Vert_p=\sqrt[p]{\sum_{i=1}^{N}|{x_i}|^p}<br>$$</li></ul><br><h4 id="简述导数与偏导数的区别"><a href="#简述导数与偏导数的区别" class="headerlink" title="简述导数与偏导数的区别"></a>简述导数与偏导数的区别</h4><ul><li>导数和偏导数本身并无本质区别，都是在极限存在的情况下自变量变化量趋于0时，函数值的变化量与自变量变化量的比值<ul><li>对于一元函数<code>y = ax+b</code>，导数只有一个</li><li>对于二元函数<code>z = x + y</code>，导数有两个，分别是<code>z</code>关于<code>x</code>的导数和<code>z</code>关于<code>y</code>的导数，称之为偏导数</li></ul></li><li>注意在多元函数求偏导时，要将求偏导之外的变量视为常数</li></ul><br><h4 id="简述随机变量与变量的区别"><a href="#简述随机变量与变量的区别" class="headerlink" title="简述随机变量与变量的区别"></a>简述随机变量与变量的区别</h4><ul><li>随机变量表示随机试验各种结果的实值单值函数。</li><li>区别<ul><li>当变量的取值概率不为1时，变量就是随机变量；相对应的，随机变量取值的概率为1时，随机变量就变成了变量</li></ul></li></ul><br><br><h3 id="3月9日"><a href="#3月9日" class="headerlink" title="3月9日"></a>3月9日</h3><h4 id="试简述概率分布与随机变量存在的联系"><a href="#试简述概率分布与随机变量存在的联系" class="headerlink" title="试简述概率分布与随机变量存在的联系"></a>试简述概率分布与随机变量存在的联系</h4><ul><li>一个随机变量表示的是一个可能取得的状态</li><li>而概率分布表示的是一个随机变量取得每个状态的可能性大小</li><li>随机变量分为<strong>离散型</strong>和<strong>连续型</strong></li></ul><br><h4 id="概率分布如何描述"><a href="#概率分布如何描述" class="headerlink" title="概率分布如何描述"></a>概率分布如何描述</h4><ul><li><p>用来描述概率分布的函数有两种</p><ul><li><strong>概率质量函数</strong>：描述离散型随机变量的概率分布</li><li><strong>概率密度函数</strong>：描述连续性随机变量的概率分布</li></ul></li></ul><br><h4 id="什么是条件概率"><a href="#什么是条件概率" class="headerlink" title="什么是条件概率"></a>什么是条件概率</h4><ul><li><p>在某种情况（<code>A， A&lt;S</code>）下，情况<code>B</code>发生的概率，记作：<br>$$<br>P(B|A) = \frac{P(AB)}{P(A)}<br>$$</p></li><li><p>且当<code>A=S</code>时，<code>P(B|A)=P(B)</code>，即情况A的作用是缩小了样本空间</p></li></ul><br><h4 id="边缘概率与联合概率的内涵与区别"><a href="#边缘概率与联合概率的内涵与区别" class="headerlink" title="边缘概率与联合概率的内涵与区别"></a>边缘概率与联合概率的内涵与区别</h4><ul><li><strong>边缘概率</strong><ul><li>与联合概率相对应，指的是某个事件发生的概率，与其他事件无关，例如：<code>P(X=1)</code></li></ul></li><li><strong>联合概率</strong>：<ul><li>指的是多个事件的同时发生，例如：<code>P(X=1, Y=2)</code></li></ul></li></ul><br><h4 id="简述期望、方差、协方差、相关系数"><a href="#简述期望、方差、协方差、相关系数" class="headerlink" title="简述期望、方差、协方差、相关系数"></a>简述期望、方差、协方差、相关系数</h4><ul><li><p><strong>期望</strong>：</p><ul><li>指的是每个结果的概率乘以结果的总和</li></ul></li><li><p><strong>方差</strong></p><ul><li>用来度量随机变量与其数学期望之间的偏离程度</li></ul><p>$$<br>Var(x) = E((x-E(x))^2)<br>$$</p></li></ul><ul><li>可以用来衡量数据的<strong>离散程度</strong></li></ul><ul><li><p><strong>协方差</strong></p><ul><li>衡量两个变量（变化趋势）的相关性大小</li></ul><p>$$<br>Cov(x,y)=E((x-E(x))(y-E(y)))<br>$$</p></li></ul><ul><li><p><strong>相关系数</strong></p><ul><li>衡量变量之间线性相关程度</li><li>而且不受变量变化幅度的影响，反映两个变量每单位变化时</li></ul><p>$$<br>Corr(x,y) = \frac{Cov(x,y)}{\sqrt{Var(x)Var(y)}}<br>$$</p></li></ul><br><br><h3 id="3月10日"><a href="#3月10日" class="headerlink" title="3月10日"></a>3月10日</h3><h4 id="试简述机器学习的内涵"><a href="#试简述机器学习的内涵" class="headerlink" title="试简述机器学习的内涵"></a>试简述机器学习的内涵</h4><ul><li>机器学习，顾名思义，是一种让机器进行学习的技术。这里的机器指的是计算机，是算法运行的载体。</li><li>另一个角度来看，也可以讲算法本身视作一个”机器“，接受出入，产生输出</li><li>对于一个任务，设计一种算法，使算法能够提取出任务相关的数据中蕴含的规律，这就是是机器学习。</li><li>根绝输入机器的数据是否带有标记可以分为监督学习和无监督学习。</li></ul><br><h4 id="试简述什么是神经网络"><a href="#试简述什么是神经网络" class="headerlink" title="试简述什么是神经网络"></a>试简述什么是神经网络</h4><ul><li>按照一定的规则将多个神经元起来的网络成为神经网络。对于不同的网络，连接规则会有所差异。</li><li>一般来说，神经网络要包含三种层：输入层、输出层、隐藏层</li></ul><br><h4 id="局部最优和全局最优的内涵及区别"><a href="#局部最优和全局最优的内涵及区别" class="headerlink" title="局部最优和全局最优的内涵及区别"></a>局部最优和全局最优的内涵及区别</h4><ul><li>优化问题的解一般分为两种：局部最优、全局最优</li><li><strong>局部最优</strong>指的是在函数值空间的一个有限区域内的最值</li><li><strong>全局最优</strong>指的是在函数整个取值空间上的最值</li></ul><br><h4 id="试简述机器学习的主要学习方式"><a href="#试简述机器学习的主要学习方式" class="headerlink" title="试简述机器学习的主要学习方式"></a>试简述机器学习的主要学习方式</h4><ul><li><strong>监督学习</strong>：使用有标签（正确答案）的数据来训练模型。训练得到的模型可以将数据映射到给定标签范围内的一个标签。常见的监督学习算法有：支持向量机、逻辑回归、决策树等</li><li><strong>无监督学习</strong>：与监督学习相对应，无监督学习使用的数据并没有被特别标识出类别。训练出的模型一般用于推断数据本身存在的一些结构。常见的无监督学习有：聚类等。</li><li><strong>半监督学习</strong>：使用的数据部分有标签，部分没有标签。属于半监督学习的算法有：拉普拉斯支持向量机等</li><li><strong>弱监督学习</strong>：使用的数据可以看作是有多个标签的数据（没有标签、一个标签、多个标签）。一般用于将输入数据映射到一组更强的标签。</li></ul><br><h4 id="评估标准中的正确率是否能较好的反映算法的性能"><a href="#评估标准中的正确率是否能较好的反映算法的性能" class="headerlink" title="评估标准中的正确率是否能较好的反映算法的性能"></a>评估标准中的正确率是否能较好的反映算法的性能</h4><ul><li><p>一般情况下正确率能直观的反映分类算法的性能，但是各类数据数量悬殊较大时并不可靠。</p></li><li><p>比如：1000个样本，正样本990，负样本10.（例如预测一个地区的地震概率）</p><ul><li><p>如果将所有的结果预测为正，可以达到99%的正确率，但这样并不合适</p></li><li><p>在这里，样本数量较少的标签才是我们关注的</p></li></ul></li></ul><br><br><h3 id="3月11日"><a href="#3月11日" class="headerlink" title="3月11日"></a>3月11日</h3><h4 id="逻辑回归可以用在那些问题上？"><a href="#逻辑回归可以用在那些问题上？" class="headerlink" title="逻辑回归可以用在那些问题上？"></a>逻辑回归可以用在那些问题上？</h4><ul><li>用于分类。用作分类任务时，关键在于设定一个阈值。</li><li>用于概率预测。</li><li>注意，逻辑回归仅能用于线性问题。即目标和特征之间时线性关系时才能使用，<ul><li>在目标和特征之间不是线性关系时不使用</li><li>在使用时要挑选与目标为线性关系的特征</li></ul></li><li>特征之间不需要满足条件独立性假设</li></ul><br><h4 id="逻辑回归与朴素贝叶斯有何区别？"><a href="#逻辑回归与朴素贝叶斯有何区别？" class="headerlink" title="逻辑回归与朴素贝叶斯有何区别？"></a>逻辑回归与朴素贝叶斯有何区别？</h4><ul><li>逻辑回归属于判别模型，计算的是条件概率，即根据特征得到最终的目标</li><li>朴素贝叶斯属于生成模型，计算的是联合概率</li><li>朴素贝叶斯属于贝叶斯，逻辑回归属于最大似然，是两种不同的概率哲学</li><li>使用朴素贝叶斯需要特征满足条件独立性假设，即各特征之间相互独立，而逻辑回归无此要求</li></ul><br><h4 id="逻辑回归与线性回归的区别有哪些？"><a href="#逻辑回归与线性回归的区别有哪些？" class="headerlink" title="逻辑回归与线性回归的区别有哪些？"></a>逻辑回归与线性回归的区别有哪些？</h4><ul><li>线性回归的目的是预测，而逻辑回归是用于分类</li><li>线性回归<code>y</code>的范围不确定，而逻辑回归中<code>y</code>的范围是<code>(0, 1)</code></li><li>线性回归参数的计算方式是最小二乘法（计算误差），而逻辑回归是极大似然估计（计算使目标出现概率最大的参数）</li></ul><br><h4 id="简要描述梯度下降的步骤"><a href="#简要描述梯度下降的步骤" class="headerlink" title="简要描述梯度下降的步骤"></a>简要描述梯度下降的步骤</h4><ul><li>初始化参数，可以随机取值</li><li>迭代操作：<ul><li>计算当前梯度</li><li>修改新的变量</li><li>向梯度最大的方向前进一步</li><li>判断是否终止</li></ul></li><li>结果一般为全局最优或局部最优</li></ul><br><h4 id="梯度下降有哪些关键参数？"><a href="#梯度下降有哪些关键参数？" class="headerlink" title="梯度下降有哪些关键参数？"></a>梯度下降有哪些关键参数？</h4><ul><li>迭代的步长<ul><li>步长太小，迭代速度过慢</li><li>步长太大，迭代太快，易错过最优解</li></ul></li><li>参数的初始值<ul><li>初始值选取不当可能会导致得到的是局部最优解</li></ul></li><li>标准化处理<ul><li>对各个特征进行标准化处理，防止特征的取值范围不同而导致梯度下降速度变慢</li></ul></li></ul><br><h4 id="梯度下降会有什么缺陷？"><a href="#梯度下降会有什么缺陷？" class="headerlink" title="梯度下降会有什么缺陷？"></a>梯度下降会有什么缺陷？</h4><ul><li>在接近极小值是收敛速度变慢</li><li>可能会出现<code>之</code>字行下降</li></ul><br><br><h3 id="3月12日"><a href="#3月12日" class="headerlink" title="3月12日"></a>3月12日</h3><h4 id="试简要描述主成分分析（PCA）的主要思想"><a href="#试简要描述主成分分析（PCA）的主要思想" class="headerlink" title="试简要描述主成分分析（PCA）的主要思想"></a>试简要描述主成分分析（PCA）的主要思想</h4><ul><li>PCA的作用是将<strong>高维数据通过线性变换投影到低维空间</strong>上去，从而可以在计算时减小计算压力，同时不会影响太多性能（被舍弃的维度是噪声或者冗余信息）<ul><li>去冗余信息：当向量可以被其他向量线性表示时，该特征是多余的</li><li>去噪声：去除较小的特征值对应的特征向量，特征值的大小反映了变换后在特征向量方向上的变换幅度，幅度越大，表示该特征包含的信息量越多，多以要保留特征值较大的。</li></ul></li><li>对角化矩阵，寻找极大线性无关组，保留较大的特征值，组成一个投影矩阵对原始样本矩阵进行投影，投影后得到新样本矩阵。</li></ul><br><h4 id="简要总结PCA的算法流程"><a href="#简要总结PCA的算法流程" class="headerlink" title="简要总结PCA的算法流程"></a>简要总结PCA的算法流程</h4><ul><li>对所有样本进行<strong>中心化</strong></li><li>计算样本的<strong>协方差矩阵</strong></li><li>对协方差矩阵进行<strong>特征值分解</strong></li><li>取最大的<code>n</code>个特征值对应的特征向量</li><li>标准化特征向量，得到<strong>特征向量矩阵</strong></li><li>转化样本集中的每个样本，得到降维后的样本矩阵</li></ul><br><h4 id="试分析PCA的主要优缺点"><a href="#试分析PCA的主要优缺点" class="headerlink" title="试分析PCA的主要优缺点"></a>试分析PCA的主要优缺点</h4><ul><li><p><strong>优点</strong></p><ul><li><p>只利用样本本身的方差衡量信息量，不受外界因素影响</p></li><li><p>得到的各主成分之间正交（无线性关系），可消除原始数据中各特征之间的影响</p></li><li><p>主要使用特征值分解实现，易于实现和计算</p></li></ul></li><li><p><strong>缺点</strong></p><ul><li>降维后的各个特征的含义有一定模糊性，可解释性降低</li><li>被丢弃掉的非主成分可能包含重要信息，丢弃掉会对数据处理有影响</li></ul></li></ul><p><br><br></p><h3 id="3月13日"><a href="#3月13日" class="headerlink" title="3月13日"></a>3月13日</h3><h4 id="试描述过拟合和欠拟合的区别"><a href="#试描述过拟合和欠拟合的区别" class="headerlink" title="试描述过拟合和欠拟合的区别"></a>试描述过拟合和欠拟合的区别</h4><p><img src="/passages/%E5%91%A8%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%883-8-3/%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%883-8-3-15%EF%BC%89%5C1.jpg" alt></p><ul><li><p>上图中，横坐标为训练样本数量，纵坐标为误差</p></li><li><p>从上图中我们可以直观的看出：</p><ul><li><strong>欠拟合</strong>：在训练集以及测试集上同时具有较高的误差，此时模型具有较高的误差。简言之就是模型还没训练好</li><li><strong>过拟合</strong>：在训练集上具有较低的误差，但是在测试集上的误差较大，此时模型的方差较大。检验之就是对训练数据拟合的太好了，不能很好的泛华到其他数据上</li><li><strong>正常</strong>：在训练集和测试集上，同时具有相对较低的偏差及方差</li></ul></li></ul><br><h4 id="如何解决过拟合和欠拟合问题"><a href="#如何解决过拟合和欠拟合问题" class="headerlink" title="如何解决过拟合和欠拟合问题"></a>如何解决过拟合和欠拟合问题</h4><ul><li><strong>解决欠拟合问题</strong><ul><li>添加特征项。通过组合，泛华，上下文特征等增加特征，有时特征数量较少也会导致模型欠拟合</li><li>添加多项式特征</li><li>增加模型的复杂程度</li><li>减少正则化系数（正则化系数是用来放置过拟合的）</li></ul></li><li><strong>解决过拟合问题</strong><ul><li>重新清洗数据（数据不纯可能导致过拟合）</li><li>增加训练样本的数量</li><li>降低模型的复杂程度</li><li>增大正则项系数</li><li><code>dropout</code></li></ul></li></ul><br><br><h3 id="3月14日"><a href="#3月14日" class="headerlink" title="3月14日"></a>3月14日</h3><h4 id="试解释误差、偏差、方差的区别和联系"><a href="#试解释误差、偏差、方差的区别和联系" class="headerlink" title="试解释误差、偏差、方差的区别和联系"></a>试解释误差、偏差、方差的区别和联系</h4><ul><li><strong>误差（Error）</strong><ul><li>误差一般用来描述学习器的实际预测结果与样本的真实结果之间的差异</li><li>误差 = 偏差 + 方差 + 噪声，换言之，误差描述的是整个模型的准确程度</li></ul></li><li><strong>偏差（Bias）</strong><ul><li>偏差描述的是模型拟合训练数据的能力，表示的是模型在样本上的输出与真实值之间的误差，是模型本身的精确程度</li><li>偏差越小，表示模型的拟合能力越强（可能产生过拟合）；偏差越大，模型的拟合能力越差（可能产生欠拟合）</li></ul></li><li><strong>方差（Variance）</strong><ul><li>方差表示的是预测值的变化范围，方差越大，数据的分布越分散，模型的稳定性会越差</li><li>方差可以用来衡量模型的稳定性</li><li>方差越小，说明模型越稳定，模型的泛化能力就更高；方差越大，则模型的泛化能力越差</li></ul></li></ul><br><h4 id="什么事经验误差和泛化误差"><a href="#什么事经验误差和泛化误差" class="headerlink" title="什么事经验误差和泛化误差"></a>什么事经验误差和泛化误差</h4><ul><li><strong>经验误差</strong>：又叫训练误差，指的是模型在<strong>训练集</strong>上的误差</li><li><strong>泛化误差</strong>：指的是模型在<strong>测试集</strong>上的误差</li></ul><br><br><h3 id="3月15日"><a href="#3月15日" class="headerlink" title="3月15日"></a>3月15日</h3><h4 id="相较于方差，使用标准差表示数据离散程度有哪些好处"><a href="#相较于方差，使用标准差表示数据离散程度有哪些好处" class="headerlink" title="相较于方差，使用标准差表示数据离散程度有哪些好处"></a>相较于方差，使用标准差表示数据离散程度有哪些好处</h4><ul><li>表示离散程度的数字与样本数据点的数量级一致，更适合对数据样本形成感性认知</li><li>表示离散程度的数字单位与样本数据的单位一致，方便做后续的分析运算</li><li>在样本数据大致符合正态分布的情况下，标准差更方便估算</li></ul><br><h4 id="训练数据类别不平衡会导致哪些问题"><a href="#训练数据类别不平衡会导致哪些问题" class="headerlink" title="训练数据类别不平衡会导致哪些问题"></a>训练数据类别不平衡会导致哪些问题</h4><ul><li>类别不平衡指<strong>分类</strong>任务中不同类别的训练样例数目差别很大的情况</li><li>分类算法在使用类别不平衡的数据进行训练时，会影响学习结果，测试结果会变差。</li><li>比如：二分类问题中有998个反例，正例有2个，那学习方法只需返回一个永远将新样本预测为反例的分类器，就能达到99.8%的精度；然而这样的分类器没有价值。</li></ul><br><h4 id="常见的类别不平衡问题解决方法"><a href="#常见的类别不平衡问题解决方法" class="headerlink" title="常见的类别不平衡问题解决方法"></a>常见的类别不平衡问题解决方法</h4><ul><li><p><strong>扩大数据集</strong></p><ul><li>增加包含小类样本数据的数据</li></ul></li><li><p><strong>欠采样</strong></p><ul><li>对<strong>大类数据</strong>进行欠采样，使之与小样本数据个数相近</li><li>例如：<code>EasyEnsemble</code>算法</li></ul></li><li><p><strong>过采样</strong></p><ul><li>对<strong>小类数据</strong>进行过采样，以增加小类的数据样本的个数</li><li>例如：<code>SMOTE</code>和<code>ADASYN</code>算法</li></ul></li><li><p><strong>使用新的评测指标</strong></p><ul><li>在类别不均衡分类任务中，不适合用正确率来评测</li></ul></li><li><p><strong>数据代价加权</strong></p><ul><li>如果任务本身是要识别小类样本，可以对分类器的小类样本增加权值，对大类样本降低权值，从而让分类器更关注小类样本</li></ul></li><li><p><strong>转化思路</strong></p><ul><li>例如将小类样本当作异常点，将分类任务转化为异常点检测任务</li></ul></li><li><p><strong>将类别再细分</strong></p><ul><li>将大类样本分成多个类别</li></ul></li></ul><br><br></vr>]]></content>
      
      
      <categories>
          
          <category> 周知识总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Artificial Intelligence </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之组合总和Ⅱ</title>
      <link href="/passages/leetcode-zhi-zu-he-zong-he-ii/"/>
      <url>/passages/leetcode-zhi-zu-he-zong-he-ii/</url>
      
        <content type="html"><![CDATA[<p>Combination Sum Ⅱ</p><a id="more"></a><h3 id="Combination-Sum-Ⅱ"><a href="#Combination-Sum-Ⅱ" class="headerlink" title="Combination Sum Ⅱ"></a>Combination Sum Ⅱ</h3><ul><li>code with Python</li><li>title number：040</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个数组<code>candidates</code>和一个目标数<code>target</code></li><li>找出<code>candidates</code>中可以使数字和为<code>target</code>的组合</li><li><code>candidates</code>中的每个数字在每个组合中只能使用<strong>一次</strong></li><li>所有数字均为正整数</li><li>解集中不能包含重复组合</li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li><p>相比与39题，该题的不同之处在于每个数字只能使用<strong>一次</strong></p></li><li><p>对与这项要求，我们可以在查找下一个数字时从<strong>当前位置的下一个位置</strong>开始</p></li><li><p>而要解决解集中不包含重复数，我们可以对数组进行排序，在检查<strong>选择列表</strong>时，滑过相同值的部分</p></li><li><p>仍是套用<a href="http://www.zivblog.top/passages/回溯法/" target="_blank" rel="noopener">回溯法</a>文章中提到的模版</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span><span class="params">(self, candidates: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> candidates:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    candidates.sort()</span><br><span class="line">    size = len(candidates)</span><br><span class="line">    res = []</span><br><span class="line">    <span class="comment"># 递归函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(i, temp_sum, temp_list)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> temp_sum == target:</span><br><span class="line">            res.append(temp_list)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, size):</span><br><span class="line">            <span class="comment"># 再加一个值大于target</span></span><br><span class="line">            <span class="keyword">if</span> temp_sum + candidates[j] &gt; target: </span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 滑过连续的相同值</span></span><br><span class="line">            <span class="keyword">if</span> j &gt; i <span class="keyword">and</span> candidates[j]==candidates[j<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 递归</span></span><br><span class="line">            backtrack(j+<span class="number">1</span>, temp_sum+candidates[j], temp_list + [candidates[j]])</span><br><span class="line">    backtrack(<span class="number">0</span>, <span class="number">0</span>, [])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯法</title>
      <link href="/passages/hui-su-fa/"/>
      <url>/passages/hui-su-fa/</url>
      
        <content type="html"><![CDATA[<p>回溯法</p><a id="more"></a><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li><p>总体上来说，回溯法（Back Tracking）是一种选优搜索算法，即通过试探的方式寻找达到目标的方式。</p></li><li><p>算法会依次尝试每个分叉点的所有可能，当探索到某一步时，发现当前的选择并不优或者达不到最终目标时，就退回上一步，再选择另一种可能进行探索。这种走不通路就退回再走的方式就是<strong>回溯法</strong>了</p></li><li><h3 id="算法讲解"><a href="#算法讲解" class="headerlink" title="算法讲解"></a>算法讲解</h3><h4 id="直观感受"><a href="#直观感受" class="headerlink" title="直观感受"></a>直观感受</h4><blockquote><p>假设你要从家去一个地方，而去往这个地方的路上有很多个岔路口。<br>用回溯法来找到去往目的地的方法就是一个岔路口一个岔路口的尝试。<br>如果发现走错了，就返回找到岔路口的下一条路，继续尝试，直到找到目的地。</p></blockquote><ul><li>从上面的例子来看，我们使用回溯法解决问题的时候，其实恰好是一次<strong>决策树</strong>的遍历</li></ul><h4 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h4><ul><li><p>既然是决策树的遍历，那我们需要考虑三个问题：</p><ul><li>路径：即已经作出的选择</li><li>选择列表：当前可以挑选的可能</li><li>结束条件：到达决策树的底层，也就是到达终点，无法再进行决策的条件</li></ul></li><li><p>下面我们将通过<strong>8皇后问题</strong>来演示回溯法的使用</p><ul><li>所谓八皇后问题，就是一个8*8的棋盘上，放置8个皇后，使得它们无法相互攻击</li><li>皇后可以攻击同一行、同一列、和所处两条对角线上的任意单位</li></ul></li><li><p>决策树的<strong>每一层</strong>对应棋盘上一行的情况，<strong>同一层上每个节点</strong>的表示在该层的对应位置放置皇后</p></li><li><p>而使用回溯法，就是遍历该决策树找到符合条件的路径（决策树中的路径对应一种摆放的方案）</p></li><li><p>既然是决策树的遍历，当然可以通过剪枝来减少代码的复杂度</p></li></ul></li></ul><h4 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h4><ul><li>剪枝的方法也很简单直接，即在走过的路径中出现的可能在后面不会再出现</li><li>一般通过一个判断路径合法性的函数来实现<br><img src="/.top//%E5%9B%9E%E6%BA%AF%E6%B3%95%5C1.png" alt="剪枝"></li><li>需要注意的是，不论如何优化，都无法使算法的复杂度降低太多，因为回溯法本身就是纯暴力穷举，遍历整棵决策树是无法避免的。</li></ul><h4 id="代码模版"><a href="#代码模版" class="headerlink" title="代码模版"></a>代码模版</h4><ul><li><p>代码方面，凡使用回溯法解决的问题，都可以套用以下代码模版</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">back_tracking</span><span class="params">(路径, 选择列表)</span>:</span></span><br><span class="line"><span class="keyword">if</span> 结束条件:</span><br><span class="line">result.add(路径)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">for</span> 选择<span class="keyword">in</span> 选择列表:</span><br><span class="line">做选择</span><br><span class="line">back_tracking(路径, 选择列表)</span><br><span class="line">回退</span><br></pre></td></tr></table></figure></li></ul><h4 id="DFS与回溯法"><a href="#DFS与回溯法" class="headerlink" title="DFS与回溯法"></a>DFS与回溯法</h4><ul><li>回溯法在实现上时遵循<strong>深度优先</strong>的原则的，即一步一步往前探索</li><li>深度优先搜索的目的是<strong>遍历</strong>，本质上是无序的，即不关心每次访问的次序，重要的是<strong>都被访问过</strong></li><li>回溯法的目的是<strong>求解</strong>，本质上是有序的。即每步都是要求的次序</li><li>深度优先搜索可以看作是工具，而回溯法是应用</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之组合总和</title>
      <link href="/passages/leetcode-zhi-zu-he-zong-he/"/>
      <url>/passages/leetcode-zhi-zu-he-zong-he/</url>
      
        <content type="html"><![CDATA[<p>Combnation Sum</p><a id="more"></a><h3 id="Combnation-Sum"><a href="#Combnation-Sum" class="headerlink" title="Combnation Sum"></a>Combnation Sum</h3><ul><li>code with Python</li><li>title number：039</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个无重复元素的数组和一个目标数</li><li>找出数组中所有可使数字和为目标数的组合</li><li>数组中元素可被无限制重复使用</li><li>所有数字均为整数，解的集合中不能包含重复的组合</li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li><p>很明显，这是一道典型的使用<strong>回溯法</strong>解决的问题</p></li><li><p>关于回溯法，可以看<a href="http://www.zivblog.top/passages/回溯法/" target="_blank" rel="noopener">另一篇</a>介绍该算法的文章</p></li><li><p>这里使用减法的思想，例如：<code>target=7, candidates=[2, 3, 6, 7]</code></p><ul><li>对于候选数字<code>2</code>，只需要找到所有<code>7-2=5</code>的所有组合，加上<code>2</code>就是结果了</li><li>对于候选数字<code>3</code>，只需要找到所有<code>7-3=4</code>的所有组合，加上<code>3</code>就是结果了</li><li>依次类推</li></ul></li><li><p>这样，我们就可得到一棵决策树，经优化后如下图</p><p><img src="/.top//tree.png" alt></p></li><li><p>正如图中已经经过剪枝，去掉了一些重复的枝叶，在代码中也要有所体现，即设置搜索起点</p></li><li><p>还有就是，我们还减去了一些从明显不能得到结果的枝叶，比如，当<code>7-3-6</code>之后的下一层就无需再遍历了</p></li><li><p>另外。对候选数组进行排序也可以加快搜索速度</p></li><li><p>对于每一条路径的选择，就是<strong>深度优先遍历了</strong></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, candidates: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">size = len(candidates)</span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    </span><br><span class="line">    candidates.sort()</span><br><span class="line">    </span><br><span class="line">    path, res = [], []</span><br><span class="line">    self._dfs(candidates, <span class="number">0</span>, size, path, res, target)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_dfs</span><span class="params">(self, candidates, begin, size, path, res, target)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">        res.append(path[:])</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(begin, size):</span><br><span class="line">        residue = target - candidates[index]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> residue &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        path.append(candidates[index])</span><br><span class="line">        self._dfs(candidates, index, size, path, res, residue)</span><br><span class="line">        path.pop()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之搜索旋转排序数组</title>
      <link href="/passages/leetcode-zhi-sou-suo-xuan-zhuan-pai-xu-shu-zu/"/>
      <url>/passages/leetcode-zhi-sou-suo-xuan-zhuan-pai-xu-shu-zu/</url>
      
        <content type="html"><![CDATA[<p>Search Rotated Sorted Array</p><a id="more"></a><h3 id="Search-Rotated-Sorted-Array"><a href="#Search-Rotated-Sorted-Array" class="headerlink" title="Search Rotated Sorted Array"></a>Search Rotated Sorted Array</h3><ul><li>code with Python</li><li>title number：033</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>假设当前的数组是在升序数组的某个结点上进行了旋转后得到<ul><li>例如：<code>[0, 1, 2, 4, 5, 6, 7] -&gt; [4, 5, 6, 7, 0, 1, 2]</code></li></ul></li><li>在当前数组中查找一个给定的目标值，<ul><li>若该值存在，则返回其索引</li><li>若不存在，则返回<code>-1</code></li></ul></li><li>数组中的数不重复</li><li>算法时间复杂度必须是<code>O(logn)</code></li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>限定了时间复杂度必须是<code>O(logn)</code>，基本上就是在暗示要使用<strong>二分搜索</strong>了</li><li>但是我们知道二分搜索的作用对象必须是有序数组，这里应该也可以用，我们分析一下：</li><li>对于数组<code>[4, 5, 6, 7, 0, 1, 2]</code>:</li><li>首先通过观察得到，这个数组包含<strong>两个有序子数组</strong>（前面的子数组整体大于后面的子数组），并且肯定会有一个子数组的长度是大于等于<code>数组长度/2</code></li><li>这样就是一种很好的性质了，假设我们要找的<code>target=6</code></li><li>首先计算<code>mid=(start+end)/2=3</code>，</li><li>比较<code>nums[mid]</code>与<code>nums[start]</code>的大小关系足以令我们确定我们现在 是位于哪一部分，之后就可以舍弃另一部分了（这和二分搜索一致）<ul><li>如果<code>nums[mid]&gt;=nums[start]</code>，则<code>nums[mid]</code>位于左边的有序子数组中</li><li>如果<code>nums[mid]&lt;nums[start]</code>，则<code>nums[mid]</code>位于右边的有序子数组中</li></ul></li><li>之后我们要确定<code>target</code>的位置，只需要比较<code>target</code>与有序部分边界的关系即可<ul><li>当<code>nums[mid]</code>在右边的有序部分时，只需判断<code>target</code>与<code>nums[mid]</code>和<code>nums[end]</code>的关系即可</li><li>当<code>nums[mid]</code>在左边的有序部分时，只需判断<code>target</code>与<code>nums[mid]</code>和<code>nums[end]</code>的关系即可</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    </span><br><span class="line">    start, end = <span class="number">0</span>, len(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> start &lt; end:</span><br><span class="line">        mid = (end - start) // <span class="number">2</span> + start</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="comment"># mid在在左边有序部分</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt; nums[left]:</span><br><span class="line">            <span class="comment"># target在左边有序部分</span></span><br><span class="line">            <span class="keyword">if</span> nums[start] &lt;= target &lt;= nums[mid]:</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">        <span class="comment"># mid在右边有序部分</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> nums[mid+<span class="number">1</span>] &lt;= target &lt;= nums[right]:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid</span><br><span class="line">                </span><br><span class="line">    <span class="keyword">return</span> left <span class="keyword">if</span> nums[left] == target <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之下一个排列</title>
      <link href="/passages/leetcode-zhi-xia-yi-ge-pai-lie/"/>
      <url>/passages/leetcode-zhi-xia-yi-ge-pai-lie/</url>
      
        <content type="html"><![CDATA[<p>Next Permutation</p><a id="more"></a><h3 id="Next-Permutation"><a href="#Next-Permutation" class="headerlink" title="Next Permutation"></a>Next Permutation</h3><ul><li>code with Python</li><li>title number：031</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li><p>将给定数字序列重新排列成字典序中下一个更大排列</p></li><li><p>如果不存在下一个更大排列，则将数字重新排列成最小的排列（升序）</p></li><li><p>原地操作，额外空间数为常数</p></li><li><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1, 2, 3 -&gt; 1, 3, 2</span><br><span class="line">3, 2, 1 -&gt; 1, 2, 3</span><br><span class="line">1, 1, 5 -&gt; 1, 5, 1</span><br></pre></td></tr></table></figure></li><li><p>这里比较难理解的是<code>下一个更大排列</code>的含义</p><ul><li>用一个比较易理解的方式是，将整组数字组成一个整数，下一个更大排列就是下一个刚刚大于当前数字的整数<ul><li>例如，给定<code>1, 2, 3 -&gt; 123</code>，则刚刚大于它的数字为<code>132 -&gt; 1, 3, 2</code></li></ul></li><li>更正式一点的说法如下：<ul><li>所谓的下一个排列，是在当前的基础上，将尾部的最小升序序列标为降序后的整个排列</li><li>比如：<code>1, 1, 5</code>的最小升序为<code>1, 5</code>，将其变为降序，则下一个更大排列为<code>1, 5, 1</code></li></ul></li></ul></li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>理解了<code>下一个更大排列</code>的含义之后，方法就很清晰了</li><li>我们从后往前遍历，找到下降点（即<code>nums[i] &gt; nums[i-1]</code>）处<ul><li>从后往前找到比下降点大的数，与下降点的数交换位置</li><li>由于下降点滑倒了后面，要重新排列下降点之后的数字（降序）</li></ul></li><li>如果没有下降点，则重新排序（升序）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span><span class="params">(self, nums: List[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    down_index = <span class="literal">None</span></span><br><span class="line">    <span class="comment"># 从后往前遍历</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt; nums[i+<span class="number">1</span>]:</span><br><span class="line">            down_index = i</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 没有下降点，重新排序        </span></span><br><span class="line">    <span class="keyword">if</span> down_index <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        nums.reverse()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 从后向前找到大于下降点的数，交换位置</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>, i, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[down_index] &lt; nums[j]:</span><br><span class="line">                nums[down_index], nums[j] = nums[j], nums[down_index]</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 对后面部分重新排序</span></span><br><span class="line">        i, j = down_index+<span class="number">1</span>, len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>代码再优化</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span><span class="params">(self, nums: List[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; nums[i<span class="number">-1</span>]:</span><br><span class="line">            nums[i:] = sorted(nums[i:])</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i, len(nums)):</span><br><span class="line">                <span class="keyword">if</span> nums[j] &gt; nums[i<span class="number">-1</span>]:</span><br><span class="line">                    nums[i<span class="number">-1</span>], nums[j] = nums[j], nums[i<span class="number">-1</span>]</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">    <span class="comment"># 找不到下降点</span></span><br><span class="line">    nums.sort()</span><br></pre></td></tr></table></figure><ul><li>不同之处在于，这里是先对下降点之后的元素进行了排序</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之两数相除</title>
      <link href="/passages/leetcode-zhi-liang-shu-xiang-chu/"/>
      <url>/passages/leetcode-zhi-liang-shu-xiang-chu/</url>
      
        <content type="html"><![CDATA[<p>Divivde Two Integers</p><a id="more"></a><h3 id="Divivde-Two-Integers"><a href="#Divivde-Two-Integers" class="headerlink" title="Divivde Two Integers"></a>Divivde Two Integers</h3><ul><li>code with Python</li><li>title number：029</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定两个整数，被除数<code>dividend</code>和除数<code>dicisor</code></li><li>将两数相除，不能使用乘法、除法和取余运算</li><li>返回两数相除得到的商</li><li>除数和被除数都是32位有符号整数，且除数不为0</li><li>环境只能存储32位有符号整数，范围为<code>[-2^31, 2^31-1]</code>，若结果溢出，则返回<code>2^31-1</code></li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li><p>最朴素的思想</p><ul><li><p>判断除数和被除数是否异号</p></li><li><p>除数和被除数取绝对值，用被除数不断减去除数，至被除数小于除数</p></li><li><p>根绝两者是否异号还原结果的真实正负情况</p></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(self, divdend: int, dividsor: int)</span> -&gt; int:</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    sign =  <span class="number">1</span> <span class="keyword">if</span> divd ^ dior &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">    divd = abs(divd)</span><br><span class="line">    dior = abs(dior)</span><br><span class="line">    <span class="keyword">while</span> divd &gt;= dior:</span><br><span class="line">        res += <span class="number">1</span></span><br><span class="line">        divd -= dior</span><br><span class="line">    res = res <span class="keyword">if</span> sign==<span class="number">1</span> <span class="keyword">else</span> -res</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> min(max(<span class="number">-2</span>**<span class="number">31</span>, res), <span class="number">2</span>**<span class="number">31</span><span class="number">-1</span>)</span><br></pre></td></tr></table></figure><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li><p>思路一中的方式明显会计算次数比较多，我们考虑是否能减少计算的次数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">观察：10 &#x2F; 3</span><br><span class="line">借鉴二分查找的思想，我们每次将除数翻倍（这里的翻倍通过除数自身加自身实现，而不是乘法）</span><br><span class="line">10&gt;3可以，10-3,result+1 </span><br><span class="line">-&gt; 7&gt;6可以，result+2 </span><br><span class="line">-&gt; 1-12&lt;0不行，所以结果是3</span><br><span class="line"></span><br><span class="line">再举个例子验证一下：12 &#x2F; 3</span><br><span class="line">12&gt;3可以，12-3，result+1 </span><br><span class="line">-&gt; 9&gt;6可以，9-6result+2 </span><br><span class="line">-&gt; 3&lt;6不行，</span><br><span class="line">-&gt; 再次从3开始判断</span><br><span class="line">-&gt; 3&lt;&#x3D;3，3-3，result+1，所以结果是4</span><br></pre></td></tr></table></figure></li><li><p>另外，我们判断除数和被除数是否异号————这决定结果的正负。在计算时我们使用绝对值函数取两者的绝对值进行计算</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(self, dividend: int, divisor: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="comment"># 特殊：被除数为1，需要判断除数的正负，并且考虑边界问题</span></span><br><span class="line">    <span class="keyword">if</span> abs(divisor) == <span class="number">1</span>:</span><br><span class="line">        result = dividend <span class="keyword">if</span> <span class="number">1</span> == divisor <span class="keyword">else</span> -dividend</span><br><span class="line">        <span class="keyword">return</span> min(<span class="number">2</span>**<span class="number">31</span> - <span class="number">1</span>, max(<span class="number">-2</span>**<span class="number">31</span>, result))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 判断除数和被除数是否异号</span></span><br><span class="line">    sign = (dividend &gt;=<span class="number">0</span>) == (divisor &gt;= <span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 取绝对值</span></span><br><span class="line">    _divisor， _dividend = abs(divisor)， abs(dividend)</span><br><span class="line">    </span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> _divisor &lt;= _dividend:</span><br><span class="line">        r, _dividend = self.multi_divide(_divisor, _dividend)</span><br><span class="line">        result += r</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 还原结果的正负号</span></span><br><span class="line">    result = result <span class="keyword">if</span> sign <span class="keyword">else</span> -result</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 检查边界</span></span><br><span class="line">    <span class="keyword">return</span> min(<span class="number">2</span>**<span class="number">31</span> <span class="number">-1</span>, max(<span class="number">-2</span>**<span class="number">31</span>, result))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_multi_divide</span><span class="params">(self, divisor, dividend)</span>:</span></span><br><span class="line">    <span class="comment"># divisor每次翻倍</span></span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    time_count = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> divisor &lt;= dividend:</span><br><span class="line">        dividend -= divisor</span><br><span class="line">        result += times_count</span><br><span class="line">        time_count += times_count</span><br><span class="line">        divisor += divisor</span><br><span class="line">    <span class="keyword">return</span> result, dividend</span><br></pre></td></tr></table></figure><h4 id="思路三"><a href="#思路三" class="headerlink" title="思路三"></a>思路三</h4><ul><li>声明：这种思路参考自题解</li><li>联想我们计算两个数除法时使用的竖式计算可以联想到使用<strong>移位与减法的组合</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(self, dividend: int, divisor: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="comment"># 判断两者是否同号</span></span><br><span class="line">    sign = (dividend &gt; <span class="number">0</span>) == (dividsor &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 取绝对值</span></span><br><span class="line">    dividend, dividsor = abs(dividend), abs(dividsor)</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 判断除数翻倍多少次会大于被除数，并将divisor变为该数</span></span><br><span class="line">    <span class="keyword">while</span> dividend &gt;= divisor:</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        divisor &lt;&lt;= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    result = <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">while</span> count &gt; <span class="number">0</span>:</span><br><span class="line">        count -= <span class="number">1</span></span><br><span class="line">        divisor &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> divisor &lt;= dividend:</span><br><span class="line">            result == <span class="number">1</span> &lt;&lt; count</span><br><span class="line">            dicidend -= divisor</span><br><span class="line">    <span class="comment">#还原结果的正负号     </span></span><br><span class="line">    <span class="keyword">if</span> sign: result = - result</span><br><span class="line">    <span class="comment"># 处理边界  </span></span><br><span class="line">    <span class="keyword">return</span> result <span class="keyword">if</span> <span class="number">-2</span>**<span class="number">31</span> &lt;= result <span class="keyword">and</span> result &lt;= <span class="number">2</span>**<span class="number">31</span><span class="number">-1</span> <span class="keyword">else</span> <span class="number">2</span>**<span class="number">31</span><span class="number">-1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之两两交换链表中的节点</title>
      <link href="/passages/leetcode-zhi-liang-liang-jiao-huan-lian-biao-zhong-de-jie-dian/"/>
      <url>/passages/leetcode-zhi-liang-liang-jiao-huan-lian-biao-zhong-de-jie-dian/</url>
      
        <content type="html"><![CDATA[<p>Swap Nodes in Pairs</p><a id="more"></a><h3 id="Swap-Nodes-in-Pairs"><a href="#Swap-Nodes-in-Pairs" class="headerlink" title="Swap Nodes in Pairs"></a>Swap Nodes in Pairs</h3><ul><li>code with Python</li><li>title number：024</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li><p>给定一个链表，两两交换其中相邻的结点</p></li><li><p>返回交换后的链表</p></li><li><p>不能只交换结点内部的值，必须操作实际的结点</p></li><li><p>示例</p><ul><li><code>1-&gt;2-&gt;3-&gt;4</code>经处理后应为<code>2-&gt;1-&gt;4-&gt;3</code></li></ul></li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>通过示例我们可以发现，相邻结点的交换并没有交集，即每个结点只会作为一个结点的相邻结点进行交换</li><li>我们使用递归的方式进行<ul><li>终止条件：当链表为空或只剩一个元素时终止</li><li>返回值：应将当前经过交换之后的子链表返回给上一层</li><li>递归主体：接收了上一步经过交换的子链表，以及当前结点，共三个结点。其中我们交换前两个结点。<ul><li>假设两个待交换结点为<code>head</code>, <code>second</code></li><li><code>head</code>要指向返回的子链表，<code>head-&gt;next=swapPairs(...)</code></li><li><code>second</code>要指向<code>head</code>，这里要使用一个临时变量存储<code>second</code>，也就是<code>head-&gt;next</code></li><li>返回值当然是<code>second</code>，因为现在它是交换后子链表的第一个结点</li></ul></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">    <span class="comment"># 没有结点或只有一个结点</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    second = head.next</span><br><span class="line">    </span><br><span class="line">    head.next = self.swapPairs(second.next)</span><br><span class="line">    second.next = head</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> second</span><br></pre></td></tr></table></figure><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li><p>按照朴素的思想，我们可以一边遍历一边交换</p></li><li><p>这种情况下，交换两个相邻的结点实际上需要涉及四个结点：即<code>pre</code>，<code>first</code>，<code>second</code>，<code>tail</code></p><ul><li><code>pre-&gt;next = first-&gt;next</code></li><li><code>first-&gt;next = second-&gt;next</code></li><li><code>second-&gt;next = first</code></li></ul></li><li><p>注意，每次移动的步长为2</p></li><li><p>此外，创建一个虚拟头部结点，方便处理</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.next <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    </span><br><span class="line">    dummp = ListNode(<span class="number">-1</span>)</span><br><span class="line">    dummp.next = head</span><br><span class="line">    pre = dummp</span><br><span class="line">    <span class="keyword">while</span> pre.next <span class="keyword">and</span> pre.next.next:</span><br><span class="line">        first = pre.next</span><br><span class="line">        second = first.next</span><br><span class="line">        </span><br><span class="line">        pre.next, second.next, first.next = second, first, second.next</span><br><span class="line">        pre = first</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> dummp.next</span><br></pre></td></tr></table></figure><ul><li>重点还是第一种递归方法的理解，本身想到了递归但是没有写出来，参考了题解中的代码</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之删除链表倒数第n个结点</title>
      <link href="/passages/leetcode-zhi-shan-chu-lian-biao-dao-shu-di-n-ge-jie-dian/"/>
      <url>/passages/leetcode-zhi-shan-chu-lian-biao-dao-shu-di-n-ge-jie-dian/</url>
      
        <content type="html"><![CDATA[<p>Remove Nth Node From End of List</p><a id="more"></a><h3 id="Remove-Nth-Node-From-End-of-List"><a href="#Remove-Nth-Node-From-End-of-List" class="headerlink" title="Remove Nth Node From End of List"></a>Remove Nth Node From End of List</h3><ul><li>code with Python</li><li>title number：019</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个链表和一个数字<code>n</code></li><li>删除链表的倒数第<code>n</code>个结点</li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>问题的关键在与确定第n个元素的位置</li><li>这里我们使用最简单的方式查找第n个元素<ul><li>第一次遍历统计整个链表的长度<code>count</code></li><li>使用<code>count-n</code>即确定的待删除结点的位置</li><li>再次遍历删除即可</li></ul></li><li>注意，要删除第<code>n</code>个结点，我们要找的实际是第<code>n-1</code>个结点</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeNthFromENd</span><span class="params">(self, head: ListNode, n: int)</span> -&gt; ListNode:</span></span><br><span class="line">    helper = ListNode(<span class="number">-1</span>)</span><br><span class="line">    helper.next = head</span><br><span class="line">    first = head</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 统计链表中元素个数</span></span><br><span class="line">    <span class="keyword">while</span> first:</span><br><span class="line">        first = first.next</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    index = count - n</span><br><span class="line">    first = helper</span><br><span class="line">    <span class="comment"># 确定待删除元素的位置</span></span><br><span class="line">    <span class="keyword">while</span> index:</span><br><span class="line">        first = first.next</span><br><span class="line">        index -= <span class="number">1</span></span><br><span class="line">    <span class="comment"># 删除元素</span></span><br><span class="line">    first.next = first.next.next</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> helper.next</span><br></pre></td></tr></table></figure><ul><li>建立辅助结点<code>helper</code>是为了更好的处理边界条件：当<code>n</code>等于链表长度时会溢出</li></ul><h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><ul><li>减少遍历链表的次数，是用双指针进行：<ul><li>初始时指针<code>p</code>和<code>q</code>分别指向<code>helper</code></li><li><code>p</code>指针先移动<code>n</code>次</li><li>之后<code>p</code>和<code>q</code>一起移动，当<code>p</code>指针指向<code>None</code>时，<code>q</code>指针恰好指向待删除结点的前一个元素</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeNthFromENd</span><span class="params">(self, head: ListNode, n: int)</span> -&gt; ListNode:</span></span><br><span class="line">    helper = ListNode(<span class="number">-1</span>)</span><br><span class="line">    helper.next = head</span><br><span class="line">    p, q = helper, helper</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> n:</span><br><span class="line">        p = p.next</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">while</span> p.next != <span class="literal">None</span>:</span><br><span class="line">        p = p.next</span><br><span class="line">        q = q.next</span><br><span class="line">        </span><br><span class="line">    q.next = q.next.next</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> helper.next</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之三数之和</title>
      <link href="/passages/leetcode-zhi-san-shu-zhi-he/"/>
      <url>/passages/leetcode-zhi-san-shu-zhi-he/</url>
      
        <content type="html"><![CDATA[<p>3 Sum</p><a id="more"></a><h3 id="3-Sum"><a href="#3-Sum" class="headerlink" title="3 Sum"></a>3 Sum</h3><ul><li>code with Python</li><li>title number：015</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个包含n个整数的数组</li><li>判断数组中是否存在三个元素之和为0</li><li>找出所有满足条件且不重复的三元组</li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li><p>按照惯例，暴力法</p></li><li><p>穷举所有的三元组的可能，并判断每个三元组的和是否为0</p></li><li><p>由于要求不能有重复的三元组，额外实现一个函数，用于判断两个三元组是否包含的元素相似</p></li><li><p>这个算法的时间复杂度已经达到了$O(n^3)$，简单写一下<strong>伪代码</strong>吧</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">    res = []</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">notInres</span><span class="params">(arr)</span>:</span></span><br><span class="line">        <span class="comment"># 判断给定三元组是否在答案中</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span> <span class="keyword">if</span> arr <span class="keyword">in</span> res <span class="keyword">else</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                <span class="comment"># 判断当前三元组是否和为0</span></span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[j] + nums[k] == <span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># 判断答案中是否包含该三元组</span></span><br><span class="line">                    <span class="keyword">if</span> notInres([nums[i], nums[j], nums[k]]):</span><br><span class="line">                        res.append([nums[i], nums[j], nums[k]])</span><br><span class="line">                        </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li><p>上面的暴力法存在太多的重复判断，并且是三层循环，我们尝试减少循环的次数</p></li><li><p>采用分治的思想，我们假定每个元素<code>a[i]</code>都可能是最终组成和为0的三元组中的一个数字，那么剩下的工作就是找到两个和为<code>-a[i]</code>的元素。这样就将循环减少到了两个</p></li><li><p>问题现在转化成了：<code>给定一个数组，找出其中两个相加等于一个给定值</code></p></li><li><p>对于转化后的问题，我们对数组进行<strong>升序排序</strong>，使用双指针解决</p><ul><li><p>固定三个指针中的最小的指针<code>i</code>，将另外两个指针分别置为<code>l=i+1</code>和<code>r=n-1</code>，通过双指针的交叉移动，记录满足条件的三元组</p></li><li><p>当<code>nums[i]&gt;0</code>时直接跳过。因为在此条件下<code>nums[i]</code>之后的元素必大于0，不可能相加为0</p></li><li><p>当<code>nums[i] == nums[i-1]</code>时，已经对<code>nums[i-1]</code>进行过搜索，再次进行必定会得到相同的结果</p></li><li><p>计算<code>nums[i]+nums[l]+nums[r]</code>的和，</p><ul><li>当大于0时<code>l+=1</code></li><li>当小于0时<code>r-=1</code></li><li>当等于0时<code>l+=1,r-=1</code></li></ul></li></ul></li><li><p>另外，如果数组长度小于3，则返回<code>[]</code></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">if</span> len(nums) &lt; <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    </span><br><span class="line">    nums.sort()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i<span class="number">-1</span>]:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        l = i+<span class="number">1</span></span><br><span class="line">        r = len(nums)<span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            <span class="keyword">if</span> nums[i]+nums[l]+nums[r]==<span class="number">0</span>:</span><br><span class="line">                res.append([nums[i], nums[l], nums[r]])</span><br><span class="line">                <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[l]==nums[l+<span class="number">1</span>]:</span><br><span class="line">                    l = l + <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[r]==nums[r<span class="number">-1</span>]:</span><br><span class="line">                r = r - <span class="number">1</span></span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[i]+nums[l]+nums[r] &gt; <span class="number">0</span>:</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之盛水最多的容器</title>
      <link href="/passages/leetcode-zhi-sheng-shui-zui-duo-de-rong-qi/"/>
      <url>/passages/leetcode-zhi-sheng-shui-zui-duo-de-rong-qi/</url>
      
        <content type="html"><![CDATA[<p>Container With Most Water</p><a id="more"></a><h3 id="Container-With-Most-Water"><a href="#Container-With-Most-Water" class="headerlink" title="Container With Most Water"></a>Container With Most Water</h3><ul><li>code with Python</li><li>title number：011</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定<code>n</code>个非负整数<code>a1, ... , an</code>，每个数代表坐标中的一个点<code>(i, ai)</code></li><li>在坐标内画<code>n</code>条垂直线<code>(i, ai)-&gt;(i, 0)</code>，找出其中两条线，使其与<code>x</code>轴围成的容器内可以容纳最多的水</li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>两条垂直线能够围成矩形面积取决于两个因素<ul><li>两条垂直线中较短的一条</li><li>两条垂直线之间的距离</li></ul></li><li>按照惯例，在情况可穷举的情况下先尝试暴力法<ul><li>设置一个变量存储截至当前能获得的最大面积</li><li>两个循环控制围成矩形的左右垂直线</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxArea</span><span class="params">(self, height: List[int])</span> -&gt; int:</span></span><br><span class="line">    maxarea = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(height)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(height)):</span><br><span class="line">            maxarea = max(maxarea, min(height[j], height[i])*(j-i))</span><br><span class="line">    <span class="keyword">return</span> maxarea</span><br></pre></td></tr></table></figure><ul><li>不出意外的超时了</li></ul><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li>双指针法<ul><li>设置两个指针，一个指向最前端的垂直线，一个直线末尾的垂直线</li><li>设置一个变量存储截至当前能获得的最大面积</li><li>计算两个垂直线围成的面积，并且使指向较短垂直线的指针向内移动</li></ul></li><li>可行性<ul><li>在思路一中我们分析得到能够影响矩形面积的有两个因素：<strong>两条中较短的垂直线</strong>以及<strong>两条垂直线之间的距离</strong></li><li>在我们的指针移动时，必然会带来两条垂直线之间距离的减小。如果移动指向两条之中较长的垂直线的指针，则会受较短的垂直线的限制<strong>必然导致面积减少</strong>；同样的情况下如果移动指向两条中较短的垂直线的指针才有可能带来面积的增加。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxArea</span><span class="params">(self, height: List[int])</span> -&gt; int:</span></span><br><span class="line">    maxarea = <span class="number">0</span></span><br><span class="line">    l, r = <span class="number">0</span>, len(height)<span class="number">-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> l &lt; r:</span><br><span class="line">        maxarea = max(maxarea, min(height[l], height[r])*(r-l))</span><br><span class="line">        <span class="keyword">if</span> height[l] &lt; height[r]:</span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> maxarea</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之最长回文子串</title>
      <link href="/passages/leetcode-zhi-zui-chang-hui-wen-zi-chuan/"/>
      <url>/passages/leetcode-zhi-zui-chang-hui-wen-zi-chuan/</url>
      
        <content type="html"><![CDATA[<p>Longest Palindromic Substring</p><a id="more"></a><h3 id="Longest-Palindromic-Substring"><a href="#Longest-Palindromic-Substring" class="headerlink" title="Longest Palindromic Substring"></a>Longest Palindromic Substring</h3><ul><li>code with Python</li><li>title number：005</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个字符串，最大长度为1000</li><li>找到字符串中的最长回文子串</li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>老规矩，先上暴力法</li><li>使用一个变量存储当前得到的最长回文子串的长度</li><li>双循环控制子串的首尾位置，判断子串是否为回文，并且当前子串长度更长时，更新</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">    <span class="comment"># 暴力法</span></span><br><span class="line">    max_length = <span class="number">0</span></span><br><span class="line">    res = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(s)+<span class="number">1</span>):</span><br><span class="line">            temp = s[i:j]   </span><br><span class="line">            <span class="keyword">if</span> temp == temp[::<span class="number">-1</span>] <span class="keyword">and</span> len(temp) &gt;= max_length:</span><br><span class="line">                max_length = len(temp)</span><br><span class="line">                res = temp             </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><ul><li>很可惜，超时了</li></ul><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li><p>其实这个问题也能使用动态规划来解决</p></li><li><p>首先想到，当一个字符串的头尾两个字符都不相等时，那这个字符串一定不是回文串；</p></li><li><p>紧接着，如果头尾两个字符串相等，我们再对去掉首尾字符的内部子串进行判断</p><ul><li>如果内部子串也是回文串，那么继续进行</li><li>如果内部子串不是回文串，那么就可以宣布结束了</li></ul></li><li><p>正式一点，按照动态规划的分析方式</p><ul><li>定义状态：<code>d[i][j]</code>：表示子串<code>s[i:j]</code>是否为回文子串</li><li>初始化：<ul><li>将初试<code>dp</code>全部设置为<code>False</code></li><li>或者仅将<code>dp[i][i]</code>设置为<code>True</code>其他设置为<code>False</code></li></ul></li><li>状态转移方程：<code>dp[i][j] = (s[i] == s[j]) and dp[i+1][j-1]</code></li><li>边界条件：<code>[i+1, j-1]</code>不构成区间，即长度小于2（为0或为1）<ul><li>由此可以直接制定规则，当字符串长度小于2时直接返回该字符串即可</li></ul></li><li>输出：当<code>dp[i][j]=True</code>时返回<code>i</code>和<code>j</code>即可</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">    <span class="keyword">if</span> len(s) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    </span><br><span class="line">    dp = [[<span class="literal">False</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s))] <span class="keyword">for</span> j <span class="keyword">in</span> range(len(s))]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">        dp[i][i] = <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(s)):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, j):</span><br><span class="line">            <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                <span class="keyword">if</span> j - i &lt; <span class="number">3</span>:</span><br><span class="line">                    dp[i][j] = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                sp[i][j] = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> dp[i][j]:</span><br><span class="line">                cur_len = j - i + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> cur_len &gt; max_len:</span><br><span class="line">                    max_len = cur_len</span><br><span class="line">                    start = i</span><br><span class="line">    <span class="keyword">return</span> s[start, start+max_len]</span><br></pre></td></tr></table></figure><ul><li>这里有一个细节，并不使用单独的结构存储最长回文子串，而是只存储其长度和起始位置，这样可以减少切片带来的时间消耗</li></ul><h4 id="思路三"><a href="#思路三" class="headerlink" title="思路三"></a>思路三</h4><ul><li>中心扩散法，参考官方题解</li><li>思路一中的暴力法是枚举子串的左右边界，然后判断该子串是否为回文串</li><li>而该方法的思路是枚举可能出现回文子串的<strong>中心位置</strong>，从中心位置向外<strong>扩散</strong></li><li>注意，字符串长度为奇数和偶数时，枚举的<strong>回文中心</strong>的形式是不同的<ul><li>当长度为奇数时，可以直接枚举具体的字符</li><li>当长度为偶数时，枚举的不再是字符，而是<strong>两个字符的间隙</strong>，或者说是枚举两个相邻字符作为中心</li></ul></li><li>使用一下方式可以兼容两种情况<ul><li>传入重合的索引，则按奇数情况中心扩散</li><li>传入相邻的索引，则按偶数情况中心扩散</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">    length = len(s)</span><br><span class="line">    <span class="keyword">if</span> length &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    </span><br><span class="line">    max_len = <span class="number">1</span></span><br><span class="line">    res = s[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 根据传入的索引进行中心扩散</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">center_spread</span><span class="params">(s, size, left, right)</span>:</span></span><br><span class="line">        i, j = left, right</span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &lt; size <span class="keyword">and</span> s[i] == s[j]:</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s[i+<span class="number">1</span>:j], j-i<span class="number">-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">        <span class="comment"># 分别进行奇数和偶数的情况</span></span><br><span class="line">        odd, odd_len = center_spread(s, length, i, i)</span><br><span class="line">        even, even_len = center_spread(s, length, i, i+<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 找到当前最长回文子串</span></span><br><span class="line">        cur_max = odd <span class="keyword">if</span> odd_len &gt;= even_len <span class="keyword">else</span> even</span><br><span class="line">        <span class="keyword">if</span> len(cur_max) &gt; max_len:</span><br><span class="line">            max_len = len(cur_max)</span><br><span class="line">            res = cur_max</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客其他细节优化</title>
      <link href="/passages/bo-ke-qi-ta-xi-jie-you-hua/"/>
      <url>/passages/bo-ke-qi-ta-xi-jie-you-hua/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="文章置顶"><a href="#文章置顶" class="headerlink" title="文章置顶"></a>文章置顶</h3><ul><li><p>替换插件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-generator-index --save</span><br><span class="line"></span><br><span class="line">npm install hexo-generator-index-pin-top -- save</span><br></pre></td></tr></table></figure></li><li><p>在需要置顶的文章的<code>Front-matter</code>中加上<code>top</code>属性，并设置为<code>True</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 2020</span><br><span class="line">data: 2020-03-04</span><br><span class="line">catagoris: ***</span><br><span class="line">tags: ***</span><br><span class="line">top: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li></ul><h3 id="链接中汉字转为拼音"><a href="#链接中汉字转为拼音" class="headerlink" title="链接中汉字转为拼音"></a>链接中汉字转为拼音</h3><ul><li><p>安装插件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-permalink-pinyin --save</span><br></pre></td></tr></table></figure></li><li><p>修改配置文件</p><ul><li>修改根目录下的配置文件，添加以下配置</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">permalink_pinyin:</span><br><span class="line">enable: true</span><br><span class="line">separator: '-'</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 博客相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之无重复的最长子串</title>
      <link href="/passages/leetcode-zhi-wu-chong-fu-de-zui-chang-zi-chuan/"/>
      <url>/passages/leetcode-zhi-wu-chong-fu-de-zui-chang-zi-chuan/</url>
      
        <content type="html"><![CDATA[<p>Longest Substring Without Repeating Characters</p><a id="more"></a><h3 id="Longest-Substring-Without-Repeating-Characters"><a href="#Longest-Substring-Without-Repeating-Characters" class="headerlink" title="Longest Substring Without Repeating Characters"></a>Longest Substring Without Repeating Characters</h3><ul><li>code with Python</li><li>title number：003</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个字符串，找出其中不含重复字符的最长子串</li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>最先应该想到的就是暴力法了</li><li>穷举所有可能的子串，并判断该子串中字符是否是无重复的</li><li>为了代码的整洁，将判断部分抽象成一个函数<ul><li>遍历字符串中每个字符</li><li>如果该字符不在辅助集合中，则添加进去</li><li>如果在集合中，则返回<code>False</code></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(s)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> self.isUnique(s[i:j]):</span><br><span class="line">                res = max(res, j-i)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isUnique</span><span class="params">(self, s)</span>:</span></span><br><span class="line">    unique = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">        <span class="keyword">if</span> s[i] <span class="keyword">in</span> unique:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            unique[s[i]] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><ul><li>很遗憾，时间复杂度太高，超时了</li></ul><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li>思路一中存在许多重复的检测，例如<ul><li><code>s[i:j]</code>是无重复的，那么在检测<code>s[i:j+1]</code>是就只需要判断<code>s[j+1]</code>是否在<code>s[i:j]</code>中即可</li></ul></li><li>直觉上的想法是遍历前面的子串<code>s[i:j]</code>，依次判断其中的元素是否与第<code>s[j+1]</code>相等</li><li>但是这样仍会带来比较高的时间复杂度，所以我们使用滑动窗口来实现<ul><li>使用集合中作为滑动窗口，初始时<code>i=j</code>（<code>i, j</code>分别为滑动窗口的左端和右端，左闭又开）</li><li>向右滑动右端点<code>j</code>，并判断<code>s[j]</code>是否在集合中，如果不在，则将其添加到集合中</li><li>如果<code>s[j]</code>在集合中，则向右滑动左端点<code>i</code></li><li>这样就可以判断所有以<code>i</code>为左端点的不重复子串了</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">    res, i, j = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    temp = set()</span><br><span class="line">    <span class="keyword">while</span> i &lt; len(s) <span class="keyword">and</span> j &lt; len(s):</span><br><span class="line">        <span class="keyword">if</span> s[j] <span class="keyword">not</span> <span class="keyword">in</span> temp:</span><br><span class="line">            temp.add(s[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            res = max(res, j-i)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            temp.remove(s[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="思路三"><a href="#思路三" class="headerlink" title="思路三"></a>思路三</h4><ul><li>思路二实际上还存在重复判断的现象，例如<ul><li><code>s[i:j]</code>和<code>s[i+1, j+1]</code>这两种左端点不同的子串就存在重复部分<code>s[i+1,j]</code></li></ul></li><li>所以我们使用字典来建立字符到索引的映射，而不是使用集合来判断字符是否存在于子串中<ul><li>具体的，当<code>s[i,j)</code>中存在<code>s[j&#39;]==s[j]</code>，即使逐渐增加左端点<code>i</code>，在<code>i</code>到达<code>j&#39;+1</code>之前，<code>j&#39;+1</code>仍会是到<code>j</code>就停止的阻碍</li><li>所以我们选择不逐渐增加左端点，而是直接跳过<code>s[i, j&#39;]</code>范围内的元素，令<code>i=j&#39;+1</code></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">n, res = len(s), <span class="number">0</span></span><br><span class="line">    i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    temp = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">if</span> s[j] <span class="keyword">in</span> temp:</span><br><span class="line">            i = max(temp[s[j]], i)</span><br><span class="line">        </span><br><span class="line">        res = max(res, j-i+<span class="number">1</span>)</span><br><span class="line">        temp[s[j]] = j+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【置顶】这里是置顶</title>
      <link href="/passages/zhe-li-shi-zhi-ding/"/>
      <url>/passages/zhe-li-shi-zhi-ding/</url>
      
        <content type="html"><![CDATA[<p>这是小站的导航页</p><a id="more"></a><h3 id="Leetcode精刷题目"><a href="#Leetcode精刷题目" class="headerlink" title="Leetcode精刷题目"></a>Leetcode精刷题目</h3><ul><li>原项目在<a href="https://github.com/azl397985856/leetcode" target="_blank" rel="noopener">这里</a></li><li>推荐一个较直观的演示<a href="https://www.cxyxiaowu.com/likou/leetcode" target="_blank" rel="noopener">图解力扣</a></li><li>更多题目请见<a href="https://leetcode-cn.com/" target="_blank" rel="noopener">leetcode</a></li><li>该部分所刷的题目参考上面项目中的题目，会有部分题目的扩充，重点是解题思路的扩充，基本做到一题多解，思路的描述相对口语化，美中不足是没有绘制相对直观的图例。</li></ul><hr><p><strong>说明（2020.6.23）：</strong></p><ul><li>发现一宝藏刷题教程，决定抽时间按顺序来一遍，链接在此：<a href="https://greyireland.gitbook.io/algorithm-pattern/" target="_blank" rel="noopener">Algorithm Pattern</a></li><li>具体安排为：学习内容 -&gt; 练习题（已做过不再更新）-&gt; Leetcode卡片 -&gt; 剑指Offer</li><li>加油，jiu mi~</li></ul><br><h4 id="简单题目"><a href="#简单题目" class="headerlink" title="简单题目"></a>简单题目</h4><table><thead><tr><th>周一</th><th>周二</th><th>周三</th><th>周四</th><th>周五</th><th>周六</th><th>周日</th></tr></thead><tbody><tr><td></td><td><a href="http://www.zivblog.top/passages/Leetcode之两数之和/" target="_blank" rel="noopener">两数之和</a></td><td><a href="http://www.zivblog.top/passages/Leetcode之回文数/" target="_blank" rel="noopener">回文数</a></td><td><a href="http://www.zivblog.top/passages/Leetcode之罗马数字转整数/" target="_blank" rel="noopener">罗马数字转整数</a></td><td><a href="http://www.zivblog.top/passages/Leetcode之最长公共前缀/" target="_blank" rel="noopener">最长公共前缀</a></td><td><a href="http://www.zivblog.top/passages/Leetcode之有效的括号/" target="_blank" rel="noopener">有效的括号</a></td><td><a href="http://www.zivblog.top/passages/Leetcode之回文串Ⅱ/" target="_blank" rel="noopener">删除排序数组中的重复项</a></td></tr><tr><td><a href="http://www.zivblog.top/passages/Leetcode之最大子序和/" target="_blank" rel="noopener">最大子序和</a></td><td><a href="http://www.zivblog.top/passages/Leetcode之合并两个有序数组/" target="_blank" rel="noopener">合并两个有序数组</a></td><td><a href="http://www.zivblog.top/passages/Leetcode之买股票的最佳时机/" target="_blank" rel="noopener">买股票的最佳时机</a></td><td><a href="http://www.zivblog.top/passages/Leetcode之二叉树的最大深度/" target="_blank" rel="noopener">二叉树的最大深度</a></td><td><a href="http://www.zivblog.top/passages/Leetcode之买股票的最佳时机Ⅱ/" target="_blank" rel="noopener">买股票的最佳时机Ⅱ</a></td><td><a href="http://www.zivblog.top/passages/Leetcode之回文串/" target="_blank" rel="noopener">回文串</a></td><td><a href="http://www.zivblog.top/passages/Leetcode之回文串Ⅱ/" target="_blank" rel="noopener">回文串Ⅱ</a></td></tr><tr><td><a href="http://www.zivblog.top/passages/Leetcode之只出现一次的数字/" target="_blank" rel="noopener">只出现一次的数字</a></td><td><a href="http://www.zivblog.top/passages/Leetcode之最小栈/" target="_blank" rel="noopener">最小栈</a></td><td><a href="http://www.zivblog.top/passages/Leetcode之两数之和Ⅱ/" target="_blank" rel="noopener">两数之和Ⅱ</a></td><td><a href="http://www.zivblog.top/passages/Leetcode之阶乘后的0/" target="_blank" rel="noopener">阶乘后的0</a></td><td><a href="http://www.zivblog.top/passages/Leetcode之多数元素/" target="_blank" rel="noopener">多数元素</a></td><td><a href="http://www.zivblog.top/passages/Leetcode之翻转二进制位/" target="_blank" rel="noopener">翻转二进制位</a></td><td><a href="http://www.zivblog.top/passages/Leetcode之位1的个数/" target="_blank" rel="noopener">位1的个数</a></td></tr><tr><td><a href="http://www.zivblog.top/passages/Leetcode之打家劫舍/" target="_blank" rel="noopener">打家劫舍</a></td><td><a href="http://www.zivblog.top/passages/Leetcode之删除链表元素/" target="_blank" rel="noopener">删除链表元素</a></td><td><a href="http://www.zivblog.top/passages/Leetcode之反转链表/" target="_blank" rel="noopener">反转链表</a></td><td><a href="http://www.zivblog.top/passages/Leetcode之包含重复数Ⅱ/" target="_blank" rel="noopener">包含重复数Ⅱ</a></td><td><a href="http://www.zivblog.top/passages/Leetcode之反转二叉树/" target="_blank" rel="noopener">反转二叉树</a></td><td><a href="http://www.zivblog.top/passages/Leetcode之使用栈实现队列/" target="_blank" rel="noopener">使用栈实现队列</a></td><td><a href="http://www.zivblog.top/passages/Leetcode之丑数/" target="_blank" rel="noopener">丑数</a></td></tr><tr><td><a href="http://www.zivblog.top/passages/Leetcode之移动0元素/" target="_blank" rel="noopener">移动0元素</a></td><td><a href="http://www.zivblog.top/passages/Leetcode之4的阶乘/" target="_blank" rel="noopener">4的阶乘</a></td><td><a href="http://www.zivblog.top/passages/Leetcode之两个数组的交集/" target="_blank" rel="noopener">两个数组的交集</a></td><td><a href="http://www.zivblog.top/passages/Leetcode之路径之和Ⅲ/" target="_blank" rel="noopener">路径之和Ⅲ</a></td><td><a href="http://www.zivblog.top/passages/Leetcode之两整数之和/" target="_blank" rel="noopener">两个整数之和</a></td><td><a href="http://www.zivblog.top/passages/Leetcode之二叉搜索树中的众数/" target="_blank" rel="noopener">二叉搜索树中的众数</a></td><td><a href="http://www.zivblog.top/passages/Leetcode之分发糖果/" target="_blank" rel="noopener">分发糖果</a></td></tr><tr><td><a href="http://www.zivblog.top/passages/Leetcode之模拟机器人行走/" target="_blank" rel="noopener">模拟机器人行走</a></td><td><a href="http://www.zivblog.top/passages/Leetcode之二维网格迁移/" target="_blank" rel="noopener">二维网格迁移</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-ping-heng-er-cha-shu/" target="_blank" rel="noopener">平衡二叉树</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-er-cha-shu-de-ceng-xu-bian-li-ii/" target="_blank" rel="noopener">二叉树的层序遍历Ⅱ</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-shan-chu-pai-xu-shu-zu-zhong-de-chong-fu-yuan-su/" target="_blank" rel="noopener">删除排序数组中的重复元素</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-shan-chu-pai-xu-shu-zu-zhong-de-chong-fu-yuan-su-ii/" target="_blank" rel="noopener">删除排序数组中的重复元素Ⅱ</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-shan-chu-pai-xu-shu-zu-zhong-de-chong-fu-yuan-su/" target="_blank" rel="noopener">删除排序数组中的重复元素</a></td></tr><tr><td><a href="http://www.zivblog.top/passages/leetcode-zhi-huan-xing-lian-biao-ii/" target="_blank" rel="noopener">环形链表Ⅱ</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-hui-wen-lian-biao/" target="_blank" rel="noopener">回文链表</a></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h4 id="中等题目"><a href="#中等题目" class="headerlink" title="中等题目"></a>中等题目</h4><table><thead><tr><th>周一</th><th>周二</th><th>周三</th><th>周四</th><th>周五</th><th>周六</th><th>周日</th></tr></thead><tbody><tr><td><a href="http://www.zivblog.top/passages/Leetcode之两数相加/" target="_blank" rel="noopener">两数相加</a></td><td><a href="http://www.zivblog.top/passages/Leetcode之无重复的最长子串/" target="_blank" rel="noopener">无重复的最长子串</a></td><td><a href="http://www.zivblog.top/passages/Leetcode之最长回文子串/" target="_blank" rel="noopener">最长回文子串</a></td><td><a href="http://www.zivblog.top/passages/Leetcode之盛水最多的容器/" target="_blank" rel="noopener">盛水最多的容器</a></td><td><a href="http://www.zivblog.top/passages/Leetcode之三数之和/" target="_blank" rel="noopener">三数之和</a></td><td><a href="http://www.zivblog.top/passages/Leetcode之删除链表倒数第n个结点/" target="_blank" rel="noopener">删除链表倒数第n个结点</a></td><td><a href="http://www.zivblog.top/passages/Leetcode之两两交换链表中的节点/" target="_blank" rel="noopener">两两交换链表中的节点</a></td></tr><tr><td><a href="http://www.zivblog.top/passages/Leetcode之两数相除/" target="_blank" rel="noopener">两数相除</a></td><td><a href="http://www.zivblog.top/passages/Leetcode之下一个排列/" target="_blank" rel="noopener">下一个排列</a></td><td><a href="http://www.zivblog.top/passages/Leetcode之搜索旋转排序数组/" target="_blank" rel="noopener">搜索旋转排序数组</a></td><td><a href="http://www.zivblog.top/passages/Leetcode之组合总和/" target="_blank" rel="noopener">组合总和</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-quan-pai-lie/" target="_blank" rel="noopener">全排列</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-quan-pai-lie-ii/" target="_blank" rel="noopener">全排列Ⅱ</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-xuan-zhuan-tu-xiang/" target="_blank" rel="noopener">旋转图像</a></td></tr><tr><td><a href="http://www.zivblog.top/passages/leetcode-zhi-zi-mu-yi-wei-ci-fen-zu/" target="_blank" rel="noopener">字母异位词分组</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-shi-xian-x-de-n-ci-mi/" target="_blank" rel="noopener">实现x的n次幂</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-tiao-yue-you-xi/" target="_blank" rel="noopener">跳跃游戏</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-he-bing-qu-jian/" target="_blank" rel="noopener">合并区间</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-di-k-ge-pai-lie/" target="_blank" rel="noopener">第k个排列</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-bu-tong-lu-jing/" target="_blank" rel="noopener">不同路径</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-ju-zhen-zhi-ling/" target="_blank" rel="noopener">矩阵置零</a></td></tr><tr><td><a href="http://www.zivblog.top/passages/leetcode-zhi-yan-se-fen-lei/" target="_blank" rel="noopener">颜色分类</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-zi-ji/" target="_blank" rel="noopener">子集</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-dan-ci-sou-suo/" target="_blank" rel="noopener">单词搜索</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-shan-chu-pai-xu-shu-zu-zhong-de-chong-fu-xiang-ii/" target="_blank" rel="noopener">删除排序数组中的重复项Ⅱ</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-fen-ge-lian-biao/" target="_blank" rel="noopener">分割链表</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-zi-ji-ii/" target="_blank" rel="noopener">子集Ⅱ</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-jie-ma-fang-fa/" target="_blank" rel="noopener">解码方法</a></td></tr><tr><td><a href="http://www.zivblog.top/passages/leetcode-zhi-fan-zhuan-lian-biao-ii/" target="_blank" rel="noopener">删除回文子序列</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-fan-zhuan-lian-biao-ii/" target="_blank" rel="noopener">反转链表Ⅱ</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-er-cha-shu-de-zhong-xu-bian-li/" target="_blank" rel="noopener">二叉树的中序遍历</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-bu-tong-de-er-cha-sou-suo-shu-ii/" target="_blank" rel="noopener">不同的二叉搜索树Ⅱ</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-yan-zheng-er-cha-sou-suo-shu/" target="_blank" rel="noopener">不同的二叉搜索树</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-yan-zheng-er-cha-sou-suo-shu/" target="_blank" rel="noopener">验证二叉搜索树</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-er-cha-shu-de-ceng-xu-bian-li/" target="_blank" rel="noopener">二叉树的层序遍历</a></td></tr><tr><td><a href="http://www.zivblog.top/passages/leetcode-zhi-lu-jing-zong-he-ii/" target="_blank" rel="noopener">路径总和Ⅱ</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-qiu-gen-dao-xie-zi-jie-dian-shu-zi-zhi-he/" target="_blank" rel="noopener">求根到叶子节点数字之和</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-bei-wei-rao-de-qu-yu/" target="_blank" rel="noopener">被围绕的区域</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-fen-ge-hui-wen-chuan/" target="_blank" rel="noopener">分割回文串</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-dan-ci-chai-fen/" target="_blank" rel="noopener">单词拆分</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-er-cha-shu-de-qian-xu-bian-li/" target="_blank" rel="noopener">二叉树的前序遍历</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-mu-biao-he/" target="_blank" rel="noopener">目标和</a></td></tr><tr><td><a href="http://www.zivblog.top/passages/leetcode-zhi-ni-bo-lan-biao-da-shi-qiu-zhi/" target="_blank" rel="noopener">逆波兰表达式求值</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-cheng-ji-zui-da-zi-shu-zu/" target="_blank" rel="noopener">乘积最大子数组</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-er-cha-shu-de-you-shi-tu/" target="_blank" rel="noopener">二叉树的右视图</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-dao-yu-shu-liang/" target="_blank" rel="noopener">岛屿数量</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-shu-zi-fan-wei-an-wei-yu/" target="_blank" rel="noopener">数字范围按位与</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-shi-xian-trie/" target="_blank" rel="noopener">实现Trie</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-chang-du-zui-xiao-de-zi-shu-zu/" target="_blank" rel="noopener">长度最小的子数组</a></td></tr><tr><td><a href="http://www.zivblog.top/passages/leetcode-zhi-zui-chang-gong-gong-zi-xu-lie/" target="_blank" rel="noopener">最长公共子序列</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-tian-jia-yu-sou-suo-dan-ci/" target="_blank" rel="noopener">添加与搜索单词</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-shu-zu-zhong-di-k-ge-zui-da-yuan-su/" target="_blank" rel="noopener">数组中第K个最大元素</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-zui-da-zheng-fang-xing/" target="_blank" rel="noopener">最大正方形</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-qiu-zhong-shu-ii/" target="_blank" rel="noopener">求众数Ⅱ</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-er-cha-sou-suo-shu-zhong-di-k-xiao-yuan-su/" target="_blank" rel="noopener">二叉搜索树中第K小元素</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-er-cha-shu-de-zui-jin-gong-gong-zu-xian/" target="_blank" rel="noopener">二叉树的最近公共祖先</a></td></tr><tr><td><a href="http://www.zivblog.top/passages/leetcode-zhi-chu-zi-shen-yi-wai-shu-zu-de-cheng-ji/" target="_blank" rel="noopener">除自身以外数组的乘积</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-sou-suo-er-wei-ju-zhen-ii/" target="_blank" rel="noopener">搜索二维矩阵Ⅱ</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-wan-quan-ping-fang-shu/" target="_blank" rel="noopener">完全平方数</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-zui-jia-mai-mai-gu-piao-shi-ji-han-leng-dong-qi/" target="_blank" rel="noopener">最佳买卖股票时机含冷冻期</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-ling-qian-dui-huan/" target="_blank" rel="noopener">零钱兑换</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-qi-ou-lian-biao/" target="_blank" rel="noopener">奇偶链表</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-di-zeng-de-san-yuan-zi-xu-lie/" target="_blank" rel="noopener">递增的三元子序列</a></td></tr><tr><td><a href="http://www.zivblog.top/passages/leetcode-zhi-shui-hu-wen-ti/" target="_blank" rel="noopener">水壶问题</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-you-xu-ju-zhen-zhong-di-k-xiao-de-yuan-su/" target="_blank" rel="noopener">有序矩阵中第k小的元素</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-chang-shu-shi-jian-nei-cha-ru-shan-chu-he-huo-qu-sui-ji-yuan-su/" target="_blank" rel="noopener">常数时间内插入删除和获取随机元素</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-fen-ge-deng-he-zi-ji/" target="_blank" rel="noopener">分割等和子集</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-liang-shu-xiang-jia-ii/" target="_blank" rel="noopener">两数相加Ⅱ</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-si-shu-xiang-jia-ii/" target="_blank" rel="noopener">四数相加Ⅱ</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-yi-he-ling/" target="_blank" rel="noopener">一和零</a></td></tr><tr><td><a href="http://www.zivblog.top/passages/leetcode-zhi-zui-chang-hui-wen-zi-xu-lie/" target="_blank" rel="noopener">最长回文子序列</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-ling-qian-dui-huan-ii/" target="_blank" rel="noopener">零钱兑换Ⅱ</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-peng-you-quan/" target="_blank" rel="noopener">朋友圈</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-zai-xi-tong-zhong-cha-zhao-chong-fu-wen-jian/" target="_blank" rel="noopener">在系统中查找重复文件</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-dan-ci-de-ya-suo-bian-ma/" target="_blank" rel="noopener">单词的压缩编码</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-ai-chi-xiang-jiao-de-ke-ke/" target="_blank" rel="noopener">爱吃香蕉的珂珂</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-shi-zi-you-xi/" target="_blank" rel="noopener">石子游戏</a></td></tr><tr><td><a href="http://www.zivblog.top/passages/leetcode-zhi-rle-die-dai-qi/" target="_blank" rel="noopener">RLE迭代器</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-pai-xu-shu-zu/" target="_blank" rel="noopener">排序数组</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-qi-shi-bo-hao-qi/" target="_blank" rel="noopener">骑士拨号器</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-zai-d-tian-nei-song-da-bao-guo-de-neng-li/" target="_blank" rel="noopener">在D天内送达包裹的能力</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-zui-jia-guan-guang-zu-he/" target="_blank" rel="noopener">最佳观光组合</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-ke-bei-k-zheng-chu-de-zui-xiao-zheng-shu/" target="_blank" rel="noopener">可被K整除的最小整数</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-lian-biao-zhong-de-xia-yi-ge-geng-da-jie-dian/" target="_blank" rel="noopener">可被K整除的最小整数</a></td></tr><tr><td><a href="http://www.zivblog.top/passages/leetcode-zhi-fei-di-de-shu-liang/" target="_blank" rel="noopener">飞地的数量</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-tuo-feng-shi-pi-pei/" target="_blank" rel="noopener">驼峰式匹配</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-liang-ge-fei-chong-die-zi-shu-zu-de-zui-da-he/" target="_blank" rel="noopener">两个非重叠子数组的最大和</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-er-cha-shu-xun-lu/" target="_blank" rel="noopener">二叉树寻路</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-jue-dui-zhi-biao-da-shi-de-zui-da-zhi/" target="_blank" rel="noopener">绝对值表达式的最大值</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-zui-chang-ding-cha-zi-xu-lie/" target="_blank" rel="noopener">最长定差子序列</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-fei-ji-zuo-wei-fen-pei-gai-lv/" target="_blank" rel="noopener">飞机座位分配概率</a></td></tr><tr><td><a href="http://www.zivblog.top/passages/leetcode-zhi-zai-shou-wu-ran-de-er-cha-shu-zhong-cha-zhao-yuan-su/" target="_blank" rel="noopener">在受污染的二叉树中查找元素</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-ke-bei-san-zheng-chu-de-zui-da-he/" target="_blank" rel="noopener">可被三整除的最大和</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-zi-chuan-chu-xian-de-zui-da-ci-shu/" target="_blank" rel="noopener">子串出现的最大次数</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-zi-shu-zu-yi-huo-cha-xun/" target="_blank" rel="noopener">子数组异或查询</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-yu-zhi-ju-li-nei-lin-ju-zui-shao-de-cheng-shi/" target="_blank" rel="noopener">阈值距离内邻居最少的城市</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-mei-ge-yuan-yin-bao-han-ou-shu-ci-de-zui-chang-zi-zi-fu-chuan/" target="_blank" rel="noopener">每个元音包含偶数次的最长子字符串</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-er-cha-sou-suo-shu-zhong-de-cha-ru-cao-zuo/" target="_blank" rel="noopener">二叉搜索树中的插入操作</a></td></tr><tr><td><a href="http://www.zivblog.top/passages/leetcode-zhi-fan-zhuan-lian-biao-ii/" target="_blank" rel="noopener">反转链表Ⅱ</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-pai-xu-lian-biao/" target="_blank" rel="noopener">排序链表</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-chong-pai-lian-biao/" target="_blank" rel="noopener">重排链表</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-fu-zhi-dai-sui-ji-zhi-zhen-de-lian-biao/" target="_blank" rel="noopener">复制带随机指针的链表</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-zi-fu-chuan-jie-ma/" target="_blank" rel="noopener">字符串解码</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-ke-long-tu/" target="_blank" rel="noopener">克隆图</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-zhu-zhuang-tu-zhong-zui-da-de-ju-xing/" target="_blank" rel="noopener">柱状图中最大的矩形</a></td></tr><tr><td><a href="http://www.zivblog.top/passages/leetcode-zhi-01-ju-zhen/" target="_blank" rel="noopener">01矩阵</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-zhi-chu-xian-yi-ci-de-shu-zi-ii/" target="_blank" rel="noopener">只出现一次的数字Ⅱ</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-zhi-chu-xian-yi-ci-de-shu-zi-iii/" target="_blank" rel="noopener">只出现一次的数字Ⅲ</a></td><td></td><td></td><td></td><td></td></tr></tbody></table><br><h4 id="困难题目"><a href="#困难题目" class="headerlink" title="困难题目"></a>困难题目</h4><table><thead><tr><th>周一</th><th>周二</th><th>周三</th><th>周四</th><th>周五</th><th>周六</th><th>周日</th></tr></thead><tbody><tr><td><a href="http://www.zivblog.top/passages/leetcode-zhi-ji-dan-diao-luo/" target="_blank" rel="noopener">鸡蛋掉落</a></td><td><a href="http://www.zivblog.top/passages/leetcode-zhi-zhu-zhuang-tu-zhong-zui-da-de-ju-xing/" target="_blank" rel="noopener">柱状图中最大的矩形</a></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><ul><li><a href="http://www.zivblog.top/passages/tong-pai-xu/" target="_blank" rel="noopener">桶排序</a></li><li><a href="http://www.zivblog.top/passages/hui-su-fa/" target="_blank" rel="noopener">回溯法</a></li><li><a href="http://www.zivblog.top/passages/dong-tai-gui-hua/" target="_blank" rel="noopener">动态规划</a></li><li><a href="http://www.zivblog.top/passages/qian-zhong-hou-zhui-biao-da-shi-de-zhuan-huan-ji-ji-suan/" target="_blank" rel="noopener">前中后缀表达式的转换及计算</a></li></ul><h3 id="Sword-offer"><a href="#Sword-offer" class="headerlink" title="Sword offer"></a>Sword offer</h3><ul><li><a href="http://www.zivblog.top/passages/sword-offer-03-shu-zu-zhong-de-chong-fu-yuan-su/" target="_blank" rel="noopener">数组中的重复元素</a></li><li>暂停该部分的更新</li></ul><h3 id="周知识总结"><a href="#周知识总结" class="headerlink" title="周知识总结"></a>周知识总结</h3><ul><li>内容包括机器学习、深度学习、自然语言处理、模型优化等</li></ul><br><h4 id="更新列表"><a href="#更新列表" class="headerlink" title="更新列表"></a>更新列表</h4><table><thead><tr><th>月/周</th><th>第一周</th><th>第二周</th><th>第三周</th><th>第四周</th><th>第五周</th></tr></thead><tbody><tr><td><strong>2020年3月</strong></td><td><a href="http://zivblog.top/passages/zhou-zhi-shi-zong-jie-3-8-3-15/">3.8~3.15</a></td><td><a href="http://zivblog.top/passages/zhou-zhi-shi-zong-jie-3-16-3-22/">3.16~3.22</a></td><td><a href="http://zivblog.top/passages/zhou-zhi-shi-zong-jie-3-23-3-29/">3.23~3.29</a></td><td></td><td></td></tr><tr><td><strong>2020年4月</strong></td><td><a href="http://zivblog.top/passages/zhou-zhi-shi-zong-jie-3-30-4-5/">3.30~4.5</a></td><td><a href="http://zivblog.top/passages/zhou-zhi-shi-zong-jie-4-6-4-12/">4.6~4.12</a></td><td><a href="http://zivblog.top/passages/zhou-zhi-shi-zong-jie-4-13-4-19/">4.13~4.19</a></td><td><a href="http://zivblog.top/passages/zhou-zhi-shi-zong-jie-4-20-4-26/">4.20~4.26</a></td><td></td></tr><tr><td><strong>2020年5月</strong></td><td><a href="http://zivblog.top/passages/zhou-zhi-shi-zong-jie-4-27-5-3/">4.27~5.3</a></td><td><a href="http://zivblog.top/passages/zhou-zhi-shi-zong-jie-5-4-5-10/">5.4~5.10</a></td><td></td><td></td><td></td></tr></tbody></table><ul><li>因科研等多方面因素，暂停该部分更新，恢复时间待定（2020.6.23）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 置顶 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之删除回文子序列</title>
      <link href="/passages/leetcode-zhi-shan-chu-hui-wen-zi-xu-lie/"/>
      <url>/passages/leetcode-zhi-shan-chu-hui-wen-zi-xu-lie/</url>
      
        <content type="html"><![CDATA[<p>Remove Palindromic Subsequences</p><a id="more"></a><h3 id="Remove-Palindromic-Subsequences"><a href="#Remove-Palindromic-Subsequences" class="headerlink" title="Remove Palindromic Subsequences"></a>Remove Palindromic Subsequences</h3><ul><li>code with Python</li><li>title number：1332</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个字符串，仅由<code>a</code>和<code>b</code>组成</li><li>每次操作可以从字符串中删除一个回文子序列</li><li>返回删除给定字符串中所有字符的<strong>最小删除次数</strong></li><li><strong>注意</strong>：<ul><li>子序列：如果一个字符串可以通过删除原字符串中某些字符而不改变原字符顺序得到，那么这个字符串就是原字符串中的一个子序列</li><li>回文：如果一个字符串向后和向前读是一致的，那么这个字符串就是一个回文串</li></ul></li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>从题目给出的子序列的定义中可以发现，子序列中的元素在原字符串中可以不连续</li><li>又因为字符串只由<code>a</code>和<code>b</code>组成，所以可以得到以下结论：<ul><li>当字符串为空时，返回0</li><li>当字符串全为<code>a</code>或全为<code>b</code>时，返回1</li><li>当字符串由<code>a</code>和<code>b</code>组成，返回2（先删除全部的<code>a</code>或<code>b</code>，在删除剩下的）</li></ul></li><li>所以这是一道语文题😂</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removePalindromeSub</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">''</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(s)</span>:</span></span><br><span class="line">        <span class="comment"># 判断给定字符串是否回文</span></span><br><span class="line">        l, r = <span class="number">0</span>, len(s) <span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            <span class="keyword">if</span> s[l] != s[r]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> isPalindrome(s) <span class="keyword">else</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><ul><li>对于Python，可以通过一些花式操作减少代码量</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removePalindromeSub</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">''</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> s == s[::<span class="number">-1</span>] <span class="keyword">else</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><ul><li>再次，注意：<strong>子序列</strong> !=<strong>子串</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之二维网格迁移</title>
      <link href="/passages/leetcode-zhi-er-wei-wang-ge-qian-yi/"/>
      <url>/passages/leetcode-zhi-er-wei-wang-ge-qian-yi/</url>
      
        <content type="html"><![CDATA[<p>Shift 2D Grid</p><a id="more"></a><h3 id="Shift-2D-Grid"><a href="#Shift-2D-Grid" class="headerlink" title="Shift 2D Grid"></a>Shift 2D Grid</h3><ul><li><p>code with Python</p></li><li><p>title number：1260</p></li><li><p>简单</p></li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个<code>m</code>行<code>n</code>列的二维网格和一个整数<code>k</code></li><li>根据规定的操作对二维网格“迁移”<code>k</code>次</li><li>每次迁移要进行三种操作：<ul><li>位于<code>grid[i][j]</code>的元素将会移动到<code>grid[i][j+1]</code></li><li>位于<code>grid[i][n-1]</code>的元素将会移动到<code>grid[i+1][0]</code></li><li>位于<code>grid[m-1][n-1]</code>的元素将会移动到<code>grid[0][0]</code></li><li><code>n</code>是列数，<code>m</code>是行数</li></ul></li><li>返回进行了<code>k</code>次迁移之后的网格</li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>暴力解决，直接翻译题目的要求</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> copy <span class="keyword">import</span> deepcopy</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shiftGrid</span><span class="params">(self, grid: List[List[int]], k: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">    n = len(grid)</span><br><span class="line">    m = len(grid[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> rnge(k):</span><br><span class="line">        old = deepcopy(grid)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                <span class="keyword">if</span> j == m<span class="number">-1</span>:</span><br><span class="line">                    grid[(i+<span class="number">1</span>)%n][<span class="number">0</span>] = old[i][j]</span><br><span class="line">                <span class="keyword">elif</span> i == n<span class="number">-1</span> <span class="keyword">and</span> j == m<span class="number">-1</span>:</span><br><span class="line">                    grid[<span class="number">0</span>][<span class="number">0</span>] = old[i][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    grid[i][j+<span class="number">1</span>] = old[i][j]</span><br><span class="line">    <span class="keyword">return</span> grid</span><br></pre></td></tr></table></figure><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li><p>在矩阵的二维表示上并没有发现什么规律，所以我们尝试将二维矩阵变成一维</p></li><li><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[1, 2, 3], k&#x3D;1[[9, 1, 2],</span><br><span class="line"> [4, 5, 6]&#x3D;&#x3D;&#x3D;&#x3D;&gt;   [3, 4, 5],</span><br><span class="line"> [7, 8, 9]] [6, 7, 8]]</span><br><span class="line"> </span><br><span class="line"> [1, 2, 3, 4, 5, 6, 7, 8, 9] -&gt; [9, 1, 2, 3, 4, 5, 6, 7, 8]</span><br></pre></td></tr></table></figure></li><li><p>所以，这是一个数组旋转问题，对于数组旋转问题，我们使用循环位移算法（三次翻转）</p><ul><li>先把<code>[0, n-k-1]</code>翻转</li><li>再把<code>[n-k, n-1]</code>翻转</li><li>最后把<code>[0, n-1]</code>翻转</li></ul></li><li><p>并且对于数组旋转问题，旋转的幅度为数组长度时，是会回到初始的样子的</p></li><li><p>另外，第<code>189</code>题也是数组旋转</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shiftGrid</span><span class="params">(self, grid: List[List[int]], k: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">    n, m = len(grid), len(grid[<span class="number">0</span>])</span><br><span class="line">    <span class="comment"># 二维转一维</span></span><br><span class="line">    arr = [grid[i][j] <span class="keyword">for</span> i <span class="keyword">in</span> range(n) <span class="keyword">for</span> j <span class="keyword">in</span> range(m)]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 取模，避免不必要的计算</span></span><br><span class="line">    k %= m*n</span><br><span class="line">    res  = []</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(l, r)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            t =arr[l]</span><br><span class="line">            arr[l] = arr[r]</span><br><span class="line">            arr[r] = t</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">    reverse(<span class="number">1</span>, m*n-k<span class="number">-1</span>)</span><br><span class="line">    reverse(m*n-k, m*n<span class="number">-1</span>)</span><br><span class="line">    reverse(<span class="number">1</span>, m*n<span class="number">-1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 一维转二维</span></span><br><span class="line">    row = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        res.append(arr[i*m, (i+<span class="number">1</span>)*m])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之模拟机器人行走</title>
      <link href="/passages/leetcode-zhi-mo-ni-ji-qi-ren-xing-zou/"/>
      <url>/passages/leetcode-zhi-mo-ni-ji-qi-ren-xing-zou/</url>
      
        <content type="html"><![CDATA[<p>Walking Robot Simulation</p><a id="more"></a><h3 id="Walking-Robot-Simulation"><a href="#Walking-Robot-Simulation" class="headerlink" title="Walking Robot Simulation"></a>Walking Robot Simulation</h3><ul><li><p>code with Python</p></li><li><p>title number：874</p></li><li><p>简单</p></li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>机器人在无限大小的网格上行走</li><li>从<code>(0, 0)</code>点出发，面向北方，有三种移动指令<ul><li><code>-2</code>：向左转90度</li><li><code>-1</code>：向右转90度</li><li><code>1 &lt;= x &lt;= 9</code>：向前移动<code>x</code>个单位</li></ul></li><li>网格上有障碍物，第<code>i</code>个障碍物位于<code>[obstacles[i][0], obstacles[i][1]]</code><ul><li>当机器人视图走到障碍物上方时，它会停留在障碍物的前一个网格方块上，但该路线的其余部分可以继续</li></ul></li><li>求从原点到机器人的最大欧式距离的<strong>平方</strong>。（根据测试用例发现，此处要求得的是移动过程中的最大距离，而不是原点到终点的距离）</li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>设置两个变量来存储机器人的当前位置和方向<ul><li>如果机器人收到了转弯的指令，则更新方向；</li><li>如果收到其他指令，则沿当前方向走指定的步数</li></ul></li><li>该问题的关键在与收到指令之后坐标的计算（转向，前进）,参考国际版的题解思路中的规律<ul><li>左转时：<code>dx, dy = -dy, dx</code></li><li>右转时：<code>dx, dy = dy, -dx</code></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">robotSim</span><span class="params">(self, commands: List[int], obstacles: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">dx, dy = <span class="number">0</span>, <span class="number">1</span><span class="comment"># 可以视作速度，初始向北，故dx=0，dy=1</span></span><br><span class="line">    x, y = <span class="number">0</span>, <span class="number">0</span><span class="comment"># 初始位置</span></span><br><span class="line">    distance = <span class="number">0</span><span class="comment"># 最大距离</span></span><br><span class="line">    obs_dict = &#123;&#125;<span class="comment"># 障碍物，字典</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> obs <span class="keyword">in</span> obstacles:</span><br><span class="line">        <span class="comment"># 元组存储，比列表占用空间小，并且比两个list速度快</span></span><br><span class="line">        obs_dict[tuple(obs)] = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 遍历指令并执行   </span></span><br><span class="line">    <span class="keyword">for</span> com <span class="keyword">in</span> commands:</span><br><span class="line">        <span class="keyword">if</span> com == <span class="number">-2</span>:<span class="comment"># 向左转90度</span></span><br><span class="line">            dx, dy = -dy, dx</span><br><span class="line">        <span class="keyword">elif</span> com == <span class="number">-1</span>:<span class="comment"># 向右转90度</span></span><br><span class="line">            dx, dy = dy, -dx</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 使用循环，一步一步的走，便于判断与障碍物的关系</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(com):</span><br><span class="line">                next_x = x + dx</span><br><span class="line">                next_y = y + dy</span><br><span class="line">                <span class="comment"># 遇到障碍物则停下</span></span><br><span class="line">                <span class="keyword">if</span> (next_x, next_y) <span class="keyword">in</span> ons_dict:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                x, y = next_x, next_y</span><br><span class="line">                <span class="comment"># 计算当前与原点的距离和最大距离之间的关系</span></span><br><span class="line">                distance = max(distance, x*x + y*y)</span><br><span class="line">    <span class="keyword">return</span> distance</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之分发糖果</title>
      <link href="/passages/leetcode-zhi-fen-fa-tang-guo/"/>
      <url>/passages/leetcode-zhi-fen-fa-tang-guo/</url>
      
        <content type="html"><![CDATA[<p>Distribute Candies</p><a id="more"></a><h3 id="Distribute-Candies"><a href="#Distribute-Candies" class="headerlink" title="Distribute Candies"></a>Distribute Candies</h3><ul><li><p>code with Python</p></li><li><p>title number：575</p></li><li><p>简单</p></li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个长度为偶数的数组，其中不同的数字代表不同的糖果，每一个数组代表一个糖果</li><li>将这些糖果平均分给<strong>一个弟弟</strong>和<strong>一个妹妹</strong></li><li>返回妹妹可以获得的最大糖果的种类数</li><li>即每个人获得的糖果数必须相同，当是妹妹要获得糖果的种类要尽量的多</li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>由于糖果的数目是偶数，所以我们要做到两个人的糖果数量一样多，并且每个人只能获得<code>n/2</code>颗糖果</li><li>如果糖果种类数大于等于<code>n/2</code>，那么妹妹最多得到<code>n/2</code>种糖果</li><li>如果糖果种类数小于<code>n/2</code>，那么妹妹能够得到的糖果种类可以是实际的糖果种类数（至少一种一颗）</li><li>至此，分析结束，我们发现这道题并不需要想办法求所有可能的分发，只需要统计糖果的种类个数即可</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">distributeCandies</span><span class="params">(self, candies: List[int])</span> -&gt; int:</span></span><br><span class="line">    num = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> candy <span class="keyword">in</span> candies:</span><br><span class="line">        <span class="keyword">if</span> candy <span class="keyword">in</span> num:</span><br><span class="line">            num[candy] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            num[candy] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> len(num) &gt;= len(candies) // <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> len(candies) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> len(num)</span><br></pre></td></tr></table></figure><ul><li>上面是使用字典统计的糖果种类，并且统计了每种糖果的数量，但是后者是我们不需要的，所以简化数据结构，尝试使用列表实现</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">distributeCandies</span><span class="params">(self, candies: List[int])</span> -&gt; int:</span></span><br><span class="line">    num = []</span><br><span class="line">    <span class="keyword">for</span> candy <span class="keyword">in</span> candies:</span><br><span class="line">        <span class="keyword">if</span> candy <span class="keyword">not</span> <span class="keyword">in</span> num:</span><br><span class="line">            num.append(candy)</span><br><span class="line">    <span class="keyword">if</span> len(num) &gt;= len(candies) // <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> len(candies) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> len(num)</span><br></pre></td></tr></table></figure><ul><li>列表实现超时？没找到原因</li><li>还可以使用集合<code>set</code>的特性（没有重复元素）来实现</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">distributeCandies</span><span class="params">(self, candies: List[int])</span> -&gt; int:</span></span><br><span class="line">    num = set(candies)   </span><br><span class="line">    <span class="keyword">if</span> len(num) &gt;= len(candies) // <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> len(candies) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> len(num)</span><br></pre></td></tr></table></figure><ul><li>代码再简化（求糖果种类数和<code>n/2</code>的较小值）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">distributeCandies</span><span class="params">(self, candies: List[int])</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">return</span> min(len(set(candies)), len(candies)//<span class="number">2</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之二叉搜索树中的众数</title>
      <link href="/passages/leetcode-zhi-er-cha-sou-suo-shu-zhong-de-zhong-shu/"/>
      <url>/passages/leetcode-zhi-er-cha-sou-suo-shu-zhong-de-zhong-shu/</url>
      
        <content type="html"><![CDATA[<p>Find Mode in Binary Search Tree</p><a id="more"></a><h3 id="Find-Mode-in-Binary-Search-Tree"><a href="#Find-Mode-in-Binary-Search-Tree" class="headerlink" title="Find Mode in Binary Search Tree"></a>Find Mode in Binary Search Tree</h3><ul><li><p>code with Python</p></li><li><p>title number：501</p></li><li><p>简单</p></li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li><p>给定一个二叉搜索树，其中存在相同的数</p></li><li><p>找出给定树中的所有众数</p></li><li><p>众数不一定只有一个，不考虑输出顺序</p></li><li><p>二叉树结构</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br></pre></td></tr></table></figure></li><li><p>二叉搜索树的特点</p><ul><li>结点左子树中所含结点的值小于当前结点的值</li><li>结点右子树中所含结点的值大于当前结点的值</li><li>左右子树也都是二叉搜索树</li></ul></li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>比较容易想到的是通过遍历树得到所有结点的值，再次遍历有序数组，查找其中的众数</li><li>值得注意的是，在二叉树的遍历算法中，对于二叉搜索树，通过中序遍历可以直接得到一个有序数组</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMode</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">    self.nums = []</span><br><span class="line">    self.inorderTraveral(root)</span><br><span class="line">    </span><br><span class="line">    res = [self.nums[<span class="number">0</span>]]</span><br><span class="line">    max_num, cur_num = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(self.nums)):</span><br><span class="line">        <span class="keyword">if</span> self.nums[i] == self.nums[i<span class="number">-1</span>]:</span><br><span class="line">            cur_num = cur_num + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur_num = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> cur_num == max_num:</span><br><span class="line">            res.append(self.nums[i])</span><br><span class="line">        <span class="keyword">elif</span> cur_num &gt; max_num:</span><br><span class="line">            res = []</span><br><span class="line">            res.append(self.nums[i])</span><br><span class="line">            max_num = cur_num</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorderTraveral</span><span class="params">(self, root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    self.inorderTraveral(root.left)</span><br><span class="line">    self.nums.append(root.val)</span><br><span class="line">    self.inorderTraveral(root.right)</span><br></pre></td></tr></table></figure><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li>思路一相当于对树中结点进行了两次遍历，我们尝试减少时间的使用</li><li>对树中结点进行遍历，使用字典存储树中的结点及其出现的次数，最后取字典中<code>value</code>最大的<code>key</code>输出</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.res = &#123;&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMode</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">result = []</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    self.visit(root)</span><br><span class="line">    Max = max(self.res.values())</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> self.res:</span><br><span class="line">        <span class="keyword">if</span> self.res[key]==Max:</span><br><span class="line">            result.append(key)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit</span><span class="params">(self, root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root:</span><br><span class="line">        <span class="keyword">if</span> root.val <span class="keyword">in</span> self.res:</span><br><span class="line">            self.res[root.val] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.res[root.val] = <span class="number">0</span></span><br><span class="line">        self.visit(root.left)</span><br><span class="line">        self.visit(root.right)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之两整数之和</title>
      <link href="/passages/leetcode-zhi-liang-zheng-shu-zhi-he/"/>
      <url>/passages/leetcode-zhi-liang-zheng-shu-zhi-he/</url>
      
        <content type="html"><![CDATA[<p>Sum of Two Integer</p><a id="more"></a><h3 id="Sum-of-Two-Integer"><a href="#Sum-of-Two-Integer" class="headerlink" title="Sum of Two Integer"></a>Sum of Two Integer</h3><ul><li><p>code with Python</p></li><li><p>title number：371</p></li><li><p>简单</p></li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>不使用<code>+</code>和<code>-</code>来计算两个数的和</li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li><p>既然不允许直接使用加法和减法，那么我们只能借助其他的方式来替代这两中运算</p></li><li><p>首先想到的就是<strong>位运算</strong>，我们来看一下按位做加法的特点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> + <span class="number">0</span> = <span class="number">0</span></span><br><span class="line"><span class="number">0</span> + <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="number">1</span> + <span class="number">1</span> = <span class="number">0</span></span><br><span class="line"><span class="number">1</span> + <span class="number">0</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>经观察不难发现，这就是位运算中的<strong>异或运算</strong></p></li><li><p>但是使用异或运算只能实现<strong>无进位</strong>的加法，如何实现进位操作呢，再次观察上面的例子，我们发现，通过<strong>与</strong>运算可以获得该位置上运算得到的进位</p></li><li><p>但是，这样得到的进位是在本位置上的，而实际上的进位要在其更高一位的位置上（左侧一位）</p></li><li><p>所以：</p><ul><li>用二进制运算求和可以分为两部分：<code>a</code>和<code>b</code>的无进位结果；<code>a</code>和<code>b</code>的进位情况</li><li>前者通过<strong>异或运算</strong>得到</li><li>后者通过<strong>与运算</strong>和<strong>移位</strong>（左移一位）得到</li><li>循环此过程，直到进位为<code>0</code>，结果即为所求</li></ul></li><li><p>在<code>Python</code>中需要特殊处理的是：</p><ul><li>由于<code>Python</code>中整数不是<code>32</code>位的，我们需要手动对<code>Python</code>中的整数进行处理，手动模拟<code>32</code>位整数</li><li>具体来说可以对<code>0x100000000</code>（16进制）取模，得到低位的<code>32</code>位数</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getSum</span><span class="params">(self, a: int, b: int)</span> -&gt; int:</span></span><br><span class="line">    mask = <span class="number">0x100000000</span></span><br><span class="line">    max_int = <span class="number">0x7FFFFFFF</span></span><br><span class="line">    min_int = max_int + <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> b != <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 计算进位</span></span><br><span class="line">        carry = (a &amp; b) &lt;&lt; <span class="number">1</span></span><br><span class="line">        <span class="comment"># 无进位加法</span></span><br><span class="line">        a = (a ^ b) % mask</span><br><span class="line">        b = carry % mask</span><br><span class="line">    <span class="keyword">return</span> a <span class="keyword">if</span> a &lt;= max_int <span class="keyword">else</span> ~((a % min_int) ^ max_int)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之路径之和Ⅲ</title>
      <link href="/passages/leetcode-zhi-lu-jing-zhi-he-iii/"/>
      <url>/passages/leetcode-zhi-lu-jing-zhi-he-iii/</url>
      
        <content type="html"><![CDATA[<p>Path Sum Ⅲ</p><a id="more"></a><h3 id="Path-Sum-Ⅲ"><a href="#Path-Sum-Ⅲ" class="headerlink" title="Path Sum Ⅲ"></a>Path Sum Ⅲ</h3><ul><li><p>code with Python</p></li><li><p>title number：437</p></li><li><p>简单</p></li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li><p>给定一颗二叉树，每个结点存放一个整数</p></li><li><p>树的结点的形式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">    self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br></pre></td></tr></table></figure></li><li><p>找出路径和等于给定数值的路径总数</p></li><li><p>路径不需要从根节点开始，也不必在叶子节点结束，但方向需要向下</p></li><li><p>示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root &#x3D; [10,5,-3,3,2,null,11,3,-2,null,1], sum &#x3D; 8</span><br><span class="line"></span><br><span class="line">      10</span><br><span class="line">     &#x2F;  \</span><br><span class="line">    5   -3</span><br><span class="line">   &#x2F; \    \</span><br><span class="line">  3   2   11</span><br><span class="line"> &#x2F; \   \</span><br><span class="line">3  -2   1</span><br><span class="line"></span><br><span class="line">返回3,和等于8的路径有:</span><br><span class="line"></span><br><span class="line">1.  5 -&gt; 3</span><br><span class="line">2.  5 -&gt; 2 -&gt; 1</span><br><span class="line">3.  -3 -&gt; 11</span><br></pre></td></tr></table></figure></li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>初次读到题目，感觉有些复杂：路径的开头可以不是根节点，结束也可以不是叶子结点</li><li>简化一下问题，如果我们规定<strong>路径的开始结点必须是根节点</strong>，那么我们通过一次遍历就可以得到所有的路径</li><li>再进一步，我们可以将树中的<strong>任意内部节点作为”根节点”</strong>，找到所以以该”根节点”为根的二叉树中符合条件的路径</li><li>对的，这样就行成了一个递归结构。其实对于这种问题，首先想到的就是使用递归解决，但是困难的地方在于找到其中的递归结构</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pathSum</span><span class="params">(self, root: TreeNode, sum: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> self.paths(root, sum) + self.pathSum(root.left, sum) + self.pathSum(root.right, sum)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">paths</span><span class="params">(self, root, sum)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> root.val == sum:</span><br><span class="line">        res += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    res += self.paths(root.left, sum - root.val)</span><br><span class="line">    res += self.paths(root.right, sum - root.val)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li>第一种方法的递归比较好理解，但是是双重递归，时间复杂度比较高</li><li>可否减少递归次数，或者减少计算的次数，从而达到减少耗费时间的目的呢，答案是肯定的</li><li>我们可以通过一次遍历，得到树中的所有节点</li><li>在此基础上，我们进行反向操纵，即每遍历到一个结点，判断在包含该节点的路径上是否路经本身或者子路径符合条件</li><li>由于只进行一次遍历，所以每便利到一个结点时进行的反向计算并<strong>不会有重复</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pathSum</span><span class="params">(self, root: TreeNode, sum: int)</span> -&gt; int:</span></span><br><span class="line">    self.data = []<span class="comment"># 保存路径上的结点</span></span><br><span class="line">    self.count = <span class="number">0</span><span class="comment"># 统计符合的路径数目</span></span><br><span class="line"></span><br><span class="line">    self.recursive(root, sum)</span><br><span class="line">    <span class="keyword">return</span> self.count</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recursive</span><span class="params">(self, root, sum)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    self.data.append(root.val)</span><br><span class="line">    cur = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.data)<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        cur += self.data[i]</span><br><span class="line">        <span class="keyword">if</span> cur == sum:</span><br><span class="line">            self.count += <span class="number">1</span></span><br><span class="line">    self.recursive(root.left, sum)</span><br><span class="line">    self.recursive(root.right, sum)</span><br><span class="line">    self.data.pop()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之两个数组的交集</title>
      <link href="/passages/leetcode-zhi-liang-ge-shu-zu-de-jiao-ji/"/>
      <url>/passages/leetcode-zhi-liang-ge-shu-zu-de-jiao-ji/</url>
      
        <content type="html"><![CDATA[<p>Intersection of Two Array</p><a id="more"></a><h3 id="Intersection-of-Two-Array"><a href="#Intersection-of-Two-Array" class="headerlink" title="Intersection of Two Array"></a>Intersection of Two Array</h3><ul><li><p>code with Python</p></li><li><p>title number：349</p></li><li><p>简单</p></li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定两个数组，计算两个数组的交集</li><li>结果中的每个元素是唯一的</li><li>不考虑输出结果的顺序</li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>比较直接的想法是，依次判断<code>nums1</code>中的元素是否在<code>nums2</code>中，如果在，则添加到交集中</li><li>因为结果中的每个元素是唯一的，所以要事先对数组进行去重操作，可以使用<code>set</code>事先</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">intersection</span><span class="params">(self, nums1: List[int], nums2: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">inter = []</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> set(nums1):</span><br><span class="line">        <span class="keyword">if</span> num <span class="keyword">in</span> set(nums2):</span><br><span class="line">            inter.append(num)</span><br><span class="line">    <span class="keyword">return</span> inter</span><br></pre></td></tr></table></figure><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li>比较取巧的方法，使用语言本身的内置函数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">intersection</span><span class="params">(self, nums1: List[int], nums2: List[int])</span> -&gt; List[int]:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list(set(nums1) &amp; set(nums2))</span><br></pre></td></tr></table></figure><h4 id="思路三"><a href="#思路三" class="headerlink" title="思路三"></a>思路三</h4><ul><li>上面的两种方法对数组的遍历多次数组，这必定会造成时间上的浪费</li><li>使用双指针可以对两个数组只遍历一遍<ul><li>首先对两个数组进行去重操作，之后再进行排序</li><li>设置两个指针，分别指向排序后的两个数组的头部</li><li>比较指针指向的两个元素是否相同，若相同则添加到交集中，并将两个指针后移</li><li>否则将指向较小元素的指针后移</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">intersection</span><span class="params">(self, nums1: List[int], nums2: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">    inter = []</span><br><span class="line">    nums1, nums2 = list(set(nums1)), list(set(nums2))</span><br><span class="line">    nums1.sort(), nums2.sort()</span><br><span class="line">    i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; len(nums1) <span class="keyword">and</span> j &lt; len(nums2):</span><br><span class="line">        <span class="keyword">if</span> nums1[i] == nums2[j]:</span><br><span class="line">            inter.append(nums1[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums1[i] &lt; nums2[j]:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> inter</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之4的阶乘</title>
      <link href="/passages/leetcode-zhi-4-de-jie-cheng/"/>
      <url>/passages/leetcode-zhi-4-de-jie-cheng/</url>
      
        <content type="html"><![CDATA[<p>Power of Four</p><a id="more"></a><h3 id="Power-of-Four"><a href="#Power-of-Four" class="headerlink" title="Power of Four"></a>Power of Four</h3><ul><li><p>code with Python</p></li><li><p>title number：342</p></li><li><p>简单</p></li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个整数（32位有符号数），判断这个是是否为4的幂次方</li><li>进阶：尝试不使用循环或者递归实现</li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>比较直接的想法就是不停的除以4直到不能整除，判断最后的数是否为整数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPowerOfFour</span><span class="params">(self, num: int)</span> -&gt; bool:</span></span><br><span class="line">    <span class="keyword">while</span> num <span class="keyword">and</span> num % <span class="number">4</span> == <span class="number">0</span>:</span><br><span class="line">        num /= <span class="number">4</span></span><br><span class="line">    <span class="keyword">return</span> num == <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li>还有一种更为直接的想法，既然给定的数是<code>32</code>位有符号整数，经过计算，<code>32</code>位有符号整数所能表达的最大的<code>4</code>的幂次方为$4^{15}$</li><li>因此，我们可以穷举所有可能，判断给定的数是否在穷举的结果中即可</li><li>注意，<code>4</code>的幂肯定是正整数啊</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPowerOfFour</span><span class="params">(self, num: int)</span> -&gt; bool:</span></span><br><span class="line">    prob = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">16</span>):</span><br><span class="line">        prob.append(pow(<span class="number">4</span>, i))</span><br><span class="line">    <span class="keyword">return</span> num <span class="keyword">in</span> prob</span><br></pre></td></tr></table></figure><h4 id="思路三"><a href="#思路三" class="headerlink" title="思路三"></a>思路三</h4><ul><li>下面根据数字本身的数学特点想到的方法</li><li>首先观察$num = 4^x$，那么，$x = log_4x = \frac{1}{2}log_2x$，此处的<code>x</code>应该是整数</li><li>再进一步，我们只需要判断$log_2x$是否为偶数即可</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> log2</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPowerOfFour</span><span class="params">(self, num: int)</span> -&gt; bool:</span></span><br><span class="line">    <span class="keyword">return</span> num &gt; <span class="number">0</span> <span class="keyword">and</span> log2(num) % <span class="number">2</span> == <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="思路四"><a href="#思路四" class="headerlink" title="思路四"></a>思路四</h4><ul><li><p>位运算</p></li><li><p>因为<code>4</code>的幂次方必定是<code>2</code>的幂次方，观察<code>2</code>的幂次方的二进制表示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">210</span><br><span class="line">4100</span><br><span class="line">81000</span><br><span class="line">1610000</span><br><span class="line">32100000</span><br><span class="line">641000000</span><br><span class="line">12810000000</span><br><span class="line">256100000000</span><br><span class="line">5121000000000</span><br><span class="line">102410000000000</span><br></pre></td></tr></table></figure></li><li><p>可以发现，<code>4</code>的幂次方的二进制中，<code>1</code>出现在奇数位上（很重要的特点）</p></li><li><p>我们想要找到一个特殊的数：奇数位为1，偶数位为0，这样的一个数与<code>4</code>的幂次方进行与运算，得到的结果与原来的数相同</p></li><li><p><code>1010101010101010101010101010101</code></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPowerOfFour</span><span class="params">(self, num: int)</span> -&gt; bool:</span></span><br><span class="line">    <span class="keyword">if</span> num &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="comment"># 是否为2的幂次方</span></span><br><span class="line">    <span class="keyword">if</span> (num &amp; num - <span class="number">1</span>) != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="comment"># 是否为4的幂次方</span></span><br><span class="line">    <span class="keyword">if</span> num &amp; <span class="number">0x55555555</span> == num:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><ul><li>注意，一定要先判断数字是否为<code>2</code>的幂次方，否则<code>5,9</code>这种数在进行与运算时也会返回<code>True</code></li><li>代码简化</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPowerOfFour</span><span class="params">(self, num: int)</span> -&gt; bool:</span></span><br><span class="line">    <span class="keyword">return</span> num &gt; <span class="number">0</span> <span class="keyword">and</span> (num &amp; num<span class="number">-1</span>)==<span class="number">0</span> <span class="keyword">and</span> num &amp; <span class="number">0x55555555</span> == num</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之移动0元素</title>
      <link href="/passages/leetcode-zhi-yi-dong-0-yuan-su/"/>
      <url>/passages/leetcode-zhi-yi-dong-0-yuan-su/</url>
      
        <content type="html"><![CDATA[<p>Move Zeros</p><a id="more"></a><h3 id="Move-Zeros"><a href="#Move-Zeros" class="headerlink" title="Move Zeros"></a>Move Zeros</h3><ul><li><p>code with Python</p></li><li><p>title number：283</p></li><li><p>简单</p></li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个数组，将数组中所有的数字<code>0</code>移动到数字的末尾</li><li>同时需要保证非<code>0</code>元素的相对顺序</li><li>需要在原数组上进行操作，不能使用额外的存储空间</li><li>示例：<code>[0,1,0,3,12] -&gt; [1,3,12,0,0]</code></li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>如果没有限制使用额外空间的话，我们可以分别使用两个数组保存<code>0</code>和非<code>0</code>元素，最后将两个数组进行拼接即可</li><li>在不能使用额外数组的限制条件下，需要转变一下思路<ul><li><code>0</code>元素最后必定出现在数组的末尾，那么我们可以只操作非<code>0</code>元素，最后在数组后面补<code>0</code>即可</li><li>使用快慢指针，<code>fast</code>用于遍历数组，<code>slow</code>用于指向非<code>0</code>元素的最后一位</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">moveZeroes</span><span class="params">(self, nums: List[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    fast = slow = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> fast &lt; len(nums):</span><br><span class="line">        <span class="keyword">if</span> nums[fast] != <span class="number">0</span>:</span><br><span class="line">            nums[slow] = nums[fast]</span><br><span class="line">            slow += <span class="number">1</span></span><br><span class="line">        fast += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(slow, fast):</span><br><span class="line">        nums[i] = <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li>思路一对数组的遍历多于一遍，我们尝试节省这部分时间<ul><li>遍历数组，第一次遇到非<code>0</code>元素就与<code>nums[0]</code>交换位置</li><li>依次类推，第<code>i</code>次遇到非<code>0</code>元素就与<code>nums[i]</code>交换，直到遍历结束</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">moveZeroes</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    i, j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[fast] != <span class="number">0</span>:</span><br><span class="line">            nums[j], nums[i] = nums[i], nums[j]</span><br><span class="line">            j += <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之丑数</title>
      <link href="/passages/leetcode-zhi-chou-shu/"/>
      <url>/passages/leetcode-zhi-chou-shu/</url>
      
        <content type="html"><![CDATA[<p>Ugly Number</p><a id="more"></a><h3 id="Ugly-Number"><a href="#Ugly-Number" class="headerlink" title="Ugly Number"></a>Ugly Number</h3><ul><li><p>code with Python</p></li><li><p>title number：263</p></li><li><p>简单</p></li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>判断给定的数是否为<code>ugly number</code></li><li>所谓<code>ugly number</code>指的是只包含质因数<code>2,3,5</code>的<strong>正整数</strong></li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>问题的关键在于求质数</li><li>首先想到的是先将给定的数进行质数分解，之后再判断分解得到的质数序列中是否含有除<code>2,3,5</code>之外的质数</li><li>但是这样需要进行质数分解并且需要使用<strong>额外的空间</strong>来存储质数序列，和<strong>额外的时间</strong>来再次遍历质数序列</li><li>换一种思路，我们对给定的数字不断除以<code>2,3,5</code>，如果最后的数字不是<code>1</code>，则返回<code>False</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isUgly</span><span class="params">(self, num: int)</span> -&gt; bool:</span></span><br><span class="line">    <span class="keyword">if</span> num &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        last = num</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> num % <span class="number">2</span>:</span><br><span class="line">            num = num // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> num % <span class="number">3</span>:</span><br><span class="line">            num = num // <span class="number">3</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> num % <span class="number">5</span>:</span><br><span class="line">            num = num // <span class="number">5</span></span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> last = num:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><ul><li>重构一下代码</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isUgly</span><span class="params">(self, num: int)</span> -&gt; bool:</span></span><br><span class="line">    <span class="keyword">if</span> num &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]:</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> num % x:</span><br><span class="line">            num = num // x</span><br><span class="line">    <span class="keyword">return</span> num == <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>第二种实现方法的用时明显减少</li><li>经分析可能是对于<code>8</code>这种只包含其中一个质数的可以减少很多无用的计算和判断</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之使用栈实现队列</title>
      <link href="/passages/leetcode-zhi-shi-yong-zhan-shi-xian-dui-lie/"/>
      <url>/passages/leetcode-zhi-shi-yong-zhan-shi-xian-dui-lie/</url>
      
        <content type="html"><![CDATA[<p>Implement Queue using Stack</p><a id="more"></a><h3 id="Implement-Queue-using-Stack"><a href="#Implement-Queue-using-Stack" class="headerlink" title="Implement Queue using Stack"></a>Implement Queue using Stack</h3><ul><li><p>code with Python</p></li><li><p>title number：232</p></li><li><p>简单</p></li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>使用栈实现队列的以下功能<ul><li><code>push(x)</code>：将一个元素放入队列尾部</li><li><code>pop()</code>：从队列首部移除元素</li><li><code>peek()</code>：获取最前端的元素</li><li><code>empty()</code>：返回队列是否为空</li></ul></li><li>只能使用栈的标准操作，对于不支持栈的语言可以使用<code>list</code>代替</li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>这个题没有什么特别的思路，重要的是理解栈和队列两种数据结构的特点<ul><li>栈：先进后出，只能在一端进行操作</li><li>队列：先进先出，只能在队头出元素，在队尾进元素</li></ul></li><li>我们使用两个栈来实现队列<ul><li>一个用来反转元素的入队顺序</li><li>一个用来存储元素的最终顺序</li></ul></li><li>入队操作<ul><li>队列是先进先出的，而栈是先进后出的</li><li>最新压入栈的元素需要在栈底，所以我们将栈<code>S1</code>中的所有元素移到栈<code>S2</code>中实现顺序的反转，并将新元素压入<code>S1</code>中，再将<code>S2</code>中的元素放回<code>S1</code>，这时<code>S1</code>中元素的顺序就是队列中的顺序了</li></ul></li><li>出队操作<ul><li>直接从<code>S1</code>中弹出即可</li></ul></li><li>判空操作<ul><li>只需要检查<code>S1</code>中是否为空即可</li></ul></li><li>取队首元素<ul><li>使用<code>front</code>存储队首元素</li><li>每次出队入队时都要更新该值</li><li>需要的时候只需要返回该值即可</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.help_stack = []</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.stack:</span><br><span class="line">        self.help_stack.append(self.stack.pop())</span><br><span class="line">        self.stack.append(x)</span><br><span class="line">        <span class="keyword">while</span> self.help_stack:</span><br><span class="line">            self.stack.append(self.help_stack.pop())</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.stack.pop()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[<span class="number">-1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span><span class="params">(self)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> bool(self.stack)</span><br></pre></td></tr></table></figure><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li>上一种方式使用了辅助栈，需要先弹出再还原，每个元素会访问两遍，所以使用的时间比较多</li><li>仍然是使用辅助栈，一个用于输入，一个用于输出</li><li>当需要查看或者出队时，我们将输出栈中的元素放入输出栈中，从输出栈中进行输出<ul><li>当输出栈不为空时可直接从输出栈中输出元素</li><li>要保证输出栈中为空的时候才能向其中放入元素</li><li>并且一次需要将输入栈中的所有元素全放入输出栈</li></ul></li><li>写一个辅助函数<code>shift</code>用于将输入栈中元素一次性全部放入输出栈中</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.stack_in = []</span><br><span class="line">        self.stack_out = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    </span><br><span class="line">        self.stack_in.append(x)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        </span><br><span class="line">        self.shift()</span><br><span class="line">        <span class="keyword">return</span> self.stack_out.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        </span><br><span class="line">        self.shift()</span><br><span class="line">        <span class="keyword">return</span> self.stack_out[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span><span class="params">(self)</span> -&gt; bool:</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack_in <span class="keyword">and</span> <span class="keyword">not</span> self.stack_out:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shift</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack_out:</span><br><span class="line">            <span class="keyword">while</span> self.stack_in:</span><br><span class="line">                self.stack_out.append(self.stack_in.pop())</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之反转二叉树</title>
      <link href="/passages/leetcode-zhi-fan-zhuan-er-cha-shu/"/>
      <url>/passages/leetcode-zhi-fan-zhuan-er-cha-shu/</url>
      
        <content type="html"><![CDATA[<p>Inverted Binary Tree</p><a id="more"></a><h3 id="Inverted-Binary-Tree"><a href="#Inverted-Binary-Tree" class="headerlink" title="Inverted Binary Tree"></a>Inverted Binary Tree</h3><ul><li><p>code with Python</p></li><li><p>title number： 226</p></li><li><p>简单</p></li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li><p>反转二叉树</p></li><li><p>左右子树互换</p></li><li><p>示例</p><p><img src="/.top//Leetcode%E4%B9%8B%E5%8F%8D%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91%5C1.png" alt></p></li><li><p>给定二叉树结构</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>非常经典的树结构的问题，很适合使用递归方法来解决<ul><li>如果根节点为空，则返回<code>None</code></li><li>否则递归反转其左右子树</li><li>边界条件：结点无左右子女</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">invertTree</span><span class="params">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    right = self.invertTree(root.right)</span><br><span class="line">    left = self.invertTree(root.left)</span><br><span class="line">    root.left = right</span><br><span class="line">    root.right = left</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li>还可以使用迭代的方式进行<ul><li>类似于深度优先搜索，我们使用一个队列来协助完成</li><li>队列中存储所有还未交换左右子女的结点</li><li>初始情况下只有根节点在队列中</li><li>出队根节点，交换其左右子女，并且左右子女入队；依次执行，直到树被遍历完</li></ul></li><li>本题的重点在于遍历树的每个节点，只要能访问到树的每个节点，皆可以实现二叉树的反转，至于使用哪种遍历方式则没那么讲究</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inverTree</span><span class="params">(self, root: TreeNOde)</span> -&gt; TreeNode:</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    queue = []</span><br><span class="line">    queue.append(root)</span><br><span class="line">    <span class="keyword">while</span> queue &gt; <span class="number">0</span>:</span><br><span class="line">        cur = queue.pop(<span class="number">0</span>)</span><br><span class="line">        cur.left, cur.right = cur.right, cur.left</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> cur.left != <span class="literal">None</span>: queue.append(cur.left)</span><br><span class="line">        <span class="keyword">if</span> cur.right != <span class="literal">None</span>: queue.append(cur.right)</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h4 id="迭代和递归的区别"><a href="#迭代和递归的区别" class="headerlink" title="迭代和递归的区别"></a>迭代和递归的区别</h4><ul><li>简单来说，递归是<strong>程序调用自身的一种编程技巧</strong>，通常把一个大型的复杂的问题转化为一个与原问题相似的规模较小的问题来解决</li><li>而迭代是<strong>利用变量的原值推算出变量的新值</strong>，是<code>A</code>不断调用<code>B</code>的过程</li><li>总体来说，递归中一定有迭代，而迭代中不一定有递归。</li><li>大部分情况下可以相互转化，<strong>优先选择使用迭代</strong>，因为递归调用函数浪费空间，并且递归的太深容易造成堆栈的溢出</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之包含重复数Ⅱ</title>
      <link href="/passages/leetcode-zhi-bao-han-chong-fu-shu-ii/"/>
      <url>/passages/leetcode-zhi-bao-han-chong-fu-shu-ii/</url>
      
        <content type="html"><![CDATA[<p>Contains Duplicate Ⅱ</p><a id="more"></a><h3 id="Contains-Duplicate-Ⅱ"><a href="#Contains-Duplicate-Ⅱ" class="headerlink" title="Contains Duplicate Ⅱ"></a>Contains Duplicate Ⅱ</h3><ul><li><p>code with Python</p></li><li><p>title number：219</p></li><li><p>简单</p></li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个整数数组和一个整数K</li><li>判断数组中是否存在两个不同的位置的元素值相等，并且这两个元素的索引之差的绝对值大于K </li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>因为需要在给定的数组中查找相同元素，找到之后再判断两者索引之差是否符合要求</li><li>这里可以使用一个哈希表来存储，将相同元素的下标存储到一起<ul><li>具体来说，使用一个字典，<code>key</code>为元素值，<code>value</code>为元素的下标</li><li>如果<code>nums[i]</code>不在字典中，则将<code>nums[i]</code>添加到字典中，同时将<code>value</code>设置为其索引</li><li>如果<code>nums[i]</code>在字典中，则判断当前的<code>nums[i]</code>的索引与字典中<code>nums[i]</code>对应的<code>value</code>的差值是否符合情况</li><li>注意：在数组遍历完之前不能因为一次的判断不符合就返回<code>False</code>，正确的做法是更新字典中<code>nums[i]</code>对应的索引</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">containsNearbyDuplicate</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; bool:</span></span><br><span class="line">    hash = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] <span class="keyword">not</span> <span class="keyword">in</span> hash:</span><br><span class="line">            hash[nums[i]] = i</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> i - hash[nums[i]] &lt;= k:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hash[nums[i]] = i</span><br><span class="line">    <span class="keyword">return</span> Fasle</span><br></pre></td></tr></table></figure><ul><li>题目比较简单，暂时没有想到其他的思路，做一下代码的简化</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">containsNearbyDuplicate</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; bool:</span></span><br><span class="line">    hash = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> index, num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">        <span class="keyword">if</span> num <span class="keyword">in</span> hash <span class="keyword">and</span> index - hash[num] &lt;= k:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        hash[num] = index</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li>这个方法时间复杂度太高，不可行<ul><li>遍历数组，每检查一个数，就去遍历其后面k个数，看是否有相等的，有则返回<code>True</code></li><li>当数组遍历完仍未发现符合的情况，则返回<code>False</code></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">containsNearbyDuplicate</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; bool:</span></span><br><span class="line">    <span class="keyword">for</span> index, num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, k+<span class="number">1</span>):   </span><br><span class="line">            <span class="keyword">if</span> index+i &lt; len(nums):</span><br><span class="line">                <span class="keyword">if</span> num == nums[index+i]:   </span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之反转链表</title>
      <link href="/passages/leetcode-zhi-fan-zhuan-lian-biao/"/>
      <url>/passages/leetcode-zhi-fan-zhuan-lian-biao/</url>
      
        <content type="html"><![CDATA[<p>Reverse Linked List</p><a id="more"></a><h3 id="Reverse-Linked-List"><a href="#Reverse-Linked-List" class="headerlink" title="Reverse Linked List"></a>Reverse Linked List</h3><ul><li><p>code with Python</p></li><li><p>title number：206</p></li><li><p>简单</p></li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>反转链表</li><li>迭代 or 递归</li><li>关键词：链表 </li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>典型的链表操作</li><li>最直接的想法就是使用一个等长的数组存储链表的元素</li><li>反向遍历数组，并将链表中的结点的值修改即可</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">    nums = []</span><br><span class="line">    cur = head</span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        nums.append(cur.val)</span><br><span class="line">        cur = cur.next</span><br><span class="line"></span><br><span class="line">    cur = head</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums), <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">        cur.val = nums[i<span class="number">-1</span>]</span><br><span class="line">        cur = cur.next</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><ul><li>可以通过，但是耗费的时间比较多，对链表进行了两次遍历</li></ul><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li>将链表反转，实际上只需要把所有的指针方向改变即可</li><li>还有一个要改变的地方是原来的头指针要指向null</li><li>这里使用双指针迭代法<ul><li>设置两个指针：<code>pre</code>和<code>cur</code></li><li>初始情况下：<code>pre=null, cur=head</code></li><li>将<code>cur</code>指向<code>pre</code>，之后不断迭代<code>cur</code>，每次迭代<code>cur</code>都将<code>cur-&gt;next</code>指向<code>pre</code>，同时将<code>pre</code>和<code>cur</code>同时向后移</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">    pre = <span class="literal">None</span></span><br><span class="line">    cur = head</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        tmp = cur.next</span><br><span class="line">        cur.next = pre</span><br><span class="line">        pre = cur</span><br><span class="line">        cur = tmp</span><br><span class="line">    <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure><h4 id="思路三"><a href="#思路三" class="headerlink" title="思路三"></a>思路三</h4><ul><li>递归，本质上还是指针方向的改变</li><li>既然是递归，我们就像想一下终止条件等问题<ul><li>终止条件：<code>当前结点或下一节点指向null</code></li><li>递归主体：<code>当前结点的下一个结点的next指向当前结点</code></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">    <span class="keyword">if</span> head==<span class="literal">None</span> <span class="keyword">or</span> head.next==null:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    <span class="comment"># 跳出递归时指向的是最后一个元素</span></span><br><span class="line">    cur = self.reverseList(head.next)</span><br><span class="line">    </span><br><span class="line">    head.next.next = head</span><br><span class="line">    head.next = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure><h4 id="思路四"><a href="#思路四" class="headerlink" title="思路四"></a>思路四</h4><ul><li>相信在学习数据结构中链表的插入时，都学过一种名叫<code>头插法</code>的插入方式</li><li>可以利用这种方式，在遍历链表的过程中，不断将链表结点添加到链表的头部</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    cur = head.next<span class="comment"># 用于遍历链表</span></span><br><span class="line">    head.next = <span class="literal">None</span></span><br><span class="line">    head_ = head</span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        temp = cur.next</span><br><span class="line">        cur.next = head_</span><br><span class="line">        head_ = cur</span><br><span class="line">        cur = temp</span><br><span class="line">    <span class="keyword">return</span> head_</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之删除链表元素</title>
      <link href="/passages/leetcode-zhi-shan-chu-lian-biao-yuan-su/"/>
      <url>/passages/leetcode-zhi-shan-chu-lian-biao-yuan-su/</url>
      
        <content type="html"><![CDATA[<p>Remove Linked List Elements</p><a id="more"></a><h3 id="Remove-Linked-List-Elements"><a href="#Remove-Linked-List-Elements" class="headerlink" title="Remove Linked List Elements"></a>Remove Linked List Elements</h3><ul><li><p>code with Python</p></li><li><p>title number：203</p></li><li><p>简单</p></li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li><p>删除链表中等于给定值<code>val</code>的所有结点</p></li><li><p>关键词：链表</p></li><li><p>Python中给定的链表结构</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next - <span class="literal">None</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>常规的链表题目<ul><li>双指针：<code>pre, cur</code>，分别指向前一个元素和当前元素</li><li>初始，<code>pre=head</code>，<code>cur=head</code></li><li>遍历列表，遇到需要删除的结点时，将<code>pre-&gt;next</code>指向<code>cur-&gt;next</code></li></ul></li><li>需要单独处理几种特殊情况：<ul><li>链表为空</li><li>待删除结点在链表头部</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, head: ListNode, val: int)</span> -&gt; ListNode:</span></span><br><span class="line">    <span class="comment"># 链表为空</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 待删除元素为第一个结点</span></span><br><span class="line">    <span class="keyword">while</span> head <span class="keyword">and</span> head.val == val:</span><br><span class="line">        head = head.next</span><br><span class="line">        </span><br><span class="line">    pre, cur = head, head</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> cur.val == val:</span><br><span class="line">            <span class="comment"># 删除当前元素</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">            pre.next = cur</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">    pre = cur</span><br><span class="line">            cur = cur.next</span><br><span class="line">    <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><ul><li>添加一个在头部的辅助结点，将几种特殊情况转化为可以一起处理的通用情况</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, head: ListNode, val: int)</span> -&gt; ListNode:</span></span><br><span class="line">    prev =ListNode(<span class="number">0</span>)</span><br><span class="line">    prev.next = head</span><br><span class="line">    cur = prev</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> cur.next:</span><br><span class="line">        <span class="keyword">if</span> cur.next.val == val:</span><br><span class="line">            cur.next = cur.next.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = cur.next</span><br><span class="line">    <span class="keyword">return</span> prev.next</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之打家劫舍</title>
      <link href="/passages/leetcode-zhi-da-jia-jie-she/"/>
      <url>/passages/leetcode-zhi-da-jia-jie-she/</url>
      
        <content type="html"><![CDATA[<p>House Robber</p><a id="more"></a><h3 id="House-Robber"><a href="#House-Robber" class="headerlink" title="House Robber"></a>House Robber</h3><ul><li><p>code with Python</p></li><li><p>title number：198</p></li><li><p>简单</p></li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>你是一个小偷，计划偷沿街的房子，要求在限定条件下取得尽可能多的现金</li><li>当你在同一晚上潜入了相邻的两间房子，警报会被触发</li><li>例如：<code>[1,2,3,1]</code><ul><li>即相邻的四座房子中分别可以偷到金额为<code>1,2,3,1</code>的现金</li><li>最佳方案是偷第一间和第三间房子，获得金额为4的现金</li></ul></li><li>关键词：动态规划</li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li><p>习惯了暴力求解，这道题其实也可已通过穷举所有可能进行求解，但是考虑所有可能的抢劫方案过于困难</p></li><li><p>但是这是一道动态规划的题目，天生的动态规划题目，哈哈</p></li><li><p>动态规划的本质在解决<code>第i个元素取不取</code>的问题，对应到该题目就是<code>第i个房子抢不抢</code>的问题</p></li><li><p>我们前<code>i</code>个房子能获得的最大价值为<code>dp[i]</code></p></li><li><p>判断的依据就是抢与不抢两种情况下哪一种带来的价值最大</p><ul><li>如果抢的话，当前获得的总价值就是<code>nums[i] + dp[i-2]</code>（相邻房子不能抢）</li><li>如果不抢的话，当前获得的总价值就是<code>dp[i-1]</code></li></ul></li><li><p>所以最难确定的状态转移方程就是<code>dp[i]=max(dp[i-2]+nums[i], dp[i-1])</code></p></li><li><p>初始状态：<code>dp[0]=0</code></p></li><li><p>返回值为<code>dp</code>的最后一个元素，即所有房间可以获得的最大价值</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">            </span><br><span class="line">    dp = nums</span><br><span class="line">    dp[<span class="number">0</span>], dp[<span class="number">1</span>] = nums[<span class="number">0</span>], max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(nums)):</span><br><span class="line">        dp[i] = max(dp[i<span class="number">-2</span>]+nums[i], dp[i<span class="number">-1</span>])</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> dp[len(nums)<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><ul><li>由于<code>dp[i]只与dp[i-1]和dp[i-2]有关</code>，设置两个变量交替存储，代替使用<code>dp</code>数组，可以减少空间的使用</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    length = len(nums)</span><br><span class="line">    <span class="keyword">if</span> length == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    prev= nums[<span class="number">0</span>] </span><br><span class="line">    cur = max(prev, nums[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, length):</span><br><span class="line">        cur, prev = max(prev+nums[i], cur), cur</span><br><span class="line">    <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure><ul><li>将<code>cur</code>和<code>pre</code>初始设置为0，可以将<code>nums</code>长为1和0的两种情况包含进来，进一步简化代码</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    cur, pre =<span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        cur, pre = max(pre+num, cur), cur</span><br><span class="line">    <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之位1的个数</title>
      <link href="/passages/leetcode-zhi-wei-1-de-ge-shu/"/>
      <url>/passages/leetcode-zhi-wei-1-de-ge-shu/</url>
      
        <content type="html"><![CDATA[<p>Number of 1 Bits</p><a id="more"></a><h3 id="Number-of-1-Bits"><a href="#Number-of-1-Bits" class="headerlink" title="Number of 1 Bits"></a>Number of 1 Bits</h3><ul><li><p>code with Python</p></li><li><p>title number：191</p></li><li><p>简单</p></li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个无符号整数，返回其二进制表达式中<code>1</code>的个数</li><li>也称为<code>汉明重量</code></li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>比较直接的方法就是，遍历数字的32位，如果某一个二进制位为1，则计数加一，最后返回计数即可</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">    n = bin(n)</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> n:</span><br><span class="line">        <span class="keyword">if</span> c == <span class="string">'1'</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li>按照十进制转二进制的方式，每得到一位，判断其是否为1</li><li>注意，区别与之前翻转二进制的题目，这里统计的是1的个数，并不需要补零的操作</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n:</span><br><span class="line">        res = n % <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> res == <span class="number">1</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        n //= <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><p>由于中间涉及比较多的计算，耗费的时间比较多</p><h4 id="思路三"><a href="#思路三" class="headerlink" title="思路三"></a>思路三</h4><ul><li>我们知道两个不同长度的二进制数进行运算，会将长度较短的二进制数左端补零。<ul><li>根据这一特性，将<code>n</code>与<code>1</code>进行与运算，将能得到<code>n</code>的最低位数字</li><li>之后再将<code>n</code>右移一位</li><li>重复以上操作，直到<code>n==0</code></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n:</span><br><span class="line">        count += n&amp;<span class="number">1</span></span><br><span class="line">        n &gt;&gt;= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><p>花费的时间比较少</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>三个思路基本思想一致，都是遍历每位，判断是否是1，然后计数</li><li>区别在于获取每一位的方式不同</li><li>其中第三种方法分要注意，重点是其中涉及到的二进制运算的知识</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之翻转二进制位</title>
      <link href="/passages/leetcode-zhi-fan-zhuan-er-jin-zhi-wei/"/>
      <url>/passages/leetcode-zhi-fan-zhuan-er-jin-zhi-wei/</url>
      
        <content type="html"><![CDATA[<p>Reverse Bits</p><a id="more"></a><h3 id="Reverse-Bits"><a href="#Reverse-Bits" class="headerlink" title="Reverse Bits"></a>Reverse Bits</h3><ul><li><p>code with Python</p></li><li><p>title number：190</p></li><li><p>简单</p></li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>颠倒给定的32位无符号整数的二进制位</li><li>关键词：位运算</li><li></li></ul><h4 id="无符号整数"><a href="#无符号整数" class="headerlink" title="无符号整数"></a>无符号整数</h4><ul><li>计算机中的数是用二进制表示的</li><li>最左边的这一位如果用来表示这个数是正数还是负数，这样的数被称为有符号整数</li><li>最左边的这一维如果不用来表示这个数是正还是负，这样的数被成为无符号整数，无符号整数只能是正数</li></ul><h4 id="位运算相关操作"><a href="#位运算相关操作" class="headerlink" title="位运算相关操作"></a>位运算相关操作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;按位左移，左移n位相当于乘以<span class="number">2</span>的n次方</span><br><span class="line">&gt;&gt;按位右移，右移n位相当于除以<span class="number">2</span>的n次方</span><br><span class="line">&amp;按位与，参与计算的两个二进制位同且为<span class="number">1</span>，结果为<span class="number">1</span>，否则为<span class="number">0</span></span><br><span class="line">|按位或，参与计算的两个二进制位有<span class="number">1</span>，结果为<span class="number">1</span>，否则为<span class="number">0</span></span><br><span class="line">^按位异或，参与计算的两个二进制位不同，结果为<span class="number">1</span>，否则为<span class="number">0</span></span><br><span class="line">~按位取反，参与计算的二进制位中<span class="number">0</span>变为<span class="number">1</span>，<span class="number">1</span>变成<span class="number">0</span></span><br><span class="line"></span><br><span class="line">python中，将整数取反之后要进行切片，去掉前面的<span class="number">0</span>b</span><br><span class="line">bin(num)将整数转化为二进制数</span><br></pre></td></tr></table></figure><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>最先联想到的是字符串的翻转<ul><li>使用两个指针，分别指向字符串的头和尾</li><li>交换两个指针指向的元素，直到指针相遇或相邻（奇数位相遇，偶数位相邻）</li></ul></li><li>但是这个问题中的二进制整数并不能通过下标访问每一位，所以需要有所改动</li><li>比较直接的方法就是将二进制转化为字符串再进行翻转，位数不够进行补位，最后再转化为整数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseBits</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">    str1 = bin(n)[<span class="number">2</span>:][::<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">while</span> len(str1) &lt; <span class="number">32</span>:</span><br><span class="line">        str1 += <span class="string">'0'</span></span><br><span class="line">    <span class="keyword">return</span> int(str1, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><ul><li><p>由于是32位无符号整数，我们进行转化得到的数可能是高位有0，而在Python中转化之后是没有的，但是反转之后要在最后面追加0</p></li><li><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">str1 = bin(n)<span class="comment"># 0b10100101000001111010011100</span></span><br><span class="line">str1 = bin(n)[<span class="number">2</span>:]<span class="comment"># 10100101000001111010011100</span></span><br><span class="line">str1 = bin(n)[<span class="number">2</span>:][::<span class="number">-1</span>]<span class="comment"># 00111001011110000010100101</span></span><br><span class="line"><span class="comment"># 可以看到，翻转之后的数字是不够32位的，所以要在后面追加0</span></span><br><span class="line"><span class="keyword">while</span> len(str1) &lt; <span class="number">32</span>:</span><br><span class="line">    str1 += <span class="string">'0'</span></span><br><span class="line"><span class="comment"># 00111001011110000010100101000000</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li><p>位运算</p></li><li><p>回想反转10进制的时候，我们的操作是这样的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ans = ans * <span class="number">10</span> + n % <span class="number">10</span></span><br><span class="line">n /= <span class="number">10</span></span><br></pre></td></tr></table></figure></li><li><p>同样的，反转二进制我们也可以如此</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ans = ans * <span class="number">2</span> + n % <span class="number">2</span></span><br><span class="line">n /= <span class="number">2</span></span><br></pre></td></tr></table></figure></li><li><p>但是要额外处理的问题还是高位的0</p><ul><li>比如：00110 计算得到的是 011，而实际应该得到的是01100</li></ul></li><li><p>所以，要计算指定次数 -&gt; 32次，而不是ans为0结束</p></li><li><p>另外，上面的四则元算可以用位运算代替</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ans = (ans &lt;&lt; <span class="number">1</span>) | (n &amp; <span class="number">1</span>)</span><br><span class="line">n &gt;&gt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># n&amp;1 == 1, 说明n的最后一位是1, n&amp;1 == 0, 说明n的最后一位是0</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseBits</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">        ans = (ans &lt;&lt; <span class="number">1</span>) | (n &amp; <span class="number">1</span>)</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之多数元素</title>
      <link href="/passages/leetcode-zhi-duo-shu-yuan-su/"/>
      <url>/passages/leetcode-zhi-duo-shu-yuan-su/</url>
      
        <content type="html"><![CDATA[<p>Majority Element</p><a id="more"></a><h3 id="Majority-Element"><a href="#Majority-Element" class="headerlink" title="Majority Element"></a>Majority Element</h3><ul><li><p>code with Python</p></li><li><p>title number：169</p></li><li><p>简单</p></li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个大小为<code>n</code>的数组，找到其中多数的元素</li><li>多数元素：在数组中出现的次数大于<code>n/2</code></li><li>给定的数组中肯定存在多数元素</li><li>关键字：位运算、数组、分治算法</li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>使用字典结构<ul><li>如果元素不在字典中，将元素加入字典，并设置<code>value</code>为1</li><li>如果元素在字典中，<code>value</code>计数加一</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    count = dict()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">in</span> count.keys():</span><br><span class="line">            count[x] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            count[x] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> count.keys():</span><br><span class="line">        <span class="keyword">if</span> count[key] &gt; len(nums)/<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> key</span><br></pre></td></tr></table></figure><p>时间复杂度高的感人，不过还是AC了</p><h4 id="思路一优化"><a href="#思路一优化" class="headerlink" title="思路一优化"></a>思路一优化</h4><ul><li>使用哈希表代替字典结构，这样可以减少空间复杂度，也能减小时间复杂度</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    count = collections.Counter(nums)</span><br><span class="line">    <span class="keyword">return</span> max(count.keys(), key=count.get)</span><br></pre></td></tr></table></figure><p>空间复杂度有所下降，时间复杂度没有明显改善</p><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li>将数组中元素排序，排序之后的数组中，多数元素的出现位置有规律<ul><li>如果多数元素是数组中的最小值，那么数组中第（n为偶数时，<code>n/2+1</code>；n为奇数时<code>n/2</code>）个元素必为多数元素</li><li>如果多数元素是数组中的最大值，同理</li><li>如果多数元素既不是最小值也不是最大值，那么有序数组的中间元素必为多数元素</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span> </span><br><span class="line">    nums.sort()</span><br><span class="line">    <span class="keyword">return</span> nums[len(nums)//<span class="number">2</span>]</span><br></pre></td></tr></table></figure><h4 id="思路三"><a href="#思路三" class="headerlink" title="思路三"></a>思路三</h4><ul><li>随机数（类似抽奖）<ul><li>因为多数元素在数组中占据的位置大于50%，所以我们可以每次取一个数</li><li>遍历一遍数组，判断取出的数是否为多数元素</li></ul></li><li>这种做法可能会永远取不到多数元素（无穷），但是也有可能一次成功（线性时间）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span> </span><br><span class="line">    majority_num = len(nums) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        rand = random.choice(nums)</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> x == rand:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> count &gt; majority_num:</span><br><span class="line">            <span class="keyword">return</span> rand</span><br></pre></td></tr></table></figure><p>可以AC</p><h4 id="思路四"><a href="#思路四" class="headerlink" title="思路四"></a>思路四</h4><ul><li>投票算法<ul><li>遍历<code>nums</code>，初始情况下将第一个元素作为候选的多数元素，</li><li>在遍历的过程中，遇到候选的多数元素，则计数器加一，否则减一</li><li>当计数器为0时，则遗忘掉之前的元素，使用下一个元素作为新的候选多数元素，继续遍历</li></ul></li><li>这种算法直觉上不好判断它的正确性，我们来分析一下<ul><li>举个例子：<code>[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]</code></li><li>在上述例子中，竖线位置处计数器会归零，也就是说，在竖线之前我们忽略掉了同样多数目的多数元素和非多数元素，在剩下的数组元素中，原来的多数元素仍是现在的多数元素，可以放心求解</li><li>总会有一组后缀会使计数器大于0，此时的候选多数元素即为所求</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span> </span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    candidate = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> count == <span class="number">0</span>:</span><br><span class="line">            candidate = num</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> num == candidate: count+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: count-=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> candidate</span><br></pre></td></tr></table></figure><h4 id="思路五"><a href="#思路五" class="headerlink" title="思路五"></a>思路五</h4><ul><li>想法与思路四类似，不过借用了栈来辅助，更加直观一些<ul><li>遍历数组，将元素入栈</li><li>如果后来的元素与栈顶元素相同，则出栈栈顶元素，否则入栈</li><li>栈顶元素即为多数元素，最终返回栈顶元素</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> len(stack)==<span class="number">0</span> <span class="keyword">or</span> stack[len(stack)<span class="number">-1</span>] == num:</span><br><span class="line">            stack.append(num)    </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            stack.remove(stack[len(stack)<span class="number">-1</span>])</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> stack[len(stack)<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>时间复杂度感人，但是可以AC</p><p>用来帮助理解投票算法</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之阶乘后的0</title>
      <link href="/passages/leetcode-zhi-jie-cheng-hou-de-0/"/>
      <url>/passages/leetcode-zhi-jie-cheng-hou-de-0/</url>
      
        <content type="html"><![CDATA[<p>Factorial Trailing Zeroes</p><a id="more"></a><h3 id="Factorial-Trailing-Zeroes"><a href="#Factorial-Trailing-Zeroes" class="headerlink" title="Factorial Trailing Zeroes"></a>Factorial Trailing Zeroes</h3><ul><li><p>code with Python</p></li><li><p>title number：172</p></li><li><p>简单</p></li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个整数<code>n</code>，返回$n!$结果位数中零的个数</li><li>例如：<ul><li>3! = 6，所以返回0</li><li>5! = 120，所以返回1</li></ul></li><li>时间复杂度应为$O(logn)$</li><li>关键词：数学</li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>最直接的想法就是对指定的整数先求阶乘，然后判断阶乘结果尾部0的个数</li><li>但是这种方法很容易就溢出，并且这种方法并不满足时间复杂度为<code>O(logn)</code></li></ul><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li>这种题目并没有通用的解法，只能通过对题目的理解寻找解决方案</li><li>首先我们知道，结尾处的<code>0</code>与数字<code>10</code>有很强的关联，即每乘一个<code>10</code>，答案的结尾就会出现一个<code>0</code></li><li>所以问题转化成了阶乘中能得出几个<code>10</code>，我们又发现，想要的到<code>10</code>，需要<code>2</code>和<code>5</code>相乘（1*10不行，因为已经出现10了）</li><li>所以问题又转化了，转化成寻找阶乘中有多少对<code>2,5</code></li><li>例如：<ul><li><code>5! = 120</code>是因为：<code>5! = 5 * 4 * 3 * 2 * 1</code>，其中出现了一对<code>2，5</code>，所以结果的末尾有一个<code>0</code></li><li>再看一个例子：<code>11! = 11 * (5*2) * 9 * (4*2) * 7 * (3*2) * (5*1) * (2*2) * 3 * (2*1) * 1</code></li><li>其中，含<code>2</code>的因子有：<code>(5*2),(4*2),(3*2),(2*2),(1*2)</code></li><li>含<code>5</code>的因子有：<code>(5*2),(5*1)</code></li></ul></li><li>可以发现，含有<code>2</code>的因子每隔两个出现一次，含有<code>5</code>的因子每隔<code>5</code>个出现一次。因此，<code>2</code>的个数一定是远多余<code>5</code>的</li><li>所以问题转化为，<strong>阶乘中有多少5</strong></li><li>因为每隔<code>5</code>个数出现一个<code>5</code>，所以<code>5</code>的个数使用<code>n/5</code>就可以得到</li><li>另外，每个<code>25</code>个数出现的是两个<code>5</code>，每隔<code>125</code>个数，出现的是三个<code>5</code></li><li><strong>综上，<code>5</code>的个数可以通过<code>n/5+n/25+n/125...</code>计算得到</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trailingZeroes</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">    count += n//<span class="number">5</span></span><br><span class="line">    n = n // <span class="number">5</span></span><br><span class="line"><span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><p>通过修改循环中计算的顺序，每次循环能减少一次计算，时间也大大减少了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trailingZeroes</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">    n = n // <span class="number">5</span></span><br><span class="line">    count += n</span><br><span class="line"><span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><p>代码没有多少，主要考察的是分析问题和问题转化的能力，非常有趣的题目~</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之两数之和Ⅱ</title>
      <link href="/passages/leetcode-zhi-liang-shu-zhi-he-ii/"/>
      <url>/passages/leetcode-zhi-liang-shu-zhi-he-ii/</url>
      
        <content type="html"><![CDATA[<p>Two Sum Ⅱ - Input array is sorted</p><a id="more"></a><h3 id="Two-Sum-Ⅱ-Input-array-is-sorted"><a href="#Two-Sum-Ⅱ-Input-array-is-sorted" class="headerlink" title="Two Sum Ⅱ - Input array is sorted"></a>Two Sum Ⅱ - Input array is sorted</h3><ul><li><p>code with Python</p></li><li><p>title number：167</p></li><li><p>简单</p></li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个升序排列的数组，找到两个数，使两者的加和等于目标数</li><li>要求返回两个数的下标，第一个数的下标要小于第二个数</li><li>说明：<ul><li>每个输入答案唯一</li></ul></li><li>关键字：数组、双指针、二分查找</li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>最先想到的当然是暴力破解</li><li>双循环，每个元素分别与其他元素相加，判断是否得到目标数</li><li>要注意，两个下标不能相等，这个要在求和时判断</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, numbers: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(numbers)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, len(numbers)):</span><br><span class="line">            <span class="keyword">if</span> numbers[i] + numbers[j] == target <span class="keyword">and</span> i != j:</span><br><span class="line">                <span class="keyword">return</span> [i+<span class="number">1</span>, j+<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>可能会超出时间限制</p><h4 id="思路一优化"><a href="#思路一优化" class="headerlink" title="思路一优化"></a>思路一优化</h4><ul><li>令<code>temp=target-numbers[i]</code>，使用<strong>二分查找</strong>在其余的元素中查找值与<code>temp</code>相等的数</li><li>找到之后，返回下标</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, numbers: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(numbers)):</span><br><span class="line">        temp = target - numbers[i]</span><br><span class="line">        left, right = i+<span class="number">1</span>, len(numbers)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = int((left+right)/<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> numbers[mid]==temp:</span><br><span class="line">                <span class="keyword">return</span> [i+<span class="number">1</span>, mid+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> numbers[mid] &lt; temp:</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid<span class="number">-1</span></span><br></pre></td></tr></table></figure><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li>比较直观的思路，双指针<ul><li><code>left</code>指向左端点，<code>right</code>指向右端点</li><li>计算两个指针指向的元素的和，判断其与目标数的大小<ul><li>大于目标数，则<code>right</code>左移</li><li>小于目标数，则<code>left</code>右移</li></ul></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, numbers: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">    left, right = <span class="number">0</span>, len(numbers)<span class="number">-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="keyword">if</span> numbers[left] + numbers[right] &lt; target:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> numbers[left] + numbers[right] &gt; target:</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> [left+<span class="number">1</span>, right+<span class="number">1</span>]</span><br></pre></td></tr></table></figure><ul><li>代码优化</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, numbers: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">    left, right = <span class="number">0</span>, len(numbers)<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="keyword">if</span> numbers[left] + numbers[right] == target:</span><br><span class="line">            <span class="keyword">return</span> [left+<span class="number">1</span>, right+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">elif</span> numbers[left] + numbers[right] &lt; target:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之最小栈</title>
      <link href="/passages/leetcode-zhi-zui-xiao-zhan/"/>
      <url>/passages/leetcode-zhi-zui-xiao-zhan/</url>
      
        <content type="html"><![CDATA[<p>Min Stack</p><a id="more"></a><h3 id="Min-Stack"><a href="#Min-Stack" class="headerlink" title="Min Stack"></a>Min Stack</h3><ul><li><p>code with Python</p></li><li><p>title number：155</p></li><li><p>简单</p></li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>设计一个支持<code>push</code>、<code>pop</code>、<code>top</code>的栈，能在常数时间内找到栈中的最小元素<ul><li><code>push()</code>：将元素入栈</li><li><code>pop()</code>：删除栈顶元素</li><li><code>top()</code>：获取栈顶元素</li><li><code>getMin()</code>：检索最小元素</li></ul></li><li>关键词：栈、设计</li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>常规思路，就是在普通栈的基础上，每次入栈的时候更新最小值</li><li>但是当最小值被出栈之后，由于最小值没有被更新，所以会出现问题<ul><li>出栈的时候判断一下最小值有没有被出栈，如果被出栈了，需要遍历栈找到新的最小值</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.min = float(<span class="string">'inf'</span>)</span><br><span class="line">        self.stack = []</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, s: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.stack.append(s)</span><br><span class="line">        <span class="keyword">if</span> s &lt; self.min:</span><br><span class="line">            self.min = s</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span> -&gt;<span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        temp = self.stack.pop()</span><br><span class="line">    <span class="keyword">if</span> temp == self.min:</span><br><span class="line">            self.min = float(<span class="string">'inf'</span>)</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> self.stack:</span><br><span class="line">                <span class="keyword">if</span> x &lt; self.min:</span><br><span class="line">                self.min = x</span><br><span class="line">                    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        temp = self.stack[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> temp</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.min</span><br></pre></td></tr></table></figure><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li>栈内存储的不是实际值，而是真实值与当前最小值之间的差值，并且在<code>push</code>和<code>pop</code>操作时更新最小值</li><li>仅当<code>top</code>操作取数据的时候，需要对数据进行还原（栈顶元素+上一个最小值）</li><li>关键问题是在还原数据时如何求得<strong>上一个最小值</strong><ul><li>如果栈顶元素小于0，说明栈顶元素是当前的最小值（栈顶元素当前值-上一个最小值，而上一个最小值只会比当前的最小值小），将其出栈会改变栈中的最小值，上一个最小值通过<code>min - 栈顶元素</code></li><li>如果栈顶元素大于0，则出栈栈顶元素对最小值没有影响</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.min = float(<span class="string">'inf'</span>)</span><br><span class="line">        self.stack = []</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.stack.append(x-self.min)</span><br><span class="line">        <span class="keyword">if</span> s &lt; self.min:</span><br><span class="line">            self.min = s</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span> -&gt;<span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        temp = self.stack.pop()</span><br><span class="line">    <span class="keyword">if</span> temp &lt; <span class="number">0</span>:</span><br><span class="line">            self.min -= temp</span><br><span class="line">                    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        temp = self.stack[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> temp &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.min</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.min + temp  </span><br><span class="line">        <span class="keyword">return</span> temp</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.min</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之只出现一次的数字</title>
      <link href="/passages/leetcode-zhi-zhi-chu-xian-yi-ci-de-shu-zi/"/>
      <url>/passages/leetcode-zhi-zhi-chu-xian-yi-ci-de-shu-zi/</url>
      
        <content type="html"><![CDATA[<p>Single Number</p><a id="more"></a><h3 id="Single-Number"><a href="#Single-Number" class="headerlink" title="Single Number"></a>Single Number</h3><ul><li><p>code with Python</p></li><li><p>title number：136</p></li><li><p>简单</p></li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个非空数组，数组中只有一个元素出现的次数为1次，其余的元素出现的次数均为两次，找出只出现一次的元素</li><li>关键词：位运算，哈希表</li><li>不能使用额外空间，并且要将时间复杂度控制在线性时间</li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>常规思路，时间复杂度取决于排序算法</li><li>对数组进行排序，排序后相同的元素都挨在一起</li><li>再对数组进行一次遍历即可找到唯一出现一次的元素</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    nums.sort()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums), <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> i<span class="number">-1</span> != <span class="number">0</span> <span class="keyword">and</span> i<span class="number">-1</span> &lt; len(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[i<span class="number">-1</span>]==nums[i<span class="number">-2</span>]:</span><br><span class="line">                <span class="keyword">del</span> nums[i<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">del</span> nums[i<span class="number">-2</span>]</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li>常规思路，时间复杂度$O(n^2)$</li><li>使用字典结构，每遇到一个字典中未出现过的字，加入字典并计数</li><li>遍历字典中的key，取value为1的key</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">dic = dict()</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> str(num) <span class="keyword">in</span> dic.keys():</span><br><span class="line">            dic[str(num)] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dic[str(num)] = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> dic.keys():</span><br><span class="line">        <span class="keyword">if</span> dic[key] == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> key</span><br></pre></td></tr></table></figure><h4 id="思路三"><a href="#思路三" class="headerlink" title="思路三"></a>思路三</h4><ul><li>常规思路，使用额外的空间</li><li>列表<code>no_dup</code>用于存储不重复的元素<ul><li>遍历<code>nums</code>，如果不在<code>no_dup</code>中，则添加</li><li>若在<code>no_dup</code>中出现过，则删除</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    no_dup = []</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> no_dup:</span><br><span class="line">            no_dup.append(num)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            no_dup.remove(num)</span><br><span class="line">    <span class="keyword">return</span> no_dup[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h4 id="思路四"><a href="#思路四" class="headerlink" title="思路四"></a>思路四</h4><ul><li>比较难考虑的一种，利用二进制异或的性质：<ul><li>任何数和本身异或则为0</li><li>任何数和0异或为其本身</li><li>满足结合律，即$a \bigoplus a \bigoplus b = a \bigoplus b \bigoplus a = b$</li></ul></li><li>初始设置<code>single_number=0</code></li><li>遍历整个数组，与<code>single_number</code>依次做异或操作</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    single_number = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        single_number ^= num</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> single_number</span><br></pre></td></tr></table></figure><h4 id="思路五"><a href="#思路五" class="headerlink" title="思路五"></a>思路五</h4><ul><li>数学：$2*(a+b+c)-(a+a+b+b+c)=c$</li><li>利用该公式即可得到唯一出现一次的元素的值（前提是只有一个元素出现一次，其余元素均出现两次）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">single_number = <span class="number">2</span>*sum(set(nums)) - sum(nums)</span><br><span class="line"><span class="keyword">return</span> single_number</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之回文串Ⅱ</title>
      <link href="/passages/leetcode-zhi-hui-wen-chuan-ii/"/>
      <url>/passages/leetcode-zhi-hui-wen-chuan-ii/</url>
      
        <content type="html"><![CDATA[<p>Valid Palindrome Ⅱ</p><a id="more"></a><h3 id="Valid-Palindrome-Ⅱ"><a href="#Valid-Palindrome-Ⅱ" class="headerlink" title="Valid Palindrome Ⅱ"></a>Valid Palindrome Ⅱ</h3><ul><li><p>code with Python</p></li><li><p>title number：680</p></li><li><p>简单</p></li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个字符串，至多删除一个字符，判断能否变成回文串</li><li>字符串只包含<code>a-z</code>的小写字母</li><li>关键字：字符串</li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>因为字符串只包含小写字母，无需对字符串进行处理</li><li>暴力破解<ul><li>先判断未删除时是否是回文串</li><li>穷举所有的删除可能，然后判断字符串是否回文</li></ul></li></ul><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li>使用双指针分别指向字符串的头部和尾部，遍历，判断指针指向的元素是否相同<ul><li>若相同，则移动指针</li><li>若不同，则分别尝试删除两个指针指向的元素，再继续判断是否是回文串</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validPalindrome</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">    <span class="keyword">if</span> s == s[::<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    left, right = <span class="number">0</span>, len(s)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="keyword">if</span> s[left] != s[right]:</span><br><span class="line">            a = s[:left] + s[left+<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">if</span> a == a[::<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            b = s[:right] + s[right+:]</span><br><span class="line">            <span class="keyword">if</span> b == b[::<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">           <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之回文串</title>
      <link href="/passages/leetcode-zhi-hui-wen-chuan/"/>
      <url>/passages/leetcode-zhi-hui-wen-chuan/</url>
      
        <content type="html"><![CDATA[<p>Valid Palindrome</p><a id="more"></a><h3 id="Valid-Palindrome"><a href="#Valid-Palindrome" class="headerlink" title="Valid Palindrome"></a>Valid Palindrome</h3><ul><li><p>code with Python</p></li><li><p>title number：125</p></li><li><p>简单</p></li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个字符串，判断其是否是回文串<ul><li>不考虑大小写</li><li>从示例来看，不考虑空格和标点</li></ul></li><li>关键字：双指针，字符串</li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>很容易想到的是双指针（头尾指针）<ul><li>头指针指向第一个元素，尾指针指向最后一个元素</li><li>先判断指针指向的元素是否是数字or字母，不是则跳过</li><li>如果两个指针指向的元素不同，返回false</li><li>如果两个指针指向的元素相同，则移动指针（头指针向后，尾指针向前）</li><li>直到两个指针相遇</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">    left, right = <span class="number">0</span>, len(s)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s[left].isalnum():</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s[right].isalnum():</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> s[left].lower() == s[right].lower():</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：<code>isalnum()</code>，字符串自带函数，用于判断字符串是否只由数字和字母组成</p><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li>还是双指针，只是对字符串进行了预处理，将非数字和字母的元素删除<ul><li>可以使用额外的空间来存储顺序字母和数字</li><li>可以在原字符串上操作，需要从后向前操作，放置数组访问出错</li></ul></li><li>主体操作还是头尾两个指针</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">    s_temp = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s[i].isalnum():</span><br><span class="line">            s_temp.append(s[i].lower())</span><br><span class="line">   left, right = <span class="number">0</span>, len(s)<span class="number">-1</span>  </span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="keyword">if</span> s[left] == s[right]:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>空间复杂度比较高，毕竟申请了额外的空间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s), <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s[i<span class="number">-1</span>].isalnum():</span><br><span class="line">            s = s[:i<span class="number">-1</span>] + s[i:]            </span><br><span class="line">    left, right = <span class="number">0</span>, len(s)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="keyword">if</span> s[left].lower() == s[right].lower():</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>时间复杂度感人，仅击败了5%</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之买股票的最佳时机Ⅱ</title>
      <link href="/passages/leetcode-zhi-mai-gu-piao-de-zui-jia-shi-ji-ii/"/>
      <url>/passages/leetcode-zhi-mai-gu-piao-de-zui-jia-shi-ji-ii/</url>
      
        <content type="html"><![CDATA[<p>Best Time to Buy and Sell Stock Ⅱ</p><a id="more"></a><h3 id="Best-Time-to-Buy-and-Sell-Stock-Ⅱ"><a href="#Best-Time-to-Buy-and-Sell-Stock-Ⅱ" class="headerlink" title="Best Time to Buy and Sell Stock Ⅱ"></a>Best Time to Buy and Sell Stock Ⅱ</h3><ul><li><p>code with Python</p></li><li><p>title number：122</p></li><li><p>简单</p></li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个数组，一只股票，第i个元素表示给定股票第i天的价格</li><li>可以尽可能多的进行交易，求能获得的最大利润</li><li>售出必须在买进<strong>之后</strong>进行，再次买进时需要<strong>先售出</strong>持有的股票</li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>贪心算法，分步操作，每步只选赚钱的</li><li>由题意知，因为在买股票前需要把手中的股票先卖出，所以有两种情况<ul><li>连续上涨交易日：有一段时间股票价格连续上涨，则这段时间的第一天买入，最后一天卖出利润最大</li><li>连续下降交易日：有一段时间股票价格连续下降，则不买卖股票最佳，不会亏钱</li></ul></li><li>这样比较不容易理解，可以把一段时间的股票持有等价为<code>在这段时间里每天都买卖</code>，</li><li>例：<code>p1,p2,p3,p4,p5</code>5天连续上涨，应该第一天买，最后一天卖，即<code>p5-p1</code>；按照上面的理解，也可以表示为<code>p5-p1 = (p2-p1)+(p3-p2)+(p4-p3)+(p5-p4)</code></li><li>算法：<ul><li>遍历整个价格列表，所有上涨交易都日买卖，所有下降交易日都不买卖</li><li>由于我们将所有交易都拆分为了连续两天的交易，<ul><li>所以，遍历整个列表，计算第<code>i-1</code>日买入且第<code>i</code>日卖出的利润，若利润大于0，则添加到总利润中，若利润小于等于0则不进行买卖</li></ul></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">    profit_sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(prices)):</span><br><span class="line">        profit = prices[i] - prices[i<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> profit &gt; <span class="number">0</span>:</span><br><span class="line">            profit_sum += profit</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> profit_sum</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：这种算法里的计算方式并不是实际操作，而是将连续时间的股票持有转化为了每天都进行买卖</p><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li><p>仍是我们熟悉的暴力破解，由于数组长度有限，必定可以穷举所有的交易组合，计算相应的利润，取最大值即可</p></li><li><p>但是时间复杂度太高，有$O(n^n)$</p></li></ul><h4 id="思路三"><a href="#思路三" class="headerlink" title="思路三"></a>思路三</h4><ul><li>动态规划，一般来说，可以用贪心算法解决的，都可以使用动态规划进行解决</li><li>定义状态，设置一个二维矩阵<code>dp[i][j]</code>：<ul><li>第一维i表示第i天，第二维j用来表示是否持有股票（0表示未持有，1表示持有）</li><li><code>value</code>为当前的收益</li></ul></li><li>状态转移方程<ul><li>0-&gt;1-&gt;0-&gt;1-&gt;0….</li></ul></li><li>初始状态<ul><li><code>dp[0][0]=0</code></li><li><code>dp[0][1]=-prices[0]</code></li></ul></li><li>输出<ul><li><code>dp[len-1][0]</code>为最终结果</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> len(prices) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    dp = [[<span class="number">0</span>]*<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(prices))]</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(prices)):</span><br><span class="line">        dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices)</span><br><span class="line">        dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>]-prices)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> dp[len(prices)<span class="number">-1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>耗时感人，仅击败5%~~</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之二叉树的最大深度</title>
      <link href="/passages/leetcode-zhi-er-cha-shu-de-zui-da-shen-du/"/>
      <url>/passages/leetcode-zhi-er-cha-shu-de-zui-da-shen-du/</url>
      
        <content type="html"><![CDATA[<p>Maximum Depth of Binary Tree</p><a id="more"></a><h3 id="Maximum-Depth-of-Binary-Tree"><a href="#Maximum-Depth-of-Binary-Tree" class="headerlink" title="Maximum Depth of Binary Tree"></a>Maximum Depth of Binary Tree</h3><ul><li><p>code with Python</p></li><li><p>title number：104</p></li><li><p>简单</p></li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><p>给定一个二叉树，求其最大深度</p><p>最大深度指的是从根节点到最深的叶节点的路径上的结点个数</p><p>看一下给定的示例：</p><p><code>[3, 9, 20, null, null, 15, 7]</code></p><blockquote><p>​       3<br>​     /    <br>9       20<br>​          /     <br>​       15       7</p><p>可以观察到，二叉树是通过层次遍历的顺序来表示的</p><p>不过这都不重要，我们在程序中获得的是一棵树</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>关键词：二叉树、深度优先搜索</p><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>深度优先遍历（DFS），使用递归的方式对二叉树的高度进行求解<ul><li>如果根节点为空，则树空，高度为0</li><li>如果不为空则递归求解其左右子树的高度，并且取其中较大的，再加一</li><li>直到到达叶子节点位置</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        left_height = self.maxDepth(root.left)</span><br><span class="line">        right_height = self.maxDepth(root.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(left_height, right_height) + <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li>还是深度优先遍历（DFS），不过这次我们使用非递归的方式实现。需要借助栈来进行<ul><li>设置变量<code>depth</code>用于记录树的深度</li><li>先将根节点入栈</li><li>当栈不为空时，迭代<ul><li>出栈栈顶元素，更新最大深度（当前结点的深度和最大深度的较大值）</li><li>根节点不为空则将根节点的左右结点入栈</li></ul></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">    stack = []</span><br><span class="line">    depth = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        stack.append((<span class="number">1</span>, root))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> stack <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        cur_depth, root = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            depth = max(cur_depth, depth)</span><br><span class="line">            stack.append((cur_depth+<span class="number">1</span>, root.left))</span><br><span class="line">            stack.append((cur_depth+<span class="number">1</span>, root.right))</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> depth</span><br></pre></td></tr></table></figure><h4 id="思路三"><a href="#思路三" class="headerlink" title="思路三"></a>思路三</h4><ul><li>既然是求最大深度，我们只需要按层遍历，并且记录树的层数，即可得到树的最大深度</li><li>层序遍历 or 广度优先遍历<ul><li>在队列中使用<code>None</code>来划分每一层，当出队时遇到<code>None</code>则深度+1</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">    queue = []</span><br><span class="line">    depth = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    queue.append(root)</span><br><span class="line">    queue.append(<span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        node = queue.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> node:</span><br><span class="line">            <span class="keyword">if</span> node.left: queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right: queue.append(node.right)</span><br><span class="line">        <span class="keyword">elif</span> queue:</span><br><span class="line">            queue.append(<span class="literal">None</span>)</span><br><span class="line">            depth+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> depth</span><br></pre></td></tr></table></figure><p><code>List.pop(num)</code>可以弹出指定位置的元素</p><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之买股票的最佳时机</title>
      <link href="/passages/leetcode-zhi-mai-gu-piao-de-zui-jia-shi-ji/"/>
      <url>/passages/leetcode-zhi-mai-gu-piao-de-zui-jia-shi-ji/</url>
      
        <content type="html"><![CDATA[<p>Best Time to Buy and Sell Stock</p><a id="more"></a><h3 id="Best-Time-to-Buy-and-Sell-Stock"><a href="#Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="Best Time to Buy and Sell Stock"></a>Best Time to Buy and Sell Stock</h3><ul><li>code with Python</li><li>title number：121</li><li>简单</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><ul><li>给定一个数组，一只股票</li><li>数组的第i位表示该股票第i天的价格</li><li>你只能进行一次买卖，计算最大利润（卖出时间不能早于买入时间）</li><li>相关标签：数组，动态规划</li></ul><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>该问题抽象一下，就是求数组中两个数的最大差值（<code>max(price[j]-price[i])，i&lt;=j</code>）</li><li>首先想到的当然是暴力法啦<ul><li>两层循环，外层循环遍历表示买入价格，内层循环遍历表示卖出价格</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> len(prices) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(prices)<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(prices)):</span><br><span class="line">            res = max(res, prices[j]-prices[i])</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>很遗憾，超时</p><h4 id="思路一改进"><a href="#思路一改进" class="headerlink" title="思路一改进"></a>思路一改进</h4><ul><li><p>针对给定的示例<code>[7,1,5,3,6,4]</code>进行观察，我们发现有很多次的计算是无用的，为了更直观</p><p><img src="/.top//Leetcode%E4%B9%8B%E4%B9%B0%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%5C1.png" alt></p></li><li><p>即我们只需要关注之前观察到的最低股价即可，用一个变量记录便利过程中的最低股价，就可以省去内层的循环</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> len(prices) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    min_p = prices[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(prices)):</span><br><span class="line">        res = max(res, prices[i]-min_p)</span><br><span class="line">        min_p = min(min_p, prices[i])</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li><p>类似于之前那道<code>Maximum Subarray</code>，这也是一道动态规划的题目</p></li><li><p>整体思想是:</p><blockquote><p>正向，求得截至当前能买入的最低价</p><p>反向，求得当前买入的能卖出的最高价，</p><p>然后两者做差即可</p><p>以示例做演示：<code>[7,1,5,3,6,4]</code>，则</p><p>正向：<code>[7,1,1,1,1,1]</code>，逆向：<code>[7,6,6,6,6,4]</code></p><p>做差并取最大值：5</p></blockquote></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line"><span class="keyword">if</span> len(prices) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    max_profit = <span class="number">0</span></span><br><span class="line">    in_price = prices[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(prices)):</span><br><span class="line">        <span class="keyword">if</span> prices[i] &lt; in_price:</span><br><span class="line">            in_price = prices[i]</span><br><span class="line">        <span class="keyword">elif</span> prices[i] - in_price &gt; max_profit:</span><br><span class="line">            max_profit = prices[i] - in_price</span><br><span class="line">    <span class="keyword">return</span> max_profit</span><br></pre></td></tr></table></figure><h4 id="还是思路二"><a href="#还是思路二" class="headerlink" title="还是思路二"></a>还是思路二</h4><ul><li>按照动态规划来一遍<ul><li>定义状态：<code>max_profit</code>是前i天的最大收益</li><li>状态转移方程：（分情况讨论）<ul><li>在第i天售出能不获得最大收益</li><li>在第i天售出能获得最大收益，并且是在第i天之前买入的</li><li>即<code>前i天的最大收益 = max(前i-1天的最大收益，第i天的价格-前i-1天的最小价格)</code></li></ul></li><li>初始条件：<code>min_price=prices[0], max_profit=0</code></li><li><code>list</code>长度为0和1时单独处理</li></ul></li><li>顺手优化了一下代码</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> len(prices) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    min_price = prices[<span class="number">0</span>]</span><br><span class="line">    max_profit = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> price <span class="keyword">in</span> prices[<span class="number">1</span>:]:</span><br><span class="line">        min_price = min(price, min_price)</span><br><span class="line">        max_profit = max(max_profit, price-min_price)</span><br><span class="line">    <span class="keyword">return</span> max_profit</span><br></pre></td></tr></table></figure><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之合并两个有序数组</title>
      <link href="/passages/leetcode-zhi-he-bing-liang-ge-you-xu-shu-zu/"/>
      <url>/passages/leetcode-zhi-he-bing-liang-ge-you-xu-shu-zu/</url>
      
        <content type="html"><![CDATA[<p>Merge Sorted Array</p><a id="more"></a><h3 id="Merge-Sorted-Array"><a href="#Merge-Sorted-Array" class="headerlink" title="Merge Sorted Array"></a>Merge Sorted Array</h3><ul><li>code with Python</li><li>title number：88</li><li>简单</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><p>给定两个有序的数组<code>nums1</code>和<code>nums2</code>，将<code>nums2</code>合并到<code>nums1</code>中形成有序数组</p><p><code>nums1</code>中有足够的位置用来存放<code>nums2</code>的元素，不能额外申请存储空间</p><p>关键词：数组，双指针</p><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ul><li>最直接的想法就是借鉴传统的<code>Merge sort</code>算法：<ul><li>使用两个指针分别指向两个有序数组的头部，从前往后比较指针指向的元素的大小，将较小的元素放入申请的空间中，并且对应的指针后移</li></ul></li><li>不过这样需要额外申请大小为<code>m+n</code>的空间，由于题目中说明了<code>nums1</code>的空间足够存储两个数组的所有元素，所以可以使用<code>num1</code>的空间来存储合并后的数组，申请大小为<code>m</code>的数组用来存储<code>nums1</code>即可</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1: List[int], m: int, nums2: List[int], n: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        p, q, f = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        nums1_temp = nums1[:m]</span><br><span class="line">        <span class="keyword">while</span> p &lt; m <span class="keyword">and</span> q &lt; n:</span><br><span class="line">            <span class="keyword">if</span> nums1_temp[p] &lt; nums2[q]:</span><br><span class="line">                nums1[f] = nums1_temp[p]</span><br><span class="line">                p += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[f] = nums2[q]</span><br><span class="line">                q += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            f += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> p &lt; m:</span><br><span class="line">            nums1[p+q:] = nums1_temp[p:]</span><br><span class="line">        <span class="keyword">if</span> q &lt; n:</span><br><span class="line">            nums1[p+q:] = nums2[q:]</span><br></pre></td></tr></table></figure><p>奇怪，用时比下面的两种还少，内存消耗也没有明显增加……</p><h4 id="思路一改进"><a href="#思路一改进" class="headerlink" title="思路一改进"></a>思路一改进</h4><ul><li>如果按照传统的合并算法，至少需要申请大小为<code>m</code>的空间。</li><li>我们还知道，<code>num1</code>中本身就有足够的空间来容纳<code>nums2</code>中的元素，而这些位置几种在数组的尾部</li><li>所以，由此我们想到，使用双指针从后往前遍历并比较，这样就可以利用<code>num1</code>后面的空闲位置了<ul><li>需要三个指针，其中两个指针分别指向<code>nums1</code>和<code>nums2</code>中的最后一个元素，另外再有一个指针指向<code>nums1</code>中新添加元素的位置</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1: List[int], m: int, nums2: List[int], n: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        p, q = m<span class="number">-1</span>, n<span class="number">-1</span></span><br><span class="line">        t = m+n<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> p&gt;=<span class="number">0</span> <span class="keyword">and</span> q&gt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums1[p] &lt; nums2[q]:</span><br><span class="line">                nums1[t] = nums2[q]</span><br><span class="line">                q -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[t] = nums1[p]</span><br><span class="line">                p -= <span class="number">1</span></span><br><span class="line">            t -= <span class="number">1</span></span><br><span class="line">        nums1[:q+<span class="number">1</span>] = nums2[:q+<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>其实指针<code>p、q、t</code>完全可以省略，直接使用<code>m,n,m+n-1</code>代替，简化版如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1: List[int], m: int, nums2: List[int], n: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">while</span> m&gt;<span class="number">0</span> <span class="keyword">and</span> n&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums1[m<span class="number">-1</span>] &lt; nums2[n<span class="number">-1</span>]:</span><br><span class="line">                nums1[m+n<span class="number">-1</span>] = nums2[n<span class="number">-1</span>]</span><br><span class="line">                n -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[m+n<span class="number">-1</span>] = nums1[m<span class="number">-1</span>]</span><br><span class="line">                m -= <span class="number">1</span>     </span><br><span class="line">        nums1[:n] = nums2[:n]</span><br></pre></td></tr></table></figure><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ul><li>其实还有一个更简洁的想法<ul><li>直接将<code>nums2</code>添加到<code>nums1</code>的尾部，在对<code>nums1</code>进行排序即可</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1: List[int], m: int, nums2: List[int], n: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums2)):</span><br><span class="line">        nums1[m+i] = nums2[i]</span><br><span class="line">        </span><br><span class="line">    nums1.sort()</span><br></pre></td></tr></table></figure><p>但事后想来，这与题目的考查点不符（相关标签中提到了双指针），就当作是一种比较有意思的想法吧，以前掌握两种想法为主</p><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之最大子序和</title>
      <link href="/passages/leetcode-zhi-zui-da-zi-xu-he/"/>
      <url>/passages/leetcode-zhi-zui-da-zi-xu-he/</url>
      
        <content type="html"><![CDATA[<p>Maximum Subarray</p><a id="more"></a><h3 id="Maximum-Subarray"><a href="#Maximum-Subarray" class="headerlink" title="Maximum Subarray"></a>Maximum Subarray</h3><ul><li>code with Python</li><li>title number：53</li><li>简单</li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><p>给定一个整数数组，找到一个连续的子串，这个子串的和最大，返回子串的和</p><p>例：<code>-2,1,-3,4,-1,2,1,-5,4</code>中能取得最大和的子串为<code>4,-1,2,1</code>，则返回6</p><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><blockquote><p>要求返回的是连续最大子序列和，最先想到的就是暴力求解</p><p>使用两层循环，外层循环控制子串头部的位置，内层循环控制子串尾部的位置</p><p>利用双层循环，穷举求和所有子串的和，返回最大值</p><p>该方法<strong>超时</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        max = nums[<span class="number">0</span>] </span><br><span class="line">        sub_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i, len(nums)):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(i,j+<span class="number">1</span>):</span><br><span class="line">                    sub_sum += nums[k]</span><br><span class="line">                <span class="keyword">if</span> sub_sum &gt; max:</span><br><span class="line">                    max = sub_sum</span><br><span class="line">                sub_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> max</span><br></pre></td></tr></table></figure><h4 id="思路一优化"><a href="#思路一优化" class="headerlink" title="思路一优化"></a>思路一优化</h4><blockquote><p>简单分析一下，时间复杂度高的原因主要是</p><p>​    对数组进行了多次的遍历</p><p>​    进行了多次的重复计算</p><p>重复计算的问题，例如：计算<code>[0, 3]</code>的和时就又计算了<code>[0, 0], [0, 1], [0, 2]</code>的和</p><p>所以可以在<code>[0, 2]</code>的基础上计算<code>[0, 3]</code>的和</p><p>优化方案为：</p><p>​    穷举子序列左端点，遍历其右端点，用<code>sum</code>记录当前和，用<code>max</code>记录最大子序列值</p><p>​    可以减少一层循环</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    max_num = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, len(nums)):</span><br><span class="line">            sum += nums[j]</span><br><span class="line">            max_num = max(max_num, sum)</span><br><span class="line">    <span class="keyword">return</span> max_num</span><br></pre></td></tr></table></figure><h4 id="思路一再优化"><a href="#思路一再优化" class="headerlink" title="思路一再优化"></a>思路一再优化</h4><blockquote><p>可以使用空间换时间的思想，使用数组<code>pre_nums</code>存储截止到<code>i</code>的子序列和</p><p>计算<code>[1, 3]</code>的子序列和可以通过<code>pre_nums[3]-pre_nums[1]</code>来得出</p><p>这样可以更大程度上减少运算</p><p>事实上，我们可以使用原数组表示存储<code>pre_nums</code>，这样连空间都省了</p></blockquote><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><p>尝试使用<strong>动态规划</strong>的思想，重点在于寻找状态转移方程</p><ul><li>定义状态：<code>dp[i]</code>：表示以<code>nums[i]</code>结尾的连续最大子序列和</li><li>状态转移方程：（分情况讨论）<ul><li>如果<code>dp[i-1]&gt;=0</code>，那么<code>dp[i]=dp[i-1]+nums[i]</code></li><li>如果<code>dp[i-1]&lt;0</code>，那么<code>dp[i]=nums[i]</code></li><li>综合一下两种情况我们可以得到：<code>dp[i]=max(nums[i], dp[i-1]+nums[i])</code></li></ul></li><li>初始值：<code>dp[0]=nums[0]</code></li><li>输出：值得注意的是，要遍历所有的<code>dp[i]</code>，取其中最大的返回</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>] </span><br><span class="line">    <span class="comment"># dp = [0 for i in range(len(nums))]</span></span><br><span class="line">    dp = nums[:]<span class="comment"># 减少了申请数组时的耗时</span></span><br><span class="line">    <span class="comment"># dp[0] = nums[0]</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">        dp[i] = max(dp[i<span class="number">-1</span>]+nums[i], nums[i])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> max(dp)</span><br></pre></td></tr></table></figure><p>换了种写法，时间减少了近一半，懵逼中……</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        size = len(nums)</span><br><span class="line">        result = sum = nums[<span class="number">0</span>]  </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, size):</span><br><span class="line">            <span class="keyword">if</span> sum &lt; <span class="number">0</span>:</span><br><span class="line">                sum = <span class="number">0</span></span><br><span class="line">            sum += nums[i]</span><br><span class="line">            <span class="keyword">if</span> sum &gt; result:</span><br><span class="line">                result = sum</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><blockquote><p>动态规划问题经常需要分类讨论，因为动态规划问题本身就是通过小问题的最优解来得到大问题的最优解。<br>因此，需要分类讨论大问题的小问题有哪些</p></blockquote><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之删除排序数组中的重复项</title>
      <link href="/passages/leetcode-zhi-shan-chu-pai-xu-shu-zu-zhong-de-chong-fu-xiang/"/>
      <url>/passages/leetcode-zhi-shan-chu-pai-xu-shu-zu-zhong-de-chong-fu-xiang/</url>
      
        <content type="html"><![CDATA[<p>Remove Duplication from Sorted Array</p><a id="more"></a><h3 id="Remove-Duplication-from-Sorted-Array"><a href="#Remove-Duplication-from-Sorted-Array" class="headerlink" title="Remove Duplication from Sorted Array"></a>Remove Duplication from Sorted Array</h3><ul><li><p>code with Python</p></li><li><p>title number：26</p></li><li><p>简单</p></li></ul><h4 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h4><p>给排序后的数组，删除重复元素，返回修改后数组的长度</p><p>关键点：原地操作，不能占用额外的内存空间</p><p>标签：双指针和数组</p><h4 id="思路一："><a href="#思路一：" class="headerlink" title="思路一："></a>思路一：</h4><p>既然是排序后的数组，说明相同的元素都连续存在</p><p>返回新的数组长度，将不重复的元素聚集在数组的前部，</p><p>如此便可以不用删除元素，而是将不重复的元素聚集的数组前部，并且不用考虑返回值范围之外的元素是什么。计数不重复元素的个数，返回不重复元素的个数。</p><blockquote><p>设置两个指针，前者用于指向不重复的元素，后者用于遍历数组</p><p>初始状态，指针P指向第一个元素，指针Q指向第二个元素，</p><p>判断两个指针所指向的元素是否相同，</p><p>若相同，则Q向后遍历</p><p>若不同，则P先向后移动，再将Q指向位置的元素赋值给P指向位置的元素</p><p>最后返回P指向位置的下标（需要+1，数组下标从0开始）</p><p>另外，数组长度小于2时直接返回数组长度即可</p><p>例：</p><p><code>1,1,2,2,3,4,4</code>  -&gt; <code>1,2,3,4,3,4,4</code>，返回长度为4</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        p = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> q <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[p] != nums[q]:</span><br><span class="line">                p += <span class="number">1</span></span><br><span class="line">                nums[p] = nums[q]</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> p+<span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="思路二："><a href="#思路二：" class="headerlink" title="思路二："></a>思路二：</h4><blockquote><p>我们尝试正常的删除元素</p><p>但是使用从前向后遍历删除元素，会导致数组访问越界（遍历数组的时候，遍历的次数并不会减少，数组元素减少了，回到之后面的访问越界）</p><p>所以可以从后往前遍历，先访问下标大的元素，</p><p>初始状态，P指向最后一个元素，Q指向倒数第二个元素</p><p>若P指向位置的元素等于Q指向位置的元素，删除Q指向位置的元素，P、Q均向前移动1</p><p>若P指向位置的元素不等于Q指向位置的元素，P、Q均向前移动1</p><p>最后返回数组长度</p><p>另外，</p><p>数组长度小于2时直接返回数组长度</p><p>与第一种思路不同，相比的两个元素是相邻的，可以只用一个指针，要控制边界</p><p>例：</p><p><code>1,1,2,3,3,4</code>-&gt;<code>1,1,2,3,3,4</code>-&gt;<code>1,1,2,3,4</code>-&gt;<code>1,1,2,3,4</code>-&gt;<code>1,2,3,4</code>，返回数组长度4</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># range(end, start, -1)即可输出倒序的数组，注意是前闭后开</span></span><br><span class="line"><span class="comment"># del函数删除数组元素</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)&lt;<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> len(nums)</span><br><span class="line">        <span class="keyword">for</span> q <span class="keyword">in</span> range(len(nums), <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> q<span class="number">-1</span> != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[q<span class="number">-1</span>]==nums[q<span class="number">-2</span>]:</span><br><span class="line">                    <span class="keyword">del</span> nums[q<span class="number">-1</span>]</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> len(nums)</span><br></pre></td></tr></table></figure><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>霍乱时期的爱情</title>
      <link href="/passages/huo-luan-shi-qi-de-ai-qing/"/>
      <url>/passages/huo-luan-shi-qi-de-ai-qing/</url>
      
        <content type="html"><![CDATA[<p>霍乱时期的爱情</p><a id="more"></a><p>《霍乱时期的爱情》加西亚-马尔克斯</p><p>&emsp;&emsp;精神忠贞和肉体忠贞真的可以分而视之吗？</p><p>&emsp;&emsp;这本被视作“爱情的百科全书”的巨作，在我看来讲述的确实一个庸俗甚至荒诞的故事。</p><p>&emsp;&emsp;出身单身贫苦家庭的文艺青年阿里萨，爱上了一个未成年少女弗尔明娜，他们在一封封情书中热恋。但弗尔明娜的父亲却一心让她嫁给一个上层社会的人。在他们经历离别之后的再次见面，弗尔明娜发现自己心中完美的他不过是自己幻想出来的，于是毅然挥手离开。</p><p>&emsp;&emsp;之后的半生中阿里萨逆袭成为航运公司董事长，在成功熬死弗尔明娜的丈夫后，他竟再次表白：“我为你保持了童真”。尽管他在51年中与无数女人睡过。</p><p>&emsp;&emsp;在51年冠冕堂皇的忠诚背后可能只是被抛弃后的不甘；在现实的洪流中弗尔明娜当年的背信弃义又显得稀疏平常。即使最后男女主如愿在一起了，但是这样的结局并无浪漫可言，设置透漏这些许荒诞和嘲讽。毕竟弗尔明娜“很难分清自己是出于同情还是爱情”。</p><p>&emsp;&emsp;按照惯例，下面是一些原文摘录，好好体会吧。</p><blockquote><p>一个人能为爱情坚守多久，答案是——五十一年九个月零四天。</p></blockquote><blockquote><p>这份迟来的顿悟是他下了一跳，原来是生命，而非死亡，才是永无止境的。</p></blockquote><blockquote><p>你要永远记住，对于一对恩爱夫妻，最重要的不是幸福，而是稳定</p></blockquote><blockquote><p>这些地方走在众人之前，它们已经有了自己的花冠女神。</p></blockquote><blockquote><p>好吧，我同意结婚，只要你不逼我吃茄子。</p></blockquote><blockquote><p>他明白他并不爱弗尔明娜，他只是喜欢它的骄傲，但这并不影响他们建立起一桩稳定的婚姻。</p></blockquote><blockquote><p>我去旅行，是因为我决定要去，而不是我对路上的风景多感兴趣。</p></blockquote><blockquote><p>诚实的生活方式其实是按照身体的意愿行事，饿的时候吃饭，爱的时候不必撒谎。</p></blockquote><blockquote><p>当一个女人说“不”的时候，实在等别人再坚持，然后才做最后的决定</p></blockquote><blockquote><p>智慧往往在已无用武之地之时才来到我身边。</p></blockquote><blockquote><p>比其婚姻中的巨大灾难，日常的琐碎烦恼更加难以躲避。</p></blockquote><blockquote><p>无法说明的病，是爱情，不是相思。</p></blockquote><blockquote><p>影响到你生命的男女之情，才算是爱情。</p></blockquote><blockquote><p>她因年龄而减损的，又因性格而弥补回来，因而勤劳赢得了更多。</p></blockquote><blockquote><p>“世上的人分两种，会勾搭的和不会勾搭的。” 他不信任后面这种人：他们一旦越轨，便觉得这件事太不可思议，于是四处炫耀爱情，就好像那是他们刚刚发明出来的似的。而经常做这种事的人恰恰相反，他们活着就是为了这个。他们感觉良好，也守口如瓶，因为知道谨言慎行是性命攸关的大事。他们从不谈论自己的丰功伟绩，也不向任何人吐露秘密，反而装出一副对这种事漠不关心的样子，以致常常招来性无能、性冷淡，甚至不男不女的名声，就像弗洛伦蒂诺·阿里萨这样。</p></blockquote><blockquote><p>作为一个仍处在孤独中的灵魂，他坚信自己比世界上任何一个人都默默爱得更深。</p></blockquote><blockquote><p>女人只会对意志坚强的男人俯首称臣，因为只有这样的男人才能带给她们安全感，他们渴望那种安全感，以面对生活的挑战。</p></blockquote><blockquote><p>可无论他，还是她，都无法说清这种相互依赖究竟是建立在爱情的基础上，还是习惯使然。他们从不曾为此问过自己，因为两人都宁愿不知道答案。</p></blockquote><blockquote><p>但她并没有把这些当做他最终衰老的确凿标志，而是视之为一次幸福的返老还童。她把他当做一个老小孩，而非一个难以此后的老人。这种自欺欺人对两人来说或许都是一种上天的恩赐，因为这让他们避免了互相同情。</p></blockquote><blockquote><p>当被人爱着的人死去时，真该带上他所有的东西。</p></blockquote><blockquote><p>他还太年轻，尚不知道回忆总是会抹去坏的，夸大好的，而也正是由于这种玄妙，我们才得以承担过去的负担。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书&amp;电影 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>被讨厌的勇气</title>
      <link href="/passages/bei-tao-yan-de-yong-qi/"/>
      <url>/passages/bei-tao-yan-de-yong-qi/</url>
      
        <content type="html"><![CDATA[<p>世界很单纯，人生也人生也一样。 不是世界复杂， 而是你把世界变复杂了。没有一个人是住在客观的世界里， 我们都居住在一个各自赋予其意义的主观的世界。</p><a id="more"></a><p>《被讨厌的勇气》岸见一郞/古贺史健</p><p>&emsp;&emsp;世界很单纯，人生也人生也一样。 不是世界复杂， 而是你把世界变复杂了。没有一个人是住在客观的世界里， 我们都居住在一个各自赋予其意义的主观的世界。</p><p>&emsp;&emsp;本书介绍了另一位心理学大师阿德勒的“目的论”理论，读一下下面的摘选吧，相信会有一番全新的认识。</p><p>&emsp;&emsp;私以为，这种“目的论”更能使人直视内心，不会像“原因论”最终会因把握不当而成为逃避的借口。</p><p>按照惯例，下面是一些句子的摘抄</p><blockquote><p>目的论：过去的事情本身并没有什么特殊的意义，是我们为了某个目的而赋予它了意义，我们希望通过赋予某件事情意义来帮助我们顺理成章地去做某事。</p></blockquote><blockquote><p>无论过去发生了什么事情，现在的状态取决于你赋予既有事件的意义。</p></blockquote><blockquote><p>人唯有在感觉自己有价值时才会有勇气。</p></blockquote><blockquote><p>当你着急奔向未来时，说明你已经不喜欢现在了。</p></blockquote><blockquote><p>人并不是住在客观的世界，而是住在自己营造的主观世界里。你所看到的世界不同于我所看到的世界，而且恐怕是不可能与任何人共有的世界。</p></blockquote><blockquote><p>小心检视，你的成功是否知识以害怕别人讨厌而换来的。若是如此，那你的成功不幸只是代表“你为了他人活了一辈子”。</p></blockquote><blockquote><p>至少我不想变成别人，也能悦纳现在的自己。</p></blockquote><blockquote><p>你的“不幸”并不是生来就有，而是由你亲手选择。</p></blockquote><blockquote><p>你在人生的某个阶段选择了不幸。这既不是因为你生在了不幸的环境中，也不是你陷入了不幸的境地中，而是因为你认为不幸对你自身而言是一种“善”。</p></blockquote><blockquote><p>如果一直保持“现在的我”，那么如何应对眼前的事情以及其结果会怎样等问题都可以根据经验进行推测，可谓是轻车熟路般的状态，即使是遇到点状况也能够想办法对付过去。</p><p>另一方面，如果选择新的生活方式，那就既不知道新的自己会遇到什么问题，也不知道应该如何应对眼前的事情。未来难以预测，生活就会充满不安，也可能有更加痛苦更加不幸的生活在等着自己。也就是说，即使人们有各种不满，但还是认为保持现状更加轻松、更能安心。</p></blockquote><blockquote><p>如果要改变对世界或自己的看法就必须改变与世界的沟通方式，甚至改变自己的行为方式。请不要忘记“必须改变”的究竟是什么。你依然是“你” ，只要重新选择生活方式就可以了。</p></blockquote><blockquote><p>首先，人是作为一种无力的存在生活在这个世界上。并且，人希望摆脱这种无力状态，继而有了普遍欲求。</p><p>与此相对应的就是自卑感。人都处于优越性这一“希望进步的状态”之中，树立某些理想或目标并努力为之奋斗。同时，对于无法达成理想的自己就会产生一种自卑感。</p></blockquote><blockquote><p>自卑感本身并不是坏事。</p><p>自卑情节是指把自己的自卑当作某种借口使用的状态。</p></blockquote><blockquote><p>如果真的拥有自信，就不会自大。正因为有强烈的自卑感才会骄傲自大，那其实是想要故意炫耀自己很优秀。担心如果不那么做的话，就会得不到周围的认可。</p></blockquote><blockquote><p>健全的自卑感不是来自与别人的比较，而是来自与“理想的自己”的比较。</p></blockquote><blockquote><p>当一个人想要做自己的时候，竞争势必会成为障碍。</p></blockquote><blockquote><p>即便不是败者，即便一直立于不败之地，处于竞争之中的人也会一刻不得安心，不想成为败者。而为了不成为败者就必须一直获胜、不能相信他人。</p></blockquote><blockquote><p>“无法真心祝福过的幸福的人”，就是因为站在竞争的角度来考虑人际关系，把他人的幸福看作“我的失败”，所以才无法给予祝福。</p></blockquote><blockquote><p>发怒时交流的一种形态，而且不使用发怒这种方式也可以交流。</p></blockquote><blockquote><p>人在人际关系中一旦确信“我是正确的”，那就已经步入了权力之争。</p></blockquote><blockquote><p>束缚，是想要支配对方的表现，也是一种基于不信任感的想法。与一个不信任自己的人处在同一个空间里，那就根本不可能保持一种自然状态。</p></blockquote><blockquote><p>人不可能一个人或者，必须在社会性的环境中，才能称之为“个人”。</p></blockquote><blockquote><p>把别人视作”敌人“，还是“伙伴”，这至关重要，并且影响你的“生活方式”。</p></blockquote><blockquote><p>自由，就是不在寻求别人的认可，</p><p>但是，这并不意味着可以旁若无人的肆意横行。</p></blockquote><blockquote><p>自由，就是允许自己被别人讨厌。</p></blockquote><blockquote><p>“不幸之源”在人际关系，反过来说，“幸福之源”也在人际关系。</p></blockquote><blockquote><p>拘泥于“认可欲求”的人，实际上也是以自我为中心的人。</p></blockquote><blockquote><p>在共同体中收到挫折之后，会不可避免的想要逃避到其他共同体中。</p><p>通常来说，人们更倾向于逃避到更小的共同体中，那里更容易找到归属感。</p><p>但应该知道的是，外面有更广阔的世界，想到这点，你就会明白，眼前的挫折不过是“杯中风暴”。</p></blockquote><blockquote><p>当我们在人际关系中遇到困难或者看不到出口的时候，首先应该考虑的是倾听”更大共同体的声音“这一原则。</p></blockquote><blockquote><p>自卑感是”纵向关系“的一种体现。</p></blockquote><blockquote><p>上帝，请赐予我平静，去接收我无法改变的；给予我勇气，去改变我能改变的；赐我智慧，分辨这两者的区别。</p></blockquote><blockquote><p>信赖的时候请尽管信赖，悲伤的时候请尽管悲伤。</p></blockquote><blockquote><p>为遥远的将来设定一个目标，并认为现在是其准备阶段。一直想着”真正想做的是这样的事情，等时机成熟了就去做“，这是一种拖延人生的生活方式。只要在拖延人生，我们就会无所进展，只能每天过着枯燥乏味的单调生活。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书&amp;电影 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>具有约束和后期编辑的自底向上的篇章分析器</title>
      <link href="/passages/ju-you-yue-shu-he-hou-qi-bian-ji-de-zi-di-xiang-shang-de-pian-zhang-fen-xi-qi/"/>
      <url>/passages/ju-you-yue-shu-he-hou-qi-bian-ji-de-zi-di-xiang-shang-de-pian-zhang-fen-xi-qi/</url>
      
        <content type="html"><![CDATA[<p>《A Linear-Time Bottom-Up Discourse Parser with Constraints and Post-Editing》论文笔记</p><a id="more"></a><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><ul><li>本文已被<code>ACL 2014</code>收录</li><li>作者是<code>Wei Feng</code>和<code>Graeme Hirst</code></li><li>该模型目前还是<code>document level</code>上效果最好的模型，虽然近期发表了许多关于<code>encoder-decoder</code>架构的文章，但是只能在句子级别证明模型的可行性，模型虽然十分新颖，但并不具有很强的说服力</li></ul><h3 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h3><ul><li>文本即的篇章分析仍然是一个挑战</li><li><code>Joty et al 2013</code>提出的模型虽然效果比较不错了，但是由于<strong>模型的计算复杂度太高</strong>，并不具有很好的实践性</li></ul><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><ul><li>先对<code>sentence level</code>建模，再对<code>document level</code>建模，这种分层次的建模过程从性能方面来说是可行的</li><li>利用初步建成的树本身的特征对树的结构进行调整，可以使树形更加合理</li><li>主要需要解决的问题是时间复杂度的问题</li></ul><h3 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h3><p><img src="%E5%85%B7%E6%9C%89%E7%BA%A6%E6%9D%9F%E5%92%8C%E5%90%8E%E6%9C%9F%E7%BC%96%E8%BE%91%E7%9A%84%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E7%AF%87%E7%AB%A0%E5%88%86%E6%9E%90%E5%99%A8%5Cdp.png" alt="dp"></p><blockquote><p>模型的整体结构如上图所示</p><ul><li>先将<code>document</code>划分为多个<code>sentence</code>，<code>sentence</code>再被划分为多个<code>EDU</code></li><li>单句子级别的处理<ul><li>先使用句内建树模型$M_{instra}$，形成句子级别的<code>Discourse Tree</code></li><li>使用$P_{intra}$对其进行<code>Post Editing</code></li></ul></li><li>多句子级的处理<ul><li>先使用多句子建树模型$M_{multi}$组合已经建成的句子级别的树，生成文本级别的<code>Discourse Tree</code></li><li>使用$P_{multi}$对文本级别的<code>Discourse Tree</code>进行<code>Post Editing</code></li></ul></li></ul><p><strong>下面分别对每个局部模型的结构进行分析</strong></p></blockquote><ul><li><code>Intra-sentential</code>结构模型</li></ul><p><img src="%E5%85%B7%E6%9C%89%E7%BA%A6%E6%9D%9F%E5%92%8C%E5%90%8E%E6%9C%9F%E7%BC%96%E8%BE%91%E7%9A%84%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E7%AF%87%E7%AB%A0%E5%88%86%E6%9E%90%E5%99%A8%5Cdp1.png" alt="dp1"></p><blockquote><p>使用线性链CRF，CRF能更好的捕获上下文信息</p><ul><li><p>第一层是篇章结构$U_j$构成</p></li><li><p>第二层是二分类节点，表示两个一层节点之间结合的概率</p></li></ul><p>为了提高模型的性能，在其维特比解码时添加了一些<code>commonsense constraints</code>（常识性约束）</p><ul><li>不允许两个相邻之间的<code>1-1 transition</code>（即每个Unit只能与唯一的另外一个Unit相结合）</li><li>不允许全0序列（即至少有两个<code>Unit</code>会别<code>merge</code>）</li></ul></blockquote><ul><li><code>Multi-sentential</code>结构模型</li></ul><p><img src="%E5%85%B7%E6%9C%89%E7%BA%A6%E6%9D%9F%E5%92%8C%E5%90%8E%E6%9C%9F%E7%BC%96%E8%BE%91%E7%9A%84%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E7%AF%87%E7%AB%A0%E5%88%86%E6%9E%90%E5%99%A8%5Cdp2.png" alt="dp2"></p><blockquote><p>与单句的结构模型相似</p><p><strong>特别的</strong>，我们采用滑动窗口的方式来为特定成分形成局部CRF链</p><p>例如（如上图所示），</p><p>如果我们想计算$U_{j-1}$和$U_j$之间结合的概率，我们构建了三个局部链，每个链中包含两个上下文</p><p> 之后我们会寻找具有最高<code>joint probability</code>的线性链，之后计算其边缘概率</p><p>同样，我们对维特比解码阶段加入了<strong>常识性约束</strong>，这种约束只在<strong>结构模型</strong>的解码阶段添加</p></blockquote><ul><li><code>Intra-sentential</code>关系模型</li></ul><p><img src="%E5%85%B7%E6%9C%89%E7%BA%A6%E6%9D%9F%E5%92%8C%E5%90%8E%E6%9C%9F%E7%BC%96%E8%BE%91%E7%9A%84%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E7%AF%87%E7%AB%A0%E5%88%86%E6%9E%90%E5%99%A8%5Cdp3.png" alt="dp3"></p><blockquote><p>线性链CRF</p><ul><li>第一层是所有篇章结构$U_j$</li><li>第二层是多分类节点，是对第一层中成对篇章结构之间的关系概率的计算</li></ul><p>不同于<code>structure model</code>，<code>relation model</code>的第二层节点并不共享第一层的节点</p></blockquote><ul><li><code>Multi-sentential</code>关系模型</li></ul><p><img src="%E5%85%B7%E6%9C%89%E7%BA%A6%E6%9D%9F%E5%92%8C%E5%90%8E%E6%9C%9F%E7%BC%96%E8%BE%91%E7%9A%84%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E7%AF%87%E7%AB%A0%E5%88%86%E6%9E%90%E5%99%A8%5Cdp4.png" alt="dp4"></p><blockquote><p>结构与单句的关系模型相似</p><p>使用了滑动窗口</p></blockquote><h4 id="Post-Editing"><a href="#Post-Editing" class="headerlink" title="Post Editing"></a>Post Editing</h4><p><img src="%E5%85%B7%E6%9C%89%E7%BA%A6%E6%9D%9F%E5%92%8C%E5%90%8E%E6%9C%9F%E7%BC%96%E8%BE%91%E7%9A%84%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E7%AF%87%E7%AB%A0%E5%88%86%E6%9E%90%E5%99%A8%5Cdp5.png" alt="dp5"></p><ul><li>在<code>Discourse Tree</code>初步建立之后，使用树本身的信息对树的形状再进行调整</li><li>事实证明，节点在树中的高度信息是有用的，因为有些<code>relation</code>只会在比较高的层次中才会出现</li><li>后期编辑的实质的在添加了树结构的特征之后再进行一次树的构建</li></ul><blockquote><p>为了完成该操作，我们维护了一个列表<code>L</code></p><p>参照上图3——9，初始的时候L中会包含所有的Unit，之后会根据概率将其中的成对Unit合并</p><p>参照10——12，若前序步骤提出了修改，使用$P^{struct}$和$P^{rel}$重新构建<code>discourse tree</code></p></blockquote><ul><li>使用的是人工提取的特征，具体内容见论文</li></ul><h3 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h3><ul><li>总结<ul><li>提出了线性时间复杂度的model</li><li>使用的是自底向上的建树方式，两个线性链CRF级联作为局部分类器</li><li>在第一个CRF（结构模型）的<code>Viterbi</code>解码时添加了约束</li><li>通过后期编辑的方法利用初次构建的树中的信息对<code>Discourse Tree</code>进行的微调</li><li>对<code>relation</code>和<code>structure</code>分别建模</li></ul></li><li><strong>CKY-like Bottom-up Parsing</strong></li></ul><p><img src="%E5%85%B7%E6%9C%89%E7%BA%A6%E6%9D%9F%E5%92%8C%E5%90%8E%E6%9C%9F%E7%BC%96%E8%BE%91%E7%9A%84%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E7%AF%87%E7%AB%A0%E5%88%86%E6%9E%90%E5%99%A8%5Cdp1.png" alt=""></p><blockquote><p>给定一组篇章单元，用<code>linear-chain CRF</code>模型构建可能的内部节点$S_j$与孩子节点$U_{j-1},U_j$以及相邻的可能节点$S_{i+1}$之间的联系，构建一组状态序列</p><p>对这组状态序列进行标注，1代表该内部节点成立，0代表不成立，即用序列标注的方式决定对应孩子节点是否应该合并</p><p>例如，</p><p>$S_2$如果成立，则变为${S_2, U_3,…., U_t}$</p><p>$S_2$与$S_3$如果同时成立，则使用我们之前提到过的约束，选取其中的一个进行合并：可以是根据规则（具有更大合并概率）或者是根据随机</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 自然语言处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 论文笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分层指针网络分析</title>
      <link href="/passages/fen-ceng-zhi-zhen-wang-luo-fen-xi/"/>
      <url>/passages/fen-ceng-zhi-zhen-wang-luo-fen-xi/</url>
      
        <content type="html"><![CDATA[<p>《Hieraechical Pointer Net Parsing》论文笔记</p><a id="more"></a><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><ul><li>该论文被<code>EMNLP 2019</code>收录</li><li>作者是南洋理工大学的<code>Liu Linlin</code>等人</li><li>本文的分别在<code>句内依存关系分析</code>和<code>句子级的篇章分析</code>上进行了实验，鉴于本人对<code>Dependency parsing</code>并未进行过多了解，但为了文章的完整性，相关内容仅为论文提及的</li></ul><h3 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h3><ul><li>基于转移的自顶向下的利用<code>Pointer Networks</code>分析效果很好并且时间复杂度是线性的</li><li>但因为解码器的线性结构，在建立树形结构的时候并不能产生合理的<code>iductive bias</code></li><li>并且在文本长度变得更长之后，decoder的state会难以捕获前面的信息</li></ul><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><ul><li>对树结构中父节点和同层的兄弟节点之间的关系建模，以获得更合理的<code>decoder state</code></li><li>同时指针网络能够捕获更长距离的依赖</li></ul><h3 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h3><h4 id="Hierachical-Decoder"><a href="#Hierachical-Decoder" class="headerlink" title="Hierachical Decoder"></a>Hierachical Decoder</h4><p><img src="%E5%88%86%E5%B1%82%E6%8C%87%E9%92%88%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90%5Cfc3.png" alt="fc3"></p><ul><li><p>相比于标准的<code>Pointer Networks</code>，这里的<code>decoder state</code>会更加合理</p><blockquote><p>$d_t = f(d_{p(t)}, d_{s(t)}, d_{t-1}, h_{p(t)})$，对于每一个<code>decoder state</code>，$d_t$由其父节点的<code>decoder state</code>、直接兄弟的<code>decoder state</code>及前一个<code>decoder state</code>和其父节点的<code>encoder hidden state</code>计算得到</p><p>$s_{t,i} = \sigma(d_t, h_i)$，其中$\sigma$是attention计算函数，$d_t$是<code>decoder state</code>，$h_i$是<code>input hidden state</code></p><p>$\alpha_t = softmax(S_t)$，计算得到Attention分布</p></blockquote></li></ul><h3 id="Dependency-Parsing"><a href="#Dependency-Parsing" class="headerlink" title="Dependency Parsing"></a>Dependency Parsing</h3><p><img src="%E5%88%86%E5%B1%82%E6%8C%87%E9%92%88%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90%5Cfc2.png" alt="fc2"></p><ul><li><p>使用类似<code>Ma et al (2018)</code>工作中的encoder</p><ul><li>用CNN编码得到每个词的字符级表征</li><li>将其与<code>word embedding</code>、<code>POS embedding</code>拼接得到<code>input X</code></li><li>使用三层双向LSTM将<code>X</code>转化为<code>hidden state</code></li></ul></li><li><p>decoder是一个单层单向LSTM，同时维护了一个stack用于$d_t$的计算</p><ul><li>另外定义了门控机制来在分层指针网络基础上抽取更有效的信息（定义了两种形式的<code>gating function</code>）</li></ul><blockquote><p>(1) $g_t = sigmod(W_{gt}d_{t-1}+W_{gp}d_{p(t)}+W_{gs}d_{s(t)}+b_g)$</p><p>(2) $g_t = sigmod(W_{gp}(d_{t-1} \odot d_{p(t)})+W_{gs}(d_{t-1} \odot d_{s(t)}) + b_g)$</p></blockquote><ul><li>更具体的<code>decoder state</code>的计算方式</li></ul><blockquote><p>$h^{‘}<em>t = tanh(W_dd</em>{t-1}+W_pd_{p(t)}+W_sd_{s(t)})$</p><p>$h^{‘’}_t = g_t \odot h^{‘}_t$</p><p>$d_t = LSTM(h^{‘’}<em>t, h</em>{p(t)})$</p></blockquote></li><li><p>Pointer</p><blockquote><p>attention的计算方式</p><p>$s_{t,i} = g_1(d_t)^{T}Wg2(h_i)+Ug1(d_t)+Vg2(h_i)+b$</p></blockquote></li><li><p>同时，在每个步骤为解码器提供有关父节点和当前节点同级节点的高阶信息</p></li><li><p>依存关系分析部分在此之前并无接触，所以总结可能存在问题</p></li></ul><h4 id="Discourse-Parsing"><a href="#Discourse-Parsing" class="headerlink" title="Discourse Parsing"></a>Discourse Parsing</h4><p><img src="%E5%88%86%E5%B1%82%E6%8C%87%E9%92%88%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90%5Cfc4.png" alt="fc4"></p><ul><li>模型的架构使用的是<code>Lin et al (2019)</code></li><li>Encoder使用的5层的双向GRU，得到词的序列的<code>representation</code>，最后一个<code>hidden state</code>作为EDU的表征，最后得到输入句子的EDU表征的序列</li><li>分层解码器使用的是5层单向GRU，$d_t$的计算方式类似于<code>dependency parsing</code>中的计算方式</li><li>计算<code>attention score</code>，用于寻找切分的位置<code>k</code></li><li>查找到切分位置之后，对于新形成的两个span，使用分类器预测两者之间的<code>relation</code>和<code>nuclearity</code></li></ul><h3 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h3><ul><li>本文的主要工作的提出了分层的指针网络，具体来说是<code>decoder state</code>更合理的计算方式</li><li>在模型的结构上并没有进行创新，模型结构使用的是<code>Ma et al 2018</code>和<code>Lin et al 2019</code>之前工作中的结构</li><li>更进一步的说，2019年的两篇基于指针网络的论文的可测试level均为sentence level，说服性一般</li><li>类似<code>encoder-decoder</code>形式的模型，可解释性一般</li></ul><h4 id="Dependency-Parsing与Discourse-Parsing"><a href="#Dependency-Parsing与Discourse-Parsing" class="headerlink" title="Dependency Parsing与Discourse Parsing"></a>Dependency Parsing与Discourse Parsing</h4><p><img src="%E5%88%86%E5%B1%82%E6%8C%87%E9%92%88%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90%5Cfc1.png" alt="fc1"></p><ul><li>相似之处是两者都是要建立树形结构</li><li>不同之处<ul><li>依存关系只能位于word之间；篇章关系位于EDU（Span）之间</li><li>依存关系分析对于任意位置的两个word均可以；篇章分析只能分析相邻的两个EDU之间的关系</li></ul></li><li>近年来的情况表明，神经网络模型的性能要好于基于特征的模型（模型比较难选择）</li></ul><h4 id="Pointer-Networks"><a href="#Pointer-Networks" class="headerlink" title="Pointer Networks"></a>Pointer Networks</h4><ul><li><p>是一种<code>encoder-decoder</code>模型，可以解决输出size依赖于输入size的问题</p></li><li><p>使用注意力机制作为input的指针</p><blockquote><p>$s_{t,i} = \sigma(d_t, h_i)$，其中$\sigma$是attention计算函数，$d_t$是<code>decoder state</code>，$h_i$是<code>input hidden state</code></p><p>$\alpha_t = softmax(S_t)$，计算得到Attention分布</p><p>$argmax(\alpha_t)$，取attention分布中的最大值，即为指针</p></blockquote></li><li><p>在parsing中的应用</p><ul><li>自定向下深度优先的方式建立树结构（即寻找划分边界）</li><li>找到划分边界之后使用分类器预测新得到的两部分之间的<code>relation &amp; nuclearity</code></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 自然语言处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 论文笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>篇章分析的递归深度模型</title>
      <link href="/passages/pian-zhang-fen-xi-de-di-gui-shen-du-mo-xing/"/>
      <url>/passages/pian-zhang-fen-xi-de-di-gui-shen-du-mo-xing/</url>
      
        <content type="html"><![CDATA[<p>《Recursive Deep Models for Discourse Parsing》论文笔记</p><a id="more"></a><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><ul><li>论文被<code>EMNLP 2014</code>收录</li><li>作者是北京大学的<code>Jiwei Li</code>等人</li></ul><h3 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h3><ul><li>近期虽然在自动篇章分割和<code>sentence level</code>的篇章分析上有所进展，但是<code>document level</code>的篇章分析仍是一个很困难的任务</li><li>近期的许多尝试的性能相比与人类仍相差许多</li><li>与句子间的依存关系分析相比，篇章单元间的关系没有如此详细的定义，没有句子级语法类似的篇章级的语法</li><li>进行篇章单元之间关系的分析所需要的语法等信息，手动构建的特征并无法有效的体现</li><li>近期深度学习架构在NLP任务中显示出了较强的在上下文中捕获单元相关语义和句法方面的优势，目前在篇章分析领域还未得到应用</li></ul><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><ul><li>单词的分布式表示构成了子句的表示，因此可以将分布式子句的表示扩展到单据或多句（篇章）级别，并产生整个文本的层次结构</li><li>使用深度神经网络来构建两个分类器，以自底向上的方式构建篇章树</li></ul><h3 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h3><p><img src="%E7%AF%87%E7%AB%A0%E5%88%86%E6%9E%90%E7%9A%84%E9%80%92%E5%BD%92%E6%B7%B1%E5%BA%A6%E6%A8%A1%E5%9E%8B%5Cdm.png" alt="rdm"></p><ul><li>使用<code>Recursive Neural Networks</code>来构建两个分类器<ul><li>二分类器，三层神经网络，判断两个篇章单元是否需要连接</li><li>多分类器，三层神经网络，判断两个篇章单元之间连接的关系</li></ul></li><li><code>Span</code>的分布式向量表示<ul><li>利用<code>Recursive Neural Networks</code>以自底向上的方式获得span的表示</li><li>利用子节点的表示通过一定形式的计算来的到其父节点（span）的表示</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>在计算span的分布式表示时，没有区分句内span和跨句子的span</li><li>使用了自底向上的probability CKY-like算法进行篇章树的构建</li><li>没有单独训练用于判别nuclearity关系的多分类器，<code>nuclearity</code>和<code>relation</code>是一起进行预测的（两者进行了绑定）</li><li>最早的使用神经网络进行篇章分析工作的论文</li></ul>]]></content>
      
      
      <categories>
          
          <category> 自然语言处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 论文笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于指针网络的通用文本分割神经模型</title>
      <link href="/passages/ji-yu-zhi-zhen-wang-luo-de-tong-yong-wen-ben-fen-ge-shen-jing-mo-xing/"/>
      <url>/passages/ji-yu-zhi-zhen-wang-luo-de-tong-yong-wen-ben-fen-ge-shen-jing-mo-xing/</url>
      
        <content type="html"><![CDATA[<p>《SEGBOT：A Generic Neural Text Segmentation Model With Pointer Network》论文笔记</p><a id="more"></a><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><ul><li><p>本文已被<code>IJCAI 18</code>收录</p></li><li><p>作者是南洋理工大学的<code>Jing Li</code>等</p></li></ul><h3 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h3><ul><li>文本分割可以分为两种<ul><li><code>Topic Segmentation</code>（主题划分）</li><li><code>EDU Segmentation</code>（EDU分割）</li><li>目前并没有适用于两者的的性能良好的分割模型</li></ul></li><li>传统的方法并不能有效避免边界稀疏问题</li><li>传统的方法更多的还是依赖于人工特征</li><li>传统的方法并不能很好的解决输出size变化的问题</li></ul><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><ul><li><p>对于输出大小变化的问题，可以使用RNN类似的网络结构解决</p></li><li><p>现在分布式的文本表征已被证明可以很好的捕获语法、句法等信息，所以在编码上使用像GloVe、ELMo等应该会提升性能</p></li><li><p>此外，使用双向的网络能很好的利用上下文的信息</p></li><li><p>对于边界稀疏问题，这里选择使用指针网络来选择分割边界</p></li></ul><h3 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h3><p><img src="%E5%9F%BA%E4%BA%8E%E6%8C%87%E9%92%88%E7%BD%91%E7%BB%9C%E7%9A%84%E9%80%9A%E7%94%A8%E6%96%87%E6%9C%AC%E5%88%86%E5%89%B2%E7%A5%9E%E7%BB%8F%E6%A8%A1%E5%9E%8B%5Csegbot1.png" alt="segbot"></p><ul><li>模型分为三个阶段<ul><li>编码阶段</li><li>解码阶段</li><li>指针阶段</li></ul></li><li>模型的功能是进行文本分割，换句话说是进行<strong>分割边界的判定或查找</strong></li></ul><p>首先，对于input，我们使用分布式的表征对其进行编码</p><ul><li><p>对于word（词），我们使用GloVe进行编码</p></li><li><p>对于句子，使用Arora在2017年使用的方法进行编码</p></li><li><p>编码阶段，</p><blockquote><ul><li>使用<strong>双向GRU</strong>来编码输入序列</li></ul></blockquote></li><li><p>解码阶段</p><blockquote><ul><li>输出中边界数量是变化的，使用基于RNN的模型</li><li>基于单向GRU的隐藏层</li></ul></blockquote></li><li><p>指针阶段</p><blockquote><ul><li>decoder的输出是输入序列中分割边界的概率分布</li><li>使用<strong>指针机制</strong>克服了传统的seq2seq模型输出维度固定的问题</li></ul></blockquote></li></ul><h3 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h3><ul><li>提出了一个端到端的分割模型（SEGBOT），能同时适用于主题分割和EDU分割</li><li>使用双向RNN对输入进行编码，使用RNN+Pointer Network来选择输入序列中的分割边界</li><li>不需要使用人工特征和其他先验知识</li><li>对于EDU分割的实验中，使用未进行<code>fine-tuning</code>的GloVe效果会更好<ul><li>原因是微调之后的GloVe相比与微调之前在测试集上的<code>vocabulary cover</code>会更少</li></ul></li><li>对比了几种预训练的<code>word embedding</code>，相比之下，像<code>Google embedding</code>的表现会差很多<ul><li>原因可能是他们在训练的过程中剔除了停用词、数字和标点</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 自然语言处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 论文笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>句子级篇章分析的线性时间统一框架</title>
      <link href="/passages/ju-zi-ji-pian-zhang-fen-xi-de-xian-xing-shi-jian-tong-yi-kuang-jia/"/>
      <url>/passages/ju-zi-ji-pian-zhang-fen-xi-de-xian-xing-shi-jian-tong-yi-kuang-jia/</url>
      
        <content type="html"><![CDATA[<p>《A Unified Linear-Time Framework for Sentence-Level Discourse Parsing》论文笔记</p><a id="more"></a><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><ul><li>文章被ACL 2019收录</li><li>作者<code>Xiang Lin</code>等，南洋理工大学</li></ul><h3 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h3><ul><li>很多NLP下游任务可以从文本连贯性分析中受益</li><li>RST连贯性分析包含两项子任务<ul><li><code>Discourse Segmentation（篇章分割）</code>，<code>text ——&gt; EDU</code></li><li><code>Discourse Parsing（篇章分析）</code>，<code>EDU ——&gt; Discourse Tree</code></li></ul></li><li>自动的EDU分割的正确性是篇章分析性能的主要影响因素</li><li>句子级的篇章分析是篇章分析的重要的第一步</li><li>之前的工作依赖于手工制作的词法、句法特征</li><li>神经模型可以以一种端到端的方式学习篇章单元的特征表示，特别是使用了更好的预训练的<code>word embedding</code>之后更进一步提高了模型的通用性</li><li>但是现在并没有很多工作使用神经网络来进行篇章分析的工作，所以我们尝试使用</li></ul><h3 id="作者的思考"><a href="#作者的思考" class="headerlink" title="作者的思考"></a>作者的思考</h3><ul><li><p>基于指针网络的<code>Discourse Segmentation</code>和<code>Discourse Parsing</code></p></li><li><p>使用<code>Top-down</code>的方式进行建树，这样的话可以从全局的角度利用更多的信息</p></li><li><p>使用预训练的语言模型进行句子的编码</p></li></ul><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><ul><li><p><code>Discourse Segmenter</code>（篇章分割）</p><p><img src="%E5%8F%A5%E5%AD%90%E7%BA%A7%E7%AF%87%E7%AB%A0%E5%88%86%E6%9E%90%E7%9A%84%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E7%BB%9F%E4%B8%80%E6%A1%86%E6%9E%B6%5Cparsing.png" alt="seg"></p><blockquote><p>Segmenter的作用就是在句子中寻找分割边界，之前有两种做法：</p><ul><li>二分类</li><li>序列标注</li><li>最近<code>Pointer Networks</code>在篇章分割上的表现也很好</li></ul><p>我们看一下图中的过程：</p><ul><li>读取整个句子，先进行编码，得到<code>X</code></li><li>将X转化为对应的隐藏状态</li><li>对于每个时刻t，我们将当前正在处理的segment的第一个token作为decoder的输入，并产生一个<code>attention score</code></li><li>基于<code>attention score</code>，我们选择分割边界</li></ul><p>值得注意的是，我们的分割器，相比于2018年Li的工作，进行了一定的改进</p><ul><li>decoder使用encoder state作为输入，而不是<code>word embedding</code></li><li>使用<code>dot attention</code>而不是<code>add attention</code></li><li>使用<code>ELMo或GloVe或BERT</code>作为<code>embedding</code>，更好的利用上下文信息</li></ul></blockquote></li><li><p><code>Discourse Parser</code>（篇章分析）</p><p><img src="%E5%8F%A5%E5%AD%90%E7%BA%A7%E7%AF%87%E7%AB%A0%E5%88%86%E6%9E%90%E7%9A%84%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E7%BB%9F%E4%B8%80%E6%A1%86%E6%9E%B6%5Cseg.png" alt="parser"></p><blockquote><p>Parser的主体使用的是Pointer Networks</p><p>我们看一下图的<strong>左边</strong>：</p><ul><li>对于给定的sentence，我们先进行ELMo或者GloVe进行编码，得到<code>X</code></li><li><code>X</code>作为input，输入到模型中</li><li>指针网络的编码器现将整个句子顺序组成一系列的Hidden state，我们使用每个EDU的最后一个隐藏状态来表示EDU</li><li>之后使用一个top-down的decoder以深度优先的方式构建<code>Discourse Tree</code></li></ul><p>我们看一下图的<strong>右边</strong>：</p><ul><li>一个堆栈<code>S</code>，<code>S</code>使用特殊的root初始化</li><li>每一步，从<code>S</code>的顶部取一$Span_{i:j}$，并使用$e_j$（EDU的representation）生成隐层的隐藏状态$d_t$，将其用于计算<code>EDU representation</code>中的<code>attention score</code></li><li>基于得分，解码器会从中选择一个位置<code>k</code>来进行划分</li><li>之后decoder会在新的拆分上预测<code>relation</code>和<code>nuclearity</code></li></ul><p><strong>模型细节</strong></p><ul><li>编码器：6层Bi-GRU，最后的hidden state被用作EDU的representation</li><li>解码器：6层Bi-GRU，decoder的输入是encoder的hidden state（我们认为encoder的hidden state比word embedding包含更多的信息）；使用dot product作为attention的计算函数</li><li>关系分类器：使用两层神经网络作为分类器；将nuclearity和relation联系起来，可以同时做这两个任务</li></ul></blockquote></li></ul><ul><li><p><code>Joint training</code></p><p><img src="%E5%8F%A5%E5%AD%90%E7%BA%A7%E7%AF%87%E7%AB%A0%E5%88%86%E6%9E%90%E7%9A%84%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E7%BB%9F%E4%B8%80%E6%A1%86%E6%9E%B6%5Cjoint.png" alt="total"></p></li></ul><blockquote><p><code>Segmenter</code>和<code>Parser</code>共享encoder，这在非神经网络模型中是不可能实现的</p><p>并且<code>Segmenter</code>和<code>Parser</code>可以作为独立的任务同时进行训练</p><p><code>Segmenter</code>和<code>Parser</code>之间可以互相收益，好的分割可以带来建树上的性能提升，反之亦然</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>一个有效的<strong>句子级篇章分析</strong>的神经框架<ul><li>一个<code>EDU</code>分割器，<code>F1 score</code>达到了95.4</li><li>一个自定向下的篇章分析器，<code>F1 score</code>在关系标注上达到了81.7</li><li>两个模型进行联合训练，效果都有所提升，分割器达到了95.5，分析器达到了81.7</li></ul></li><li>对于<code>End-to-End</code>的系统，在关系标注上的<code>F1 score</code>达到了77.5，相比于之前的系统有较高提升</li><li>篇章分析的时间为线性时间</li></ul><h3 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h3><ul><li><p>当前的篇章分析的主要方式</p><ul><li>Bottom-up：Transition Based和CKY-like</li><li>Top-down：Encoder-Decoder</li></ul></li><li><p>当前篇章分析的另一个区别</p><ul><li>贪婪的基于转移的算法<ul><li>线性时间</li><li>基于局部信息</li></ul></li><li>表格分析（chart parsing）<ul><li>正确率更高</li><li>速度很慢</li></ul></li></ul></li><li><p>篇章连贯性分析</p><ul><li><p><code>Soricut</code>和<code>Marcu</code>，<code>SPADE</code></p><blockquote><p> 使用句法特征来进行parsing和segmentation的生成模型</p><p>之后的工作都集中在研究语法的影响</p></blockquote></li><li><p><code>Joty</code>等，2015年，CODRA</p><blockquote><p> 包括一个segmenter和一个两阶段的discourse parser</p><ul><li>第一阶段是句子级的篇章分析</li><li>第二阶段是多句子的篇章分析</li></ul></blockquote></li><li><p><code>Feng</code>等，2014a</p><blockquote><p>一个基于CRF和人工特征的两阶段的parser</p></blockquote></li><li><p><code>Li</code>等，2014</p><blockquote><p>基于Recursive Networks的篇章分析</p></blockquote></li><li><p><code>Ji</code>等，2014</p><blockquote><p>基于shift-reduce的篇章分析的表征学习模型</p></blockquote></li><li><p><code>Wang</code>等，2017</p><blockquote><p>两阶段的parser，</p><ul><li>第一阶段基于shift-reduce进行建树，只标记了nuclearity</li><li>第二阶段再进行relation的标记</li></ul><p>使用SVM + 大量的手工特征</p></blockquote></li><li><p><code>Wang</code>等，2018</p><blockquote><p>使用了LSTM + CRF和ELMo的篇章分割器</p></blockquote></li><li><p><code>Li</code>等，2018</p><blockquote><p>基于Pointer Networks的分割器</p></blockquote></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 自然语言处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 论文笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Attention的分层神经网络的篇章分析</title>
      <link href="/passages/ji-yu-attention-de-fen-ceng-shen-jing-wang-luo-de-pian-zhang-fen-xi/"/>
      <url>/passages/ji-yu-attention-de-fen-ceng-shen-jing-wang-luo-de-pian-zhang-fen-xi/</url>
      
        <content type="html"><![CDATA[<p>《Discourse Parsing with Attention-based Hierarchical Neural Networks》论文笔记</p><a id="more"></a><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><ul><li>这篇文章发表在EMNLP 2016</li><li>作者是北大的<code>Qi Li</code>、<code>Tianshi Li</code>、<code>Baobao Chang</code></li></ul><h3 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h3><ul><li><code>Discourse Parsing</code>依然是一个很有挑战的工作</li><li>尽管在近期（2016年）的工作已经显示出神经网络在特征抽取方面的良好性能，但是在篇章分析的工作上，目前性能较好的模型还是需要人工来构建特征</li><li>在之前的工作中，只有Li在2014年使用过RNN来计算<code>subtree</code>的<code>representation</code>，但是RNN存在梯度消失问题，而且对长距离依赖的捕获能力也不强；同时传统的变换函数并不能对特征之间的交互进行建模，也不能构建出组合特征</li></ul><h3 id="作者的思考"><a href="#作者的思考" class="headerlink" title="作者的思考"></a>作者的思考</h3><ul><li><p>RNN的梯度消失和处理长距离依赖性能较差的问题</p><blockquote><p>使用LSTM来代替RNN，LSTM可以解决梯度消失问题，并且在捕获长距离依赖上效果更好</p></blockquote></li><li><p>EDU（由word构成）和Span（由EDU构成）的构成方式并不同</p><blockquote><p>对于两种结构需要分开处理，所以需要构建分层的神经网络</p></blockquote></li><li><p>更多的语义信息</p><blockquote><p>对于Span中的每一个EDU，使用Attention，以获取Span中突出的语义信息</p><p>同时使用Attention，可以辅助LSTM，使网络获取更长距离的依赖</p></blockquote></li><li><p>传统变换函数的缺陷</p><blockquote><p>使用tensor-based的变换函数，对特征之间的交互进行建模，并且可以构造组合特征</p></blockquote></li></ul><h3 id="解决方案or模型"><a href="#解决方案or模型" class="headerlink" title="解决方案or模型"></a>解决方案or模型</h3><ul><li><p>先来看一下模型的结构图</p><p><img src="%E5%9F%BA%E4%BA%8EAttention%E7%9A%84%E5%88%86%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E7%AF%87%E7%AB%A0%E5%88%86%E6%9E%90%5Cparsing_model.png" alt="model"></p><blockquote><p>我们来看一下模型的结构</p><p>首先，最下面的<strong>分层双向LSTM</strong>，分别是EDU级别的Bi-LSTM和Span级别的Bi-LSTM</p><p>之后一层<strong>Attention</strong>，用以捕获Span中的语义信息</p><p>再之后经过<strong>基于Tensor的变换函数</strong>，增加一些<strong>组合特征</strong>，同时添加一些<strong>人工特征</strong></p><p>将特征组合之后输入<strong>三个分类器</strong>，分别用于</p><ul><li>判断Span是否该组合的二分类器</li><li>判断核关系的多分类器（三分类）</li><li>判断Span之间的关系的多分类器</li></ul></blockquote></li><li><p>人工特征</p><p><img src="%E5%9F%BA%E4%BA%8EAttention%E7%9A%84%E5%88%86%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E7%AF%87%E7%AB%A0%E5%88%86%E6%9E%90%5Cbase_feature.png" alt="handfeature"></p><blockquote><p>之前的工作主要是通过使用特征来完成的</p><p>并且之前Li的工作也显示一些<strong>基本的特征</strong>仍然是有效的</p></blockquote></li><li><p>模型加速（两级缓存）</p><blockquote><p>probilistic CKY-like算法的复杂度为$O(n^3)$，但是在本项工作中，我们以分层的双向LSTM为模型，计算复杂度为$O(n^4)$</p><p>由于多数计算是重复的，所以可以使用缓存来减少计算复杂度</p><p>具体思路见论文</p></blockquote></li></ul><h3 id="几点解释"><a href="#几点解释" class="headerlink" title="几点解释"></a>几点解释</h3><ul><li><p>为什么使用分层网络结构</p><blockquote><p>EDU和Span的构成不同，需要分开处理，处理之后再进行组合</p></blockquote></li><li><p>为什么使用双向LSTM</p><p><img src="%E5%9F%BA%E4%BA%8EAttention%E7%9A%84%E5%88%86%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E7%AF%87%E7%AB%A0%E5%88%86%E6%9E%90%5CBiLSTM_EDU.png" alt="bi-lstm1"></p><p><img src="%E5%9F%BA%E4%BA%8EAttention%E7%9A%84%E5%88%86%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E7%AF%87%E7%AB%A0%E5%88%86%E6%9E%90%5CBiLSTM_Span.png" alt="bi-lstm2"></p><blockquote><p>discourse marker通常出现在文本单元的beginning和end，所以需要从两个方向来捕获</p><p>LSTM虽然记忆能力比较强，但是序列末尾的token由于经过更少的遗忘，所以对整个表征的影响更大</p><p>使用Bi-LSTM就可以对序列的beginning和end分别处理</p></blockquote></li><li><p>使用Attention的作用</p><blockquote><p>通过全局上下文关注每个EDU，提取重要的语义信息，剔除不重要的信息</p><p>LSTM虽然可以捕获长距离依赖，但是受限于输出的固定维度，在文本很长的始终，LSTM可能不足以捕获整个语义</p></blockquote></li><li><p>tensor-based transformation function</p><blockquote><p>直观上，允许两个span的特征之间进行复杂的交互可能有助于识别它们之间的关系</p><p>我们使用该函数来增加span特征之间的交互，并且产生一些组合特征</p></blockquote></li></ul><h3 id="一点细节"><a href="#一点细节" class="headerlink" title="一点细节"></a>一点细节</h3><ul><li>使用GloVe对word embedding进行的预训练，并且在训练的时候对word embedding进行了微调，以应对训练集中的OOV情况</li><li>使用Stanford CoreNLP ToolKit来处理文本，进行词法，词性信息</li><li>初始化模型参数为[-0.012, 0.012]之间的数</li><li>dropout为0.03</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>分层双向LSTM模型</li><li>加入了Attention机制</li><li>tensor-based transformation function</li><li>two level cache以加速模型</li></ul>]]></content>
      
      
      <categories>
          
          <category> 自然语言处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 论文笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Word_Representation综述</title>
      <link href="/passages/word-representation-zong-shu/"/>
      <url>/passages/word-representation-zong-shu/</url>
      
        <content type="html"><![CDATA[<p>One-Hot、词袋模型、TF-IDF、n-gram、word2vec、GloVe、ELMo、GPT、BERT、XLNet</p><a id="more"></a><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><ul><li>一直计划要写一篇综述，奈何知识储备不够，最近在看过相关的论文之后有了一些想法</li><li>我们都知道，文本是无法直接放入到模型来训练的，所以就需要将其转化为模型能够识别的形式，也就是向量，这就是文本表征的工作</li><li>本文主要是梳理文本表征的常见模型和一些最近表现比较好的模型，作为之前针对每个模型文章的补充</li><li>在这里，我会尽量使用比较简短的语言描述各个模型的大体思路，进步以及存在的缺陷</li><li>如果您发现有错误，欢迎来信<code>指教&amp;讨论</code></li></ul><h3 id="纲要"><a href="#纲要" class="headerlink" title="纲要"></a>纲要</h3><ul><li><p>离散式的文本表征（忽略词与词之间的关系）</p><blockquote><ul><li><p>One-Hot编码</p></li><li><p>词袋模型</p></li><li><p>TF-IDF</p></li><li><p>N-gram</p></li></ul></blockquote></li><li><p>分布式的文本表征</p><blockquote><ul><li><p>word2vec</p></li><li><p>GloVe</p></li><li><p>ELMo</p></li></ul></blockquote></li><li><p>两段式（预训练+微调）</p><blockquote><ul><li><p>GPT</p></li><li><p>BERT</p></li><li><p>XLNet</p></li></ul></blockquote></li></ul><h3 id="One-Hot编码"><a href="#One-Hot编码" class="headerlink" title="One-Hot编码"></a>One-Hot编码</h3><ul><li><p>对分词后的词构造无重复的集合，每个词占一位，值为0或1</p></li><li><p>编码时，整个向量中，该词的位置为1，其他位置为0</p></li><li><p>例如</p><blockquote><p>文本：篇章分析可能是我喜欢的方向</p><p>分词结果：篇章分析、可能、是、我、喜欢、的、方向</p><p>对于词“篇章分析”，编码为 : [1, 0, 0, 0, 0, 0, 0]</p></blockquote></li><li><p>优缺点</p><blockquote><p>优点：形式简单，易于理解和计算</p><p>缺点：忽略了词与词之间的关系，向量维度会随词的增多而快速增长</p></blockquote></li></ul><h3 id="词袋模型"><a href="#词袋模型" class="headerlink" title="词袋模型"></a>词袋模型</h3><ul><li><p>对文本进行分词，统计每个词出现的次数，构建词袋（可以想像成<code>词：次数</code>的键值对组成的字典）</p></li><li><p>可以对句子进行编码，每个词的位置是其在文档中出现的次数</p></li><li><p>例如</p><blockquote><p>文本：NLP is my favorite direction. I will invest time in this direction</p><p>词袋：{NLP : 1, is : 1, my : 1, favorite : 1, direction : 2, I : 1, will : 1, invest : 1, time : 1, in : 1, this : 1]</p><p>该句的编码为：[1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 2]</p></blockquote></li><li><p>优缺点</p><blockquote><p>优点：易于理解</p><p>缺点：没有考虑词与词之间的关系</p></blockquote></li></ul><h3 id="TF-IDF"><a href="#TF-IDF" class="headerlink" title="TF-IDF"></a>TF-IDF</h3><ul><li><p>TF、IDF的含义</p><blockquote><p>TF表示的是词频，可以表示为：$TF = \frac{某文本中w出现的次数}{文本中所有词的个数}$</p><p>IDF表示的事逆文档频率指数，可以表示为：$IDF= log \frac{文档总数}{包含w的文档数+1}$</p></blockquote><blockquote><p>基本思想为：一个词在一个文档中出现的次数越多表示这个词越能表示这个文档；一个词在越多的文档中，则这个词对于文档分类的贡献越小</p></blockquote></li><li><p>优缺点</p><blockquote><p>优点：简单快速，结果符合实际情况</p><p>缺点：单纯以词频衡量词的重要性，不够全面，而且没有考虑词的位置信息</p></blockquote></li></ul><h3 id="N-gram"><a href="#N-gram" class="headerlink" title="N-gram"></a>N-gram</h3><ul><li><p>使用滑动窗口的方式来进行分词，N表示的是窗口的大小</p></li><li><p>比如2-gram，就是把两个词当作一组来处理，然后向后移动一个词的长度，再次组成另一组词，然后统计词频生成字典</p></li><li><p>这种模型一定程度上考虑了词的顺序</p></li><li><p>例如</p><blockquote><p>文本：</p><p>John likes to watch movies. Mary likes too.</p><p>John also likes to watch football games.</p><p>若构造的词典为：</p><p>{“John likes”: 1, “likes to”: 2, “to watch”: 3, “watch movies”: 4, “Mary likes”: 5, “likes too”: 6, “John also”: 7, “also likes”: 8, “watch football”: 9, “football games”: 10}</p><p>则第一句话的编码为</p><p>[1, 2, 3, 4]</p></blockquote></li><li><p>优缺点</p><blockquote><p>优点：一定程度上利用了词的顺序关系</p><p>缺点：向量维度会增长非常快</p></blockquote></li></ul><h3 id="word2vec"><a href="#word2vec" class="headerlink" title="word2vec"></a>word2vec</h3><ul><li><p>有两种：CBOW和Skip-gram</p></li><li><p>CBOW</p><blockquote><p>获得中间词两边的上下文，利用上下文来预测中间的单词</p><p>把窗口中的中间词作为y，其他词当作x输入</p><p>x输入经过one-hot编码，然后通过一个隐层求和操作，最后通过激活函数softmax，计算每个词的生成概率</p><p>训练圣经网络得到的权重矩阵就是文本表示词向量的结果</p></blockquote></li><li><p>Skip-gram</p><blockquote><p>通过当前词来预测窗口中上下文词的出现概率</p><p>把当前词作为x，把窗口中的其他词当作y，通过一个隐层接一个softmax激活函数来预测其他词的概率</p></blockquote></li><li><p>优缺点</p><blockquote><p>优点：分布式的word representation，更大程度上利用了文本内在的信息</p><p>缺点：</p><ul><li>对每个词只是在windows中进行训练，并没有使用全局信息</li><li>每个词的向量表示在训练结束后就确定了，对多义词并不能有有效的进行表示和处理         </li></ul></blockquote></li></ul><h3 id="GloVe"><a href="#GloVe" class="headerlink" title="GloVe"></a>GloVe</h3><ul><li><p>Global Vectors for Word Representation</p></li><li><p>它是一个基于全局词频统计的词表征</p></li><li><p>共现矩阵</p><blockquote><p>顾名思义，共现就是共同出现的意思</p><p>在矩阵中，$X_{ij}$表示的事词j在词i的上下文中出现的次数</p><p>论文中用以下公式近似的表达两者之间的关系</p><p>$$w^T_iw_j + b_i + b_j = log(X_{ij})$$</p><p>其中$w^T_iw_j$即我们最终要求解的词向量，$b_i$和$b_j$是bias，$X_{ij}$是共现矩阵中的值</p></blockquote></li><li><p>优缺点</p><blockquote><p>优点：</p><ul><li>结合了LSA和word2vec两者的特征，既使用了全局特征的矩阵分解方法，也了用了局部上下文特征（统计上下文中的出现次数时使用了滑动窗口）</li></ul></blockquote></li></ul><h3 id="ELMo"><a href="#ELMo" class="headerlink" title="ELMo"></a>ELMo</h3><ul><li><p>双层语言模型的深层上下文的词表示</p></li><li><p>主要想法</p><blockquote><p>使用双向LSTM作为语言模型在语料上训练出词的向量表示</p><p>在下游任务重会根据词的上下文对词的向量表示进行调整</p><p>使用了三层的双向LSTM（AR语言模型），每层向量表示的内涵是不同的</p><ul><li>底层的可以捕获语法等方面的特征</li><li>高层的可以捕获语境相关的特征</li></ul></blockquote></li><li><p>优缺点</p><blockquote><p>优点：</p><ul><li>因为可以在应用的时候动态调整词向量的值，解决了多义词、歧义等问题</li><li>学习的范围更广，一定程度上更能表示一个词的意思</li></ul><p>缺点：</p><ul><li>特征提取器使用的是LSTM而不是transformer，特征提取能力可能不是很高</li><li>虽然说的是使用了上下文信息，但是只是对双向LSTM的hidden state进行简单的拼接，并不能有效的整合上下文信息</li></ul></blockquote></li></ul><h3 id="GPT"><a href="#GPT" class="headerlink" title="GPT"></a>GPT</h3><ul><li><p>GPT 1.0</p><blockquote><ul><li>两段式的过程：Pre-training和fine-tuning<ul><li>先通过无标签的文本去训练生成语言模型</li><li>在下游任务中再使用有标签的数据进行监督式的微调</li></ul></li><li>相比于ELMo，改动有两点<ul><li>特征抽取器使用的是transformer的decoder</li><li>采用的是单向语言模型（AR）</li></ul></li></ul></blockquote></li><li><p>GPT 2.0</p><blockquote><ul><li>两段式的过程：Pre-training和fine-tuning<ul><li>先通过无标签的文本去训练生成语言模型</li><li>在下游任务中使用<strong>无监督</strong>的方式进行微调</li></ul></li><li>仍然使用的是transformer的decoder作为特征抽取器</li><li>使用的是单向语言模型（不是很了解其中的内涵）</li><li>主要的改进：<ul><li>扩大了transformer的模型容量（加深了层数，增加了参数个数）</li><li>使用了更大且很有质量的数据集来进行训练</li></ul></li><li>给出了一种新的生成式任务的做法<ul><li>即一个词一个词往外蹦，然后根据时间顺序组合起来作为结果</li></ul></li></ul></blockquote></li></ul><h3 id="BERT"><a href="#BERT" class="headerlink" title="BERT"></a>BERT</h3><ul><li><p>两段式的过程：Pre-training和fine-tuning</p><ul><li>先通过无标签的文本去训练生成语言模型</li><li>在下游任务中再使用有标签的数据进行监督式的微调</li></ul></li><li><p>预训练过程中有两点创新</p><ul><li><p>MLM</p><blockquote><p>典型的AE语言模型，通过对输入序列mask掉一些token，然后使用其他的词去预测这些被mask掉的词</p><p>正因如此，模型可以很好的利用上下文的信息，也即双向语言模型</p><p>但是mask操作会导致预训练和微调存在差异，BERT通过对mask操作分为三种选择来减缓这种影响</p></blockquote></li><li><p>NSP</p><blockquote><p>因为一些下游任务基于句子间的关系的理解，这些关系无法通过语言模型来捕获</p><p>所以设计了这个<code>根据一个句子预测下一个句子</code>的任务</p></blockquote></li></ul></li><li><p>优缺点</p><blockquote><p>优点：利用了上下文的信息，是一个双向的模型</p><p>缺点：</p><ul><li>mask操作会导致预训练和微调存在差异</li><li>mask的时候是假设被mask的词之间是相互独立的，而这样会丢失一些词之间的关系</li></ul></blockquote></li></ul><h3 id="XLNet"><a href="#XLNet" class="headerlink" title="XLNet"></a>XLNet</h3><ul><li><p>基于AR语言模型，对生成式的任务有天生的优势</p></li><li><p>两段式的过程：Pre-training和fine-tuning</p></li><li><p>具体思路</p><blockquote><p>XLNet是基于AR语言模型的，但是我们知道AR语言模型只能看到词一侧的信息</p><p>XLNet是如何让单向的AR语言模型看到上下文的信息的呢？（这也是XLNet的一个比较新颖的贡献）</p><ul><li>将待预测的单词固定，对其他的词进行排序</li><li>这样就可以在单向的情况下看到后面的词了，也就达到了双向的效果</li><li>具体的过程可以取<a href="http://www.zivblog.top/passages/xlnet-jian-dan-li-jie/" target="_blank" rel="noopener">XLNet简单理解</a>中看</li></ul><p>在此基础上，XLNet引入了transformer XL的机制，即段循环机制和相对位置编码，使得模型能够捕获更远距离的上下文依赖</p></blockquote></li><li><p>优缺点</p><blockquote><p>优点：</p><ul><li>解决了BERT中mask操作带来的负面影响</li><li>对于生成式的任务和长文档输入的NLP任务表现更加优秀</li></ul></blockquote></li></ul><h3 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h3><ul><li>写完上面的内容之后还是有些意尤未尽，有很多地方描述的不够详尽，但是本身水平有限，在后续的时间里会随时纠正其中的错误和补充其中的不够全面的地方</li><li>如果您对其中的内容有不同看法或者有好的想法，欢迎来信交流</li><li>邮箱 : <a href="mailto:wjf850300210@163.com">wjf850300210@163.com</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 自然语言处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 论文笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XLNet简单理解</title>
      <link href="/passages/xlnet-jian-dan-li-jie/"/>
      <url>/passages/xlnet-jian-dan-li-jie/</url>
      
        <content type="html"><![CDATA[<p>《XLNet-Generalized Autoregressive Pretrainingfor Language Understanding》论文笔记</p><a id="more"></a><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><ul><li><p>今年6月发布的XLNet，在很多任务上的性能都超过了BERT</p></li><li><p>但BERT本身的地位并不能被忽视</p><blockquote><p>BERT的除了其性能上带来的提升，更关键的是，它证明了一个非常深的模型能够显著提高NLP任务的准确率，并且这个模型性可以从无标记的数据集中预训练得到</p><p>另外，它也开启了“两段式”大门，即在大型数据集上预训练，再针对下游任务进行微调</p></blockquote></li><li><p>XLNet可以看作是BERT的一个发展，它使用新的结构避免了BERT的缺陷，并且结合了transformer XL的一些思路使其在面对长文本时的性能更加出众</p></li></ul><h3 id="从BERT开始"><a href="#从BERT开始" class="headerlink" title="从BERT开始"></a>从BERT开始</h3><ul><li><p>在之前的文章中我们对<a href="http://www.zivblog.top/passages/bert-jian-dan-li-jie/" target="_blank" rel="noopener">BERT</a>做过以此比较详细的介绍，这里再简单的回顾一下</p></li><li><p>BERT的结构是双向transformer</p></li><li><p>它的预训练，使用MLM和NSP</p></li><li><p>BERT的局限也在于此，</p><blockquote><p> 在MLM中，BERT对输入序列进行的mask操作，使用被mask掉的词的上下文来对其进行预测</p><p>正因为如此，BERT的以很好的利用双向语境信息</p><p>但也因为如此，BERT的预训练与微调是有差异的，因为应用到下游任务中时，并不会有mask操作</p></blockquote></li><li><p>XLNet的作者认为，BERT的缺点主要在于以下几个方面：</p><ul><li>首先，是mask操作使得pre-training和fine-tuning之间存在差异</li><li>其次，BERT做mask操作时，是认为被mask掉的token之间是相互独立的，并没有利用这些token之间的依赖关系</li></ul></li><li><p>针对以上的问题，XLNet提出了一种新的结构，并且取得了较好的性能</p></li></ul><h3 id="在XLNet之前"><a href="#在XLNet之前" class="headerlink" title="在XLNet之前"></a>在XLNet之前</h3><ul><li><p>作者认为，当前的预训练模型主要有两种：</p><ul><li>AR（AutoRegression）：自回归语言模型</li></ul><blockquote><p>根据上文预测下一个单词或者下文预测前一个单词</p><p>说道这里，你可能会想到ELMo，ELMo中确实用到了这种LM，而且最后对于两个方向的hidden state做了拼接，从这一点看来，ELMo还是自回归LM，是一种“伪上下文”，并不能很有效的利用上下文信息</p></blockquote><blockquote><p>优点：对于生成式的下游任务，本身就是单方向的，所以AR可以很好的适应；还有一点是相比于AE，能够学习到token之间的依赖</p><p>缺点：只能利用上文或者下文的信息</p><p>提前说一句，XLNet提供了一种使用自回归语言模型利用上下文信息的方法，详细的内容过会再讲</p></blockquote><ul><li>AE（AutoEncoder）：自编码语言模型</li></ul><blockquote><p>类似与BERT的自编码方式，破坏掉输入的一部分，再对破坏掉的进行预测，以此来捕捉深层次的双向信息</p><p>BERT的做法就是将input中的token进行mask操作</p></blockquote><blockquote><p>优点：能较好的融入双向语言模型，同时利用待预测单词的上下文</p><p>缺点：对输入的破坏会导致预训练过程与微调存在差异，可能导致性能的波动</p></blockquote></li><li><p>XLNet的想法是，能否将这两种的优点结合起来，然后还能尽可能的避免其缺点，即</p><ul><li>在自回归模型的基础上如何引入双向语言模型</li><li>在自编码模型的基础上如何抛掉mask，是pre-training和fine-tuning一致</li></ul></li></ul><h3 id="XLNet详述"><a href="#XLNet详述" class="headerlink" title="XLNet详述"></a>XLNet详述</h3><ul><li><p>上面提到的问题是XLNet致力于解决的，并且在此基础上，XLNet还融合了transformer XL一些思路来获取更大范围的上下文</p></li><li><p>XLNet仍然是两阶段：</p><ul><li>LM的pre-training</li><li>针对下游任务的fine-tuning<h4 id="下面介绍一下XLNet中的主要“部件”"><a href="#下面介绍一下XLNet中的主要“部件”" class="headerlink" title="下面介绍一下XLNet中的主要“部件”"></a>下面介绍一下XLNet中的主要“部件”</h4></li></ul></li><li><p>PLM（Permutation Language Modeling，排列语言模型）</p><ul><li>在BERT中通过对mask的预测来捕获深层次的上下文信息，但是因此也带来了预训练和微调不一致的问题，XLNet该怎么做呢</li></ul><blockquote><p>首先要明确的是，不同于BERT是一种AE，XLNet是基于AR的</p><p>那么问题来了，AR是只能捕获一侧信息的，我们该怎么让它能够利用两侧的信息呢</p><p>思考一下，对于一个前向的AR模型，要预测第i个位置的token，如果我们在预测时既能看到上文的词，又能看到下文的词，是不是就能视作是利用了上下文的信息了。在此基础上，也就不需要mask操作了</p><p>那应该怎么做呢？</p><p>接上面的假设，对于第i个位置待预测的token，正常的情况下，前向AR可以看到的$[1, i-1]$的词。这里，我们的操作是，固定待预测的token，将其他的词进行排列。这样就可以用AR的单向方式来习得双向信息了</p><p>这就是排列语言模型的含义</p></blockquote><p><img src="XLNet%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%5Cxlnet2.png" alt="xlnet2"></p><ul><li>尽管最为直接的方式是对序列进行排序之后挑选一部分作为输入，但实际上这样是不允许的，因为你不能在fine-tuning的时候对原始序列进行排序，所以输入的必须还是原始序列，所以我们选择在transformer的内部利用<code>attention mask</code></li></ul><blockquote><p>比如对于序号为1234的句子，先随机取一种排列，比如是3241，根据这个序列我们可以做出下图的mask</p><p>解释一下，</p><p>在新的排列中，1在最后一个，所以根据前向AR的方式，1能看到234全部，所以第一行中的234未被mask</p><p>以此类推，第二行中，2在第二个，只能看到3，所以三的位置未被mask</p><p>。。。</p></blockquote><p><img src="XLNet%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%5Cxlnet1.png" alt="xlnet1"></p><ul><li>Two-stream Self-attention（双流自注意力机制）</li></ul></li></ul><blockquote><p>打乱了顺序后位置信息变得十分重要，同时对于每个位置来说，需要预测的是对应位置的词，于是输入就不能包含内容信息，否则模型就学习不到东西</p><p>于是这里就造成了位置信息与内容信息的割裂，因此在transformer中位置信息+内容信息输入Self-Attention的流之外，还增加了一个只有位置信息作为Self-Attention中query输入的流</p><p>这样，就能利用query stream在对需要预测位置进行预测的同时，又不会泄露当前位置的内容信息</p></blockquote><blockquote><p>具体操作就是用两组hidden state，g和h</p><p>其中g中只有位置信息，作为self-attention中的Q</p><p>h中包含内容信息，作为self-attention中的K和V</p></blockquote><p>  <img src="XLNet%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%5Cxlnet3.png" alt="xlnet3"></p><blockquote><p>如果模型只有一层的话，这样的Query stream就足够了，但是层数一旦多了之后，为了取得更高层的h，就需要Content Stream了。这时h同时作为Q、K、V</p></blockquote><p>  <img src="XLNet%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%5Cxlnet4.png" alt="xlnet4"></p><blockquote><p>对于上图，最下面的蓝色的content stream的输入是e(x)，就是x对应的词向量，不同的词对应不同的词向量</p><p>旁边的query stream，这个和后面的Relative Segment Encoding有关，之后细讲</p></blockquote><ul><li><p>Partial Prediction（部分预测）</p><blockquote><p>在排序后对每个位置进行预测的话，会导致优化过难，训练难以收敛。</p><p>所以作者就做了一个类似BERT的操作，即训练时只对每句话部分位置进行预测</p></blockquote></li></ul><ul><li><p>XLNet其实看起来更像一个大杂烩，它实际上融合了目前许多优秀的模型的特性</p><blockquote><p>通过PLM预测训练目标，吸收了BERT的双向语言模型</p><p>使用更多更有质量的预训练数据，这点与GPT2.0很像</p><p>transformer对长文档NLP应用不够友好，于是引入了transformer XL的部件来解决该问题</p><p>下面介绍一下在XLNet中用到的transformer XL中的部件</p></blockquote></li><li><p>transformer XL中的两个技巧</p><ul><li>Segment Recurrent Mechanism（段循环机制）</li></ul><blockquote><p>首先因为训练transformer时，会将文本按一定长度处理成segment（段），这样的话，模型时无法学习到更长的上下文信息的。</p><p>所以受RNN的启发，我们能否将前一段计算完成后，将其hidden state保存下来，在之后的分段计算时，将之前保存下来的hidden state和当前段的hidden state拼接起来作为Attention中的K和V，以此来获得更长的上下文信息</p></blockquote><p><img src="XLNet%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%5Cxlnet5.png" alt="xlnet5"></p><blockquote><p>对于上图，</p><p>该段的前面隐藏层的输出，对应图上的灰色线</p><p>前面短的隐藏层的输出，对应上图的绿色线，可以使模型创建长期依赖关系</p></blockquote><ul><li>Relative Position Encoding（相对位置编码）</li></ul><blockquote><p>如果在分段的情况下仍使用transformer的位置编码，会导致每段中的相同位置的位置编码是相同的</p><p>但实际情况是，这些段内相对位置相同的编码，对建模的贡献是不相同的；而且模型训练时也会产生歧义</p><p>此时就可以使用相对位置编码，不关心句中词的绝对信息，而是词与词之间有多少个词这样的相对信息</p></blockquote><ul><li>Relative Segment Encoding</li></ul><blockquote><p>类似于BERT中的NSP（next sentence prediction），这里也有类似的功能</p><p>XLNet提出了<strong>Relative Segment Encoding</strong>，因为以前BERT是直接分A、B句，每个句子有个segment embedding，XLNet借鉴了relative position的思想，<strong>只判断两个token是否在一个segment中，而不是判断他们各自属于哪个segment</strong>。</p><p>具体实现是在计算attention weight的时候，给query额外操作一波，算出一个额外的权重加到原本的权重上去，跟relative positional encoding差不多。</p><p>这样做的优点是之后可以处理更多的segments，而不是像BERT只能处理两个。</p></blockquote></li></ul><h3 id="与BERT的比较"><a href="#与BERT的比较" class="headerlink" title="与BERT的比较"></a>与BERT的比较</h3><ul><li>其实从本质看来，XLNet中的PLM和BERT中的mask是类似的，都是为了解决如和使用上下文信息的目的</li><li>区别在于<ul><li>Bert直接对输入端的序列进行mask操作，赋予mask标记</li><li>XLNet则是通过attention mask机制，在transformer内部进行操作，输入的还是原序列，并不会导致预训练和微调的差异</li></ul></li><li>另外，XLNet由于使用的AR语言模型，所以在生成式的NLP任务中会表现更好</li><li>因为引入了transformer XL中的机制，对于长文档输入的NLP任务，会比BERT更加优秀</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><p><a href="https://zhuanlan.zhihu.com/p/71916499" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/71916499</a></p></li><li><p><a href="https://github.com/NLP-LOVE/ML-NLP/tree/master/NLP/16.9%20XLNet" target="_blank" rel="noopener">https://github.com/NLP-LOVE/ML-NLP/tree/master/NLP/16.9%20XLNet</a></p></li><li><p>《XLNet-Generalized Autoregressive Pretrainingfor Language Understanding》</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 自然语言处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 论文笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>word2vec简单理解</title>
      <link href="/passages/word2vec-jian-dan-li-jie/"/>
      <url>/passages/word2vec-jian-dan-li-jie/</url>
      
        <content type="html"><![CDATA[<p>《Efficient Estimation of Word Representation in Vector Space》论文笔记</p><a id="more"></a><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><ul><li>这篇论文发表于2013年，那时的计算能力还不像现在这样，BERT这样超大的模型几乎是不可能的</li><li>在word2vec提出之前，使用的基本都是离散的文本表示，这种方式没有使用词与词之间的关系，可想而知性能也是比较差的</li><li>虽然在现在看来word2vec（CBOW和Skip-gram）无论从性能和技术本身来说已经比较过时了，但是整篇论文读下来还是被作者的许多比较精妙idea所折服</li><li>昨天组会师兄说，不要总是低头自己搞研究，要多抬头看看别人的工作思路，其中最值得借鉴的就是Google的研究人员们的工作思路了。我对此深以为然，确实真正的走在前列的人的思路能影响整个行业的发展。</li><li>我们知道，在ML中，真正决定整个模型的上限是数据，而算法只能无限接近这个上限</li><li>对于文本数据来说，最关键的就是对文本的表示。这里，我们暂且将其分为以下两种：<ul><li>文本的离散表示</li><li>文本的分布式表示<ul><li>基于矩阵的分布式表示</li><li>基于神经网络的分布式表示</li></ul></li></ul></li></ul><h3 id="文本的离散表示"><a href="#文本的离散表示" class="headerlink" title="文本的离散表示"></a>文本的离散表示</h3><h4 id="One-Hot编码"><a href="#One-Hot编码" class="headerlink" title="One-Hot编码"></a>One-Hot编码</h4><ul><li><p>对文本分词后构造无重复的集合，每个词占一位，值为0或1</p></li><li><p>每个词的表示是一个：该词的位置为1，其他位置为0的向量</p></li><li><p>例如：</p><blockquote><p>对于文本：我喜欢NLP。</p><p>分词结果：[我，喜欢，NLP]</p><p>词向量分别为[1, 0, 0], [0, 1, 0], [0, 0, 1]</p></blockquote></li></ul><h4 id="BOW（词袋模型）"><a href="#BOW（词袋模型）" class="headerlink" title="BOW（词袋模型）"></a>BOW（词袋模型）</h4><ul><li><p>对文本分词，统计每个词出现的次数，构建词袋（可以想象成字典）</p></li><li><p>句子的表示，向量中每个位置的值为对应的词出现的次数</p></li><li><p>例如：</p><blockquote><p>文本：我喜欢ML，我也喜欢NLP。</p><p>词袋{“我” : 2, “喜欢” : 2, “也” : 1, “ML” : 1, “NLP” : 1}</p><p>句子的表示为：[2, 2, 1, 2, 1, 2, 1]</p></blockquote></li></ul><h4 id="TF-IDF"><a href="#TF-IDF" class="headerlink" title="TF-IDF"></a>TF-IDF</h4><ul><li><p>这种方法的思想是：</p><blockquote><p>词的重要性随其在文档中出现的次数成正比例增加，同时会随其在整个语料库中不同文本中出现的次数而减少。</p><p>换言之就是，一个词在一个文档中出现越多并且在其他文档中出现的次数越少，说明该词越能代表该文章</p></blockquote></li><li><p>TF表示的是词频；IDF表示的是逆文本频率指数</p><blockquote><p>$$TF = \frac{某文本中w出现的次数}{文本中所有词的个数}$$</p><p>$$IDF = log \frac{文档总数}{包含w的文档数+1}$$，加1的目的是防止分母为0</p><p>$$TFIDF = TF*IDF$$</p></blockquote></li></ul><h4 id="n-gram"><a href="#n-gram" class="headerlink" title="n-gram"></a>n-gram</h4><ul><li><p>利用了滑动窗口的方式来进行“分词”，之后再进行词的频率的统计</p></li><li><p>例如：</p><blockquote><ul><li><p>对于文本：“见到你的那一刻，这些年承受的孤独都随风而逝了”</p></li><li><p>我们设置N=2</p></li><li><p>分词结果为</p><p>[“见到、你”, “你、的”, “的、那一刻”, “那一刻、这些年”, “”, “这些年、承受”, “承受、的”, “的、孤独”, “孤独、都”, “都、随风而逝”, “随风而逝、了”]</p></li><li><p>统计词频</p><p>{“见到、你” : 1, “你、的” : 1, “的、那一刻” : 1, “那一刻、这些年” : 1, “这些年、承受” : 1, “承受、的” : 1, “的、孤独” : 1, “孤独、都” : 1, “都、随风而逝” : 1, “随风而逝、了” : 1}</p></li><li><p>所以文本的表示为[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]</p></li></ul></blockquote></li></ul><h4 id="离散表示的缺点"><a href="#离散表示的缺点" class="headerlink" title="离散表示的缺点"></a>离散表示的缺点</h4><ul><li>无法利用词与词之间的关系</li><li>词表的维度过大</li><li>会导致生成的向量稀疏</li></ul><h3 id="分布式表示"><a href="#分布式表示" class="headerlink" title="分布式表示"></a>分布式表示</h3><ul><li>所谓分布是表示，就是利用词的上下文来表示词的语义</li></ul><h4 id="基于矩阵的的分布式表示"><a href="#基于矩阵的的分布式表示" class="headerlink" title="基于矩阵的的分布式表示"></a>基于矩阵的的分布式表示</h4><ul><li>比较经典的有“共现矩阵”</li><li><a href="http://www.zivblog.top/passages/glove-qian-xi/" target="_blank" rel="noopener">GloVe</a></li></ul><h4 id="基于神经网络的分布式表示"><a href="#基于神经网络的分布式表示" class="headerlink" title="基于神经网络的分布式表示"></a>基于神经网络的分布式表示</h4><ul><li><p>前馈神经网络语言模型（NNLM）</p><ul><li>该模型由输入层、投影层、隐藏层、输入层构成</li></ul><blockquote><p>在输入层，前N个使用one-hot编码，</p><p>接着输入层被投影到投影层</p><p>隐藏层用来对词典中所有词计算概率分布</p></blockquote><ul><li>对n元语言模型进行建模，定义一个前向窗口，把窗口的最后一个词作为y，前面的词作为x，使用前面的词来预测最后一个次出现的概率</li><li>训练过程中得到的中间产物——词向量矩阵，就是我们想要得到的文本表示向量矩阵</li></ul></li><li><p>循环神经网络语言模型（RNNLM）</p><ul><li>RNNLM可以突破NNLM的一些局限，可以更有效的表征更复杂的模型</li><li>没有投影层，只有输入层、隐藏层、输出层</li><li>使用时间延迟连接将隐藏层和自身连接的循环矩阵可以使模型能够利用过去的信息</li></ul></li><li><p>下面介绍本文的重点，CBOW和skip-gram</p></li><li><p>这两种模型将会使用尽可能小的计算复杂性来得到词的分布式表示</p><blockquote><p>通过之前的神经网络语言模型的分析，我们知道，大部分复杂性是由非线性隐藏层引起的</p><p>所以我们尝试使用更加简单的模型架构来学习词的分布式表示</p></blockquote><h5 id="CBOW"><a href="#CBOW" class="headerlink" title="CBOW"></a>CBOW</h5></li><li><p>架构类似于NNLM，但是移除了非线性隐藏层，并且投影层由所有词共享,因此所有词会被投影到相同的位置</p></li><li><p>换言之，</p><blockquote><p>CBOW就是使用中间词的上下文，使用上下文来预测中间的词，如图所示</p></blockquote><p><img src="word2vec%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%5Cwv1.png" alt="wv1"></p><blockquote><p>把中间词当作y，把窗口中的其他词当作x输入，x输入使用one-hot编码，</p><p>通过一个隐层进行求和操作，之后通过激活函数softmax，计算每个单词的生成概率</p><p>而求得的权重矩阵即为文本表示（词向量）</p></blockquote></li></ul><h5 id="skip-gram"><a href="#skip-gram" class="headerlink" title="skip-gram"></a>skip-gram</h5><ul><li><p>与CBOW相反，使用当前词作为带有连续的投影层的对数线性分类器的输入，然后预测当前词之前和之后一定范围内的词。</p><p><img src="word2vec%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%5Cwv2.png" alt="wv2"></p><blockquote><p>把中间词作为x，把窗口中的其他词作为y，通过一个隐层接一个softmax激活函数来预测其他词的概率</p></blockquote></li></ul><h5 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h5><ul><li>对每个local context window单独训练，并未利用包含在global co-occurence中的信息，后面提出了<a href="http://www.zivblog.top/passages/glove-qian-xi/" target="_blank" rel="noopener">GloVe</a></li><li>多义词无法处理，因为训练之后每个词的表示都确定下来了，为了解决该问题，后面提出了<a href="http://www.zivblog.top/passages/elmo-jian-dan-li-jie/" target="_blank" rel="noopener">ELMo</a></li></ul><h4 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h4><ul><li><p>层次softmax</p><blockquote><p>整篇文章读下来，就是在极致的减小计算量</p><p>而如果只是连接一个softmax的话，计算复杂度还是很高，为O(kh)，k是类别数量，h是文本特征的维度数</p><p>所以这里提出了层次softmax（Hierarchiacal softmax），</p><p>将输入层中的词和词组构成特征向量，再将特征向量通过线性变换映射到隐藏层，隐藏层通过求解最大似然函数，然后根据每个类别的权重和模型参数构建Huffman树，将Huffman树作为输出。最终可以将计算复杂度降到$O(hlog_2k)$</p><p>在使用n个训练样本进行训练时，根据每个类别出现的次数作为权重来见Huffman数，出现次数多的类别的样本，路径就会变短。</p></blockquote></li><li><p>负例采样</p><blockquote><p>在正确单词之外的负样本进行采样，最终目的就是为了计算量</p><p>比如语料库中有10w数据，如果每个神经元均要进行反向传播的话，计算代价太大。</p><p>正例对应的神经元肯定需要进行反向传播的，所以从负例中选择一部分神经元进行反向传播，以减少计算量。</p></blockquote><blockquote><ul><li><p>已知一个词w，它的上下文为context(w)，那么词w就是正例，其他词就是负例，但是这样来看负例太多了。</p></li><li><p>在语料中，每个词出现的频率是不一样的，采样的时候要保证频率高的要比频率低的词更容易被选中</p></li><li><p>随机数产生是均匀分布的，但是取词概率可不是均匀分布的，其概率随着词频大小变化</p></li></ul></blockquote><blockquote><p>如果词表的大小为V，我们就将一段长度为1的线段分成V份，但是每段的长度不同（词频不同）</p><p>每个词的线段长度由下式确定:</p><p>$$len(w) = \frac{count(w)^{3/4}}{\sum count(u)^{3/4}}$$</p><p>这样，每个词对应的线段都会划分成对应的小块，M份中的每一分都会落在某一个词对应的线段上。</p><p>采样的时候，我们是需要从M个位置中采样n个位置就行了，此时采样到的每一个位置对应到的线段所属的词就是我们的负例词</p></blockquote></li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li>《Efficient Estimation of Word Representation in Vector Space》</li></ul>]]></content>
      
      
      <categories>
          
          <category> 自然语言处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 论文笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GloVe浅析</title>
      <link href="/passages/glove-qian-xi/"/>
      <url>/passages/glove-qian-xi/</url>
      
        <content type="html"><![CDATA[<p>《Global Vectors for Word Representation》笔记</p><a id="more"></a><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><ul><li>这次换个形式，本文分为两部分<ul><li>第一部分对论文中提到的两个Related Work进行总结</li><li>第二部分按照作者自己的思路对GloVe的流程进行阐述（如果您发现作者在理解上有瑕疵，请及时指正）</li></ul></li></ul><h3 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h3><h4 id="Matrix-Factorization-Methods"><a href="#Matrix-Factorization-Methods" class="headerlink" title="Matrix Factorization Methods"></a>Matrix Factorization Methods</h4><ul><li>利用低秩近似来分解捕获关于语料库的统计信息的大矩阵</li><li>LSA（潜在语义分析）：矩阵是<code>term-document</code>类型的，即行对应<code>term</code>，列对应语料库中不同的文档</li><li>HAL（语言的超空间模拟）：矩阵是<code>term-term</code>类型的，即行列均对应单词，<code>entries</code>对应给定单词在另一个单词上下文中出现的次数</li><li>HAL相关的方法的一个主要问题是出现最频繁的单词对相似性度量的贡献不成比例</li></ul><h4 id="Shallow-Window-Based-Method"><a href="#Shallow-Window-Based-Method" class="headerlink" title="Shallow Window-Based Method"></a>Shallow Window-Based Method</h4><ul><li>这种方法是学习有助于在本地上下文窗口中进行预测的单词表示</li><li><code>shallow window-based</code>的方法的缺点在于他们不直接对语料库的共现统计数据进行操作，这种类型的模型只扫描corpus中的上下文窗口，这无法利用数据中大量的重复信息</li></ul><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><ul><li><p>说一下个人感受</p><blockquote><p>GloVe模型并没有严格的数学推导，所以其证明过程并不是完全意义上的等式证明</p><p>它更像是一个作者在自身经验的基础上提出的一个相对符合自然语言处理任务的模型</p><p>效果好就是王道</p></blockquote></li><li><p>首先，明确一些符号的含义</p><blockquote><p>$X_{ij}$：j在i的上下文中出现的次数</p><p>$X_i=\sum_k X_{ik}$：任意词在i上下文中出现的次数</p><p>$P_{ij}=P(j|i)=\frac{X_{ij}}{X_i}$：j在i上下文中出现的概率</p></blockquote></li><li><p>其次，还有一张图，也就是所谓的<code>Co-occurrence matrix</code>（共现矩阵）</p><p><img src="GloVe%E6%B5%85%E6%9E%90%5Cglove1.jpg" alt="glove1"></p></li></ul><ol><li><p>该如何利用这些<code>Prob</code>呢？</p><blockquote><p>​    在该图中<code>Prob</code>的值都比较大，但是考虑当句子很长的时候（包含的词很多），<code>Prob</code>的值会变得很小，这种很小的值所能表是的意义太少</p><p>​    所以我们考虑使用<code>Prob</code>的比值来扩大值的大小</p><p>​    比值的意义就是对比<code>i</code>上下文中出现的两个词与<code>i</code>的相关性的大小</p><p>​    <strong>例如</strong>：</p><p>​    $$\frac{P(k|ice)}{P(k|steam)} = \frac{0.7}{0.1} = 7$$</p><p>​    由于<code>Prob</code>都是在所在的数量级一般是相同的，所以比值一般会得到一个比较大的数</p></blockquote></li><li><p>该怎么解读<code>Prob</code>的比值呢？</p><blockquote><p>根据上面的例子</p><p>当<code>Prob</code>大于1的时候，说明<code>k</code>与<code>ice</code>的相关程度更高</p><p>当<code>Prob</code>近似于1的时候，说明<code>k</code>与<code>ice</code>和<code>steam</code>的相关程度相近</p><p>当<code>Prob</code>小于1的时候，说明<code>k</code>与<code>steam</code>的相关程度更高</p></blockquote></li><li><p>模型的建立与优化</p><blockquote><p>设<code>i,j,k</code>为三个word，$w_i,w_j,w_k$为三个word vector</p><p>模型假设为$F(w_i, w_j, w_k)=\frac{P_{ij}}{P{jk}}$，用于评估<code>i,j</code>分别与<code>k</code>的相关程度</p></blockquote><ol><li><p>用<code>i,j</code>的差异（做差）来反应<code>Prob</code>商的关系，则</p><p>$$F((w_i-w_j), w_k)= \frac{P_{ik}}{P_{jk}}$$</p></li><li><p>构造一种线性关系（点乘）</p><p>$$F((w_i - w_j)^Tw_k)=\frac{P_{ik}}{P_{jk}}$$</p></li><li><p>我们知道，<code>k</code>是<code>target word</code>，<code>i,j</code>是<code>context word</code>。而实际中，<code>k和i</code>以及<code>k和j</code>是<code>arbitrary</code>的。所以在标准是平衡的情况下，$X_{ij}$和$X_{ji}$的值应该是基本相等的，也就是说$X_{ij}$和$X_{ji}$是可随意交换的</p></li><li><p>我们假设</p><p>$$F((w_i-w_j)^Tw_k)=\frac{F(w_i^T w_k)}{F(w_j^T w_k)} = \frac{P_{ik}}{P_{jk}}=\frac{\frac{X_{ik}}{X_i}}{\frac{X_{jk}}{X_j}}$$</p></li><li><p>我们考虑是否有一个函数能将相减的表达式转化为相除，最直接的一个——指数函数。因此，令<code>F</code>为<code>exp</code>函数</p><p>$$w_i^T w_k = log(P_{ik})=log(\frac{X_{ik}}{X_i})=log(X_{ik})-log(X_i)$$</p></li><li><p>通过观察可以发现，$log(X_i)$与k是无关的，也就是说它是一个常数。既然是常数，那我们就可以通过在等式的左边添加一些bias来抵消掉，于是：</p><p>$$W_i^Tw_k + b_i +b_k = log(X_{ik})$$</p></li></ol></li><li><p>建立损失函数（优化）</p><ul><li><p>我们知道，模型优化的目的就是减小左式与右式之间的差距，使之尽可能的接近</p></li><li><p>所以我们构建相应的损失函数（加权最小二乘回归模型），通过最小化损失来完成该目标</p><p>$$J = \sum_{i,j=1} f(X_{ij}) (w_i^Tw_j+b_i+b_j - log(X_{ij}))^2$$</p></li><li><p>我们可以看到，其中的$log(X_{ij})$是可以直接统计得到的</p></li><li><p>其中，$f(X_{ij})$的表达式为</p><p><img src="GloVe%E6%B5%85%E6%9E%90%5Cglove2.png" alt="glove2"></p><p><img src="GloVe%E6%B5%85%E6%9E%90%5Cglove3.png" alt="glove2"></p><blockquote><p>$f(X_{ij})$需要满足三个特性：</p><ol><li>$f(0)=0$，f应该为连续函数</li><li>$f(x)$应该是非递减函数，这样<code>rare</code>的<code>co-occurences</code>不会过大</li><li>对于较大的x值，$f(x)$应该相对较小，防止<code>frequent</code>的<code>co-occurrences</code>不会过大</li></ol></blockquote></li></ul></li></ol><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li>《Global Vectors for Word Representation》</li></ul>]]></content>
      
      
      <categories>
          
          <category> 自然语言处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 论文笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GPT简单理解</title>
      <link href="/passages/gpt-jian-dan-li-jie/"/>
      <url>/passages/gpt-jian-dan-li-jie/</url>
      
        <content type="html"><![CDATA[<p>《Imporving Language Understanding by Generative Pre-Training》</p><p>《Language Models are Unsupervised Multitask Learners》</p><p>论文笔记</p><a id="more"></a><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><ul><li>GPT迄今为止已经有了两个版本，GPT1.0时候的性能已经足够出众，但是由于之后BERT更加出众的表现使GPT1.0并没有受到多大的关注</li><li>后面OpenAI的大牛们又提出了GPT2.0，GPT2.0相比于1.0最大的改进是扩大了模型的容量（参数数量），使用更大更优质的数据集，并且性能也有了很大的提升</li><li>下面做详细介绍</li></ul><h3 id="GPT-1-0"><a href="#GPT-1-0" class="headerlink" title="GPT 1.0"></a>GPT 1.0</h3><ul><li>GPT（Generative Pre-Training，生成式预训练），从名字就可以看出来，GPT必然会在生成式的任务重表现良好</li><li>GPT 1.0是在论文《Imporving Language Understanding by Generative Pre-Training》中提出来的</li><li>下面简要介绍一下GPT 1.0的思路</li></ul><blockquote><ul><li><p>GPT 1.0也是一种两段式的过程，即：</p><ul><li>先通过无标签的文本去训练生成语言模型</li><li>再用有标签的数据对模型进行微调</li></ul></li><li><p>相比于ELMo，GPT 1.0有两点改动</p><ul><li>特征抽取器使用的是transformer，而不是RNN</li><li>采用的是单向语言模型</li></ul></li></ul></blockquote><ul><li><p>因为使用了transformer，所以对特征有更好的抽取；但是使用单向的AR语言模型，没有很好的利用上下文的信息，所以会导致一定的性能下降</p></li><li><p>下面看一下训练过程</p></li></ul><blockquote><p>对于给定的无监督的语料的token序列$U = {u_1, …, u_{i-1}}$，模型训练的目标是最大化语言模型的极大似然函数</p><p>$$L_1(U) = \sum_i log P(u_i|u_{i-k},…u_{i-1}; \Theta)$$</p><p>我们使用一个多层的transformer的decoder作为语言模型：</p><p>输入为word embedding和token的位置信息</p><p>再第transformer_block的输出向量做softmax，输出为词的概率分布</p><p>$$h_0 = UW_e + W_p$$</p><p>$$h_l = transformer_block(h_{l-1})$$</p><p>$$P(U) = softmax(h_n W_e^T)$$</p></blockquote><ul><li>下面是fine-tuning（微调）</li></ul><blockquote><p>假设每一条数据为一个单词序列$x_1, … x_m$以及相应的标签$y$，通过之前预训练的模型获得输出向量$h^m_l$，再送入线性输出层，来预测$y$</p><p>$$P(y|x^1, … , x^m)=softmax(h_l^m W_y)$$</p></blockquote><h3 id="GPT-2-0"><a href="#GPT-2-0" class="headerlink" title="GPT 2.0"></a>GPT 2.0</h3><ul><li>GPT 2.0是在论文《Language Models are Unsupervised Multitask Learners》中提出的</li><li>下面简要介绍GPT 2.0结构和特性</li></ul><blockquote><ul><li><p>GPT 2.0与GPT 1.0相同，使用的仍是transformer的decoder构建的</p></li><li><p>GPT 2.0使用的仍是单向语言模型，这使它原生就适合生成式的任务</p></li><li><p>GPT 2.0仍是两段式的过程，即pre-training + fine-tuning</p></li><li><p>GPT 2.0针对下游任务进行微调时使用的是无监督的方式</p></li><li><p>它的主要改进是选择一条其他的路来强化BERT或者说是GPT1.0与训练阶段</p><ul><li>扩大了transformer的模型参数容量（通过加深层数，增加了参数个数）</li><li>使用更大的数据集来训练，这也是为什么要进行参数扩容的原因</li></ul></li></ul></blockquote><ul><li>与BERT的比较</li></ul><blockquote><ul><li>GPT 2.0使用的是transformer的decoder构建的，而BERT使用的是transformer的encoder构建的</li><li>GPT 2.0使用的仍是单向的AR语言模型，而BERT使用的事AE语言模型</li><li>GPT 2.0的微调阶段使用的是无监督的方式，而BERT使用的是监督的方式</li><li>相比于BERT，在预训练阶段采用了多任务的方式，不单单知识在一个任务上进行学习，并且每个任务均要保证其损失函数能够收敛，不同的任务共享主题transformer参数，能进一步提升模型的泛化能力，即便在没有进行微调的情况下依旧能够有不错的表现</li></ul></blockquote><ul><li>GPT 2.0给出了一种新的生成式任务的做法</li></ul><blockquote><p>在GPT 2.0出现之前，生成式的任务一边都是使用RNN、transformer，在输出端直接输出一个序列</p><p>而GPT2.0的方式是，就是一个词一个词往外蹦，然后拼接输出的内容作为结果（这种方式与语言模型的用法极其相似，所以GPT 2.0是否可以看作是一种性能出众的语言模型？）</p></blockquote><ul><li>为什么第二阶段不用有监督的方式进行微调？</li></ul><blockquote><p>对于这一点，参考网上一些大牛的说法</p><p>“感觉作者主要是为了证明第一阶段学习到了很多的只是，并且足够通用”</p></blockquote><ul><li>为什么预训练不使用双向语言模型</li></ul><blockquote><p>BERT之所以性能出众的原因就是其使用了双向的语言模型，按正常的思路来说使用双向语言模型应该会成为一种趋势，比如<a href="http://www.zivblog.top/passages/xlnet-jian-dan-li-jie/" target="_blank" rel="noopener">XLNet</a></p><p>参考网上一些大牛的说法</p><p>“GPT 2.0这样做的主要目的估计是为了与BERT进行比较，毕竟两者的最大差异就在于此。而且GPT2.0使用了另一种方式来赶超BERT，即提升模型容量和训练数据的大小”</p></blockquote><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li>《Imporving Language Understanding by Generative Pre-Training》</li><li>《Language Models are Unsupervised Multitask Learners》</li><li><a href="https://zhuanlan.zhihu.com/p/56865533" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/56865533</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 自然语言处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 论文笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ELMo简单理解</title>
      <link href="/passages/elmo-jian-dan-li-jie/"/>
      <url>/passages/elmo-jian-dan-li-jie/</url>
      
        <content type="html"><![CDATA[<p>《Deep contextualized word representations》论文笔记</p><a id="more"></a><h3 id="写在前面（Abstract、Introduction）"><a href="#写在前面（Abstract、Introduction）" class="headerlink" title="写在前面（Abstract、Introduction）"></a>写在前面（Abstract、Introduction）</h3><ul><li>深度学习的精髓在于<code>representation</code>，而在NLP任务中，相对应的就是<code>embedding</code>和<code>language model</code>任务</li><li>本文提出了一种利用双向LM学习的深层上下文的词表示（<code>deep contextualized word representation</code>）</li><li>作者认为一种好的<code>representation</code>模型需要包含两个特点：<ul><li>词语的用法在语义和语法上的复杂性特点</li><li>随上下文（语境）变化，词的含义要有所变化</li></ul></li><li>在本文提出的模型中，每个<code>word representation</code>都是整个输入语句的函数<ul><li>先在语料上以语言模型为模型训练出双向LSTM，然后利用LSTM生成词语的表征</li><li>在应用到下游任务中时<ul><li>先使用下游任务的（忽略标签的）语料库进行LM的微调</li><li>再利用有标签的语料库进行监督学习</li></ul></li></ul></li><li>ELMo表征是<code>deep</code>的，它是BiLM的所有层的内部表征，产生的<code>word representation</code>内涵的非常丰富的<ul><li>高层的LSTM可以捕获语境相关的特征</li><li>低层的LSTM可以捕获语法方面的特征</li><li>将其结合起来必然能丰富生成的表征的内涵</li></ul></li></ul><h3 id="简述（基于论文内容）"><a href="#简述（基于论文内容）" class="headerlink" title="简述（基于论文内容）"></a>简述（基于论文内容）</h3><h4 id="LM（Language-Model）"><a href="#LM（Language-Model）" class="headerlink" title="LM（Language Model）"></a>LM（Language Model）</h4><ul><li><p>ELMo（Embeddings from Language Model），从其名称可以看出来，模型是与语言模型相关的</p></li><li><p>FLM（forward language model，前向语言模型）</p><blockquote><p>给定一个序列$(t_1, … t_N)$，前向语言模型通过$t_k$之前的序列来预测$t_k$，可以表示为：</p><p>$p(t_1, … t_N) = \prod_{k=1}^{N}p(t_k|t_1, t_2, … t_{k-1})$</p></blockquote></li><li><p>BLM（backward language model，后向语言模型）</p><blockquote><p>给定一个序列$(t_1, … t_N)$，前向语言模型通过$t_k$之后的序列来预测$t_k$，可以表示为：</p><p>$p(t_1, … t_N) = \prod_{k=1}^{N}p(t_k|t_{k+1}, t_{k+2}, … t_{N})$</p></blockquote></li><li><p>BiLM（双向语言模型）</p><blockquote><p>双向语言模型结合了FLM和BLM两者的特点，对于给定的序列$(t_1, … t_N)$，对于任意待预测位置的token，通过其上下文进行预测</p><p>假设输入的token的词向量表示为$x_{k}^{LM}$，在每个位置k，每层LSTM都输出相应上下文的表示$h_{k,j}^{ \rightarrow LM}$ (j表示LSTM层数)。顶层的LSTM输出$h_{k,L}^{\rightarrow LM}$(L是最大层数)，通过softmax层来预测下一个$token$</p><p>对数似然函数表示如下：</p><p>$\sum_{k=1}^N(log p(t_k|t_1,…t_{k-1}; \Theta_x, \Theta^{\rightarrow}<em>{LSTM}, \Theta_s) + log p(t_k|t</em>{k-1}, … t_N;\Theta_x, \Theta^{\leftarrow}_{LSTM}, \Theta_s))$</p></blockquote></li><li><p>模型的结构图</p><p><img src="ELMo%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%5Celmo1.jpg" alt="elmo1"></p><blockquote><p>最底层是单词的word embedding</p><p>往上走是第一层双线LSTM中对应单词位置的embedding，这层编码单词的句法信息更多一些</p><p>再之上是第二层的LSTM中对应单词位置的embedding，这层编码的语义信息更多一些</p></blockquote></li><li><p>相比于之前的模型只使用最后一层的输出值来作为<code>word embedding</code>，ELMo将所有层的输出值进行线性组合用来作为<code>W E</code>的值，正因为如此，EMLo可以解决同一词的包含多个含义的问题，这个后面会细说</p></li></ul><h4 id="ELMo"><a href="#ELMo" class="headerlink" title="ELMo"></a>ELMo</h4><ul><li><p>对于每一个token，一个L层的BiLM要计算$2L+1$个表征</p><p><img src="ELMo%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%5Celmo2.png" alt="elmo2"></p></li><li><p>在下游任务中，会把$R_k$压缩成一个向量：</p><p>$ELMo_k^{task}$ = $E(R_k; \Theta^{task})$ = $\gamma^{task} \sum_{j=0}^L s_{j}^{task} h_{k, j}^{LM}$</p><ul><li>$ s^{task}_j$是softmax-normalized的权重</li><li>$\gamma^{task}$则允许不同的任务对ELMo向量进行缩放</li></ul></li><li><p>在论文中，作为最终用于实验的预训练模型，为了平衡语言模型之间的perplexity和下游任务的计算复杂度，使用了2层BiLSTM，并且第一层和第二层之间有残差</p></li><li><p>整个EMLo会为每个token提供一个三层的输出，而下游模型使用的是这三层输出的线性组合</p></li></ul><h3 id="一点想法"><a href="#一点想法" class="headerlink" title="一点想法"></a>一点想法</h3><ul><li>上面的内容是根据论文的顺序和内容写的一点笔记（摘抄+翻译），下面说一下读过论文之后的一点想法</li><li>EMLo模型的特点从其论文题目中就可以体会到，“deep”和“context”，其中后者更为关键</li><li>在此之前的<code>word embeddings</code>是一种静态的方式，也就是说在预训练之后，每个token的表示就完全固定住了，并不会因为出现的上下文的不同而改变表示。很明显这有巨大缺陷。</li><li>还有一点来说，ELMo词的表示是学习的范围更广，在一定程度上更能表示一个词的意思</li><li>而EMLo是怎么做的呢，事先用一个语言模型学习一个单词的<code>Word Embedding</code>，此时多义词还无法区分，但是在使用的过程中，会随时根据词所在的上下文调整单词的表示，也就解决了多义词，或者说是歧义的问题。</li><li>因为ELMo给下游提供的是每个单词的特征形式，所以这类预训练的方法被称为”Feature-based Pre-train”</li><li>还有另一种预训练方法是”fine-tuning Pre-train”，之前文章中的<a href="http://www.zivblog.top/passages/bert-jian-dan-li-jie/" target="_blank" rel="noopener">BERT</a>就是基于该方法的</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li>《Deep contextualized word representations》</li><li><a href="https://www.cnblogs.com/huangyc/p/9860430.html" target="_blank" rel="noopener">https://www.cnblogs.com/huangyc/p/9860430.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 自然语言处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 论文笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BERT简单理解</title>
      <link href="/passages/bert-jian-yao-li-jie/"/>
      <url>/passages/bert-jian-yao-li-jie/</url>
      
        <content type="html"><![CDATA[<p>《BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding》论文笔记</p><a id="more"></a><h3 id="BERT是什么"><a href="#BERT是什么" class="headerlink" title="BERT是什么"></a>BERT是什么</h3><ul><li>BERT全称<code>Bidirectional Encoder Representation from Transformers</code>，即双向的<code>Transformer</code>编码器</li><li>模型主要的创新点都在<code>pre-train</code>上<ul><li>使用<code>MLM（Masked LM）</code>捕捉词语级别的<code>representation</code></li><li>使用<code>Next Sentence Prediction</code></li></ul></li><li>BERT的贡献点在于<ul><li>效果极好，刷新了很多NLP任务的最好性能</li><li>广泛的通用性（本身的特性决定它可以经过微调适用于很多下游任务）</li></ul></li></ul><h3 id="简述（基于论文内容）"><a href="#简述（基于论文内容）" class="headerlink" title="简述（基于论文内容）"></a>简述（基于论文内容）</h3><ul><li><p>语言模型的预训练对于NLP任务来说是十分重要的</p></li><li><p>当前预训练语言模型的方式有两种</p><ul><li>基于特征的预训练方式，例如<a href="http://www.zivblog.top/passages/elmo-jian-dan-li-jie/" target="_blank" rel="noopener">ELMo</a></li><li>基于微调的预训练方式，例如<a href="http://www.zivblog.top/passages/gpt-jian-dan-li-jie/" target="_blank" rel="noopener">GPT</a></li></ul></li><li><p>接下来我们要介绍的BERT，是一种基于微调的预训练语言模型</p></li><li><p>BERT主要包含两部分：</p><ul><li>pre-training</li></ul><blockquote><p>使用无标记的数据进行预训练</p></blockquote><ul><li>fine-tuning</li></ul><blockquote><p>使用与训练模型的参数作为模型的初始化参数</p><p>根据不同的下游任务的标记数据对所有参数进行调整</p><p>在微调过程中，除了输出层，其他层的结构不变</p></blockquote></li><li><p>关于BERT的预训练分为两块（BERT的主要创新点）：</p><ul><li>Masked LM（像是完型填空）</li></ul><blockquote><p>很明显，深度双向模型的性能要高过单一的left-to-right和right-to-left的浅层模型，</p><p>但是，标准语言模型只能从左往右或从右往左进行训练</p><p>为了进行deep bidirectional representation的训练，我们简单的mask掉一部分的input token</p><p>如果只是简单的mask掉一些token，会导致pre-training和fine-tuning之间的不匹配问题，因为在下游任务重fine-tuning时是不需要mask掉token的</p><p>为了减小这种不匹配的程度，我们对mask做了一些改善，对于确定要进行mask操作的token，有以下三种处理方式：</p><ol><li>80%的几率直接mask掉</li><li>10%的几率用随机的token代替</li><li>10%的几率使用</li></ol><p>在进行完mask操作之后，就可以使用其所在的上下文对mask掉的token进行预测（使用交叉熵损失函数）</p></blockquote><ul><li>Next Sentence Prediction</li></ul><blockquote><p>许多下游任务基于对句子间的关系的理解，而这些关系是无法通过LM进行捕获的</p><p>这里设计了一个根据一个句子生成下一个句子的任务</p><p>训练集的构建：</p><ol><li>句子对A和B，50%的几率是真实的前后句，label为IsNext</li><li>50%的几率不是前后句，label为NotNext</li></ol></blockquote></li></ul><ul><li><p>关于fine-tuning</p><blockquote><p>对于每一个下游任务，我们将任务特殊的Input和Output放入BERT中，并且微调每一个参数</p></blockquote></li><li><p>迁移策略</p><blockquote><p>BERT将大量传统的下游具体任务中的操作转移到预训练LM上，在预训练之后，只需加上不同的输出层并进行微调，就可以实现各种任务</p><p>与之相似的，在图像领域，很多模型都会迁移ImageNet的参数等</p></blockquote></li><li><p>BERT的输入表示</p><p><img src="BERT%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%5Cbert1.png" alt="bert1"></p><blockquote><p>从图示可以看出，</p><p>对于给定的输入，其输入表示有三部分的embedding组成：</p><ol><li>token的embedding，表示的是词向量，第一个是CLS标志（classification，即分类符）</li><li>segment的embedding，用来区分两种句子，因为预训练有时要接受sentence pairs作为输入</li><li>Position的embedding，这个是transformer中要用到的，具体可以看一下tansformer的那片<a href="http://www.zivblog.top/passages/transformer-jian-dan-li-jie/" target="_blank" rel="noopener">文章</a></li></ol></blockquote></li></ul><h3 id="说一点感受"><a href="#说一点感受" class="headerlink" title="说一点感受"></a>说一点感受</h3><ul><li>MLM的工作原理是从输入中随机掩盖掉一些词，目的是基于其上下文来预测被掩盖的原始词汇，MLM允许representation融合上下文，这就使双向transformer得以应用。而transformer编码器并知道到它真正要预测的单词是哪些（并且按照论文中提到的操作，除了被掩盖掉，还有随机替换和不改变这两种方式），所以必须对每个输入保持分布式的上下文表示。</li><li>MLM中，随机替换的词只有15%*10%=1.5%，所以对于文章的原意并没有很大的影响，不会影响模型对于语言的理解</li><li>因为transformer有self-attention机制，所以可以理解为BERT自带双向功能</li><li>因为双向功能的存在，必须使用MLM来完成token级别的预训练</li><li>为了得到句子级别的语义表征，加入了NSP，与MLM联合训练</li><li>由于mask在实际应用中，mask不会出现，所以需要尽量减小预训练是mask操作带来的影响，论文取了15%。也就是说每个batch中只有15%用来做预测，所以BERT的收敛速度会很慢</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li>《BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding》</li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> 自然语言处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 论文笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Pointer_Networks》笔记</title>
      <link href="/passages/zhi-zhen-wang-luo/"/>
      <url>/passages/zhi-zhen-wang-luo/</url>
      
        <content type="html"><![CDATA[<p>Pointer Network</p><a id="more"></a><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><ul><li>在学习segbot的时候接触到了指针网络，遂找了一下提出指针网络的开山之作《Pointer Network》</li><li>作者对PtrNet的了解到现在也只是论文中原始版本的模型，之后一些应用场景下的变体还未做深入了解</li><li>望不吝赐教，谢谢</li></ul><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><ul><li>简单来说，PtrNet是一种使用的Attention机制的网络结构，能够计算一个由目标序列指向源序列的指针序列</li><li>它能有效的解决当前文本序列生成模型的三个问题<ul><li>目标序列的词表和源序列的词表强相关，这就意味着面对不同的任务或者特定的环境，需要构建相应的词表</li><li>传统S2S问题中，输出向量的长度往往是词表的长度。词表的长度是固定的，不能处理动态变长序列，长度作为超参数需要提前指定。每次超参数的修改都需要重新训练模型</li><li>许多场景下不允许OOV（Out Of Bag）的存在</li></ul></li></ul><h3 id="模型详述"><a href="#模型详述" class="headerlink" title="模型详述"></a>模型详述</h3><ul><li><p>首先介绍一下attention机制中的对齐系数</p><blockquote><p>在之前的文章<a href="http://www.zivblog.top/passages/attention-ji-zhi-jian-dan-zong-jie/" target="_blank" rel="noopener">《Attention机制简单总结》</a>中，我们有简单介绍过对齐的作用和操作方式</p><p>以机器翻译为例，源序列与目标序列中的词并不是顺序对应的，所以需要由控制的使其对应起来，这就是对齐</p><p>说白了，对齐其实讲的就是一种相似度，是input和output对应位置的相似度</p></blockquote></li><li><p>回到PtrNet，从上面的介绍我们知道了，对齐系数表示的其实是<strong>目标序列当前时刻</strong>和<strong>源序列所有时刻</strong>之间的相关性大小。很显然，既然相关性不一样，直觉上我们当然会选择相关性最大的。而这里再通过一个softmax，将目标序列当前时刻的对齐向量标准化，则对其向量中值最大的那个维度就是“Pointer”，只想源序列中与当前时刻相关性最大的词。</p></li><li><p>这样，解码器的每一个时刻我们都能从源序列中抽取出一个进行输出（例如阅读理解任务），并不需要构建词表，也就解决了词表需要重构的问题</p></li><li><p>而且，解码器的输出是一个指针序号的序列，并不是具体的词，所以也不会出现OOV问题</p><p><img src="/.top//%E3%80%8APointer-Networks%E3%80%8B%E7%AC%94%E8%AE%B0%5Cpn1.png" alt="pn1"></p><blockquote><p>看一下模型的示意图吧</p><p>左边绿色的部分是输入序列，右边紫色的部分是输出序列</p><p>传统的Attention是将对齐向量和hidden state组合为context vector再求概率分布作为Attention层的输出</p><p>而PtrNet则是直接将对齐向量a通过softmax，指向输入序列中最有可能是输出的元素</p><p>上面的箭头就是所谓的“Pointer”，指向最有可能的输出</p></blockquote></li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li>《Pointer Networks》</li><li><a href="https://zhuanlan.zhihu.com/p/73590690" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/73590690</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文笔记 </tag>
            
            <tag> Artificial Intelligence </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见的模型评估标准</title>
      <link href="/passages/chang-jian-de-mo-xing-ping-gu-biao-zhun/"/>
      <url>/passages/chang-jian-de-mo-xing-ping-gu-biao-zhun/</url>
      
        <content type="html"><![CDATA[<p>常见的模型评估标准</p><a id="more"></a><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><ul><li>平时做比赛和看论文的时候会看到一些模型的评估参数，都是碰到了再查，今天下定决心整理一下，给之后的工作省点劲</li><li>本文分为两块：<ul><li>以西瓜书为主要参考资料的模型评估标准论述</li><li>以<a href="https://www.cntofu.com/book/170/readme.html" target="_blank" rel="noopener">scikit-learn中文文档</a>为主的相关函数使用方法</li></ul></li></ul><h3 id="模型评估标准方法"><a href="#模型评估标准方法" class="headerlink" title="模型评估标准方法"></a>模型评估标准方法</h3><ul><li><p>留出法</p><blockquote><p>简单来说就是将训练数据集划分为互斥的两部分，一部分用来训练模型，一部分用来评估模型的性能</p><p>需要注意的是：</p><ol><li>训练集和测试集要保持数据的分布一致，从划分数据集时采样的方法来看，可以使用“分层采样”</li><li>另外，数据集的划分也存在很多种可能，所以一般都要使用多次留出法对模型进行评估，最后将均值作为评估的结果</li><li>此外，划分为两部分的数据集在规模上不宜相差过大，一般取2/3~4/5作为训练集，剩余的用作测试</li></ol></blockquote></li><li><p>交叉验证法</p><blockquote><p>在了解留出法之后，理解交叉验证就会容易很多了</p><p>交叉验证的思想是：</p><ol><li>将数据集划分为k个<strong>大小相同</strong>的<strong>互斥</strong>的数据集</li><li>使用其中k-1个数据集进行训练，使用剩余的一个作为测试集进行测试</li><li>从而进行k次训练和测试，最终返回的是k个测试结果的均值</li></ol><p>它还存在一种特殊情况：k=样本个数，这种划分方式我们称为“留一法”</p><p>需要注意的是：</p><ol><li>数据集划分的时候为了保证各个子集之间数据分布一致，使用“分层采样”</li><li>数据集的划分存在多种可能，一般要使用多次交叉验证，最后将均值返回</li><li>留一法在数据集较大的时候不适用，因为会十分显著的增加计算成本</li></ol></blockquote></li><li><p>自助法</p><blockquote><p>以上两种方法在模型的训练过程中，并没有使用全部的数据，为了解决这个问题，提出了“自助法”</p><p>自助法：</p><ol><li>对于数据集D，对齐进行随机放回的下采样，建立$D^{&#39;}$</li><li>使用D用来训练模型，使用$D^{&#39;}$来进行测试</li></ol><p>值得注意的是：</p><ol><li>自助采样仍会一定程度上改变初始数据的分布，对测试结果有一定的影响</li><li>所以在初始数据量足够的情况下，使用留出法和交叉验证法比较好</li></ol></blockquote></li></ul><h3 id="模型性能评估"><a href="#模型性能评估" class="headerlink" title="模型性能评估"></a>模型性能评估</h3><ul><li><p>错误率与精度</p><ul><li>错误率是分类错误的样本占样本总数的比例</li><li>精度是分类正确的样本占样本总数的比例</li></ul></li><li><p>混淆矩阵</p><p><img src="/.top//%E5%B8%B8%E8%A7%81%E7%9A%84%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E6%A0%87%E5%87%86%5Cpinggu1.png" alt="pinggu1"></p><blockquote><p>先解释一下各个值代表的含义：</p><ol><li>TP：表示被正确分类的正样本的个数</li><li>FP：表示被错误分类的负样本的个数</li><li>FN：表示被错误分类的正样本的个数</li><li>TN：表示被正确分类的负样本的个数</li></ol></blockquote><ul><li>直观来讲，我们希望TP与TN的数量越大越好，而FP与FN的数量越小越好</li><li>针对混淆矩阵，又提出了四个二级指标：<ul><li>Accuracy（准确率）= $\frac{TP+TN}{TP+TN+FP+FN}$：模型判断正确的结果占总观测值的比重</li><li>Precision（精确率）= $\frac{TP}{TP+FP}$：在模型预测是正例的结果中，预测正确的比重</li><li>Sensitivity（灵敏度） = Recall（召回率）= $ \frac{TP}{TP+FN}$：在真实值是正例的所有结果中，模型预测对的比重</li><li>Specificity（特异度）= $ \frac{TN}{TN+FP}$：在真实值是负例的所有结果中，模型预测对的比重</li></ul></li><li>针对上面四个指标，又提出了三级指标：<ul><li>F1-score = $\frac{2<em>Precision</em>Recall}{Precision + Recall}$：综合和精确率与召回率产出的结果</li></ul></li></ul></li><li><p>ROC与AUC</p><ul><li>ROC和AUC是一个从整体上评价二分类模型性能的指标</li><li>其中AUC（Area Under Curve）是坐标系中AUC曲线下面的面积</li><li>ROC根据真阳率和假阳率分别作为纵坐标和横坐标<ul><li>真阳率表示正样本被预测为正样本的比例，记为TPR</li><li>假阳率表示负样本被预测为正样本的比例，记为FPR</li></ul></li><li>从图形的角度来看，我们希望真阳率越大越好，假阳率越小越好，也就是曲线越上凸越好</li><li>AUC的值越大越好</li></ul></li></ul><h3 id="调包指南"><a href="#调包指南" class="headerlink" title="调包指南"></a>调包指南</h3><h4 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a>交叉验证</h4><ul><li><p>使用train_test_split对数据集进行划分</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"></span><br><span class="line">iris = datasets.load_iris()</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(iris.data, iris.target, test_size=<span class="number">0.25</span>, random_state=<span class="number">0</span>)</span><br></pre></td></tr></table></figure></li><li><p>验证集的准备和使用</p><ul><li>如果将数据集划分为：训练集、验证集、测试集，就会导致训练数据不足，因此这里可以使用交叉验证来实现</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"></span><br><span class="line">clf = SVC(kernel=<span class="string">'linear'</span>, C=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># cv是整数时，使用k-fold</span></span><br><span class="line">scores = cross_val_score(clf, iris.data, iris.target, cv=<span class="number">5</span>)<span class="comment">#5-fold</span></span><br><span class="line">print(scores)</span><br><span class="line"></span><br><span class="line"><span class="comment"># cv还可以详细设置数据集划分</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> ShuffleSplit</span><br><span class="line">cv = ShuffleSplit(n_splits=<span class="number">3</span>, test_size=<span class="number">0.3</span>, random_state=<span class="number">0</span>)</span><br><span class="line">scores = cross_val_score(clf, iris.data, iris.target, cv=cv)</span><br><span class="line">print(scores)</span><br></pre></td></tr></table></figure></li><li><p>学习到其他奇技淫巧，随时更新</p></li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li>西瓜书，《机器学习》周志华</li><li>scikit-learn中文文档</li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Artificial Intelligence </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Transformer简单理解</title>
      <link href="/passages/transformer-jian-dan-li-jie/"/>
      <url>/passages/transformer-jian-dan-li-jie/</url>
      
        <content type="html"><![CDATA[<p>《Attention is all you need》</p><a id="more"></a><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul><li>传统的序列转换模型都是基于包含Encoder和Decoder的复杂的循环神经网络</li><li>比较好的模型都是在Encoder和Decoder之间使用attention连接</li><li>在此基础上，Google的Ashish Vaswani们提出了完全基于attention的网络结构——transformer</li><li>在机器翻译中有很好的表现，并且并行性更好，训练时间也大大的减少了</li></ul><h3 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h3><h4 id="为什么使用transformer"><a href="#为什么使用transformer" class="headerlink" title="为什么使用transformer"></a>为什么使用transformer</h4><ul><li>在之前的模型中，关联任意两个输入和输出位置的信号所需要的操作次数都会随位置之间距离的增加而变得困难，所以会导致学习相隔较远距离的两个位置之间的依赖性变得十分困难，transformer中，将这种操作减少到了固定次数</li><li>而且因为使用了Multi-head attention，可以进行并行计算了</li></ul><h4 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h4><ul><li><p>Transformer是一种基于encoder-decoder结构的模型</p></li><li><p>在论文中</p><blockquote><p>编码器：</p><ol><li><p>由6个相同的层堆叠在一起，每层有两个子层，第一个子层是一个多头的自注意机制，第二层是一个简单的全连接前馈神经网络</p></li><li><p>另外两个子层外面都添加了一个残差链接，然后进行了层标准化的操作</p></li></ol><p>解码器：</p><ol><li>堆叠了6个相同的层，在编码器原有的两层之前加入了Masked Multi-Head Attention</li><li>同样也有残差连接和层标准化</li></ol></blockquote><p><img src="/.top//transformer%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%5Ctransformer1.PNG" alt="transformer1"></p><blockquote><p>这是论文中的给出的结构图，我们来一步步的看一下它的详细执行过程：</p><p>在Encoder中：</p><ol><li>Inputs在经过input embedding之后，再做positional encodings</li><li>之后要经过Multi-head attention</li><li>在经过position-wise Feed Forward</li><li>每个子层之间有残差连接</li></ol><p>在Decoder中：</p><ol><li>相比与Encoder，除了position encodings，Multi-head attention和position-wise Feed Forward之外，还有Masked Multi-head attention</li><li>最后还要经过Linear和Softmax输出概率</li></ol></blockquote></li></ul><h4 id="子结构介绍"><a href="#子结构介绍" class="headerlink" title="子结构介绍"></a>子结构介绍</h4><ul><li><p>Multi-head attention和Self attention都已经在上一篇文章中有所介绍了，<a href="http://www.zivblog.top/passages/attention-ji-zhi-jian-dan-zong-jie/" target="_blank" rel="noopener">详细请看</a></p></li><li><p>接下来说一下positional encodings</p><blockquote><p>我们知道，不管是翻译还是其他文本相关的任务中，序列本身的位置信息是十分有用的。</p><p>而在transformer中，我们并没有使用任何的循环或者卷积，也就没有捕获到文本的序列信息。</p><p>所以我们要将token（序列中的字符或者词）的相对及绝对位置信息以另一种方式注入到模型中去。</p><p>所以这里使用到了positional encoding，也就是位置编码。</p><p>位置编码与token的embeddings的维度相同，所以可以<strong>直接相加</strong></p><p>也可以选择将位置编码和token的embeddings<strong>拼接起来</strong></p><p><strong>2019.11.29 更新</strong></p><p>我们构造的位置编码公式如下：</p><p>$$PE_{2i}(p)=sin(\frac{p}{10000^{\frac{2i}{d_{pos}}}})$$</p><p>$$PE_{2i+1}(p)=cos(\frac{p}{10000^{\frac{2i}{d_{pos}}}})$$</p><p>$d_{pos}$表示的是词嵌入的长度，我们需要构造一个相同长度的$PE$</p><p>其中，p表示词的位置，$PE_i(p)$表示第p个词位置向量汇总的第i个元素的值，然后将词向量与位置向量直接加和</p><p>指的注意的是，该向量中不仅包含了<strong>绝对位置信息</strong>，由于：</p><p>$$sin(a+b)=sinasinb+cosacosb, cos(a+b)=cosacosb-sinasinb$$</p><p>所以位置$p+k$的位置向量可以表示为位置p向量的线性变换，使得<strong>相对位置信息</strong>也得到的表示</p></blockquote></li><li><p>残差模块</p><blockquote><p>在上面的结构图中我们可以发现，在每个编码器中的每个子层的周围都有一个残差连接</p><p>残差的好处在于，由输入x得到输出f(x)变为由输入x得到输出f(x)+x，在对x求偏导是，加入常数项1，不会产生梯度消失的问题</p></blockquote></li><li><p>Masked Multi-head attention</p><blockquote><p>masked的用法说来简单，就是对序列中对当前没用的位置的值进行掩盖，使其不起作用</p><p>在multi-head attention中使用到了padding mask：</p><ol><li>在我们输入的每句话长度不同，所以要对较短的数据进行长度补齐（一般是用0），这些填充值并没有什么作用，所以需要masked掉</li><li>具体做法是，在填充位置上加上一个趋近于负无穷的数，经过softmax之后，这些位置的概率就会趋近于0，也就是达到了mask的目的</li></ol><p>在decoder输入数据中使用了sequence mask：</p><ol><li>预测t时刻的输出值$y_t$时，应该使用全部的输入序列和输出序列的$(y_1, … y_{t-1})$，所以训练的时候，就需要将t-1时刻之后的信息全部隐藏掉</li><li>具体做法是使用一个上三角矩阵，上三角全为1，下三角全为0，对角线值为0.与输入序列相乘，就达到了目的</li></ol></blockquote></li><li><p>最终的线性变换和Softmax层</p><blockquote><p>解码的组件最后会输出一个实数向量，我们现在面临的问题就是如何把浮点数变成一个单词</p><p>线性变换层是一个简单的全连接神经网络，它可以把解码组建产生的响亮投射到一个比它大的多的对数几率向量中</p><p>比如说我们的模型从训练集中学习了10000个不同的单词，那么对数几率向量就是长度为10000的向量——每个单位长度对应一个单词的分数</p><p>接下来的Softmax层便是把这些分数转化成概率，概率最高位置对应的单词就会被选做该时刻的输出</p></blockquote></li></ul><h3 id="三种不同方式使用的Multi-head-Attention"><a href="#三种不同方式使用的Multi-head-Attention" class="headerlink" title="三种不同方式使用的Multi-head Attention"></a>三种不同方式使用的Multi-head Attention</h3><ul><li>encoder-decoder的attention，query来自之前的decoder，keys和values来自encoder的输出。这使得解码器中每个位置能关注到输入序列的所有位置</li><li>在encoder中含有self-attention，在self-attention中，所有的keys，values，queries均来encoder之前一层的输出</li><li>decoder的self-attention层也一样，不同的是，在scaled dot attention操作中，加了一个masked的操作，保证softmax操作之后不会将非法的values连到attention中</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li>《Attention is all you need》</li><li><a href="https://spaces.ac.cn/archives/4765/comment-page-1" target="_blank" rel="noopener">https://spaces.ac.cn/archives/4765/comment-page-1</a></li><li><a href="https://www.cnblogs.com/huangyc/p/9813907.html" target="_blank" rel="noopener">https://www.cnblogs.com/huangyc/p/9813907.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文笔记 </tag>
            
            <tag> Artificial Intelligence </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Attention机制简单总结</title>
      <link href="/passages/attention-ji-zhi-jian-yao-zong-jie/"/>
      <url>/passages/attention-ji-zhi-jian-yao-zong-jie/</url>
      
        <content type="html"><![CDATA[<p>Attention机制简单总结</p><a id="more"></a><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><ul><li><p>按照许多介绍Attention机制的博客的惯例，都会以图像领域的例子作为引子，这里也仿照诸位前辈的套路，对Attention做感性的认识。</p></li><li><p>实际上，Attention机制刚开始就是应用在图像领域中，并且取得了很好的效果，后来就有人尝试将Attention引入NLP领域中</p></li><li><p>以人的注意力机制为例，当我们看到一幅画的时候，我们虽然能够看到画的全貌，但是在深入观察的时候，眼睛真正聚焦的只是其中的画的一部分，也就是说，人脑对整幅画面的关注程度是不均衡的。用更形式话的语言来说就是——对于画面的不同局部，在人脑中成像时所占的权重是不同的。这种权重的思想就是AM的核心。</p></li><li><p>Attention Model在NLP中最早应用的领域是机器翻译。简单来说就是在Decode的时候，由于不同语言语法或者表述上的不同，每个时刻翻译的输出对应输入序列的不同局部，并且并不是顺序对应的，这时候利用Attention机制就很容易能够完成这项工作了。</p></li><li><p>Attention机制在NLP领域中有很广泛的应用，并且出现了很多变体，这里会尽可能全面的去介绍一下。本人才疏学浅，有遗漏或者表述错误的地方烦请指正。</p></li><li><p>如有侵权，请联系删除或注明</p></li></ul><h3 id="Attention的一个通用的定义"><a href="#Attention的一个通用的定义" class="headerlink" title="Attention的一个通用的定义"></a>Attention的一个通用的定义</h3><ul><li>给定一组向量集合values，以及一个向量query，attention机制就是一种根据query计算values的加权求和的机制</li><li>Attention的重点就是每个value的权值的计算。相对应的，权值大的就意味着关注程度高，对于当前输出有更高的作用。</li><li>换言之，Attention机制是根据一些规则或者附加信息，对向量集合中抽取向量进行加权求和。</li><li><del>更简单粗暴一点的讲，**只要我们从向量中选取部分向量进行的加权求和，我们就使用的Attention</del>**</li><li>更正：Attention与求和没有关系，重点是权重分配，也就是部分向量对于当前任务是积极的还是消极的</li></ul><h3 id="翻译任务中的Attention"><a href="#翻译任务中的Attention" class="headerlink" title="翻译任务中的Attention"></a>翻译任务中的Attention</h3><ul><li><p>核心思想：目标语言的每一个字应该是它在源语言中每个字的不同权重的加权和</p></li><li><p>在Encoder-Decoder结构中，Encoder会把所有的输入序列编码成统一的语义特征C在进行解码，因此，C中必须包含原始序列的全部信息，而它的长度就限制了存储信息的能力，也就限制了翻译的质量。</p></li><li><p>Attention机制在其中的应用方式就是，在每个时刻输入不同的C（不同的加权和）来解决只有一个C时<strong>信息存储能力不足</strong>的问题</p><p><img src="/.top//Attention%E6%9C%BA%E5%88%B6%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93%5Cattention1.jpg" alt="attention1"></p></li><li><blockquote><p>对于上图来说，就是在Encoder和hidden之间了一层Attention，每一个$c_i$都会自动选取与当前索要输出的y最和是的上下文信息</p><p>而如何来选择合适的上下文信息呢，这就直接与权重（姑且以$a_{ij}$来表示）相关了，而权重是通过模型训练得到的</p></blockquote><p><img src="/.top//Attention%E6%9C%BA%E5%88%B6%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93%5Cattention2.png" alt="attention2"></p></li></ul><ul><li><blockquote><p>对于机翻的Attention机制，我们做更进一步的解释：</p><ol><li>在Encoder的过程中保留每个隐藏状态（$h_1, … , h_n$）</li><li>对于Decoder的每一个时刻，此时能得到Decoder的输入和上一步的隐藏状态输出，所以可以得到当前步的隐藏状态，记为$S_t$</li><li>在每一步进行$S_t \cdot h_i$的到attention score —— 对应图中第二层</li><li>利用Softmax将attention score转化为概率分布（和为的概率） —— 对应第三行</li><li>按照得到的概率分布，计算Encoder和hidden states的加权和。这里得到的$Attention_t$就是Decoder在t时刻的注意力向量了</li></ol></blockquote></li></ul><h3 id="Attention机制的诸多变体"><a href="#Attention机制的诸多变体" class="headerlink" title="Attention机制的诸多变体"></a>Attention机制的诸多变体</h3><h4 id="Self-attention"><a href="#Self-attention" class="headerlink" title="Self-attention"></a>Self-attention</h4><ul><li><p>出自《Attention is all you need》，该文章还提出了tranformer模型，我会尝试在<a href="http://www.zivblog.top/passages/transformer-jian-dan-li-jie/" target="_blank" rel="noopener">另一篇文章</a>中简单介绍一下</p><p><img src="/.top//Attention%E6%9C%BA%E5%88%B6%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93%5Cattention3.png" alt="attention3"></p></li></ul><blockquote><ol><li><p>序列中每一字符对其上下文字符的影响作用都不尽相同，每个字对序列的语义信息贡献也不同，可以通过一种机制将源输入序列中字符向量通过加权的方式，融合所有字符的语义向量信息来产生新的向量，从一定程度上增强了语义信息</p></li><li><p>对于输入文本，我们对其中的每个字分别增强语义向量表示：</p><ol><li>我们将每个字作为Query， 每一个文字由成对的&lt;key, value&gt;构成，它们都来自编码层</li></ol></li><li><p>Self-Attention = $Attention(X, X, X)$，也就是说再序列内部做attention，寻找序列内部的关系</p></li></ol></blockquote><blockquote><p><strong>2019.11.1 更新</strong></p><p>可以想到的是，在增加了self-attention之后，模型能更好的捕获句子长距离的相互依赖特征。因为self-attention是跨越距离直接将两个句子联系起来，而不是像RNN和LSTM那样通过会有遗忘的问题。</p></blockquote><blockquote><p><strong>2019.11.29 更新</strong></p><p><img src="/.top//Attention%E6%9C%BA%E5%88%B6%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93%5Csf.png" alt="sf"></p><ul><li>对于每一个<code>self-attention</code>，均有独立维护的的三个线性映射矩阵$（W_i^V, W_i^K, W_i^Q）$</li><li>将输入的矩阵X与三个映射矩阵相乘，得到self-attention的三个输入Querys、Keys、Values</li><li>用Query和Keys的点积计算所有单词相对于当前词的得分score，该分数决定在编码该单词时其他单词给予了多少贡献</li><li>将score除以向量维度的平方根，在对其进行softmax归一化。这样对于每个单词都会获得所有单词对该单词编码的贡献分数，当然当前单词将获得最大分数，但也会关注其他单词的贡献大小</li><li>对于得到的socre，我们将其乘以每一个对应的value向量，即对所有向量加权求和，最后的输出就是self-attention对该向量的输出</li></ul></blockquote><ul><li>这里额外解释一下Query、Key、Value的传统含义</li></ul><blockquote><ol><li>Query从字面意思来讲，就是查询，查询“我与你们的相似度是多少？”</li><li>Key是键，即Query要比较的值，</li><li>Value是值，与Key一一对应，</li><li>Query与key相似度为a，即Value的权重（通过$Softmax(q_t \cdot k_s)$，得到$q_t$与$v_s$的相似度，再加权求和）</li></ol><p>当Query来自解码层，Key、Value来自编码层时，就是最基本的attention</p><p>当Query和Key、Value均来自编码层时，就是我们这里讲的Self-Attention了，因为它计算的事序列内部的依赖关系</p></blockquote><blockquote><p><strong>2019.10.23 更新</strong></p><p>self-attention计算得到的分数值，决定了我们在某位置encode一个词的时候，对句子其他部分的关注程度，比如一些代词与其真正实体间对应关系</p></blockquote><h4 id="Multi-head-Attention"><a href="#Multi-head-Attention" class="headerlink" title="Multi-head Attention"></a>Multi-head Attention</h4><ul><li><p>对于Scaled dot-product attention，只是除以了一个$\sqrt{d_k}$，以防止softmax进入梯度极小的区域</p><p>$$Attention(Q, K, V) = softmax(\frac{QK^T}{\sqrt{d_k}})V$$</p></li><li><p>而Multi-head Attention是，从一个向量$q_t$出发</p><p><img src="/.top//Attention%E6%9C%BA%E5%88%B6%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93%5Cattention4.png" alt></p><p>$$Attention(q_t, K, V) = \sum^m_{s=1} \frac{1}{z}exp(\frac{&lt;q_t, k_s&gt;}{\sqrt{s_k}})v_s$$</p><p>$$head_i = Attention(QW^Q_i, KW^K_i, VW^V_i)$$</p><p>$$MultiHead(Q, K, V) = Concat(head_1, …, head_h)$$</p></li><li><p>注意，这里并行计算的多个Scaled Dot-Product Attention之间的参数是不共享的</p></li><li><blockquote><p><strong>2019.11.29 更新</strong></p><ul><li>Linear可以看作是一个没有激活函数的全连接层，各自维护了一个线性映射矩阵</li><li><code>multi-head attention</code>即并行多个<code>self-attention</code></li><li>对于每个<code>self-attention</code>的输出进行简单的拼接，并与一个映射矩阵相乘，从而得到整体矩阵的输出</li></ul><p>参考：<a href="https://www.cnblogs.com/sandwichnlp/p/11612596.html" target="_blank" rel="noopener">https://www.cnblogs.com/sandwichnlp/p/11612596.html</a></p></blockquote></li></ul><ul><li>从两个方面提高了注意力层的性能：<ul><li>扩展了模型专注于不同位置的能力</li><li>给出了注意力层的多个表示子空间</li></ul></li></ul><h4 id="Soft-Attention"><a href="#Soft-Attention" class="headerlink" title="Soft Attention"></a>Soft Attention</h4><ul><li>所谓Soft，就是在求Attention的概率分布的时候，对于句子中的任意一个单词都给出一个概率</li><li>也就是说Soft是给每个单词都赋予了一个单词对齐概率</li></ul><h4 id="Hard-Attention"><a href="#Hard-Attention" class="headerlink" title="Hard Attention"></a>Hard Attention</h4><ul><li>与Soft Attention相对比来说，Hard Attention并没有为每个单词赋予一个对齐概率</li><li>它的做法是，直接从句子中找到某个特定的单词，然后把目标句子单词和这个单词堆砌，而其他输入句子中的单词硬性地规定其对齐概率为0</li><li>这种方式明显不够灵活，代价太高</li><li>并且已经被证明在图像领域可行，而在文本领域作用不大</li></ul><h4 id="Global-Attention"><a href="#Global-Attention" class="headerlink" title="Global Attention"></a>Global Attention</h4><ul><li>在解码过程中，每一时刻的上下文向量都需要计算Encoder中每一个单词（所谓的Global）的Attention权重，再加权得到</li></ul><h4 id="Local-Attention"><a href="#Local-Attention" class="headerlink" title="Local Attention"></a>Local Attention</h4><ul><li>首先找到一个对齐位置，在对齐位置左右大小固定的窗口内（所谓的Local）计算注意力权重，最终加权得到上下文向量</li></ul><h4 id="静态-Attention"><a href="#静态-Attention" class="headerlink" title="静态 Attention"></a>静态 Attention</h4><ul><li>对一个文档或者句子，计算每个词的Attention分布，然后加权得到一个向量来表示这个文档或者句子的向量表示</li><li>区别与Soft Attention，静态Attention只计算一个得到句子的向量表示</li></ul><h3 id="后面想到的"><a href="#后面想到的" class="headerlink" title="后面想到的"></a>后面想到的</h3><p><strong>2019.11.1更新</strong></p><p><img src="/.top//Attention%E6%9C%BA%E5%88%B6%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93%5Cattention6.jpg" alt="attention6"></p><blockquote><p>浅析一下attention的本质思想：</p><p>将source中的构成元素想象成是由一系列&lt;key, value&gt;数据对组成</p><p>如上图所示，给定target中的某个元素的Query，通过计算Query与各个key（K）的相似性与相关性，得到每个key对应value的权重稀疏，然后对value进行甲醛求和，即最终的attention值</p><p>而对于attention计算的第一阶段，计算相似度的方式有多种，常见的有：点积、cosin相似性、MLP网络</p></blockquote><p><img src="/.top//Attention%E6%9C%BA%E5%88%B6%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93%5Cattention5.png" alt="attention5"></p><blockquote><p>Attention的计算过程如上图所示，</p><ul><li>首先根据Q和K计算权重权重系数<ul><li>根据Q和K计算相似性</li><li>利用softmax进行归一化处理</li></ul></li><li>根据权重对value加权求和</li></ul></blockquote><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://www.jianshu.com/p/6b2e586f9256" target="_blank" rel="noopener">https://www.jianshu.com/p/6b2e586f9256</a></li><li><a href="http://www.360doc.com/content/18/0506/06/36490684_751494854.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/18/0506/06/36490684_751494854.shtml</a></li><li><a href="https://blog.csdn.net/hahajinbu/article/details/81940355" target="_blank" rel="noopener">https://blog.csdn.net/hahajinbu/article/details/81940355</a></li><li><a href="https://blog.csdn.net/mpk_no1/article/details/72862348" target="_blank" rel="noopener">https://blog.csdn.net/mpk_no1/article/details/72862348</a></li><li>《Attention is all you need》</li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Artificial Intelligence </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GRU的简单理解与实现</title>
      <link href="/passages/gru-de-jian-dan-li-jie-yu-shi-xian/"/>
      <url>/passages/gru-de-jian-dan-li-jie-yu-shi-xian/</url>
      
        <content type="html"><![CDATA[<p>GRU的简单理解与实现</p><a id="more"></a><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><ul><li>之前介绍了传统的<code>RNN</code>和<code>LSTM</code>，<code>GRU</code>可以看作是<code>LSTM</code>的一种变体，它相较于<code>LSTM</code>网络结构更加简单，因此训练起来更加快速。</li><li><code>GRU</code>是<code>LSTM</code>的变体，所以解决的也是<code>RNN</code>中的长距离依赖问题</li><li><code>GRU</code>模型只有两个门：更新门（<code>update gate</code>）和重置门（<code>reset gate</code>）</li></ul><h3 id="门控神经网络（GRU）"><a href="#门控神经网络（GRU）" class="headerlink" title="门控神经网络（GRU）"></a>门控神经网络（GRU）</h3><ul><li><p>下面依次介绍<code>GRU</code>模型中的更新门和重置门</p><p><img src="/.top//GRU%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0%5Cgru1.png" alt="gru1"></p><p>​                                                图片来自参考资料1的论文配图</p><p><img src="/.top//GRU%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0%5Cgru2.png" alt="gru2"></p><p>​                                                            图片来自网络</p></li><li><p><strong>更新门</strong></p><blockquote><p>首先，更新门的作用类似与LSTM中的遗忘门和输入门，决定要丢弃哪些信息以及添加哪些新信息</p><p>在上图中，z表示的是更新门，更新门的值越大说明前一时刻的状态信息带入的越多</p><ol><li>$$h^j_t = (1-z^j_t)h^j_{t-1} + z^j_t \widetilde{h}^j_i$$</li></ol><p>t时刻的激活$h^j_t$是先前激活$h^j_{t-1}$与候选激活$\widetilde{h}^j_i$之间的线性插值</p><ol start="2"><li>$$z^j_t = \sigma(W_z x_t + U_zh_{t-1})^j$$</li></ol><p>$z^j_t$是更新门，用于决定unit更新其激活或者内容的程度</p><ol start="3"><li>$$\widetilde{h}^j_i = tanh(W_rx_t + U(r_t \odot h_{t-1}))^j$$</li></ol><p>候选激活，计算方式和传统RNN单元类似</p><p>这种在现有状态和新的计算状态之间进行线性求和的过程类似于LSTM的单元，但是GRU没有任何机制可以控制其状态的暴露程度，每次整个状态都会暴露</p></blockquote></li><li><p><strong>重置门</strong></p><blockquote><p>重置门决定是否忘记过去的信息</p><p>在上图中，r表示的是重置门，重置门的值越小，说明忽略的信息越多</p><p>当重置的门趋近于0的时候，该单元相当于读取序列的第一个元素，也就是会完全遗忘掉之前的计算状态</p><ol><li>$$r^j_t = \sigma(W_rx_t+U_rh_{t-1})^j$$</li></ol><p>计算方式类似于更新门</p></blockquote></li><li><p>以上就是GRU模型的unit介绍</p></li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleGRU</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, input_size, hidden_size, output_size, num_layers=<span class="number">1</span>)</span>:</span></span><br><span class="line">        super(SimpleLSTM, self).__init__()</span><br><span class="line"></span><br><span class="line">        self.hidden_size = hidden_size</span><br><span class="line">        self.num_layers = num_layers</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 三层神经网络</span></span><br><span class="line">        self.embedding = nn.Embedding(input_size, hidden_size)</span><br><span class="line">        self.gru = nn.GRU(hidden_size, hidden_size, num_layers, batch_first=<span class="literal">True</span>)</span><br><span class="line">        self.fc = nn.Linear(hidden_size, output_size)</span><br><span class="line">        self.softmax = nn.LogSoftmax(dim=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, input, hidden_size)</span>:</span></span><br><span class="line">        x = self.embedding(input)</span><br><span class="line"></span><br><span class="line">        output, hidden = self.lstm(x, hidden)</span><br><span class="line">        output = output[:, <span class="number">-1</span>, :]</span><br><span class="line"></span><br><span class="line">        output = self.fc(output)</span><br><span class="line">        output = self.softmax(output)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> output, hidden</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initHidden</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 对隐含层单元的初始化</span></span><br><span class="line">        hidden = Variable(torch.zeros(self.num_layers, <span class="number">1</span>, self.num_layers))</span><br><span class="line">        <span class="comment"># 对隐含单元内部的状态cell的初始化</span></span><br><span class="line">        cell = Variable(torch.zeros(self.num_layers, <span class="number">1</span>, self.hidden_size))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (hidden, cell)</span><br></pre></td></tr></table></figure><ul><li>如果只是对<code>GRU</code>和<code>LSTM</code>来说的话，一方面<code>GRU</code>的参数更少，因而训练稍快或需要更少的数据来泛化。另一方面，如果你有足够的数据，<code>LSTM</code>的强大表达能力可能会产生更好的结果。</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li>《Empirical Evaluation of Gated Recurrent Neural Networks on Sequence Modeling》</li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Artificial Intelligence </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>支持向量机相关数学知识简介</title>
      <link href="/passages/zhi-chi-xiang-liang-ji-xiang-guan-shu-xue-zhi-shi-jian-jie/"/>
      <url>/passages/zhi-chi-xiang-liang-ji-xiang-guan-shu-xue-zhi-shi-jian-jie/</url>
      
        <content type="html"><![CDATA[<p>支持向量机相关数学知识简介</p><a id="more"></a><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><ul><li>接上文，这篇文章主要对支持向量机中涉及到的一些数学概念的整理，有表述错误指出还请指正</li><li>本文主要介绍以下几个知识点<ul><li>什么是凸优化问题</li><li>拉格朗日乘子法及KKT条件</li><li>slater条件</li><li>SMO算法的简单介绍</li></ul></li></ul><h4 id="凸优化问题"><a href="#凸优化问题" class="headerlink" title="凸优化问题"></a>凸优化问题</h4><ul><li><p>首先要说一下什么最优化问题</p><blockquote><p>在机器学习等任务中，最主要的任务就是优化，也就是通过使用训练数据对机器学习算法中的参数进行训练，使模型的性能变得更好。那么进行参数更新的时候以什么为标准呢，那就是损失最小化；而损失最小化就是一个优化问题。</p></blockquote></li><li><p>什么是凸优化问题</p><ul><li><p>定义</p><blockquote><p>$minimize f(x)$</p><p>$subject$ $to$ $g_i(x) &lt;= 0, i=1,…,m$</p><p>​            $h_i(x) = 0, i=1,…p$</p><p>简单来说就是，目标函数$f(x)$需要是凸函数，变量所属的集合是凸集合（凸集合指的是集合内任意两个点之间的连线，连线上的点都在集合内部）</p></blockquote></li><li><p>为什么是凸优化</p><blockquote><p>凸优化有着很好的性质，凸优化问题的局部最优解就是全局最优解</p><p>也就是说，凸函数的任意局部极值点也是全局极值点</p></blockquote></li></ul></li></ul><h4 id="Lagrange乘子法及KKT条件"><a href="#Lagrange乘子法及KKT条件" class="headerlink" title="Lagrange乘子法及KKT条件"></a>Lagrange乘子法及KKT条件</h4><ul><li><p>什么是Lagrange乘子法</p><blockquote><p>Lagrange乘子法是一种寻找变量受一个或多个条件限制时的多元函数极值的方法</p><p>该方法将一个有n个变量和k个约束条件的最优化问题转化为一个有n+k个变量的方程组的极值问题，转化后的问题的变量不受约束</p><p>例，下图</p></blockquote><p><img src="/.top//%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E7%9B%B8%E5%85%B3%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%AE%80%E4%BB%8B%5Cmath1.png" alt="math1"></p></li><li><p>KKT条件</p><ul><li><p>对于有不等式约束的优化问题，需要满足三个条件，满足这三个条件之后的函数的解就是极小值点</p><blockquote><p>这三个条件就是KKT条件：</p><p>给定优化问题：$min f(x)$，subject to $g(x) &lt;= 0$</p><p>则对应拉个朗日问题为：$L(x, \alpha) = f(x) + \alpha g(x)$</p><p>要满足：</p><p>$\nabla_x L(x^*, \alpha^*) =\nabla f(x^*) + \alpha^* \nabla g(x^*)=0$ ： 偏导为0</p><p>$g(x) &lt;= 0$ ： 约束条件满足原条件</p><p>$\alpha^* &gt;= 0$ ： 拉格朗日乘子非负</p><p>$\alpha^* c(x^*) = 0$ ： 乘子为0或约束至少一个为0</p><p>这就是所谓的KKT条件</p></blockquote></li></ul></li><li><p>注意</p><blockquote><p>如果优化问题是优化问题的话，KKT条件就是极小值点（全局极小）存在的充要条件，也就是求出来的解就是最小值点</p><p>如果优化问题不是凸优化问题，KKT条件知识极小值点存在的必要条件，KKT点是驻点，可能是极值点</p></blockquote></li></ul><h4 id="Slater条件"><a href="#Slater条件" class="headerlink" title="Slater条件"></a>Slater条件</h4><blockquote><p>Slater的官方定义为：存在x，使不等式约束$g(x) &lt;= 0$严格成立</p><p>也就是说，当slater条件成立且原问题是凸优化问题时，强对偶性成立（强对偶性指的是原问题（最小化）的最优值与对偶问题（最大化）的最优值相等）</p><p>因此，满足slater的凸优化问题可以转化为其对应的对偶问题进行求解</p></blockquote><h4 id="SMO简单介绍"><a href="#SMO简单介绍" class="headerlink" title="SMO简单介绍"></a>SMO简单介绍</h4><ul><li><p>SMO是针对求解SVM问题的Lagrange对偶问题</p></li><li><p>在SVM的对偶问题中，我们最后求解的变量只有一堆拉格朗日乘子，该算法的基本思想就是每次只选取一对$(\alpha_i,\alpha_j)$，</p></li><li><p>首先要明确的是，最小化的凸优化问题被我们转化成了最大化的对偶问题</p></li><li><p>对偶问题的二次规划表述如下：</p><blockquote><p>$max \sum_{i=1}^n \alpha_i - \frac{1}{2}\sum_{i=1}^n \sum{j=1}^{n} \alpha_i \alpha_j y_i y_j x^T_i x_j$</p><p>$s.t. \sum_{i=1}^n \alpha_i y_i = 0$</p><p>$\alpha_i &gt;= 0, i = 1,2,…,n$</p></blockquote></li><li><p>SMO在整个二次规划中只做了两件事</p><ul><li>选取一对参数$(\alpha_i, \alpha_j)$</li><li>固定其他$\alpha $，将$(\alpha_i, \alpha_j) $代入上述表达式进行求最优解，获得更新后的$(\alpha_i, \alpha_j )$</li><li>不断执行这两个步骤直至收敛</li></ul></li><li><p>根据上面的介绍，我们知道KKT条件是对偶问题最优解的必要条件</p><blockquote><p>除了拉个朗日乘子非负的约束外，其他条件都是根据目标函数推导得到的最优解必须满足的条件，</p><p>如果违背了这些条件，那得到的解必然不是最优解，目标函数的值会减小</p><p>所以在SMO的迭代中，$(\alpha_i, \alpha_j )$其中如果有一个违背了KKT条件，一轮迭代后，目标函数必然会增大</p><p>也就是说，KKT条件违背的程度越大，迭代后的优化效果越明显</p></blockquote></li><li><p>所以</p><blockquote><p>为了找到优化程度最大的方向进行优化，SMO先选取违背KKT条件程度最大的变量，第二个变量选择使目标函数值增大最快的变量</p><p>如何找到使目标函数值增大最快的变量呢，SMO使用了一个启发式的方法，当确定了第一个变量之后，选择使两个变量对应样本之间最大的变量作为第二个变量。</p><p>直观上来说，就是更新两个差别很大的变量会给目标函数带来更大的变化</p></blockquote></li></ul><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><ul><li>以上是我在学习SVM的过程中对相关数学概念的简单了解，尚未进行深入的学习</li><li>希望对大家有帮助</li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Artificial Intelligence </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dropout浅析</title>
      <link href="/passages/dropout-qian-xi/"/>
      <url>/passages/dropout-qian-xi/</url>
      
        <content type="html"><![CDATA[<p>Dropout浅析</p><a id="more"></a><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><ul><li>在第一次接触到<code>dropout</code>的时候，就被其极具智慧的思路所折服，这真的是一种能让人眼前一亮的想法</li><li>在写这篇文章之前，我查阅过多种形式的资料，有视频，有博客，有书籍。在这里记录一些学习过程中的注意点和思路以供后来者学习查阅</li><li>我会尽量详尽的去阐述我对该方法的想法，有不详细或错误的地方欢迎指出</li></ul><h3 id="Dropout的提出"><a href="#Dropout的提出" class="headerlink" title="Dropout的提出"></a>Dropout的提出</h3><ul><li>2012年，<code>Hintion</code>大佬在论文<code>《Improving neural networks by preventing co-adaptation of feature detectors》</code>正式提出了<code>dropout</code>。</li><li>2012年，有是<code>Hinton</code>，还有<code>Alex</code>首次在其论文<code>《ImageNet Classification with Deep Convolutional Neural Networks》</code>中使用了<code>dropout</code>方法，并且凭借该论文提出的<code>AlexNet</code>获得了当年的图像识别冠军。</li></ul><h3 id="Dropout提出的原因"><a href="#Dropout提出的原因" class="headerlink" title="Dropout提出的原因"></a>Dropout提出的原因</h3><ul><li>我们知道，神经网络一般包含巨量的参数，这样就要求要有大量的训练数据来对这些权重进行训练，但是这也带来了两个问题：<ul><li>当数据量充足的时候，训练可以进行，但是极其耗费时间</li><li>当数据量与模型的复杂程度不匹配的时候，就会导致模型过拟合，缺乏泛化能力</li></ul></li></ul><h3 id="Dropout的功能"><a href="#Dropout的功能" class="headerlink" title="Dropout的功能"></a>Dropout的功能</h3><ul><li><p>为了解决上面阐述的两个问题，我们提出了<code>Dropout</code>，它理所应当要解决这些问题，下面一一阐述</p></li><li><p>对于与神经网络复杂程度不匹配的数据集规模（网络的复杂程度大于数据集规模），很容易导致过拟合，所以采取以下措施：</p><blockquote><p>对每个训练样本，采用dropout的方法，随机让一部分神经元失效，以此来减少过拟合的程度</p><p>具体做法是：</p><ol><li>训练阶段，每次更新参数之前，每个神经元有一定的概率被丢弃，假设为p%。这里需要注意，输入层的神经元要尽可能的保留</li><li>测试阶段，去掉dropout，所有神经元都保留。这里要注意要乘以(1-p)%，具体原因之后解释</li></ol></blockquote></li><li><p>通过模型融合的方式（多个基训练器共同决策）可以提高模型的性能，但是对于神经网络来说，单独训练多个不同的模型的代价太大，而且训练多个模型对训练数据的需求也是极大的；而且由于模型太复杂，即使是多个完整的网络模型融合，还会带来一个新的问题，就是决策的响应时间太长，不利用应用。于是：</p><blockquote><ol><li><p>由于dropout每次都丢弃部分神经元，可以视作每次都训练了一个不同形状的神经网络</p></li><li><p>最后测试阶段去掉dropout后，可以视作将多个模型进行融合</p></li><li><p>也就是说，加了dropout来训练的网络模型，可以视作另一种形式的集成学习，每一个batch训练的都是不同的基分类器</p></li></ol></blockquote></li><li><p>下面通过图片来直观感受一下</p><p><img src="/.top//Dropout%E6%B5%85%E6%9E%90%5Cd4.png" alt="d4"></p><blockquote><p>本图表示的是完整的神经网络</p><p>画红X的表示这部分神经元会在本轮训练中暂时“失效”</p></blockquote><p><img src="/.top//Dropout%E6%B5%85%E6%9E%90%5Cd1.png" alt="d1"></p><blockquote><p>本图表示的是不同的训练轮次中，由于“丢弃”不同的神经元而导致神经网络变化成的不同的形状</p></blockquote><p><img src="/.top//Dropout%E6%B5%85%E6%9E%90%5Cd2.png" alt="d2"></p><blockquote><p>测试过程中，由于不使用dropout，神经网络又变成了完整的形状</p></blockquote><p><img src="/.top//Dropout%E6%B5%85%E6%9E%90%5Cd3.png" alt="d3"></p><blockquote><p>这张图回答了之前留下的小问题：为什么要乘(1-p)%</p><p>直观的就是，之前参与训练的都是保留下来的神经元（被保留的概率是(1-p)%），所以求loss和反向传播的时候都是(1-p)%z，为了保证输出期望一致，在启用所有神经元的时候也要乘(1-p)%</p></blockquote></li></ul><h3 id="为什么Dropout能解决过拟合问题"><a href="#为什么Dropout能解决过拟合问题" class="headerlink" title="为什么Dropout能解决过拟合问题"></a>为什么Dropout能解决过拟合问题</h3><ul><li><p><strong>通过类似取平均的方式减缓过拟合</strong></p><blockquote><p>我们考虑，使用相同的训练数据去训练多个不同的神经网络，对于几个网络的结果，我们可以通过<strong>投票</strong>或者<strong>取平均</strong>的方式来进行最终结果的判定</p><p>因为综合了多个网络的判定结果，能通过多个不同网络对不同结果的相互抵消来减轻整体上的过拟合</p></blockquote></li><li><p><strong>减少神经元之间复杂的共适应关系</strong></p><blockquote><p>在不使用dropout的时候，相邻的或者说是相关的多个神经元在更新权值的时候会相互影响以取得更好的结果。</p><p>这种方式虽然能够使模型在训练集上表现的很好，但是在测试集或者其他数据上，这种共适应关系会成为模型泛化的障碍</p><p>而使用了dropout之后，由于两个神经元不一定每次都同时出现，权值的更新会更加客观，减轻拥有隐含依赖的节点对整体的影响</p><p>从另一个角度来说，这种方式选择性的主动丧失对某些特征的敏感程度来增加鲁棒性</p></blockquote></li></ul><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><ul><li>在全连接神经网络中，dropout被大量的使用，通常设置为0.5或者0.3</li><li>而卷积神经网络的隐藏层由于其自身的部分连接特性，<code>dropout</code>使用的并不是很多</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li>《Improving neural networks by preventing co-adaptation of feature detectors》</li><li>《一天搞懂深度学习》李宏毅</li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Artificial Intelligence </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CNN理解及简单实现</title>
      <link href="/passages/cnn-de-li-jie-ji-jian-dan-shi-xian/"/>
      <url>/passages/cnn-de-li-jie-ji-jian-dan-shi-xian/</url>
      
        <content type="html"><![CDATA[<p>CNN理解及简单实现</p><a id="more"></a><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><ul><li>在前面<a href="http://www.zivblog.top/passages/RNN及LSTM理解/" target="_blank" rel="noopener">RNN及LSTM理解</a>中，我们思考了为什么要使用神经网络，并且列举了几点好处：<ul><li>自动提取特征</li><li>数据格式的简易性</li><li>调参工作量大大减小</li></ul></li><li>但是实际上并不会有十全十美的东西，也不会有适合与所有问题的解决方案。虽然神经网络在当下的许多任务中表现的十分优秀，但是它也存在一些缺点，下面我们就一起来思考一下<ul><li>首先，随着我们不断加深神经网络的层数，每个网络层都会增加大量的神经元，与此同时带来的参数也会快速增长。我们知道，参数越多模型就越复杂，而复杂模型带来的问题也有很多<ul><li>其一，模型容易过拟合</li><li>其二，大量参数的学习需要大量的数据为支撑</li><li>其三，传统神经网络来说，层数一旦太深，就容易随着反向传播的不断迭代，梯度越来越小，最终梯度趋于0的时候，神经元的权值无法更新，也就相当于对应的神经源并不起作用，同时也很难收敛</li></ul></li><li>其次，由于神经网络内部是一个黑盒，人们并不能对内部工作的具体细节进行有效的解释</li><li>最后，耗时耗力，参数多意味着需要大量数据来训练，巨大的训练量也需要很长的训练时间和昂贵的硬件设备</li></ul></li><li>暂时就想到这些，后面会继续补充</li></ul><h3 id="卷积神经网络（CNN）"><a href="#卷积神经网络（CNN）" class="headerlink" title="卷积神经网络（CNN）"></a>卷积神经网络（CNN）</h3><ul><li>卷积神经网络的最大特征就是它所包含的卷积计算，所以，卷积神经网络是一类<strong>包含卷积计算的具有深度结构的前馈神经网络</strong>。</li><li>卷积神经网络具有表征学习能力，能够按照其阶层结构对输入信息进行平移不变分类（来自“百度百科”）。被广泛应用到计算机视觉（CV）和自然语言处理（NLP）等领域</li><li>卷积神经网络可以进行监督学习和非监督学习，其隐含层的卷积和参数共享和层间连接的稀疏性使得卷积神经网络能够以较小的计算量对格点化特征（如像素和音频）进行学习，并且对数据没有额外特征工程的要求（来自“百度百科”）</li><li>卷积神经网络被应用到各个领域，像物体分割、风格转换等，但是CNN真正的作用就是一个特征提取器，这就是为什么在很多任务中，在CNN之后都要加各种神经网络的原因了。</li></ul><h4 id="为什么使用卷积神经网络"><a href="#为什么使用卷积神经网络" class="headerlink" title="为什么使用卷积神经网络"></a>为什么使用卷积神经网络</h4><blockquote><p>以最典型的图片识别为例：</p><p>首先，因为图像是由像素组成的，对于灰度图像（每个像素只有一个采样颜色）来说，如果图片大小为（48*48*1）,如果使用的是全连接神经网络，隐藏层只有一层，包含15个神经单元，则参数个数为：48*48*15*10+15+10=345625。所以参数太多，不便于反向传播计算，而卷积神经网络就相比之下参数少了很多，这个之后会细说。</p><p>​                      </p><p>其次，许多有用特征（比如鸟喙）在整张图片中占的地方很小，我们需要一个专门针对该类特征的特征选择器对其进行捕捉，传统的全连接神经网络是没有这种功能的，而卷积神经网络的卷积层做的就是该工作。</p><p>​               </p><p>第三，除了局部特征，我们还要把握整体的特征，而且还有想缩小图片的需求（图片缩小 -&gt; 像素变少 -&gt; 训练加快），而池化层可以完成该项工作。</p><p>​       </p><p>简要的说完这些，我想大概就能理解为什么卷积神经网络为什么在图像识别中表现如此突出了。</p></blockquote><h4 id="下面对卷积神经网络做基本介绍"><a href="#下面对卷积神经网络做基本介绍" class="headerlink" title="下面对卷积神经网络做基本介绍"></a>下面对卷积神经网络做基本介绍</h4><ul><li><p>包含三个基本层：卷积层、池化层、全连接层，这里主要介绍卷积层和池化层</p></li><li><p><strong>卷基层</strong></p><p><img src="/.top//CNN%E7%90%86%E8%A7%A3%E5%8F%8A%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%5Ccnn1.png" alt="cnn1"></p><blockquote><p>如上图所示，</p><p>对于一张6*6的图片，我们使用两个3*3的卷积核对其进行扫描，stride设为1（每次卷积和移动一个像素）</p><p>计算方法为（以第一次扫描为例）feature_map(1, 1)=1*1 + 0*-1 + 0*-1 + 0*-1 + 1*1 + 0*-1 + 0*-1 + 0*-1 + 1*1 = 3</p><p>​    </p><p>这就是最简单的内积公式，按照此方法通过扫描，我们可以得到一个4*4的feature_map，这也就是我们通过一个卷积核抽取出来的特征了</p></blockquote><ul><li>卷积层的特征：局部感知，参数共享</li><li>不同的特征提取器（卷积核），对于图像扫描得到的结果是不同的</li><li>对于RGB的图像来说，卷积核也要变为深度为3的立体卷积核</li></ul><p><img src="/.top//CNN%E7%90%86%E8%A7%A3%E5%8F%8A%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%5Ccnn3.png" alt="cnn3"></p></li></ul><ul><li><p><strong>池化层</strong></p><ul><li>在通过卷积核得到特征之后，我们想要减少数据量同时保留有用信息，这时就用到池化操作了</li><li>池化利用的是局部相关性原理，对提取出的特征进行subsampling</li><li>常用的池化方式有max-pooling和average-pooling</li></ul><p><img src="/.top//CNN%E7%90%86%E8%A7%A3%E5%8F%8A%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%5Ccnn4.png" alt="cnn4"></p><ul><li>池化与卷积的操作方式类似，都是通过扫描进行的，不过池化的话是对滑动窗口中的值取max或者average</li><li>我们可以思考一下max pooling为什么是有效的？<ul><li>对于卷积层提取出来的特征，也就是一个更小的图片，我们对局部区域的像素取最大值，可以视作是提取出对该特征最有效的数值，而被舍弃的，则是对该特征没有特别大帮助的。</li><li>与此同时，减小了feature_map的尺寸，减少了参数，减小了计算量，效果却损失不大</li><li>但是，在周边信息有效的情况下强行删去，也会导致效果下降，所以最好的办法就是对比一下加上max pooling前后的效果再决定是否使用</li></ul></li></ul></li><li><p><strong>Zero Padding</strong></p><ul><li><p>为了方面对边缘或者角上的特征进行提取，我们会加入zero_padding，也就是在图片的周围加上一圈0来填充</p></li><li><p>通过在周围填充0，也能达到图片经过卷积之后尺寸不变的效果</p><p><img src="/.top//CNN%E7%90%86%E8%A7%A3%E5%8F%8A%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%5Ccnn2.png" alt="cnn2"></p></li></ul></li><li><p><strong>全连接层</strong></p><ul><li>在多次卷积池化之后，已经提取了很多特征，我们需要将其铺平，然后才能作为input输入的全连接层中，最终使用softmax进行分类</li></ul><p><img src="/.top//CNN%E7%90%86%E8%A7%A3%E5%8F%8A%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%5Ccnn5.png" alt="cnn5"></p></li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用Pytorch</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets, transforms</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleCNN</span><span class="params">(torch.nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(SimpleCNN, self).__init__() <span class="comment"># b, 3, 32, 32</span></span><br><span class="line">        layer1 = torch.nn.Sequential() </span><br><span class="line">        layer1.add_module(<span class="string">'conv1'</span>, torch.nn.Conv2d(<span class="number">3</span>, <span class="number">32</span>, <span class="number">3</span>, <span class="number">1</span>, padding=<span class="number">1</span>))//输入<span class="number">3</span>维，输出<span class="number">32</span>维，输出大小<span class="number">32</span>＊<span class="number">32</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment"># b, 32, 32, 32</span></span><br><span class="line">        layer1.add_module(<span class="string">'relu1'</span>, torch.nn.ReLU(<span class="literal">True</span>)) </span><br><span class="line">        layer1.add_module(<span class="string">'pool1'</span>, torch.nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>)) <span class="comment"># b, 32, 16, 16 //池化为16*16</span></span><br><span class="line">        self.layer1 = layer1</span><br><span class="line"> </span><br><span class="line">        layer2 = torch.nn.Sequential()</span><br><span class="line">        layer2.add_module(<span class="string">'conv2'</span>, torch.nn.Conv2d(<span class="number">32</span>, <span class="number">64</span>, <span class="number">3</span>, <span class="number">1</span>, padding=<span class="number">1</span>))</span><br><span class="line">        <span class="comment"># b, 64, 16, 16 处理成64维， 16＊16</span></span><br><span class="line">        layer2.add_module(<span class="string">'relu2'</span>, torch.nn.ReLU(<span class="literal">True</span>))</span><br><span class="line">        layer2.add_module(<span class="string">'pool2'</span>, torch.nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>)) <span class="comment"># b, 64, 8, 8</span></span><br><span class="line">        self.layer2 = layer2</span><br><span class="line"> </span><br><span class="line">        layer3 = torch.nn.Sequential()</span><br><span class="line">        layer3.add_module(<span class="string">'conv3'</span>, torch.nn.Conv2d(<span class="number">64</span>, <span class="number">128</span>, <span class="number">3</span>, <span class="number">1</span>, padding=<span class="number">1</span>))</span><br><span class="line">        <span class="comment"># b, 128, 8, 8 处理成128维，4*4</span></span><br><span class="line">        layer3.add_module(<span class="string">'rellu3'</span>, torch.nn.ReLU(<span class="literal">True</span>))</span><br><span class="line">        layer3.add_module(<span class="string">'pool3'</span>, torch.nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>)) <span class="comment">#b 128, 4, 4</span></span><br><span class="line">        self.layer3 = layer3</span><br><span class="line">        <span class="comment"># 全连接输出</span></span><br><span class="line">        layer4 = torch.nn.Sequential()</span><br><span class="line">        layer4.add_module(<span class="string">'fc1'</span>, torch.nn.Linear(<span class="number">2048</span>, <span class="number">512</span>))</span><br><span class="line">        layer4.add_module(<span class="string">'fc_relu1'</span>, torch.nn.ReLU(<span class="literal">True</span>))</span><br><span class="line">        layer4.add_module(<span class="string">'fc2'</span>, torch.nn.Linear(<span class="number">512</span>, <span class="number">64</span>))</span><br><span class="line">        layer4.add_module(<span class="string">'fc_relu2'</span>, torch.nn.ReLU(<span class="literal">True</span>))</span><br><span class="line">        layer4.add_module(<span class="string">'fc3'</span>, torch.nn.Linear(<span class="number">64</span>, <span class="number">10</span>))</span><br><span class="line">        self.layer4 = layer4</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        conv1 = self.layer1(x)</span><br><span class="line">        conv2 = self.layer2(conv1)</span><br><span class="line">        conv3 = self.layer3(conv2)</span><br><span class="line">        fc_input = conv3.view(conv3.size(<span class="number">0</span>), <span class="number">-1</span>)</span><br><span class="line">        fc_out = self.layer4(fc_input)</span><br><span class="line">        <span class="keyword">return</span> fc_out</span><br><span class="line"> </span><br><span class="line">model = SimpleCNN()</span><br></pre></td></tr></table></figure><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>《一天搞懂深度学习》李宏毅</li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Artificial Intelligence </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python之文件的删除</title>
      <link href="/passages/python-zhi-wen-jian-de-shan-chu/"/>
      <url>/passages/python-zhi-wen-jian-de-shan-chu/</url>
      
        <content type="html"><![CDATA[<p>文件删除</p><a id="more"></a><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><ul><li>本文主要介绍文件的几种操作，包括：</li></ul><blockquote><p>判断文件是否存在</p><p>判断是文件or文件夹</p><p>删除文件和文件夹</p><p>递归删除文件夹下的所有文件（不包括文件夹）</p></blockquote><ul><li>使用的工具包为<code>os</code>，要记得<code>import</code>奥</li></ul><h4 id="判断文件是否存在"><a href="#判断文件是否存在" class="headerlink" title="判断文件是否存在"></a>判断文件是否存在</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.path.exists(path)</span><br></pre></td></tr></table></figure><h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> os.path.exists(path):</span><br><span class="line">    os.remove(path)</span><br></pre></td></tr></table></figure><h4 id="判断是文件还是文件夹"><a href="#判断是文件还是文件夹" class="headerlink" title="判断是文件还是文件夹"></a>判断是文件还是文件夹</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断是否为文件</span></span><br><span class="line">print(os.path.isfile(path))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断是否为文件夹</span></span><br><span class="line">print(os.path.isdir(path))</span><br></pre></td></tr></table></figure><h4 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path):</span><br><span class="line">    os.makedirs(path)</span><br></pre></td></tr></table></figure><h4 id="删除文件夹"><a href="#删除文件夹" class="headerlink" title="删除文件夹"></a>删除文件夹</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> os.path.exists(path):</span><br><span class="line">    os.removedirs(path)</span><br></pre></td></tr></table></figure><h4 id="递归删除文件夹下的所有文件"><a href="#递归删除文件夹下的所有文件" class="headerlink" title="递归删除文件夹下的所有文件"></a>递归删除文件夹下的所有文件</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">del_file</span><span class="params">(dir_path)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> os.listdir(dir_path):</span><br><span class="line">        file_path = os.path.join(dir_path, i)</span><br><span class="line">        <span class="keyword">if</span> os.path.isfile(file_path) == <span class="literal">True</span>:</span><br><span class="line">            os.remove(file_path)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            del_file(file_path)</span><br></pre></td></tr></table></figure><h4 id="介绍一种动态绝对路径的方法"><a href="#介绍一种动态绝对路径的方法" class="headerlink" title="介绍一种动态绝对路径的方法"></a>介绍一种动态绝对路径的方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">很多时候会因为文件路径导致程序产生一些模型奇妙的问题</span></span><br><span class="line"><span class="string">一般来说，绝对路径是最保险的，但是缺点就是缺乏动态性</span></span><br><span class="line"><span class="string">这里我们使用：项目文件夹绝对路径+文件夹内相对路径，结合绝对路径和相对路径的优势，基本不会因为文件路径造成问题了</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">project_path = os.path.dirname(os.path.abspath(__file__))</span><br><span class="line"></span><br><span class="line">file_path = os.path.join(project_path, dirname, file_name)</span><br></pre></td></tr></table></figure><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人间失格</title>
      <link href="/passages/ren-jian-shi-ge/"/>
      <url>/passages/ren-jian-shi-ge/</url>
      
        <content type="html"><![CDATA[<p>见即所望，相遇即美好。</p><a id="more"></a><p>&emsp;&emsp;看这本书之前，看到的一些评论，对于这本书可谓毁誉参半，有些人将其吹捧到了天上，有些人将其踩到了脚底。</p><p>&emsp;&emsp;别人眼中平淡安逸的温水世界，在有些人脚下是铺满烧红石头的煎熬之路。</p><p>&emsp;&emsp;书中的“我”，内心脆弱，面对生活和世人会慌乱不知所措，不知道如何跟世界相处，我想有些人天生就是这样，有时候社交这样的事情并不是靠练习就可以做到如鱼得水的。</p><p>&emsp;&emsp;即便如此，他也是在努力的生活啊。有人会觉得，他并没有努力，因为他总是随波逐流，做太多自毁前程的事情。可是对于一个跟我们这些普通人根本不在一个世界的人来说，他有自己的世界观和价值观，也许我们所鼓吹的成功，他根本就不向往。</p><p>&emsp;&emsp;一个人生错了世界，这又能怪谁呢？</p><p>&emsp;&emsp;而正是因为意识到自己不该生而为人，但又想在已知的现实中活下去，他才会努力学习各种令人发笑的本领，说些违心但似乎人们爱听的话，这是一个“胆小鬼”积极的方式。就像一个刚出生的小孩在尝试触碰世界一样，可能会慢慢适应，也有可能会被吓到然后缩回去。</p><p>&emsp;&emsp;读不懂，只能说明我们与他不在同一个世界，或者说，我们并没有经历那个压抑的年代，这，是一种幸运。</p><p>&emsp;&emsp;这本书最可怕的是那种切身的带入感，它让你会不知不觉的携带上那种悲观的情绪，仿佛被世界抛弃。</p><p>&emsp;&emsp;成人以来，想不到有什么足够失望的事，生活足够简单，打球，游戏，代码，还有偶尔的一些悸动。</p><p>&emsp;&emsp;我自认为是一个无趣的人，不会聊天，不会社交，喜欢停留在舒适的人际圈中静静的生活。</p><p>&emsp;&emsp;我慢热也不喜欢热闹，如果对你热情，说明你对我很重要。</p><p>&emsp;&emsp;所见即所望，相遇即美好。</p><p>&emsp;&emsp;愿生活顺利，学有所成，所爱之人皆在幸福之中。</p><p>&emsp;&emsp;That‘s all。</p><p>按照惯例，下面是书中的一些句子。</p><blockquote><p> 相逢的喜悦乃是转瞬即逝的情愫，而唯有离别的伤痛却刻骨铭心。</p></blockquote><blockquote><p>我每时每刻都感到不安，感到忐忑，以至于无处可荣，我只有越发地依赖于酒精和麻醉药物给我带来的头晕目眩的感觉，只为求的片刻的平和安宁，结果却反而将自己弄的一塌糊涂。</p></blockquote><blockquote><p>谁说人非要快乐不可，说的好像快乐由的人选择。</p></blockquote><blockquote><p>我渴望着狂暴而巨大的欢乐，即是再大的悲哀接踵而至，我也在所不惜。</p></blockquote><blockquote><p>我是一个畏畏缩缩，总看别人脸色行事，对他人的信赖早已遍布裂纹的人。</p></blockquote><blockquote><p>我的不幸全来自自身的罪恶，所以不可能向任何人抗议。</p></blockquote><blockquote><p>我的不幸乃是一个人缺乏拒绝能力所带来的不幸。 </p></blockquote><blockquote><p>“只是一切都将逝去”，这是我一致过着地狱般生活的这个所谓“人”的世界里，或许是唯一可以视为真理的一句话</p></blockquote><blockquote><p>我天生就是一个不会与人争辩的人，所以只能做出一副疲惫不堪或是感激涕零的表情。</p></blockquote><blockquote><p>世上所有人的说法，总是显得转弯抹角，含糊不清，其中有一种试图逃避责任似的微妙性和复杂性。</p></blockquote><blockquote><p>我只是对气氛骤然变换所带来的扫兴感到近于知悉的恐惧，所以，即是明知事后对自己不利，也必定会像往常一样，进行拼死拼活的服务</p></blockquote><blockquote><p>我甚至认为，与其对世人的“真实生活”感到畏惧，每个夜晚都在辗转难眠的地狱中呻吟叹息，还不如被关进牢房来的畅快和轻松</p></blockquote><blockquote><p>在我看来，伤口的疼痛就仿佛是它现货的情感，甚而爱情的呢喃。</p></blockquote><blockquote><p>我彷佛看见世界在一霎那间被地狱之火裹挟着，在我眼前熊熊燃烧起来。</p></blockquote><blockquote><p>越是对事物感到胆怯的神经质的人，就越是渴望暴风雨降临得更加猛烈 。</p></blockquote><blockquote><p>在与人交往时，我最介意的，就是唯恐出现那种可怕的沉默局面，所以，天生嘴笨的我才会抢先拼命地搞笑，</p></blockquote><blockquote><p>于是，我对人类的节俭不禁感到黯然神伤。</p></blockquote><blockquote><p>我与别人几乎从不交谈，该说些什么，该怎么说，我都摸不着头脑。</p></blockquote><blockquote><p>表面上我不断地强装出笑脸，可在内心确实对人类拼死拼活地服务，命悬一线的服务，汗流浃背地服务。</p></blockquote><blockquote><p>他们寥寥数语的责备，在我看来如同晴天霹雳一般，是我几近疯狂，哪里还谈得上以理相争呢。</p></blockquote><blockquote><p>我一直对人类畏惧不已，并因为这种畏惧而感到颤栗，对自己作为人类的一员的言行也毫无自信，只好将肚子的懊恼深藏进胸中的小匣子里，将精神上的忧郁和过敏封存起来，伪装成天真无邪的乐天外表，把自己一步步地彻底打磨成搞笑的畸人。</p></blockquote><blockquote><p>这种绝对的追求因为缺乏显式的根据和足够的心理准备，一遇到挫折就会很容易蜕变成强烈的自卑和完全的自暴自弃，要么完美，要么彻底破灭</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书&amp;电影 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习之支持向量机</title>
      <link href="/passages/ji-qi-xue-xi-zhi-zhi-chi-xiang-liang-ji/"/>
      <url>/passages/ji-qi-xue-xi-zhi-zhi-chi-xiang-liang-ji/</url>
      
        <content type="html"><![CDATA[<p>支持向量机</p><a id="more"></a><h3 id="算法要点"><a href="#算法要点" class="headerlink" title="算法要点"></a>算法要点</h3><ul><li>支持向量机学习的基本想法是求解能够正确划分训练数据集并且几何间隔最大的分离超平面</li><li>对训练数据集找到几何间隔最大的超平面意味着以充分大的置信度对训练数据进行分类</li><li>支持向量机是：最大化分类间隔的线性分类器</li><li>三种情况<ul><li>训练数据线性可分时，通过硬间隔最大化，得到线性可分支持向量机</li><li>训练数据近似线性可分时，通过软间隔最大化，得到线性支持向量机</li><li>训练数据线性不可分时，通过使用核技巧及软间隔最大化，得到非线性支持向量机</li></ul></li></ul><h4 id="函数间隔和几何间隔"><a href="#函数间隔和几何间隔" class="headerlink" title="函数间隔和几何间隔"></a>函数间隔和几何间隔</h4><ul><li>函数间隔<ul><li>可以表示分类预测的正确性和确信度</li><li>表示为$\gamma_i = y_i(w \cdot x_i + b)$</li></ul></li><li>几何间隔，对函数间隔的法向量w进行规范化等约束，防止参数成比例改变带来的问题</li><li>对函数间隔中的$w$和$b$进行归一化处理之后就是几何间隔了</li><li>几何间隔表示为：$\gamma_i = y_i(\frac{w}{||w||} \cdot x_i + \frac{b}{||w||})$</li></ul><h4 id="支持向量"><a href="#支持向量" class="headerlink" title="支持向量"></a>支持向量</h4><ul><li>训练数据集的样本点中与分离超平面距离最近的样本点的实例称为支持向量</li><li>支持向量是使约束条件式等号成立的点</li><li>决定分离超平面时，只有支持向量起作用</li></ul><h4 id="间隔边界"><a href="#间隔边界" class="headerlink" title="间隔边界"></a>间隔边界</h4><ul><li>支持向量所在的两个超平面称为间隔边界</li><li>间隔依赖于分离超平面的法向量$w$，等于$\frac{2}{||w||}$</li></ul><h4 id="松弛变量"><a href="#松弛变量" class="headerlink" title="松弛变量"></a>松弛变量</h4><ul><li>在线性支持向量机中，会存在某些样本点无法满足函数间隔大于等于1的约束条件</li><li>为了解决这个问题，对每个点引入松弛变量，使函数间隔加上松弛变量大于等于1</li><li>约束条件变为：$y_i(w \cdot x_i + b) &gt;= 1 - \xi_i$</li></ul><h4 id="惩罚因子"><a href="#惩罚因子" class="headerlink" title="惩罚因子"></a>惩罚因子</h4><ul><li>因为引入了松弛变量的样本点分类的置信度是不足够大的，所以对于每个松弛变量，支付一个代价（乘以一个系数）</li><li>$C &gt; 0$</li><li>C值大时对误分类的惩罚增大，C值小时对误分类的惩罚减小</li></ul><h4 id="核函数"><a href="#核函数" class="headerlink" title="核函数"></a>核函数</h4><ul><li>非线性分类问题无法在当前的空间内实现分类，需要映射到更高维的空间来寻找分割超平面</li><li>所采用的方法是进行一个非线性变换，将非线性问题转换为线性问题<ul><li>首先使用一个变换将原空间的数据映射到新空间</li><li>在新空间中使用线性分类学习方法从训练数据中学习分类模型</li></ul></li><li>核技巧的思想是：在学习和预测过程中，只定义核函数$K(x, z)$，而不显式地定义映射函数</li><li>在SVM中的应用就是将目标函数和决策函数中的实例与实例之间的内积使用核函数代替</li></ul><h4 id="SMO算法（sequential-minimal-optimization，序列最小优化算法）"><a href="#SMO算法（sequential-minimal-optimization，序列最小优化算法）" class="headerlink" title="SMO算法（sequential minimal optimization，序列最小优化算法）"></a>SMO算法（sequential minimal optimization，序列最小优化算法）</h4><ul><li>SMO算法是支持向量机学习的一种快速算法</li><li>不断将原二次规划问题分解为只有两个变量的二次规划子问题，并对子问题进行解析求解，直到所有变量满足KKT条件为止</li><li>通过启发式的方法得到原二次规划问题的最优解</li></ul><h3 id="SVM算法理解"><a href="#SVM算法理解" class="headerlink" title="SVM算法理解"></a>SVM算法理解</h3><ul><li>SVM脉络图</li></ul><p><img src="/.top//%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%5Csvm.jpg" alt></p><p>​                                         图片来源：公众号SIGAI</p><h4 id="线性分类器"><a href="#线性分类器" class="headerlink" title="线性分类器"></a>线性分类器</h4><ul><li>SVM可以说是起源于线性分类器，所以理解线性分类器对理解SVM是有很大帮助的</li><li>线性分类器是在n维空间中的分类超平面，将空间分割成两个部分</li><li>对于二维空间，线性分类器是一条直线；对于三维空间，线性分类器是一个平面</li><li>线性分类器的超平面方程为：$w^Tx + b = 0$，其中$w和b$是通过训练得到的参数</li></ul><h4 id="最大化分类间隔（线性可分支持向量机）"><a href="#最大化分类间隔（线性可分支持向量机）" class="headerlink" title="最大化分类间隔（线性可分支持向量机）"></a>最大化分类间隔（线性可分支持向量机）</h4><ul><li><p>一般情况下，给定一组训练样本，可行的线性分类器不止一个</p></li><li><p>如何在所有可行的线性分类器中选择效果（泛化能力）最好的分类器呢？（有一下几点考虑）</p><ul><li>分类平面不应该偏向任何一类</li><li>距离两个类别的样本都要尽可能的远</li></ul></li><li><p>这样，就是我们最大化间隔的基本就形成了；最大化间隔就是SVM的基本思想</p></li><li><p>如何衡量间隔是最大的呢？</p><ul><li><p>假设：给定训练样本集I，特征向量有n维，类别标签为-1和+1</p></li><li><p>SVM为该分类任务寻找最优分类超平面：$w^Tx + b = 0$</p></li><li><p>首先，保证每个样本被正确的分类，即：</p><ul><li>对于正样本，$w^Tx + b &gt;= 0$</li><li>对于负样本，$w^Tx + b &lt;= 0$</li><li>可以统一写成：$y_i(w^Tx_i + b) &gt;= 0$，其中$y_i$是训练集样本的标签</li></ul></li><li><p>其次，超平面距离两类样本的距离要尽可能大，</p><ul><li><p>每个样本点到超平面的举例为：$d = \frac{|w^Tx_i + b|}{||w||}$</p></li><li><p>$||w||$是向量的L2范数，是一个常数（范数是对向量长度的一种度量）</p></li><li><p>对于超平面方程，两边同乘不等于0的常数，还是用一个超平面，根据此特性可以化简求解问题</p></li><li><p>给$w$和$b$加上如下约束，$min_{x_i}|w^Tx_i + b|=1$</p></li><li><p>消掉此冗余并化简点到超平面距离计算公式，分类超平面的约束变成：$y_i(w^Tx_i + b)&gt;=1$</p></li><li><p>分类超平面与两类样本之间的间隔为：</p><p>$d(w, b) = min_{x_i,y_i=-1}d(w, b; x_i)+min_{x_i, y_i=1}d(w, b; x_i)= \frac{2}{||w||}$</p></li></ul></li><li><p>目标是使该间隔最大化，这与最小化$||w||$等价，同时也与最小化$\frac{1}{2}||w||^2$等价</p></li></ul></li><li><p>于是，优化问题最后变成</p><blockquote><p>$$min \frac{1}{2}w^Tw$$</p><p>$$y_i(w^Tx_i+b) &gt;= 1$$</p></blockquote></li></ul><h4 id="这是一个凸优化问题，并且满足Slater条件"><a href="#这是一个凸优化问题，并且满足Slater条件" class="headerlink" title="这是一个凸优化问题，并且满足Slater条件"></a>这是一个凸优化问题，并且满足Slater条件</h4><ul><li>凸优化问题意味着我们可以得到全局最优解</li><li>满足Slater条件意味着我们可以用拉格朗日对偶将其转化为对偶问题（对偶问题的求解会更加简单）进行求解</li></ul><h4 id="对偶问题"><a href="#对偶问题" class="headerlink" title="对偶问题"></a>对偶问题</h4><ul><li><p>之前的优化问题中，包含许多的不等式约束，因此通过拉格朗日对偶将其转化成对偶问题，对偶问题为：</p><blockquote><p>$$min_\alpha \frac{1}{2}\sum^l_{i=1}\sum^l_{j=1}\alpha_i\alpha_jy_iy_jx_i^Tx_j - \sum^l_{i=1}\alpha_i$$</p><p>$$\alpha_i &gt;= 0, i=1,…,l$$</p><p>$$\sum^l_{i=1}\alpha_iy_i = 0$$</p></blockquote></li><li><p>这里的$\alpha$是拉个朗日乘子变量，在对偶问题中，它们是优化变量</p></li><li><p>值得注意的是，只有问题满足强对偶条件，也就是原问题与对偶问题有相同的最优解</p></li><li><p>强对偶成立的判断依据是Slater条件</p></li></ul><h4 id="梳理一下"><a href="#梳理一下" class="headerlink" title="梳理一下"></a>梳理一下</h4><ul><li><p>初始是最大化间隔：$\frac{1}{2} ||w||^2，s.t. y_i(w \cdot x_i + b) - 1 &gt;= 0$</p></li><li><p>应用拉格朗日对偶性构建拉格朗日函数（引入拉格朗日乘子$\alpha $）</p><p>$L(w, b, \alpha) = \frac{1}{2} ||w||^2 - \sum^N_{i=1}\alpha_iy_i(w \cdot x_i + b) + \sum^N_{i=1}\alpha_i$</p></li><li><p>根据拉格朗日对偶性，原始问题的对偶问题是极大极小问题：$max_\alpha min_{w, b}L(w, b, \alpha)$</p><ul><li><p>对于该问题，我们先求对$w$和$b$的极小，再对$\alpha $求极大</p></li><li><p>求极小的方法就是将$L(w, b, \alpha )$对$w$和$b$求偏导并令其等于0</p></li><li><p>将偏导数等于0代会，可得：</p><p>$min_{w, b} L(w, b, \alpha ) = -\frac{1}{2} \sum^N_{i=1}\sum^N_{j=1} \alpha_i \alpha_j y_i y_j(x_i \cdot x_j) + \sum^N_{i=1} \alpha_i$</p></li><li><p>下一步是对上式再对$\alpha $再求极大，但是我们可以对上式两边同乘-1转化为求极小的问题，即：</p><p>$$max_\alpha min_{w, b} L(w, b, \alpha) = min_\alpha \frac{1}{2} \sum^N_{i=1}\sum^N_{j=1} \alpha_i \alpha_j y_i y_j(x_i \cdot x_j) + \sum^N_{i=1} \alpha_i$$</p></li><li><p>求得最优解$\alpha^{*} = (\alpha^{*}_i, …, \alpha^{*}_N)$</p></li><li><p>计算</p><blockquote><p>$w^{*} = \sum^N_{i=1}\alpha^{*}_iy_ix_i$</p><p>$b^{*} = y_i - \sum^N_{i=1}\alpha^{*}_iy_i(x_i \cdot x_j)$</p></blockquote></li><li><p>求得分离超平面：$w^{*} \cdot x + b^{*} = 0$</p></li><li><p>决策函数：$f(x) = sign(w^{*} \cdot x + b^{*})$</p></li></ul></li></ul><h4 id="线性支持向量机"><a href="#线性支持向量机" class="headerlink" title="线性支持向量机"></a>线性支持向量机</h4><ul><li><p>引入了惩罚因子和松弛变量</p></li><li><p>也可以通过转化为对偶问题解决</p></li><li><p>如下：</p><blockquote><p>$$min_\alpha \frac{1}{2}\sum^l_{i=1}\sum^l_{j=1}\alpha_i\alpha_jy_iy_jx_i^Tx_j - \sum^l_{i=1}\alpha_i$$</p><p>$$0 &lt;= \alpha_i &lt;= C$$</p><p>$$\sum^l_{j=1}\alpha_jy_j = 0$$</p></blockquote></li><li><p>相比于线性可分的对偶问题，多了个$\alpha_i &lt;= C$的约束</p></li><li><p>分离超平面$\sum^N_{i=1}\alpha^{*}_iy_i(x \cdot x_i) +b^{*} = 0$</p></li><li><p>决策函数为$f(x) = sign(\sum^l_{i=1}\alpha_i^{*}y_i(x \cdot x_i) + b^{*})$</p></li></ul><h4 id="非线性可分支持向量"><a href="#非线性可分支持向量" class="headerlink" title="非线性可分支持向量"></a>非线性可分支持向量</h4><ul><li><p>使用的核技巧，还是线性可分的问题</p></li><li><p>对偶问题变为</p><blockquote><p>$$min_\alpha \frac{1}{2}\sum^l_{i=1}\sum^l_{j=1}\alpha_i\alpha_jy_iy_j\phi(x_i)^T\phi(x_j) - \sum^l_{i=1}\alpha_i$$ = $$min_\alpha \frac{1}{2}\sum^l_{i=1}\sum^l_{j=1}\alpha_i\alpha_jy_iy_jK(x_i, x_j) - \sum^l_{i=1}\alpha_i$$</p><p>$$0 &lt;= \alpha_i &lt;= C$$</p><p>$$\sum^l_{j=1}\alpha_jy_j = 0$$</p></blockquote></li><li><p>决策函数为$f(x) = sign(\sum^l_{i=1}\alpha^{*}_iy_iK(x , x_i) + b^{*})$，其中$K(x, x_i)= \phi(x) \cdot \phi(x)$</p></li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span>  train_test_split</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_data</span><span class="params">()</span>:</span></span><br><span class="line">    iris = load_iris()</span><br><span class="line"></span><br><span class="line">    df = pd.DataFrame(iris.data, columns=iris.feature_names)</span><br><span class="line">    df[<span class="string">'label'</span>] = iris.target</span><br><span class="line">    df.columns = [<span class="string">'sepal length'</span>, <span class="string">'sepal width'</span>, <span class="string">'petal length'</span>, <span class="string">'petal width'</span>, <span class="string">'label'</span>]</span><br><span class="line"></span><br><span class="line">    data = np.array(df.iloc[:<span class="number">100</span>, [<span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>]])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将三类转化成两类：（1，-1）</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(data)):</span><br><span class="line">        <span class="keyword">if</span> data[i, <span class="number">-1</span>] == <span class="number">0</span>:</span><br><span class="line">            data[i, <span class="number">-1</span>] == <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data[:, :<span class="number">2</span>], data[:, <span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SVM</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, max_iter=<span class="number">100</span>, kernel=<span class="string">'linear'</span>)</span>:</span></span><br><span class="line">        self.max_iter = max_iter</span><br><span class="line">        self._kernel = kernel</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init_args</span><span class="params">(self, features, labels)</span>:</span></span><br><span class="line">        self.m, self.n = features.shape</span><br><span class="line">        self.X = features</span><br><span class="line">        self.Y = labels</span><br><span class="line">        self.b = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将Ei保存在一个列表中</span></span><br><span class="line">        self.alpha = np.ones(self.m)</span><br><span class="line">        self.E = [self._E(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(self.m)]</span><br><span class="line">        <span class="comment"># 松弛变量</span></span><br><span class="line">        self.C = <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_KKT</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        y_g = self._g(i) * self.Y[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.alpha[i] == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> y_g &gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="number">0</span> &lt; self.alpha[i] &lt;self.C:</span><br><span class="line">            <span class="keyword">return</span> y_g == <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> y_g &lt;= <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_g</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        <span class="comment"># g(x)预测值，输入xi(X[i])</span></span><br><span class="line">        r = self.b</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(self.m):</span><br><span class="line">            r += self.alpha[j] * self.Y[j] * self.kernel(self.X[i], self.X[j])</span><br><span class="line">        <span class="keyword">return</span> r</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kernel</span><span class="params">(self, x1, x2)</span>:</span></span><br><span class="line">        <span class="comment"># 核函数</span></span><br><span class="line">        <span class="keyword">if</span> self._kernel == <span class="string">'linear'</span>:</span><br><span class="line">            <span class="keyword">return</span> sum([ x1[k] * x2[k] <span class="keyword">for</span> k <span class="keyword">in</span> range(self.n)])</span><br><span class="line">        <span class="keyword">elif</span> self._kernel == <span class="string">'poly'</span>:</span><br><span class="line">            <span class="keyword">return</span> (sum([ x1[k] * x2[k] <span class="keyword">for</span> k <span class="keyword">in</span> range(self.n)]) + <span class="number">1</span>) **<span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_E</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        <span class="comment"># E(x)为g(x)对输入x的预测值和y的差</span></span><br><span class="line">        <span class="keyword">return</span> self._g(i) - self.Y[i]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_init_alpha</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 外层循环遍历所有满足0&lt;a&lt;C的样本点， 检验是否满足KKT</span></span><br><span class="line">        index_list = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(self.m) <span class="keyword">if</span> <span class="number">0</span> &lt; self.alpha[i] &lt; self.C]</span><br><span class="line">        <span class="comment"># 否则遍历整个训练集</span></span><br><span class="line">        non_satisfy_list = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(self.m) <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> index_list]</span><br><span class="line">        index_list.extend(non_satisfy_list)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> index_list:</span><br><span class="line">            <span class="keyword">if</span> self._KKT(i):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            E1 = self.E[i]</span><br><span class="line">            <span class="comment"># 如果E2是+，选择最小的；如果E2是负的，选择最大的</span></span><br><span class="line">            <span class="keyword">if</span> E1 &gt;= <span class="number">0</span>:</span><br><span class="line">                j = min(range(self.m), key=<span class="keyword">lambda</span> x: self.E[x])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j = min(range(self.m), key=<span class="keyword">lambda</span> x: self.E[x])</span><br><span class="line">            <span class="keyword">return</span> i, j</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_compare</span><span class="params">(self, _alpha, L, H)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> _alpha &gt; H:</span><br><span class="line">            <span class="keyword">return</span> H</span><br><span class="line">        <span class="keyword">elif</span> _alpha &lt; L:</span><br><span class="line">            <span class="keyword">return</span> L</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> _alpha</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, features, labels)</span>:</span></span><br><span class="line">        self.init_args(features, labels)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> range(self.max_iter):</span><br><span class="line">            <span class="comment"># train</span></span><br><span class="line">            i1, i2 = self._init_alpha()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 边界</span></span><br><span class="line">            <span class="keyword">if</span> self.Y[i1] == self.Y[i2]:</span><br><span class="line">                L = max(<span class="number">0</span>, self.alpha[i1] + self.alpha[i2] - self.C)</span><br><span class="line">                H = min(self.C, self.alpha[i1] + self.alpha[i2])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                L = max(<span class="number">0</span>, self.alpha[i2] - self.alpha[i1])</span><br><span class="line">                H = min(self.C, self.C + self.alpha[i2] - self.alpha[i1])</span><br><span class="line"></span><br><span class="line">            E1 = self.E[i1]</span><br><span class="line">            E2 = self.E[i2]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># eta = k11 + k22 - 2k12</span></span><br><span class="line">            eta = self.kernel(self.X[i1], self.X[i1]) + self.kernel(</span><br><span class="line">                self.X[i2],</span><br><span class="line">                self.X[i2]) - <span class="number">2</span>*self.kernel(self.X[i1], self.X[i2])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> eta &lt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            alpha2_new_unc = self.alpha[i2] + self.Y[i2] * (E1 - E2)/eta</span><br><span class="line">            alpha2_new = self._compare(alpha2_new_unc, L, H)</span><br><span class="line"></span><br><span class="line">            alpha1_new = self.alpha[i1] + self.Y[i1] * self.Y[i2] * (</span><br><span class="line">                self.alpha[i2] - alpha2_new)</span><br><span class="line"></span><br><span class="line">            b1_new = -E1 - self.Y[i1] * self.kernel(self.X[i1], self.X[i1]) * (</span><br><span class="line">                alpha1_new - self.alpha[i1]) - self.Y[i2] * self.kernel(</span><br><span class="line">                    self.X[i2],</span><br><span class="line">                    self.X[i1]) * (alpha2_new - self.alpha[i2]) + self.b</span><br><span class="line">            b2_new = -E2 - self.Y[i1] * self.kernel(self.X[i1], self.X[i2]) * (</span><br><span class="line">                alpha1_new - self.alpha[i1]) - self.Y[i2] * self.kernel(</span><br><span class="line">                    self.X[i2],</span><br><span class="line">                    self.X[i2]) * (alpha2_new - self.alpha[i2]) + self.b</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt; alpha1_new &lt; self.C:</span><br><span class="line">                b_new = b1_new</span><br><span class="line">            <span class="keyword">elif</span> <span class="number">0</span> &lt; alpha2_new &lt; self.C:</span><br><span class="line">                b_new = b2_new</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 选择中点</span></span><br><span class="line">                b_new = (b1_new + b2_new)/<span class="number">2</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 更新参数</span></span><br><span class="line">            self.alpha[i1] = alpha1_new</span><br><span class="line">            self.alpha[i2] = alpha2_new</span><br><span class="line">            self.b = b_new</span><br><span class="line"></span><br><span class="line">            self.E[i1] = self._E(i1)</span><br><span class="line">            self.E[i2] = self._E(i2)</span><br><span class="line"></span><br><span class="line">        print(<span class="string">"train_done!"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        r = self.b</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.m):</span><br><span class="line">            r += self.alpha[i] * self.Y[i] * self.kernel(data, self.X[i])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> r &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self, X_test, y_test)</span>:</span></span><br><span class="line">        right_count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(X_test)):</span><br><span class="line">            result = self.predict(X_test[i])</span><br><span class="line">            <span class="keyword">if</span> result == y_test[i]:</span><br><span class="line">                right_count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> right_count / len(X_test)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_weight</span><span class="params">(self)</span>:</span></span><br><span class="line">        yx = self.Y.reshape(<span class="number">-1</span>, <span class="number">1</span>) * self.X</span><br><span class="line">        self.w = np.dot(yx.T, self.alpha)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.w</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    X, y = create_data()</span><br><span class="line">    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.25</span>)</span><br><span class="line"></span><br><span class="line">    plt.scatter(X[:<span class="number">50</span>,<span class="number">0</span>],X[:<span class="number">50</span>,<span class="number">1</span>], label=<span class="string">'0'</span>)</span><br><span class="line">    plt.scatter(X[<span class="number">50</span>:,<span class="number">0</span>],X[<span class="number">50</span>:,<span class="number">1</span>], label=<span class="string">'1'</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">    svm = SVM(max_iter=<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">    svm.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">    score = svm.score(X_test, y_test)</span><br><span class="line"></span><br><span class="line">    print(score)</span><br></pre></td></tr></table></figure><h4 id="关于凸优化问题、拉格朗日乘子法、slater条件、KKT条件、SMO会在另一篇文章中进行整理"><a href="#关于凸优化问题、拉格朗日乘子法、slater条件、KKT条件、SMO会在另一篇文章中进行整理" class="headerlink" title="关于凸优化问题、拉格朗日乘子法、slater条件、KKT条件、SMO会在另一篇文章中进行整理"></a>关于凸优化问题、拉格朗日乘子法、slater条件、KKT条件、SMO会在另一篇文章中进行整理</h4><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li>《统计学习方法（第二版）》</li><li><a href="https://github.com/fengdu78/lihang-code" target="_blank" rel="noopener">黄海广博士的代码</a></li></ul><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Artificial Intelligence </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RNN及LSTM理解</title>
      <link href="/passages/rnn-ji-lstm-li-jie/"/>
      <url>/passages/rnn-ji-lstm-li-jie/</url>
      
        <content type="html"><![CDATA[<p>RNN &amp; LSTM </p><a id="more"></a><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><h4 id="为什么要使用神经网络呢？"><a href="#为什么要使用神经网络呢？" class="headerlink" title="为什么要使用神经网络呢？"></a>为什么要使用神经网络呢？</h4><ul><li><p>自动提取特征</p><blockquote><p>很多人可能会有类似的疑问，机器学习已经可以解决绝大部分问题了，为什么还要使用多种神经网络呢？</p><p>​    我们来回想一下，在传统机器学习模型的搭建过程中，我们首先要把数据处理成能够输入到模型中的形式，这一步我们称作特征工程。而且在很多时候时候，特征工程占据了我们整个项目的绝大多数时间。特征数目过少，我们会无法精确的完成任务；特征数目过多，又会导致模型的泛化能力下降。也就是说，特征构造的好坏直接决定了我们模型的上限，最终还是由“人”来完成的绝大部分工作。</p><p>​    神经网络的出现，使我们不需要做大量的特征工程的工作，我们只需要直接把数据灌进神经网络中，它就会在训练的过程中自我修正，自动学习到需要的特征。</p></blockquote></li><li><p>数据格式的简易性</p><blockquote><p>​    传统的机器学习中，我们需要对数据进行一些处理，比如归一化、格式的转化等</p><p>​    而在神经网络中，我们可以直接把数据投入其中，不需要对数据进行大量额外的处理</p></blockquote></li><li><p>调参的工作量大大减小</p><blockquote><p>​    在机器学习中，每个参数的调整都拥有背后的理论依据，我们想要将参数调整到一个较好的状态，需要掌握很扎实的算法知识</p><p>​    对于一个简单的三层神经网络来说，我们只需要随机初始化给每一个神经元一个权重和偏执项，大量的参数调整工作在网络的自学习过程中会自动实现</p></blockquote></li><li><p>下面会简单记录一下在学习循环神经网络（RNN）及长短期记忆网络（LSTM）过程中的一些想法</p></li></ul><h3 id="循环神经网络（RNN）"><a href="#循环神经网络（RNN）" class="headerlink" title="循环神经网络（RNN）"></a>循环神经网络（RNN）</h3><ul><li><p>循环神经网络是由<code>John Hopfield</code>等人提出来的神经网络模型</p></li><li><p>它的最大不同之处就在于它的连接存在着大量的环路，信息在传递的过程中有很大概率在网络中保留；而人工神经网络和卷积神经网络，它们工作的前提是：元素之间相互独立，输入输出之间互不干扰，因此相比于<code>CNN</code>等，<code>RNN</code>就具有了“记忆”的功能，也就拥有了处理对序列信息敏感的数据，例如音频、文本等</p></li><li><p><img src="/.top//RNN%E5%8F%8ALSTM%E7%90%86%E8%A7%A3%5CRNN.jpg" alt></p><blockquote><p>​    如上图所示，循环神经网络的最大特点就是它的隐含层中包含大量的循环连接</p><p>​    也就是说输入t时刻的输入$X_t$经过输入层（变为$X_tW_{Xt}$）进入隐含层，而隐含层节点当前时刻的输出$h_t$并不是仅仅与输入层过来的$X_tW_{Xt}$有关，还与上一时刻的输出$h_{t-1}$有关，也就是说这两项共同决定了隐藏层的输出</p><p>​    在隐含层和输出层的最后一步运算都要经过一个非线性的映射，即激活函数，可以是sigmod或这其他函数</p><p>​    S时刻的输出可以表示为：$S_t = softmax(softmax(W_{Xh}X_t + W_{hh}h_{t-1}) * W_{hY})$</p><p>​    在这里$W_{Xh},  W_{hh}, W_{hY}$分别表示的是输入层到隐含层的权重，隐含层内上一时刻输出连接到当前时刻输出的权重，隐含层输出到输出层的权重</p></blockquote></li><li><p>使用Pytorch实现简单的RNN</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleRNN</span><span class="params">(nn.module)</span>:</span></span><br><span class="line">    <span class="comment"># 初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, input_size, hidden_size, output_size, num_layers=<span class="number">1</span>)</span>:</span></span><br><span class="line">        <span class="comment"># 定义</span></span><br><span class="line">        super(SimpleRNN, self).__init__()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 超参数定义</span></span><br><span class="line">        self.hidden_size = hidden_size</span><br><span class="line">        self.num_layers = num_layers</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 各层网络：三层，分别是embedding、rnn层、全连接输出层</span></span><br><span class="line">        self.embedding = nn.Embedding(input_size, hidden_size)</span><br><span class="line">        <span class="comment"># batch_size表示可以让输入张量的第一个维度表示batch指标，默认是时间</span></span><br><span class="line">        self.rnn = nn.RNN(hidden_size, hidden_size, num_layers, batch_first= <span class="literal">True</span>)  </span><br><span class="line">        self.fc = nn.Linear(hidden_size, output_size)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># logsoftmax层</span></span><br><span class="line">        self.softmax = nn.LogSoftmax(dim=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 前向运算过程(当前的输入， 上一时刻的输出)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, input, hidden)</span>:</span></span><br><span class="line">        <span class="comment"># embedding层的计算</span></span><br><span class="line">        <span class="comment"># input的尺寸是：(batch_size, num_step, data_dim)</span></span><br><span class="line">        x = self.embedding(input)</span><br><span class="line">        <span class="comment"># x的尺寸是：(batch_size, num_step, hidden_size)</span></span><br><span class="line">        output, hidden = self.rnn(x, hidden)</span><br><span class="line">        <span class="comment"># output的尺寸：(batch_size, num_step, hidden_size)</span></span><br><span class="line">        output = output[:, <span class="number">-1</span>, :]   <span class="comment"># 获取RNN最后一个时刻的隐含层状态作为这一层的输出</span></span><br><span class="line">        <span class="comment"># output的尺寸：(batch_size, hidden_size)</span></span><br><span class="line">        <span class="comment"># 输入最后一层全连接网络</span></span><br><span class="line">        output = self.fc(output)</span><br><span class="line">        <span class="comment"># output尺寸：(batch_size, output_size)</span></span><br><span class="line">        <span class="comment"># softmax函数</span></span><br><span class="line">        output = self.softmax(output)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> output, hidden</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 初始化隐含层神经单元</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initHidden</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Variable(torch.zeros(self.num_layers, <span class="number">1</span>, self.hidden_size))</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">rnn层：当第一个维度的尺寸大于一的时候，RNN就会运行多步</span></span><br><span class="line"><span class="string">而RNN的输出output的维度是随着输入x变化的，也就是说，如果x执行的是t个步骤，那么output中就包含了t步的每一步RNN隐含层的输出</span></span><br><span class="line"><span class="string">所以要取最后一个时刻的隐含层状态作为该层的输出</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">if</span> __name__ = <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 简单使用</span></span><br><span class="line">    rnn = SimpleRNN(input_size=<span class="number">1</span>, hidden_size=<span class="number">2</span>, output_size=<span class="number">26</span>)</span><br><span class="line">    <span class="comment"># 交叉熵损失函数</span></span><br><span class="line">    criterion = torch.nn.NLLLoss()</span><br><span class="line">    <span class="comment"># adam优化算法</span></span><br><span class="line">    optimizer = torch.optim.Adam(rnn.parameters(), lr=<span class="number">0.001</span>)</span><br><span class="line"></span><br><span class="line">    loss = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 初始化隐含层神经单元</span></span><br><span class="line">    hidden = rnn.initHidden()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对每一个序列的所有字符进行循环</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> range(len(seq)<span class="number">-1</span>):</span><br><span class="line">        <span class="comment"># 当前自负作为输入，下一字符作为标签</span></span><br><span class="line">        x = Variable(torch.LongTensor([seq[t]]).unsqueeze(<span class="number">0</span>))</span><br><span class="line">        <span class="comment"># x尺寸：(batch_size=1, time_steps=1, data_dimension=1)</span></span><br><span class="line">        y = Variable(torch.LongTensor([seq[t+<span class="number">1</span>]]))</span><br><span class="line">        <span class="comment"># y尺寸：(batch_size=1, data_dimension=1)</span></span><br><span class="line">        output, hidden = rnn(x, hidden)</span><br><span class="line">        <span class="comment"># output尺寸：(batch_size, output_size=26)</span></span><br><span class="line">        <span class="comment"># hidden尺寸：(layer_size=1, batch_size=1, hidden_size)</span></span><br><span class="line">        loss += criterion(output, y)    <span class="comment"># 计算损失函数</span></span><br><span class="line">        loss = <span class="number">1.0</span> * loss/len(seq)      <span class="comment"># 计算每字符的损失数值</span></span><br><span class="line"></span><br><span class="line">        optimizer.zero_grad()       <span class="comment"># 梯度清空</span></span><br><span class="line">        loss.backward()     <span class="comment"># 反向传播</span></span><br><span class="line"></span><br><span class="line">        optimizer.step()</span><br></pre></td></tr></table></figure></li></ul><h3 id="长短期记忆网络"><a href="#长短期记忆网络" class="headerlink" title="长短期记忆网络"></a>长短期记忆网络</h3><ul><li><p>虽然<code>RNN</code>已经能解决记忆问题了，但是从实践运行的角度来看，<code>RNN</code>的记忆能力有限，只能记住几十部以内的模式，无法完成更长时间的记忆。</p></li><li><p>直观来讲，是因为每个隐含层单元计算的最后一步都要进过一个非线性激活函数，而这些函数大多输出一个位于[0, 1]之间的数，因此输入值只能保留一个分数进行输出，多步下来就会导致数值（信息）衰减的很快。</p></li><li><p><code>LSTM</code>与<code>RNN</code>的区别就是，<code>LSTM</code>使用的是经过改造的RNN的隐藏层单元。既然<code>RNN</code>爱忘事，那么我们就想些办法阻止它，也就是<code>LSTM</code>中加入的门控开关：<strong>输入门、输出门、遗忘门</strong>。</p></li><li><p>下面对<code>LSTM</code>的具体内部细节做一下讲解。</p></li><li><p>下面是简单<code>RNN</code>网络的架构图</p><p><img src="/.top//RNN%E5%8F%8ALSTM%E7%90%86%E8%A7%A3%5Clstm1.png" alt></p></li><li><p><code>LSTM</code>在<code>RNN</code>的基础上引入节点状态信息，并通过遗忘门和输入们更新节点状态，最后通过输出门控制更新后的节点状态信息输出，如下图</p><p><img src="/.top//RNN%E5%8F%8ALSTM%E7%90%86%E8%A7%A3%5Clstm2.png" alt></p><blockquote><p>贯穿在图上方的水平线为细胞状态，黄色的矩形是学习得到的网络层，粉色圈表示运算操作，黑色的箭头表示向量的传输</p></blockquote></li><li><p>首先看一下<strong>遗忘门</strong></p><p><img src="/.top//RNN%E5%8F%8ALSTM%E7%90%86%E8%A7%A3%5Clstm3.png" alt></p><blockquote><p>​    遗忘门决定哪些信息需要从细胞状态中被遗忘</p><p>​    遗忘门以上一层的输出$h_{t-1}$和本层的输入$x_t$作为输入，通过一个<code>sigmod</code>函数，得到输出$f_t$，输出值表示的是上一层的状态被遗忘的概率</p><p>​    $f_t = sigmod(W_f \cdot [h_{t-1}, x_t] + b_f)$    </p></blockquote></li><li><p>之后是<strong>输入门</strong></p><p><img src="/.top//RNN%E5%8F%8ALSTM%E7%90%86%E8%A7%A3%5Clstm4.png" alt></p><blockquote><p>​    输入门包含两部分，第一部分使用<code>sigmod</code>函数，输出为$i_t$；第二部分使用<code>tanh</code>函数，输出为$C_t$</p><p>​    可以理解成$C^{“}_t$是网络中本层的输出，$i_t$是概率，表示的是$C^{“}_t$在网络中被保留的程度</p><p>​    所以$i_t*C^{“}_t$表示的就是该层被保留的程度</p><p>​    $i_t = sigmod(W_i \cdot [h_{t-1}, x_t] + b_i)$</p><p>​    $C^{‘’}<em>t = tanh(W_c \cdot [h</em>{h-1}, x_t] +b_C)$</p></blockquote></li><li><p>最后的是输出门</p><p><img src="/.top//RNN%E5%8F%8ALSTM%E7%90%86%E8%A7%A3%5Clstm6.png" alt></p><blockquote><p>​    输出门用来控制该层的细胞状态有多少被过滤。</p><p>​    首先使用<code>sigmod</code>函数得到一个[0, 1]之间的概率$o_t$，接着将细胞状态$C_t$通过<code>tanh</code>函数处理后与$o_t$相乘，得到本层的输出（输出会传入下一个细胞作为下个细胞的一个输入，也会直接输出到下一层）</p><p>​    $o_t = sigmod(W_o \cdot [h_{t-1}, x_t] + b_o)$</p><p>​    $h_t = o_t * tanh(C_t)$    </p></blockquote></li><li><p>另外</p><p><img src="/.top//RNN%E5%8F%8ALSTM%E7%90%86%E8%A7%A3%5Clstm5.png" alt></p><blockquote><p>​    接上面的知识，$f_t$是遗忘门的输出，控制着上层细胞状态$C_{t-1}$被遗忘的程度，即$f_t*C_{t-1}$表示上一个细胞状态在本细胞状态中的角色</p><p>​    另外，$i_t * C_t$表示的是本细胞状态的另一部分</p><p>​    所以，本细胞的细胞状态是$C_t = f_t * C_{t-1} + i_t * C^{“}_t$</p></blockquote></li><li><p>使用<code>Pytorch</code>实现简单的<code>LSTM</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleLSTM</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, input_size, hidden_size, output_size, num_layers=<span class="number">1</span>)</span>:</span></span><br><span class="line">        super(SimpleLSTM, self).__init__()</span><br><span class="line"></span><br><span class="line">        self.hidden_size = hidden_size</span><br><span class="line">        self.num_layers = num_layers</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 三层神经网络</span></span><br><span class="line">        self.embedding = nn.Embedding(input_size, hidden_size)</span><br><span class="line">        self.lstm = nn.LSTM(hidden_size, hidden_size, num_layers, batch_first=<span class="literal">True</span>)</span><br><span class="line">        self.fc = nn.Linear(hidden_size, output_size)</span><br><span class="line">        self.softmax = nn.LogSoftmax(dim=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, input, hidden_size)</span>:</span></span><br><span class="line">        x = self.embedding(input)</span><br><span class="line"></span><br><span class="line">        output, hidden = self.lstm(x, hidden)</span><br><span class="line">        output = output[:, <span class="number">-1</span>, :]</span><br><span class="line"></span><br><span class="line">        output = self.fc(output)</span><br><span class="line">        output = self.softmax(output)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> output, hidden</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initHidden</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 对隐含层单元的初始化</span></span><br><span class="line">        hidden = Variable(torch.zeros(self.num_layers, <span class="number">1</span>, self.num_layers))</span><br><span class="line">        <span class="comment"># 对隐含单元内部的状态cell的初始化</span></span><br><span class="line">        cell = Variable(torch.zeros(self.num_layers, <span class="number">1</span>, self.hidden_size))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (hidden, cell)</span><br></pre></td></tr></table></figure></li></ul><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><p>《Pytorch深度学习原理与实战》</p></li><li><p>图片来源于网络</p></li></ul><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Artificial Intelligence </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习之逻辑回归</title>
      <link href="/passages/ji-qi-xue-xi-zhi-luo-ji-hui-gui/"/>
      <url>/passages/ji-qi-xue-xi-zhi-luo-ji-hui-gui/</url>
      
        <content type="html"><![CDATA[<p>逻辑回归</p><a id="more"></a><h3 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h3><ul><li><p>逻辑回归，虽然名字中带有“回归”的字样，但是它并不是做回归任务的，而是用回归的思想来做分类</p></li><li><p>根据数据对分类边界线建立回归公式，以此进行分类</p></li><li><p>算法概述</p><blockquote><p>以二分类为例，逻辑回归会计算输入的实例在已知<code>x</code>的条件下$P(Y=1|x)$和$P(Y=0|x)$的概率，并将实例分到概率值较大的那一类</p></blockquote></li><li><p>优缺点</p><blockquote><p>优点：计算代价不高，易于理解和实现</p><p>缺点：容易欠拟合，分类精度可能不高</p></blockquote></li><li><p>多项逻辑回归模型可以用于多分类</p></li><li><p>逻辑回归与最大熵模型都是对数线性模型，当标签值只有两个的时候的最大熵模型就是逻辑回归模型</p></li><li><p>回归模型：$f(x) = \frac{1}{1+e^{-wx}}$</p></li></ul><h3 id="最大熵模型"><a href="#最大熵模型" class="headerlink" title="最大熵模型"></a>最大熵模型</h3><ul><li>熵表示的是数据的不确定性，熵越大，不确定性越大</li><li>最大熵模型：保留所有的不确定性，将风险降到最低</li><li>最大熵模型的学习过程就是在可能的模型集合中选择最优模型，熵最大的情况就是等概率，即最不确定的情况</li><li>最大熵模型也可以用于二分类和多分类任务</li><li>最大熵模型的具体推导过程还在学习中，后续持续更新</li></ul><h3 id="相关数学知识"><a href="#相关数学知识" class="headerlink" title="相关数学知识"></a>相关数学知识</h3><ul><li>经验分布：经验分布是指依据样本频率估计概率的方式得到的与实际近似的分布</li><li>极大似然估计：利用已知的样本结果，反推最有可能（最大概率）导致这样结果的参数值</li></ul><h3 id="代码实现及测试"><a href="#代码实现及测试" class="headerlink" title="代码实现及测试"></a>代码实现及测试</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入相关包</span></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> exp</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd </span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt </span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_data</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 加载iris数据集并转化格式</span></span><br><span class="line">    iris = load_iris()</span><br><span class="line">    df = pd.DataFrame(iris.data, columns=iris.feature_names)</span><br><span class="line">    df[<span class="string">'label'</span>] = iris.target</span><br><span class="line">    <span class="comment"># 选择前100行中的前两列和最后一列，即数据结构为(x, y, label)</span></span><br><span class="line">    data = np.array(df.iloc[:<span class="number">100</span>, [<span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>]])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data[:, :<span class="number">-1</span>], data[:, <span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogisticRegressionClassifier</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, max_iter=<span class="number">200</span>, learning_rate=<span class="number">0.01</span>)</span>:</span></span><br><span class="line">        self.max_iter = max_iter</span><br><span class="line">        self.learning_rate = learning_rate</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sigmod</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> / (exp(-x) + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">data_matrix</span><span class="params">(self, X)</span>:</span></span><br><span class="line">        <span class="comment"># 将X转化成矩阵，并将第一行设置成1，这样[1, x][w, b]</span></span><br><span class="line">        data_mat = []</span><br><span class="line">        <span class="keyword">for</span> d <span class="keyword">in</span> X:</span><br><span class="line">            <span class="comment"># print(d)</span></span><br><span class="line">            data_mat.append([<span class="number">1.0</span>, *d])</span><br><span class="line">        <span class="keyword">return</span> data_mat</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, X, y)</span>:</span></span><br><span class="line">        data_mat = self.data_matrix(X)</span><br><span class="line">        <span class="comment"># 初始化权重为0，长度为len(x)+1, 即[b, w]</span></span><br><span class="line">        self.weights = np.zeros((len(data_mat[<span class="number">0</span>]), <span class="number">1</span>), dtype=np.float32)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> iter_ <span class="keyword">in</span> range(self.max_iter):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(X)):</span><br><span class="line">                <span class="comment"># w*x + b</span></span><br><span class="line">                result = self.sigmod(np.dot(data_mat[i], self.weights))</span><br><span class="line">                error = y[i] - result</span><br><span class="line">                <span class="comment"># 权重更新</span></span><br><span class="line">                self.weights += self.learning_rate * error *np.transpose([data_mat[i]])</span><br><span class="line">        </span><br><span class="line">        print(<span class="string">'LogisticRegression Model(learning_rate=&#123;&#125;,max_iter=&#123;&#125;)'</span>.format(</span><br><span class="line">            self.learning_rate, self.max_iter))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self, X_test, y_test)</span>:</span></span><br><span class="line">        right = <span class="number">0</span></span><br><span class="line">        X_test = self.data_matrix(X_test)</span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> zip(X_test, y_test):</span><br><span class="line">            result = self.sigmod(np.dot(x, self.weights))</span><br><span class="line">            <span class="comment"># 统计预测正确的数量</span></span><br><span class="line">            <span class="keyword">if</span> (result &gt; <span class="number">0</span> <span class="keyword">and</span> y==<span class="number">1</span>) <span class="keyword">or</span> (result &lt; <span class="number">0</span> <span class="keyword">and</span> y==<span class="number">0</span>):</span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> right/float(len(X_test))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 数据准备</span></span><br><span class="line">    X, y = create_data()</span><br><span class="line">    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(X_train, X_test, y_train, y_test)</span></span><br><span class="line"></span><br><span class="line">    lr_clf = LogisticRegressionClassifier()</span><br><span class="line">    <span class="comment"># 训练</span></span><br><span class="line">    lr_clf.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 用测试集测试模型性能</span></span><br><span class="line">    lr_clf.score(X_test, y_test)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 绘制</span></span><br><span class="line">    x_points = np.arange(<span class="number">4</span>, <span class="number">8</span>)</span><br><span class="line">    <span class="comment"># 拟合曲线weights = [b, Wx, Wy], 曲线为：weights[1]*x + weights[2]*y + b = 0 ---&gt; y = (weights[1]*x + b) / weights[2]</span></span><br><span class="line">    y_ = -(lr_clf.weights[<span class="number">1</span>]*x_points + lr_clf.weights[<span class="number">0</span>]) / lr_clf.weights[<span class="number">2</span>]</span><br><span class="line">    plt.plot(x_points, y_)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 散点</span></span><br><span class="line">    plt.scatter(X[:<span class="number">50</span>, <span class="number">0</span>], X[:<span class="number">50</span>, <span class="number">1</span>], label=<span class="string">'0'</span>)</span><br><span class="line">    plt.scatter(X[<span class="number">50</span>:, <span class="number">0</span>], X[<span class="number">50</span>:, <span class="number">1</span>], label=<span class="string">'1'</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">    print(lr_clf.weights)</span><br></pre></td></tr></table></figure><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><p>《统计学习方法（第二版）》</p></li><li><p>《机器学习实战》</p></li><li><p><a href="https://github.com/fengdu78/lihang-code" target="_blank" rel="noopener">黄海广博士的代码</a></p></li></ul><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Artificial Intelligence </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习之决策树</title>
      <link href="/passages/ji-qi-xue-xi-zhi-jue-ce-shu/"/>
      <url>/passages/ji-qi-xue-xi-zhi-jue-ce-shu/</url>
      
        <content type="html"><![CDATA[<p>决策树</p><a id="more"></a><h3 id="算法要点"><a href="#算法要点" class="headerlink" title="算法要点"></a>算法要点</h3><ul><li><p>决策树是一种基本的分类与回归方法</p></li><li><p>决策树模型可以认为是if-then规则的集合，也可以认为是定义在特征空间与类空间上的条件概率分布</p></li><li><p>决策树的学习过程主要分为三个步骤：特征选择、决策树的生成、决策树的修剪</p></li><li><blockquote><p>优点：计算复杂度不高，输出结果易于理解，对中间的缺失不敏感，可以处理不相关特征数据</p><p>缺点：可能会产生过度匹配问题</p></blockquote></li><li><p>决策树的训练</p><blockquote><p>决策树学习，本质上是从训练数据中归纳出一组分类规则，由于符合这一规则的决策树可能有多个，故我们要寻找的是一个与训练数据矛盾较小的决策树，同时具有较好的泛化能力。</p><p>决策树的学习策略是：以损失函数（通常是正则化的极大似然函数）为目标函数的最小化。</p><p>递归的选择最优特征（该特征对数据集的划分是当前最优的划分），并根据该特征对训练数据进行分割，直到所有子集中只包含一个类别的数据</p></blockquote></li><li><p>具体训练过程</p><ul><li>开始，构建根节点，将所有训练数据都放在根节点</li><li>选择一个最优特征，按照这一特征将训练数据分割成子集</li><li>如果子集已经可以被很好的分类了，则构建叶节点，并将这个子集放到叶节点之中</li><li>若还存在子集不能被很好的分类，那么对这些子集选择新的最优特征，继续进行分类</li><li>直到所有训练数据子集被基本正确分类，或者没有合适的特征为止</li><li>以上步骤进行完毕之后，我们还需要防止决策树的过拟合，也就是对决策树的剪枝，使其拥有较好的泛化能力</li></ul></li><li><p>决策树的生成值考虑局部最优，决策树的剪枝则需要考虑全局最优</p></li><li><p>决策树常用的学习算法有：ID3、C4.5、CART</p></li></ul><h4 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h4><ul><li>特征选择在于选取对于训练数据具有分类能力的特征，特征选择的准则通常使用<strong>信息增益</strong>和<strong>信息增益比</strong></li><li><strong>熵</strong>表示的是随机变量不确定性的度量；熵越大，随机变量的不确定性就越大</li><li><strong>条件熵</strong>$H(Y|X)$表示在已知随即便来那个X的情况下随机变量Y的不确定性</li><li><strong>信息增益</strong>表示得之特征X的信息而使类Y的信息的不确定性减少的程度（也就是X对 最终确定类别Y的贡献度），<strong>信息增益越大的特征具有更强的分类能力</strong></li><li>特征A对数据集合D的信息增益，定义为：集合D的经验熵（由数据估计得到的熵）$H(D)$与特征A给定条件下D的经验条件熵$H(D|A)$之差，即$g(D, A) = H(D) - H(D|A)$</li><li>根据信息增益选择特征的方式是：计算所有特征的信息增益，并选择信息增益最大的特征作为当前的划分依据</li><li>由于信息增益偏向于选择取值较多的特征，所以提出信息增益比来矫正该问题，定义为：<strong>特征A对数据集合D的信息增益</strong>与<strong>训练数据集D关于特征A的值的熵</strong>之比</li></ul><h4 id="决策树的生成"><a href="#决策树的生成" class="headerlink" title="决策树的生成"></a>决策树的生成</h4><ul><li><p><strong>ID3算法</strong></p><blockquote><p>从根节点开始，对节点计算所有可能的特征的信息增益，选择信息增益最大的特征作为节点的特征，由该特征的不同取值建立子节点，再对子节点递归的调用以上方法；直到所有特征的信息增益均很小或没有特征可以选择为止</p><p>​     </p><p>ID3算法只有树的生成，所以该算法生成的树容易产生过拟合</p></blockquote></li><li><p><strong>C4.5算法</strong></p><blockquote><p>相比于ID3算法，C4.5使用信息增益比为标准来进行决策树的构建</p></blockquote></li><li><p><strong>剪枝处理</strong></p><blockquote><p>剪枝的目的主要是为了防止过拟合</p><p>在学习时过多的考虑如何提高对训练数据的正确分类，从而构建出过于复杂的决策树</p><p>具体来说，剪枝从已经生成的树上裁剪掉一些字数或叶子结点，并将其根节点或父节点作为新的叶节点</p><p>通过优化损失函数还考虑了减少模型复杂度，从整体上优化了模型</p></blockquote></li><li><p><strong>CART算法</strong></p><blockquote><p>CART：分类与回归树，可以用于回归，也可以用于分类</p><p>决策树生成：基于训练数据集生成决策树，生成的决策树要尽量大</p><p>决策树剪枝：用验证数据集对已生成的树进行剪枝并选择最优子树，这是用损失函数最小作为剪枝的标准</p><p>​    首先从生成算法产生的决策树T0底端开始不断剪枝，直到T0的根节点，形成一个子树序列，</p><p>​    然后，通过交叉验证法在独立的验证数据集上对子树序列进行测试，从中选择最优子树</p><p>决策树的生成就是递归地构建二叉决策树的过程。对于回归树用平方误差最小化准则；对于分类书用基尼指数最小化准则进行特征选择</p></blockquote></li></ul><h3 id="代码实现及测试"><a href="#代码实现及测试" class="headerlink" title="代码实现及测试"></a>代码实现及测试</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd </span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> log</span><br><span class="line"><span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用ID3算法生成决策树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="comment"># 结点类，树的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, root=True, label=None, feature_name=None, feature=None)</span>:</span></span><br><span class="line">        self.root = root</span><br><span class="line">        self.label = label</span><br><span class="line">        self.feature_name = feature_name</span><br><span class="line">        self.feature = feature</span><br><span class="line"></span><br><span class="line">        self.tree = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        self.result = &#123;</span><br><span class="line">            <span class="string">'label'</span>:self.label,</span><br><span class="line">            <span class="string">'feature'</span>:self.feature,</span><br><span class="line">            <span class="string">'tree'</span>:self.tree</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&#123;&#125;'</span>.format(self.result)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_node</span><span class="params">(self, val, node)</span>:</span></span><br><span class="line">        self.tree[val] = node</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, features)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.root <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">return</span> self.label</span><br><span class="line">        <span class="keyword">return</span> self.tree[features[self.feature]].predict(features)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DTree</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, epsilon=<span class="number">0.1</span>)</span>:</span></span><br><span class="line">        self.epsilon = epsilon</span><br><span class="line">        self._tree = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 熵</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calc_ent</span><span class="params">(self, datasets)</span>:</span></span><br><span class="line">        data_length = len(datasets)</span><br><span class="line">        label_count = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(data_length):</span><br><span class="line">            label = datasets[i][<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> label <span class="keyword">not</span> <span class="keyword">in</span> label_count:</span><br><span class="line">                label_count[label] = <span class="number">0</span></span><br><span class="line">            label_count[label] += <span class="number">1</span></span><br><span class="line">        ent = -sum([(p/data_length) * log(p/data_length, <span class="number">2</span>) <span class="keyword">for</span> p <span class="keyword">in</span> label_count.values()])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ent</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 经验条件熵</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cond_ent</span><span class="params">(self, datasets, axis=<span class="number">0</span>)</span>:</span></span><br><span class="line">        data_length = len(datasets)</span><br><span class="line">        feature_sets = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(data_length):</span><br><span class="line">            feature = datasets[i][axis]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> feature <span class="keyword">not</span> <span class="keyword">in</span> feature_sets:</span><br><span class="line">                feature_sets[feature] = []</span><br><span class="line">            feature_sets[feature].append(datasets[i])</span><br><span class="line">        cond_ent = sum([(len(p)/data_length)*self.calc_ent(p) <span class="keyword">for</span> p <span class="keyword">in</span> feature_sets.values()])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cond_ent</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 信息增益</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info_gain</span><span class="params">(self, ent, cond_ent)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> ent - cond_ent</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info_gain_train</span><span class="params">(self, datasets)</span>:</span></span><br><span class="line">        count = len(datasets[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">        ent = self.calc_ent(datasets)</span><br><span class="line">        best_feature = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> range(count):</span><br><span class="line">            c_info_gain = self.info_gain(ent, self.cond_ent(datasets, axis=c))</span><br><span class="line">            best_feature.append((c, c_info_gain))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 比较大小</span></span><br><span class="line">        best_ = max(best_feature, key=<span class="keyword">lambda</span> x: x[<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> best_</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(self, train_data)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        input: 数据集，特征集，阈值eta</span></span><br><span class="line"><span class="string">        output：决策树T</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        _, y_train, featrues = train_data.iloc[:, :<span class="number">-1</span>], train_data.iloc[:, <span class="number">-1</span>], train_data.columns[:<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 若D中实例属于同一类Ck，则T为单结点树，并且Ck为结点的类别，返回T</span></span><br><span class="line">        <span class="keyword">if</span> len(y_train.value_counts()) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> Node(root=<span class="literal">True</span>, label=y_train.iloc[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果特征集A为空，则T为单节点树，将D中实例树最大的类Ck作为该节点的类标记，返回T</span></span><br><span class="line">        <span class="keyword">if</span> len(featrues) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> Node(root=<span class="literal">True</span>, label=y_train.value_counts().sort_values(ascending=<span class="literal">False</span>).index[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算最大信息增益，Ag为信息增益最大的特征</span></span><br><span class="line">        max_feature, max_info_gain = self.info_gain_train(np.array(train_data))</span><br><span class="line">        max_feature_name = featrues[max_feature]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 信息增益Ag如果小于阈值eta（相当于特征集为空），则T为单节点树，并将D中是实例数最大的类别Ck作为该节点的类标记</span></span><br><span class="line">        <span class="keyword">if</span> max_info_gain &lt; self.epsilon:</span><br><span class="line">            <span class="keyword">return</span> Node(root=<span class="literal">True</span>,</span><br><span class="line">                        label=y_train.value_counts().sort_values(ascending=<span class="literal">False</span>).index[<span class="number">0</span>]</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 构建Ag子集</span></span><br><span class="line">        node_tree = Node(</span><br><span class="line">            root=<span class="literal">False</span>, feature_name=max_feature_name, feature=max_feature</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        featrue_list = train_data[max_feature_name].value_counts().index</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> f <span class="keyword">in</span> featrue_list:</span><br><span class="line">            sub_train_df = train_data.loc[train_data[max_feature_name] == f].drop([max_feature_name], axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 递归生成树</span></span><br><span class="line">            sub_tree = self.train(sub_train_df)</span><br><span class="line">            node_tree.add_node(f, sub_tree)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># pprint.pprint(node_tree.tree)</span></span><br><span class="line">        <span class="keyword">return</span> node_tree</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, train_data)</span>:</span></span><br><span class="line">        self._tree = self.train(train_data)</span><br><span class="line">        <span class="keyword">return</span> self._tree</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, X_test)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._tree.predict(X_test)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_data</span><span class="params">()</span>:</span></span><br><span class="line">    datasets = [[<span class="string">'青年'</span>, <span class="string">'否'</span>, <span class="string">'否'</span>, <span class="string">'一般'</span>, <span class="string">'否'</span>],</span><br><span class="line">               [<span class="string">'青年'</span>, <span class="string">'否'</span>, <span class="string">'否'</span>, <span class="string">'好'</span>, <span class="string">'否'</span>],</span><br><span class="line">               [<span class="string">'青年'</span>, <span class="string">'是'</span>, <span class="string">'否'</span>, <span class="string">'好'</span>, <span class="string">'是'</span>],</span><br><span class="line">               [<span class="string">'青年'</span>, <span class="string">'是'</span>, <span class="string">'是'</span>, <span class="string">'一般'</span>, <span class="string">'是'</span>],</span><br><span class="line">               [<span class="string">'青年'</span>, <span class="string">'否'</span>, <span class="string">'否'</span>, <span class="string">'一般'</span>, <span class="string">'否'</span>],</span><br><span class="line">               [<span class="string">'中年'</span>, <span class="string">'否'</span>, <span class="string">'否'</span>, <span class="string">'一般'</span>, <span class="string">'否'</span>],</span><br><span class="line">               [<span class="string">'中年'</span>, <span class="string">'否'</span>, <span class="string">'否'</span>, <span class="string">'好'</span>, <span class="string">'否'</span>],</span><br><span class="line">               [<span class="string">'中年'</span>, <span class="string">'是'</span>, <span class="string">'是'</span>, <span class="string">'好'</span>, <span class="string">'是'</span>],</span><br><span class="line">               [<span class="string">'中年'</span>, <span class="string">'否'</span>, <span class="string">'是'</span>, <span class="string">'非常好'</span>, <span class="string">'是'</span>],</span><br><span class="line">               [<span class="string">'中年'</span>, <span class="string">'否'</span>, <span class="string">'是'</span>, <span class="string">'非常好'</span>, <span class="string">'是'</span>],</span><br><span class="line">               [<span class="string">'老年'</span>, <span class="string">'否'</span>, <span class="string">'是'</span>, <span class="string">'非常好'</span>, <span class="string">'是'</span>],</span><br><span class="line">               [<span class="string">'老年'</span>, <span class="string">'否'</span>, <span class="string">'是'</span>, <span class="string">'好'</span>, <span class="string">'是'</span>],</span><br><span class="line">               [<span class="string">'老年'</span>, <span class="string">'是'</span>, <span class="string">'否'</span>, <span class="string">'好'</span>, <span class="string">'是'</span>],</span><br><span class="line">               [<span class="string">'老年'</span>, <span class="string">'是'</span>, <span class="string">'否'</span>, <span class="string">'非常好'</span>, <span class="string">'是'</span>],</span><br><span class="line">               [<span class="string">'老年'</span>, <span class="string">'否'</span>, <span class="string">'否'</span>, <span class="string">'一般'</span>, <span class="string">'否'</span>],</span><br><span class="line">               ]</span><br><span class="line">    labels = [<span class="string">u'年龄'</span>, <span class="string">u'有工作'</span>, <span class="string">u'有自己的房子'</span>, <span class="string">u'信贷情况'</span>, <span class="string">u'类别'</span>]</span><br><span class="line">    <span class="comment"># 返回数据集和每个维度的名称</span></span><br><span class="line">    <span class="keyword">return</span> datasets, labels</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    datasets, labels = create_data()</span><br><span class="line">    data_df = pd.DataFrame(datasets, columns=labels)</span><br><span class="line"></span><br><span class="line">    dt = DTree()</span><br><span class="line">    tree = dt.fit(data_df)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(tree)</span></span><br><span class="line"></span><br><span class="line">    print(dt.predict([<span class="string">'老年'</span>, <span class="string">'否'</span>, <span class="string">'否'</span>, <span class="string">'一般'</span>]))</span><br></pre></td></tr></table></figure><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>《统计学习方法（第二版）》</li><li>《机器学习实战》</li><li><a href="https://github.com/fengdu78/lihang-code" target="_blank" rel="noopener">黄海广博士的代码</a></li></ul><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Artificial Intelligence </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之有效的括号</title>
      <link href="/passages/leetcode-zhi-you-xiao-de-gua-hao/"/>
      <url>/passages/leetcode-zhi-you-xiao-de-gua-hao/</url>
      
        <content type="html"><![CDATA[<p>有效的括号</p><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><ul><li>题目详情见：<a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">有效的括号</a></li><li>题目难度：简单</li><li>相关标签：栈、字符串</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>括号匹配是栈的应用之一，这里讲一下思路</li><li>只要遇到左括号就入栈，遇到右括号则右括号与栈顶元素匹配，<ul><li>如果匹配则栈顶元素出栈</li><li>如果不匹配则失败</li></ul></li><li>直到所有括号均遍历一遍</li><li>可以使用Python的字典{‘左括号’：’右括号’}，右括号是不会有入栈的可能的</li><li>几个特殊情况<ul><li>栈空时的pop操作会报错，所以我们给栈赋初值，并对该初值在字典中建立对应关系</li><li>当序列以左括号结尾是，也是需要特殊处理的，这时判断一下栈内的元素个数即可（加上我们的初值长度应该为2）</li></ul></li></ul><h3 id="代码一"><a href="#代码一" class="headerlink" title="代码一"></a>代码一</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">dict = &#123;<span class="string">'('</span>: <span class="string">')'</span>, <span class="string">'['</span>: <span class="string">']'</span>, <span class="string">'&#123;'</span>: <span class="string">'&#125;'</span>, <span class="string">'?'</span>: <span class="string">'?'</span>&#125;</span><br><span class="line">stack = [<span class="string">'?'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line"><span class="comment"># 左括号，入栈</span></span><br><span class="line"><span class="keyword">if</span> c <span class="keyword">in</span> dict:</span><br><span class="line">stack.append(c)</span><br><span class="line"><span class="comment"># 右括号</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">top = stack.pop()</span><br><span class="line"><span class="comment"># 匹配失败</span></span><br><span class="line"><span class="keyword">if</span> dict[top] != c:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="keyword">if</span> len(stack) == <span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="keyword">if</span> len(stack) == <span class="number">2</span>:</span><br><span class="line"><span class="comment"># 左括号结尾,匹配失败</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h3 id="代码二"><a href="#代码二" class="headerlink" title="代码二"></a>代码二</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 与代码一实现的算法思想是相同的，但是代码实现上更加简洁紧凑</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self,s: str)</span> -&gt; bool:</span></span><br><span class="line">    dict = &#123;<span class="string">'('</span>: <span class="string">')'</span>, <span class="string">'['</span>: <span class="string">']'</span>, <span class="string">'&#123;'</span>: <span class="string">'&#125;'</span>, <span class="string">'?'</span>: <span class="string">'?'</span>&#125;</span><br><span class="line">stack = [<span class="string">'?'</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">in</span> dict:</span><br><span class="line">            stack.append(c)</span><br><span class="line">        <span class="keyword">elif</span> dict[stack.pop()] != c:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> len(stack) == <span class="number">1</span></span><br></pre></td></tr></table></figure><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之最长公共前缀</title>
      <link href="/passages/leetcode-zhi-zui-chang-gong-gong-qian-zhui/"/>
      <url>/passages/leetcode-zhi-zui-chang-gong-gong-qian-zhui/</url>
      
        <content type="html"><![CDATA[<p>最长公共前缀</p><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><ul><li>题目详情见：<a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="noopener">最长公共前缀</a></li><li>题目难度：简单</li><li>相关标签：字符串</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>输入只有小写字母，不存在干扰数据，可以直接处理</li><li>最直接的思路就是选定一个字符串，将其前缀依次与各个字符串的前缀比较，前缀长度依次加1，时间复杂度很高（不写了，有兴趣的可自行实现）</li><li>将字符串数组是做二维数组，按列扫描，直到发现某一列不完全相同，之前的列中任取一行就是最长共同前缀（见代码一）<ul><li>利用<code>set</code>：每次取每个字符串的同一列，放入<code>set</code>中，如果<code>set</code>长度为1，则是共同字符</li><li>利用<code>zip()</code>函数：返回<code>strs</code>的每个字符串的迭代器</li></ul></li><li>前两个字符串找最长公共子串，结果再与第三个字符串找共同前缀，直到整个字符串数组全部参与（见代码二）<ul><li>这里还可以进行优化：求所有字符串长度的最小值，所有求公共字串的过程都只需要求最小值长度的即可</li></ul></li><li>在讨论区看到了一个超赞的想法，这里记录一下（见代码二）</li></ul><h3 id="代码一"><a href="#代码一" class="headerlink" title="代码一"></a>代码一</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs: List[str])</span> -&gt; str：</span></span><br><span class="line"><span class="function">if not strs:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 返回每一列的集合（不含重复元素）</span></span><br><span class="line">    ss = list(map(set, zip(*strs)))</span><br><span class="line">    </span><br><span class="line">    res = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> i, x <span class="keyword">in</span> enumerate(ss):</span><br><span class="line">        x = list(x)</span><br><span class="line">        <span class="comment"># 长度大于1说明该列不完全相同</span></span><br><span class="line">        <span class="keyword">if</span> len(x) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 将完全相同的列的字母添加到最长公共子串中</span></span><br><span class="line">        res = res + x[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="代码二"><a href="#代码二" class="headerlink" title="代码二"></a>代码二</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> strs:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    </span><br><span class="line">    s1 = min(strs)</span><br><span class="line">    s2 = max(strs)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i, x <span class="keyword">in</span> enumerate(s1):</span><br><span class="line">        <span class="keyword">if</span> x != s2[i]</span><br><span class="line">        <span class="keyword">return</span> s2[:i]</span><br><span class="line">    <span class="keyword">return</span> s1</span><br></pre></td></tr></table></figure><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习之朴素贝叶斯</title>
      <link href="/passages/ji-qi-xue-xi-zhi-po-su-bei-xie-si/"/>
      <url>/passages/ji-qi-xue-xi-zhi-po-su-bei-xie-si/</url>
      
        <content type="html"><![CDATA[<p>朴素贝叶斯</p><a id="more"></a><h3 id="算法要点"><a href="#算法要点" class="headerlink" title="算法要点"></a>算法要点</h3><ul><li><p>朴素贝叶斯是基于贝叶斯定理与特征条件独立假设的<strong>分类方法</strong></p></li><li><p>算法概述</p><blockquote><p>对于给定的训练数据集，首先基于特征条件独立假设学习输入输出的联合概率分布；</p><p>然后基于此模型，对给定输入的x，利用贝叶斯定理求出后验概率最大的输出y</p></blockquote></li><li><p>优缺点</p><blockquote><p>优点：在数据较少的情况下仍然有效，可以完成多分类任务</p><p>缺点：对于输入数据的准备方式较为敏感</p></blockquote></li></ul><h3 id="相关数学知识"><a href="#相关数学知识" class="headerlink" title="相关数学知识"></a>相关数学知识</h3><ul><li>先验概率分布<ul><li>与实验结果无关，与随机抽样无关，反应在进行统计试验之前根据其他有关参数的知识而得知的分布</li></ul></li><li>条件概率<ul><li>已知某条件的情况下，计算事件发生的概率</li><li>$P(事件1|条件) = \frac{P(时间1 and 条件)}{P(条件)}$</li><li>已知$P(x|c)$求$P(c|x)$，$P(c|x) = \frac{P(x|c)P(c)}{P(x)}$</li></ul></li><li>极大似然估计<ul><li>已知某个参数值能使这个样本出现的概率最大，我们就直接将这个参数的值做为估计的真实值</li></ul></li><li>模型：<ul><li>高斯模型</li><li>多项式模型</li><li>伯努利模型</li></ul></li></ul><h3 id="代码实现及测试"><a href="#代码实现及测试" class="headerlink" title="代码实现及测试"></a>代码实现及测试</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd </span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt </span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_data</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 读取数据并返回X，y</span></span><br><span class="line">    iris = load_iris()</span><br><span class="line"></span><br><span class="line">    df = pd.DataFrame(iris.data, columns=iris.feature_names)</span><br><span class="line">    df[<span class="string">'label'</span>] = iris.target</span><br><span class="line">    df.columns = [<span class="string">'sepal length'</span>, <span class="string">'sepal width'</span>, <span class="string">'petal length'</span>, <span class="string">'petal width'</span>, <span class="string">'label'</span>]</span><br><span class="line"></span><br><span class="line">    data = np.array(df.iloc[:<span class="number">100</span>, :])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回X，y</span></span><br><span class="line">    <span class="keyword">return</span> data[:, :<span class="number">-1</span>], data[:, <span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NaiveBayes</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.model = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 数学期望（平均值）</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mean</span><span class="params">(self, X)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> sum(X) / float(len(X))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 标准差（方差的算术平方根 sqrt(sum(x - r)^2)/N）</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">stdev</span><span class="params">(self, X)</span>:</span></span><br><span class="line">        avg = self.mean(X)</span><br><span class="line">        <span class="keyword">return</span> math.sqrt(sum([pow(x - avg, <span class="number">2</span>) <span class="keyword">for</span> x <span class="keyword">in</span> X]) / float(len(X)))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 概率密度函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gaussian_probability</span><span class="params">(self, x, mean, stdev)</span>:</span></span><br><span class="line">        exponent = math.exp(-(math.pow(x - mean, <span class="number">2</span>) / (<span class="number">2</span> * math.pow(stdev, <span class="number">2</span>))))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span> / (math.sqrt(<span class="number">2</span> * math.pi) * stdev)) * exponent</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 处理X_train:  取每一条数据的均值和标准差</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">summarize</span><span class="params">(self, train_data)</span>:</span></span><br><span class="line">        summaries = [(self.mean(i), self.stdev(i)) <span class="keyword">for</span> i <span class="keyword">in</span> zip(*train_data)]</span><br><span class="line">        <span class="keyword">return</span> summaries</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 分类别求出数学期望和标准差</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, X, y)</span>:</span></span><br><span class="line">        <span class="comment"># 无重复的标记</span></span><br><span class="line">        labels = list(set(y))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 根据类别标记创建类别标记数个字典键值对</span></span><br><span class="line">        data = &#123;label: [] <span class="keyword">for</span> label <span class="keyword">in</span> labels&#125;</span><br><span class="line">        <span class="comment"># 将不同类别标记的实例放到不同的列表中</span></span><br><span class="line">        <span class="keyword">for</span> f, label <span class="keyword">in</span> zip(X, y):</span><br><span class="line">            data[label].append(f)</span><br><span class="line">        self.model = &#123;</span><br><span class="line">            label: self.summarize(value)</span><br><span class="line">            <span class="keyword">for</span> label, value <span class="keyword">in</span> data.items()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'gassianNB train done !'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算概率</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate_probabilities</span><span class="params">(self, input_data)</span>:</span></span><br><span class="line">        probabilities = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> label, value <span class="keyword">in</span> self.model.items():</span><br><span class="line">            probabilities[label] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(value)):</span><br><span class="line">                mean, stdev = value[i]</span><br><span class="line">                <span class="comment"># 计算高斯概率密度函数</span></span><br><span class="line">                probabilities[label] *= self.gaussian_probability(input_data[i], mean, stdev)</span><br><span class="line">        <span class="keyword">return</span> probabilities</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, X_test)</span>:</span></span><br><span class="line">        label = sorted(</span><br><span class="line">            self.calculate_probabilities(X_test).items(),</span><br><span class="line">            key=<span class="keyword">lambda</span> x: x[<span class="number">-1</span>])[<span class="number">-1</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> label</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self, X_test, y_test)</span>:</span></span><br><span class="line">        <span class="comment"># 计算预测正确率</span></span><br><span class="line">        right = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> X, y <span class="keyword">in</span> zip(X_test, y_test):</span><br><span class="line">            label = self.predict(X)</span><br><span class="line">            <span class="keyword">if</span> label == y:</span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> right / float(len(X_test))</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    X, y = create_data()</span><br><span class="line"></span><br><span class="line">    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(X_test[0], y_test[0])</span></span><br><span class="line"></span><br><span class="line">    model = NaiveBayes()</span><br><span class="line"></span><br><span class="line">    model.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'X is [4.4, 3.2, 1.3, 0.2], label is &#123;&#125;'</span>.format(model.predict([<span class="number">4.4</span>, <span class="number">3.2</span>, <span class="number">1.3</span>, <span class="number">0.2</span>])))</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'model score : '</span>, model.score(X_test, y_test))</span><br></pre></td></tr></table></figure><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Artificial Intelligence </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xgboost和lightGBM的安装</title>
      <link href="/passages/xgboost-he-lightgbm-de-an-zhuang/"/>
      <url>/passages/xgboost-he-lightgbm-de-an-zhuang/</url>
      
        <content type="html"><![CDATA[<p>LightGBM，XGBoost</p><a id="more"></a><p>LightGBM，XGBoost作为非常经典的GBDT模型，在机器学习的比赛中使用的频率也是非常之高。这里记录一下安装这两个库的步骤</p><h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3><ul><li>Windows10</li><li>Python3.7</li></ul><h3 id="Xgboost的安装"><a href="#Xgboost的安装" class="headerlink" title="Xgboost的安装"></a>Xgboost的安装</h3><ul><li>官网上有很详细的安装方法，但折腾了半天还是不能使用。所以这里我们选择使用离线安装的方式进行安装</li><li>首先在<a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/#xgboost" target="_blank" rel="noopener">这里</a>下载对应版本的xgboost版本</li><li>将目录切换到whl文件所在的目录</li><li>使用<code>pip install xgboost-XXXXXX.whl</code>进行安装</li><li>安装完成之后，使用<code>import xgboost as xgb</code>测试是否安装成功</li></ul><h3 id="lightGBM的安装"><a href="#lightGBM的安装" class="headerlink" title="lightGBM的安装"></a>lightGBM的安装</h3><ul><li>LightGBM是微软开源的一个Python工具包</li><li>网上大部分的安装教程都是编译安装的，坑点比较多，这里介绍一种简单的安装方式</li><li>在<a href="https://pypi.org/project/lightgbm/#files" target="_blank" rel="noopener">这里</a>下载whl安装包</li><li>将目录切换到lightGBM所在的目录</li><li>使用<code>pip install lightgbm-XXXXX.whl</code>进行安装</li><li>使用<code>import lightgbm as lgb</code>测试</li></ul><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 工具配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习之感知机模型</title>
      <link href="/passages/ji-qi-xue-xi-zhi-gan-zhi-ji-mo-xing/"/>
      <url>/passages/ji-qi-xue-xi-zhi-gan-zhi-ji-mo-xing/</url>
      
        <content type="html"><![CDATA[<p>感知机模型</p><a id="more"></a><h3 id="算法要点"><a href="#算法要点" class="headerlink" title="算法要点"></a>算法要点</h3><ul><li><p>感知机是线性分类模型，属于判别模型，二分类模型</p></li><li><p>旨在求出特征空间中将实例划分为正负两类的分离超平面</p></li><li><p>算法概述</p><blockquote><p>感知机是根据输入实例的特征向量对其进行而分类的线性分类模型</p><p>感知机学习的策略是极小化损失函数</p><p>感知机学习算法是基于随即梯度下降法的对损失函数的最优化算法</p><p>输入空间到输出空间的函数（感知机）：$f(x) = sign(w*x + b)$</p><p>损失函数：$L(w, b) = - \sum_{x_i \in M}{y_i(w \cdot x_i + b)}$</p><p><strong>学习策略</strong>：在假设空间中选取使损失函数最小的模型参数$w, b$</p></blockquote></li><li><p>优化过程</p><blockquote><p>每次随机选取其中一个误分类点计算损失</p><p>损失函数分别对$w, b$求偏导</p><p>根据学习率进行参数值的更新</p></blockquote></li><li><p>当训练数据集线性可分时，感知机学习算法是收敛的</p></li></ul><h3 id="代码实现及测试"><a href="#代码实现及测试" class="headerlink" title="代码实现及测试"></a>代码实现及测试</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Perceptron</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 初始化模型的参数：w初始化为与data长度相同的一维向量，b初始化为0，learning rate为0.1</span></span><br><span class="line">        self.w = np.ones(len(data[<span class="number">0</span>])<span class="number">-1</span>, dtype=np.float32)</span><br><span class="line">        self.b = <span class="number">0</span></span><br><span class="line">        self.l_r = <span class="number">0.1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sign</span><span class="params">(self, x, w, b)</span>:</span></span><br><span class="line">        y = np.dot(x, w) + b</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, X_train, y_train)</span>:</span></span><br><span class="line">        <span class="comment"># 随机梯度下降</span></span><br><span class="line">        is_wrong = <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 有误分点的时候才会进行梯度下降</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> is_wrong:</span><br><span class="line">            wrong_count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> d <span class="keyword">in</span> range(len(X_train)):</span><br><span class="line">                X = X_train[d]</span><br><span class="line">                y = y_train[d]</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> y*self.sign(X, self.w, self.b) &lt;= <span class="number">0</span>:</span><br><span class="line">                    self.w = self.w + self.l_r * np.dot(y, X)</span><br><span class="line">                    self.b = self.b + self.l_r * y</span><br><span class="line">                    wrong_count += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> wrong_count == <span class="number">0</span>:</span><br><span class="line">                is_wrong = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Perceptron Model'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, X)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> np.dot(self.w, X) + self.b &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加载数据集</span></span><br><span class="line">    iris = load_iris()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 转化数据格式</span></span><br><span class="line">    df = pd.DataFrame(iris.data, columns=iris.feature_names)</span><br><span class="line">    df[<span class="string">'label'</span>] = iris.target</span><br><span class="line">    df.columns = [<span class="string">'sepal length'</span>, <span class="string">'sepal width'</span>, <span class="string">'petal length'</span>, <span class="string">'petal width'</span>, <span class="string">'label'</span>]</span><br><span class="line"></span><br><span class="line">    data = np.array(df.iloc[:<span class="number">100</span>, [<span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>]])</span><br><span class="line">    X, y = data[:, :<span class="number">-1</span>], data[:,<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将实例的target分为两类（感知机是二分类模型）,并且target设为1，-1</span></span><br><span class="line">    y = np.array([<span class="number">1</span> <span class="keyword">if</span> i==<span class="number">1</span> <span class="keyword">else</span> <span class="number">-1</span> <span class="keyword">for</span> i <span class="keyword">in</span> y])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加载模型并训练</span></span><br><span class="line">    perceptron = Perceptron()</span><br><span class="line">    perceptron.fit(X, y)</span><br><span class="line"></span><br><span class="line">    x_points = np.linspace(<span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="comment"># 划分超平面</span></span><br><span class="line">    y_ = -(perceptron.w[<span class="number">0</span>] * x_points + perceptron.b) / perceptron.w[<span class="number">1</span>]</span><br><span class="line">    <span class="comment"># 直线</span></span><br><span class="line">    plt.plot(x_points, y_)</span><br><span class="line">    <span class="comment"># 散点图</span></span><br><span class="line">    plt.plot(data[:<span class="number">50</span>, <span class="number">0</span>], data[:<span class="number">50</span>, <span class="number">1</span>], <span class="string">'bo'</span>, color=<span class="string">'blue'</span>, label=<span class="string">'1'</span>)</span><br><span class="line">    plt.plot(data[<span class="number">50</span>:<span class="number">100</span>, <span class="number">0</span>], data[<span class="number">50</span>:<span class="number">100</span>, <span class="number">1</span>], <span class="string">'bo'</span>, color=<span class="string">'orange'</span>, label=<span class="string">'-1'</span>)</span><br><span class="line">    plt.xlabel(<span class="string">'sepal length'</span>)</span><br><span class="line">    plt.ylabel(<span class="string">'sepal width'</span>)</span><br><span class="line">    plt.legend()</span><br><span class="line"></span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(perceptron.predict([1, 2]))</span></span><br></pre></td></tr></table></figure><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>《统计学习方法（第二版）》</li></ul><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Artificial Intelligence </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习之K临近算法</title>
      <link href="/passages/ji-qi-xue-xi-zhi-k-lin-jin-suan-fa/"/>
      <url>/passages/ji-qi-xue-xi-zhi-k-lin-jin-suan-fa/</url>
      
        <content type="html"><![CDATA[<p>K临近算法</p><a id="more"></a><h3 id="算法要点"><a href="#算法要点" class="headerlink" title="算法要点"></a>算法要点</h3><ul><li><p>KNN是一种有监督的机器学习算法</p></li><li><p>不具有显示的学习过程，预测 –&gt; 现场投票</p></li><li><p>结果唯一确定</p></li><li><p>算法概述</p><blockquote><p>给定一个训练数据集，对于任意的待预测实例，计算该实例与训练集中所有实例的距离，选择与该实例距离最近的K个实例进行投票，实例数最多的类别即被认定为待预测实例的类别</p></blockquote></li><li><p>关键参数：K，即允许参与最终投票的实例数</p></li><li><p>距离度量</p><ul><li>欧式距离</li><li>曼哈顿距离</li><li>各坐标距离的最大值</li></ul></li><li><p>特殊情况：当<code>k=1</code>的时候，称为最临近算法。也即是只与输入实例点最近的实例的类别有关</p></li><li><p>K值的取值</p><ul><li>选择较小的K值，近似误差会减小，估计误差会增大。也就是说K值的减小就意味着整体模型变得复杂，容易发生过拟合</li><li>选择较大的K值，可以减少模型的估计误差，但是学习的近似误差会增大。意味着模型变得简单。</li></ul></li></ul><h3 id="代码实现及测试"><a href="#代码实现及测试" class="headerlink" title="代码实现及测试"></a>代码实现及测试</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math </span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> combinations</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd </span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt </span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">验证数据集：鸢尾花数据集</span></span><br><span class="line"><span class="string">算法：自主实现的KNN</span></span><br><span class="line"><span class="string">辅助：</span></span><br><span class="line"><span class="string">    使用sklearn中的函数将数据集划分为训练集和测试集</span></span><br><span class="line"><span class="string">    使用Counter函数作为计数器</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_data</span><span class="params">(iris)</span>:</span></span><br><span class="line">    <span class="comment"># 转化数据格式</span></span><br><span class="line">    df = pd.DataFrame(iris.data, columns=iris.feature_names)</span><br><span class="line">    df[<span class="string">'label'</span>] = iris.target</span><br><span class="line">    df.columns = [<span class="string">'sepal length'</span>, <span class="string">'sepal width'</span>, <span class="string">'petal length'</span>, <span class="string">'petal width'</span>, <span class="string">'label'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 绘制散点图（取前两个维度作为坐标，每一个类别取50个）</span></span><br><span class="line">    plt.scatter(df[:<span class="number">50</span>][<span class="string">'sepal length'</span>], df[:<span class="number">50</span>][<span class="string">'sepal width'</span>], label=<span class="string">'0'</span>)</span><br><span class="line">    plt.scatter(df[<span class="number">50</span>:<span class="number">100</span>][<span class="string">'sepal length'</span>], df[<span class="number">50</span>:<span class="number">100</span>][<span class="string">'sepal width'</span>], label=<span class="string">'1'</span>)</span><br><span class="line">    plt.xlabel(<span class="string">'sepal length'</span>)</span><br><span class="line">    plt.ylabel(<span class="string">'sepal width'</span>)</span><br><span class="line">    plt.legend()</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KNN</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, X_train, y_train, n_neighbors=<span class="number">3</span>, p=<span class="number">2</span>)</span>:</span></span><br><span class="line">        <span class="comment"># 默认K取3，距离默认使用欧式距离</span></span><br><span class="line">        self.n = n_neighbors</span><br><span class="line">        self.p = p</span><br><span class="line">        self.X_train = X_train</span><br><span class="line">        self.y_train = y_train</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, X)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        将输入的X与训练集的各个实例计算距离，取前n_neighbors个进行投票</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        knn_list = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 先将前n个存入knn_list，再计算后len(X_train)-n个，同时比较，将距离更小的替换进来</span></span><br><span class="line">        <span class="comment"># 可减小内存压力</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.n):</span><br><span class="line">            <span class="comment"># 计算所有实例与待预测实例之间的距离</span></span><br><span class="line">            dist = np.linalg.norm(X - self.X_train[i], ord=self.p)</span><br><span class="line">            <span class="comment"># (距离, target)作为数据对</span></span><br><span class="line">            knn_list.append((dist, self.y_train[i]))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.n, len(self.X_train)):</span><br><span class="line">            max_index = knn_list.index(max(knn_list, key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>]))</span><br><span class="line">            dist = np.linalg.norm(X - self.X_train[i], ord=self.p)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> knn_list[max_index][<span class="number">0</span>] &gt; dist:</span><br><span class="line">                knn_list[max_index] = (dist, self.y_train[i])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 统计实例数最多的类别</span></span><br><span class="line">        knn = [k[<span class="number">-1</span>] <span class="keyword">for</span> k <span class="keyword">in</span> knn_list]</span><br><span class="line">        count_pairs = Counter(knn)</span><br><span class="line"></span><br><span class="line">        max_count = sorted(count_pairs.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])[<span class="number">-1</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> max_count</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self, X_test, y_test)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        计算预测正确率</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        right_count = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> X, y <span class="keyword">in</span> zip(X_test, y_test):</span><br><span class="line">            label = self.predict(X)</span><br><span class="line">            <span class="keyword">if</span> label == y:</span><br><span class="line">                right_count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> right_count / len(X_test)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 加载数据集</span></span><br><span class="line">    iris = load_iris()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 显示数据</span></span><br><span class="line">    <span class="comment"># show_data(iris)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 预处理数据</span></span><br><span class="line">    new_iris = np.column_stack((iris.data, iris.target))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 划分数据集</span></span><br><span class="line">    X_train, X_test, y_train, y_test = train_test_split(new_iris[:, :<span class="number">4</span>],new_iris[:, <span class="number">-1</span>], test_size = <span class="number">0.3</span>, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    clf = KNN(X_train, y_train)</span><br><span class="line">    print(clf.score(X_test, y_test))</span><br></pre></td></tr></table></figure><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>《统计学习方法（第二版）》</li></ul><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Artificial Intelligence </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python库之collections</title>
      <link href="/passages/python-ku-zhi-collections/"/>
      <url>/passages/python-ku-zhi-collections/</url>
      
        <content type="html"><![CDATA[<p>collections</p><a id="more"></a><p>今天看代码的时候发现了<code>collections</code>这个<code>Python</code>库，遂学习一下</p><h3 id="collections是什么"><a href="#collections是什么" class="headerlink" title="collections是什么"></a>collections是什么</h3><ul><li><code>collections</code>是一个<code>Python</code>内建的集合模块，提供许多有用的集合类</li><li><code>collections</code>模块提供了特定目标的容器，以提供<code>Python</code>标准内建容器<code>dict、list、set、tuple</code>的替代选择</li></ul><h3 id="collections提供的功能模块"><a href="#collections提供的功能模块" class="headerlink" title="collections提供的功能模块"></a>collections提供的功能模块</h3><ul><li><code>namedtuple</code>：用来创建一个自定义的<code>tuple</code>对象，并且规定了<code>tuple</code>元素的个数，并可以用属性而不是索引来引用<code>tuple</code>的某个元素</li><li><code>deque</code>：为了高效实现插入和删除操作的双向列表，适合用于队列和栈</li><li><code>ChainMap</code>：类似字典的容器类，将多个映射集合到一个视图里面</li><li><code>Counter</code>：一个简单的计数器（使用频率较高）</li><li><code>OrderedDict</code>：字典的子类，保存了他们被添加的顺序</li><li><code>defaultdict</code>：<code>key</code>不存在时，返回一个默认值，而默认的<code>dict</code>在<code>key</code>不存在是会抛出<code>keyError</code></li><li><code>UserDict</code>：封装了字典对象，简化了字典子类化</li><li><code>UserList</code>：封装了列表对象，简化了列表子类化</li><li><code>UserString</code>：封装了列表对象，简化了字符串子类化</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><ul><li><p><code>namedtuple</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">namedtuple</span></span><br><span class="line"><span class="string">允许自定义tuple对象，可以规定tuple的元素个数，允许使用属性来引用元素</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># 定义一个坐标点tuple，并规定元素个数为2</span></span><br><span class="line">Point = namedtuple(<span class="string">'Point'</span>, [<span class="string">'x'</span>, <span class="string">'y'</span>])</span><br><span class="line"></span><br><span class="line">p = Point(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用属性和索引都可以引用元素</span></span><br><span class="line">print(p.x, p.y)     <span class="comment"># 1 2</span></span><br><span class="line">print(p[<span class="number">0</span>], p[<span class="number">1</span>])   <span class="comment"># 1 2</span></span><br></pre></td></tr></table></figure></li><li><p><code>deque</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">deque</span></span><br><span class="line"><span class="string">高效实现列表的插入和删除元素，适合用于队列和栈</span></span><br><span class="line"><span class="string">另外还实现了除list本身的append()和pop()方法之外的appendleft()和popleft()，即允许高效的从头部添加和删除元素</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">q = deque([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</span><br><span class="line">q.append(<span class="string">'x'</span>)</span><br><span class="line">q.appendleft(<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line">print(q)        <span class="comment"># deque(['y', 'a', 'b', 'c', 'x'])</span></span><br></pre></td></tr></table></figure></li><li><p><code>defaultdict</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">defaultdict</span></span><br><span class="line"><span class="string">在dict中引用的key不存在的时候，不会抛出KeyError，而是抛出一个预先设定的值</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">dd = defaultdict(<span class="keyword">lambda</span> :<span class="string">'N/A'</span>)</span><br><span class="line">dd[<span class="string">'key1'</span>] == <span class="string">'abc'</span></span><br><span class="line"></span><br><span class="line">print(dd[<span class="string">'key1'</span>])   <span class="comment"># abc</span></span><br><span class="line">print(dd[<span class="string">'key2'</span>])   <span class="comment"># N/A</span></span><br></pre></td></tr></table></figure></li><li><p><code>OrderedDict</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">OrderedDict</span></span><br><span class="line"><span class="string">字典在迭代时是无序的</span></span><br><span class="line"><span class="string">而OrderedDict，保存了他们被添加的顺序</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">d = dict([(<span class="string">'a'</span>, <span class="number">1</span>), (<span class="string">'b'</span>, <span class="number">2</span>), (<span class="string">'c'</span>, <span class="number">3</span>)])</span><br><span class="line">print(d) <span class="comment"># &#123;'a': 1, 'c': 3, 'b': 2&#125;</span></span><br><span class="line"></span><br><span class="line">od = OrderedDict([(<span class="string">'a'</span>, <span class="number">1</span>), (<span class="string">'b'</span>, <span class="number">2</span>), (<span class="string">'c'</span>, <span class="number">3</span>)])</span><br><span class="line">print(od)   <span class="comment"># OrderedDict([('a', 1), ('b', 2), ('c', 3)])</span></span><br></pre></td></tr></table></figure></li><li><p><code>Counter</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter </span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Counter</span></span><br><span class="line"><span class="string">计数器</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">print(Counter(<span class="string">'programming'</span>))   <span class="comment"># Counter(&#123;'g': 2, 'm': 2, 'r': 2, 'a': 1, 'i': 1, 'o': 1, 'n': 1, 'p': 1&#125;)</span></span><br></pre></td></tr></table></figure></li><li><p><code>ChainMap</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> ChainMap</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">ChainMap</span></span><br><span class="line"><span class="string">将多个字典或者映射，将它们从逻辑上合并为一个单一的映射后执行某些操作</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">a = &#123;<span class="string">'x'</span>: <span class="number">1</span>, <span class="string">'z'</span>: <span class="number">3</span> &#125;</span><br><span class="line">b = &#123;<span class="string">'y'</span>: <span class="number">2</span>, <span class="string">'z'</span>: <span class="number">4</span> &#125;</span><br><span class="line"></span><br><span class="line">c = ChainMap(a,b)</span><br><span class="line">print(c[<span class="string">'x'</span>]) <span class="comment"># 1 (from a)</span></span><br><span class="line">print(c[<span class="string">'y'</span>]) <span class="comment"># 2 (from b)</span></span><br><span class="line">print(c[<span class="string">'z'</span>]) <span class="comment"># 3 (from a)</span></span><br></pre></td></tr></table></figure></li><li><p><code>UserDict、UserList、UserString</code>需要的可以自行查阅官方帮助文档</p></li></ul><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://www.liaoxuefeng.com/wiki/897692888725344/973805065315456" target="_blank" rel="noopener">廖雪峰的官方网站</a></li><li><a href="https://docs.python.org/zh-cn/3/library/collections.html" target="_blank" rel="noopener">Python官方文档</a></li></ul><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之罗马数字转整数</title>
      <link href="/passages/leetcode-zhi-luo-ma-shu-zi-zhuan-zheng-shu/"/>
      <url>/passages/leetcode-zhi-luo-ma-shu-zi-zhuan-zheng-shu/</url>
      
        <content type="html"><![CDATA[<p>罗马数字转整数</p><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><ul><li>题目详情见：<a href="https://leetcode-cn.com/problems/roman-to-integer/" target="_blank" rel="noopener">罗马数字转整数</a></li><li>题目难度：简单</li><li>相关标签：数字、字符串</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>我们发现特殊情况下，左边的数字小于右边的数字。也就是说，从左往右看的时候，左边的字符表示的数字小于右边的字符表示的数字，则需要用右边的字符减去左边的（这里可以通过将左边的字符表示的数字取负来实现）</li><li>其他情况下（左边的字符大于或等于右边的字符），只需要将它们表示的数字相加即可</li><li>建立字典：单个罗马字符与数字之间的映射</li><li>使用语言：Python</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ramonToInt</span><span class="params">(s: str)</span>:</span></span><br><span class="line">    roma_nums = &#123;<span class="string">'I'</span>:<span class="number">1</span>, <span class="string">'V'</span>:<span class="number">5</span>, <span class="string">'X'</span>:<span class="number">10</span>, <span class="string">'L'</span>:<span class="number">50</span>, <span class="string">'C'</span>:<span class="number">100</span>, <span class="string">'D'</span>:<span class="number">500</span>, <span class="string">'M'</span>:<span class="number">1000</span>&#125;</span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s) - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> roma_nums[s[i]] &gt;= roma_nums[s[i+<span class="number">1</span>]]:</span><br><span class="line">        num += roma_nums[s[i]]</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">            num -= roma_nums[s[i]]</span><br><span class="line">last_num = s[len(s)<span class="number">-1</span>]</span><br><span class="line">    </span><br><span class="line">    num = num + roma_nums[last_num]</span><br><span class="line">    <span class="keyword">return</span> num</span><br></pre></td></tr></table></figure><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之回文数</title>
      <link href="/passages/leetcode-zhi-hui-wen-shu/"/>
      <url>/passages/leetcode-zhi-hui-wen-shu/</url>
      
        <content type="html"><![CDATA[<p>尽量使用Python解决，不排除使用C编写代码</p><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><ul><li>题目详情请见<a href="https://leetcode-cn.com/problems/palindrome-number/" target="_blank" rel="noopener">回文数</a></li><li>题目难度：简单</li><li>相关标签：数学</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>判断一个整数是否是回文数，最直接的想法就是利用字符串来处理</li><li>进阶要求：不允许将整数转化为字符串</li><li>注意负号会影响回文，例如：-121反过来是121-，所以我们可以认为负数不可能是回文数</li><li>我们这里要求的是整数，所以要注意反转数字时的溢出问题（MIN_VALUE~MAX_VALUE）</li><li>这里有一点要注意：如果是回文数，显然是不会溢出的，所以溢出的必然不是回文数</li><li>总结一下：<strong>负数</strong>不可能是回文数，反转之后溢出的不是回文数，<strong>10的倍数</strong>不是回文数</li><li>使用字符串（见代码一）：<ul><li>先判断是否为负数，如果是负数，则返回False</li><li>如果是正数，则转化成字符串，再将字符与反转之后的字符串比较</li><li>相等，则返回True；否则，返回False</li></ul></li><li>不使用字符串（见代码二）：<ul><li>主要思想是：取其后半段与前半段进行比较即可，这样不用处理溢出问题</li><li>要注意数字的位数是偶数还是奇数</li><li>具体做法见代码</li></ul></li></ul><h3 id="代码一"><a href="#代码一" class="headerlink" title="代码一"></a>代码一</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一般要求，使用字符串来处理</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, x: int)</span> -&gt; bool:</span></span><br><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">x_str = str(x)</span><br><span class="line"><span class="keyword">if</span> x_str[::<span class="number">-1</span>] == x_str:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h3 id="代码二"><a href="#代码二" class="headerlink" title="代码二"></a>代码二</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 具体做法</span><br><span class="line"># <span class="number">1.</span> 每次进行取余操作，去除最低位（y = x % <span class="number">10</span>）</span><br><span class="line"># <span class="number">2.</span> 将最低为的数字加到取出数的末尾（rN = rN*<span class="number">10</span> + y）</span><br><span class="line"># <span class="number">3.</span> 每取一个最低为数字，x都要自除以<span class="number">10</span></span><br><span class="line"># <span class="number">4.</span> 判断x是否小于rN，小于的时候说明已经对半或过半了</span><br><span class="line"># <span class="number">5.</span> 最后判断奇数偶数位分别判断（奇数位的中间一位不需要判断）</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> isPalindrome(<span class="keyword">int</span> x)&#123;</span><br><span class="line">    <span class="keyword">int</span> rN=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>))&#123;</span><br><span class="line">        <span class="comment">// 负数不是回文数，10的倍数不可能是回文数，因为末位为0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(x &gt; rN)&#123;</span><br><span class="line">           rN = rN * <span class="number">10</span> + x % <span class="number">10</span>；</span><br><span class="line">           x = x / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 分别处理偶数位和奇数位的情况</span></span><br><span class="line">        <span class="keyword">return</span> x == rN || x = rN / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​                 </p><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息熵</title>
      <link href="/passages/xin-xi-shang/"/>
      <url>/passages/xin-xi-shang/</url>
      
        <content type="html"><![CDATA[<p>信息熵</p><a id="more"></a><h3 id="信息熵"><a href="#信息熵" class="headerlink" title="信息熵"></a>信息熵</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul><li>任何信息都存在冗余，冗余大小与信息中每个符号的出现概率（不确定性）有关</li><li>把<strong>信息中排除了冗余后的平均信息量</strong>即为信息熵</li><li>表征了随机变量X<strong>所有情况下的平均不确定度</strong></li><li>定义：$H(X)=-\sum_{x \in X}{P(x)log(P(X))}$</li><li>概率大，出现的机会多，不确定性就小；反之，概率小，不确定性就大，所以不确定性函数<code>f(X)</code>是概率<code>P(X)</code>的单调递减函数：即概率越大，不确定性越小</li><li>独立符号的不确定性是可加的，即$f(P_1, P_2) = f(P_1) + f(P_2)</li></ul><h4 id="对定义的理解"><a href="#对定义的理解" class="headerlink" title="对定义的理解"></a>对定义的理解</h4><ul><li><p>下面我们对一些概念做更加通俗的理解：</p><ul><li><p>为什么有的信息量大，有的信息量小？</p><blockquote><p>有些事情本来<strong>不是很确定</strong>，例如明天股票的涨跌；所以你的信息对明天股票是涨是跌带来的<strong>信息量很小</strong>。但是如果告诉你明天NBA决赛开始了，两者似乎没什么联系，但是加入决赛开始大家都去看球不关注股市了，没人坐庄的股票很大概率会跌，所以这句话信息量很大，因为<strong>本来不确定的事情便的十分确定</strong>了。</p><p>有些事<strong>本来就很确定</strong>，例如太阳从东边升起，你再说100遍，你的话还是<strong>没有任何信息量</strong>，因为这件事不能更加确定了</p><p>所以说信息量的大小跟<strong>事情不确定性的变化</strong>有关</p></blockquote></li><li><p>不确定性的变化与什么有关呢？</p><blockquote><p>跟事情的可能<strong>结果的数量</strong>有关。也就是说可能结果数量比较大时，我们得到的新信息才由潜力拥有大量信息。</p><p>跟<strong>概率</strong>有关，尤其是<strong>初始概率</strong>。比如电影院由225个座位，小明坐哪个座位的结果数量很多，但是如果说一开始就知道小明在第一排最左边的可能是99%，那么结果就几乎确定了，也就是说在这个时候再告诉我小明的什么信息也没有了。</p></blockquote></li><li><p>如何衡量不确定性的变化的大小呢？</p><blockquote><p>不能是负数</p><p>信息量之间可以相加</p><p>信息量连续依赖于概率，也就是说，某个概率变化了极小一个值，信息量不应该变化很大</p><p>信息量的大小跟可能结果数量有关。如果每一个结果出现的概率一样，那么对于可能结果数量多的那个时间，新信息有更大的潜力具有更大的信息量。因为初始状态下不确定性更大</p><p>所以数学上，<strong>信息熵是信息量的期望（累加和）</strong></p></blockquote></li></ul></li></ul><h4 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h4><ul><li><p>在自然语言处理中，信息熵只反映内容的<strong>随机性</strong>（不确定性）和<strong>编码</strong>情况，与<strong>内容本身</strong>无关</p></li><li><p>也就是说，对于一篇文章，其信息熵反映的是文章中字符编码之间的关系，也就是与有多少个不同字符有关，而与一共有多少字符没有关系</p></li><li><p>一本100万字的中文书平均有多少信息量？</p><ul><li><p>根据之前的知识，我们知道100万这个数字是没有用的，我们关注的不是文章总共有多少字，而是有多上个字是频繁出现的</p></li><li><p>我们知道，常用的汉字约7000个，假设每个汉字等概率，那么一个汉字的信息熵为：</p><p>$H = -(1/7000log(1/7000) +….1/7000log(1/70000)) \approx 13$</p><p>也就是说，整本书的信息量大约是1300万</p></li></ul></li></ul><h4 id="所以"><a href="#所以" class="headerlink" title="所以"></a>所以</h4><ul><li><p>信息量的大小和事件发生的概率成反比，表示为：</p><p>$$h(x) = -log(P(x))$$</p></li><li><p>信息量度量的是一个具体事件发生所带来的信息，而<strong>熵</strong>则是在结果出来之前对可能产生的信息量的期望——考虑该随机变量的所有可能取值，即<strong>所有可能发生事件所带来的信息量的期望</strong></p></li><li><p>信息熵是用来衡量事物不确定性的。信息熵越大，事物越具不确定性，事物越复杂，信息量就越大</p></li></ul><p>如果您发现错误或有疑问，欢迎交流指or指教</p><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 自然语言处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>词袋模型（BOW）</title>
      <link href="/passages/ci-dai-mo-xing-bow/"/>
      <url>/passages/ci-dai-mo-xing-bow/</url>
      
        <content type="html"><![CDATA[<p>词袋模型</p><a id="more"></a><h4 id="词袋模型可以用来干什么？"><a href="#词袋模型可以用来干什么？" class="headerlink" title="词袋模型可以用来干什么？"></a>词袋模型可以用来干什么？</h4><ul><li>词袋模型可以用于表示一段文本，包括句子、篇章等。</li></ul><h4 id="词袋模型是如何实现的？"><a href="#词袋模型是如何实现的？" class="headerlink" title="词袋模型是如何实现的？"></a>词袋模型是如何实现的？</h4><ul><li>首先将文本划分为一个个独立的词</li><li>将这些词无重复的存到一个“袋子”里，这个就叫做词袋</li><li>统计每个词的词频（在该段文本中出现的次数），存入对应词相同的下标位置</li><li>这个词频就作为该词的编码</li></ul><h4 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h4><ul><li><code>John likes to watch movies. Mary likes too. But I do not like.</code></li><li>单词列表：[‘John’, ‘likes’, ‘to’, ‘watch’, ‘movies’, ‘Mary’, ‘too’, ‘But’, ‘I’, ‘do’, ‘not’,’like’]</li><li>建立词典：{‘John’: 1, ‘likes’: 2, ‘to’: 1, ‘watch’: 1, ‘movies’: 1, ‘Mary’: 1, ‘too’: 1, ‘But’: 1, ‘I’: 1, ‘do’: 1, ‘not’:1, ‘like’:1}</li><li>三句文本的编码为依次为：<ul><li>[1, 2, 1, 1, 1]</li><li>[1, 2, 1]</li><li>[1, 1, 1, 1, 1]</li></ul></li></ul><h4 id="词袋模型有什么缺陷？"><a href="#词袋模型有什么缺陷？" class="headerlink" title="词袋模型有什么缺陷？"></a>词袋模型有什么缺陷？</h4><ul><li>忽略了文本的语法和语序信息，仅仅将其看作若干词汇的集合</li></ul><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 自然语言处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之整数取余</title>
      <link href="/passages/leetcode-zhi-zheng-shu-qu-yu/"/>
      <url>/passages/leetcode-zhi-zheng-shu-qu-yu/</url>
      
        <content type="html"><![CDATA[<p>整数取余</p><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><ul><li>题目详情见：<a href="https://leetcode-cn.com/problems/reverse-integer/" target="_blank" rel="noopener">整数反转</a></li><li>题目难度：简单</li><li>相关标签：数学</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>输入的数字是32位的有符号整数，要注意是否会产生溢出</li><li>值得注意的是题目要求只能用<code>int</code>来存储，那么想要使用<code>Long</code>类型来存储的想法也行不通了</li><li>如果没有溢出问题，本题的思路是非常简单的，直接使用栈或者数组记录每一位的数字，再依次乘以相应的10^n累加即可</li><li>解决溢出一般有两种思路，一种是转化成字符串，使用try_catch结构来解决；另一种是使用数学的方式来解决</li><li>通过数学的方式来解决溢出问题<ul><li>通过循环求得数字X的每一位，在每一步计算新值的时候都进行溢出判断</li><li><code>int</code>的最大值是<code>MAX_VALUE=2147483647</code>，最小值是<code>MIN_VALUE=-2147483648‬</code>，这里我们假设当前计算结果是<code>anw</code>，下一位为<code>next</code><ul><li>当出现<code>anw &gt; MAX_VALUE / 10</code>并且还有<code>next</code>添加时，必定会上溢出</li><li>当出现<code>anw == MAX_VALUE / 10</code>并且<code>next &gt; 7</code>时，必定会上溢出</li><li>当出现<code>anw &lt; MIN_VALUE / 10</code>并且还有<code>next</code>需要添加时，必定会下溢出 </li><li>当出现<code>anw == MIN_VALUE / 10</code>并且<code>next &lt; -8</code>时，并定会下溢出</li></ul></li></ul></li><li>通过转化为字符串来解决溢出问题<ul><li>先将给定的数字转化成字符串，再利用字符串可以随机访问每一个位置的元素值的特性，依次取值，添加到新的字符串中</li><li>使用<code>int()</code>将字符串转化为数字</li><li>要注意的是负数的<code>str[0]</code>是不需要参与反转的，只需要再最后转化层整数的时候加负号即可</li></ul></li></ul><h3 id="代码一"><a href="#代码一" class="headerlink" title="代码一"></a>代码一</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 由于对于负数取余上的一些不同，我们使用java语言实现该算法</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> pop = x % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (ans &gt; Integer.MAX_VALUE / <span class="number">10</span> || (ans == Integer.MAX_VALUE / <span class="number">10</span> &amp;&amp; pop &gt; <span class="number">7</span>)) </span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (ans &lt; Integer.MIN_VALUE / <span class="number">10</span> || (ans == Integer.MIN_VALUE / <span class="number">10</span> &amp;&amp; pop &lt; -<span class="number">8</span>)) </span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            ans = ans * <span class="number">10</span> + pop;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码二"><a href="#代码二" class="headerlink" title="代码二"></a>代码二</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, x: int)</span> -&gt; int:</span></span><br><span class="line"><span class="comment">#MAX_VALUE = 2147483647</span></span><br><span class="line">    <span class="comment">#MIN_VALUE = -2147483648</span></span><br><span class="line">        </span><br><span class="line">    strx = str(x)   <span class="comment"># 转化成字符串</span></span><br><span class="line">    n = len(strx)   <span class="comment"># 字符串长度</span></span><br><span class="line"></span><br><span class="line">    strxx = <span class="string">''</span></span><br><span class="line">    <span class="keyword">if</span> x &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            strxx = strx[i] + strxx</span><br><span class="line">        <span class="keyword">return</span> int(strxx) <span class="keyword">if</span> int(strxx)&lt;=<span class="number">2147483647</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 负数反转时要跳过负号</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            strxx = strx[i] + strxx</span><br><span class="line">        <span class="keyword">return</span> -int(strxx) <span class="keyword">if</span> -int(strxx)&gt;=<span class="number">-2147483648</span> <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离线安装Pytorch</title>
      <link href="/passages/chi-xian-an-zhuang-pytorch/"/>
      <url>/passages/chi-xian-an-zhuang-pytorch/</url>
      
        <content type="html"><![CDATA[<p>离线安装Pytorch</p><a id="more"></a><blockquote><p>今天在新电脑上配置环境，无奈暂时没有有线网络和无线网卡，遂使用其他机器下载离线whl包进行了Pytorch的安装，这里略作整理，供有相关需要的同行们查阅。</p></blockquote><ul><li><p>安装环境</p><ul><li>Windows10专业版</li><li>Python3.7</li></ul></li><li><p>操作步骤</p><ul><li><p>首先要下载离线包，由于每个人的电脑硬件配置不同，这里建议如下操作：</p><ul><li><p>打开Pytorch的官网，按照引导选择自己的配置，注意安装工具那里选择pip，这时你会得到一个网址，像这样：<img src="/.top//%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85pytorch%5Cpytorch%E6%BC%94%E7%A4%BA1.png" alt></p></li><li><p>我们复制其中的网址到浏览器打开，就可以在其中选择要下载的离线包了。</p></li></ul></li><li><p>之后就是安装了</p><ul><li>执行<code>conda install torch-xxxx</code>和<code>conda install torchvision xxxx</code>即可安装成功了。</li></ul></li><li><p>测试</p><ul><li>在python文件中或命令行下的python环境中执行<code>import torch</code>和<code>import torchvision</code>，若成功导入，则说明安装成功。</li></ul></li></ul></li></ul><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 工具配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>conda创建虚拟环境</title>
      <link href="/passages/conda-xu-ni-huan-jing-chuang-jian/"/>
      <url>/passages/conda-xu-ni-huan-jing-chuang-jian/</url>
      
        <content type="html"><![CDATA[<p>conda创建虚拟环境</p><a id="more"></a><ul><li><p><code>conda</code>是什么？</p><blockquote><p>简单来说，<code>conda</code>就是一个<code>Python</code>包的管理工具，用于管理<code>Python</code>的各种工具包；同时<code>conda</code>还可以用于虚拟环境之间的创建和切换，可以实现多套环境之间的共存，满足使用者对多重不同环境配置的需求。</p></blockquote></li><li><p>更换软件源</p><ul><li><p><code>conda</code>默认的软件源是国外的，在软件包的安装的时候速度会受限，多以更换为国内的源会有所改善。</p></li><li><p>这里以<code>Windows</code>下将软件源修改为清华源为例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> conda config --<span class="built_in">set</span> show_channel_urls yes</span></span><br><span class="line"></span><br><span class="line">注意要删除掉.condarc文件，默认在C:/username/Anaconda/pkgs/free文件夹下</span><br></pre></td></tr></table></figure></li><li><p>另外，国内主流的文件源还有中科大源，需要的可自行百度。</p></li></ul></li><li><p><code>conda</code>常用命令</p></li></ul>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出当前conda环境所链接的所有软件包</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> conda list</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出当前创建的所有虚拟环境</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> conda env list</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建conda虚拟环境</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> conda create -n 环境名 python=指定python版本</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在指定环境中安装工具包包</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> conda install -n 环境名 工具包名</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 激活虚拟环境</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> activate 虚拟环境名</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭虚拟环境（使用系统默认环境）</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> deactivate 环境名</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除虚拟环境</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> conda remove -n 虚拟环境名 --all</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 卸载环境中的一个包</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> conda remove -n 环境名 包名</span></span><br></pre></td></tr></table></figure><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 工具配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Numpy100题之81~100</title>
      <link href="/passages/numpy100-ti-zhi-81-100/"/>
      <url>/passages/numpy100-ti-zhi-81-100/</url>
      
        <content type="html"><![CDATA[<p>学习笔记</p><p>答案整理</p><p>原文地址：<a href="https://zhuanlan.zhihu.com/p/76186124" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/76186124</a></p><p>总结：有些操作过分为了操作而操作，使用频率不高，不必花费过多时间在上面</p><a id="more"></a><ol><li><p>考虑一个数组<code>Z = [1,2,3,4,5,6,7,8,9,10,11,12,13,14]</code>，如何生成一个数组<code>R = [[1,2,3,4]， [2,3,4,5], [3,4,5,6], ...,[11,12,13,14]]</code>?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># np.stride_tricks.as_strided(x, shape, strides, subok, writeable) 按照shape对x进行分块</span></span><br><span class="line">Z = np.arange(<span class="number">1</span>, <span class="number">15</span>, dtype=np.uint32)</span><br><span class="line">R = np.lib.stride_tricks.as_strided(Z, (<span class="number">11</span>, <span class="number">4</span>), (<span class="number">4</span>, <span class="number">4</span>))</span><br><span class="line">print(R)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[[ <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>]</span><br><span class="line"> [ <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>]</span><br><span class="line"> [ <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>]</span><br><span class="line"> [ <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>]</span><br><span class="line"> [ <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>]</span><br><span class="line"> [ <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>]</span><br><span class="line"> [ <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span>]</span><br><span class="line"> [ <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]</span><br><span class="line"> [ <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span>]</span><br><span class="line"> [<span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span>]</span><br><span class="line"> [<span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span>]]</span><br></pre></td></tr></table></figure></li><li><p>计算一个矩阵的秩</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># np.linalg.svd() 奇异值分解，三个返回值，s的对角线是奇异值，由大到小排列</span></span><br><span class="line">Z = np.random.uniform(<span class="number">0</span>, <span class="number">1</span>, (<span class="number">10</span>, <span class="number">10</span>))</span><br><span class="line">U, S, V = np.linalg.svd(Z)</span><br><span class="line">rank = np.sum(S &gt; <span class="number">1e-10</span>)</span><br><span class="line">print(rank)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure></li><li><p>如何找到一个数组中出现频率最高的值？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># np.bincount(), argmax()</span></span><br><span class="line"><span class="comment"># 使用宾count()统计元素值的频率，argmax()返回的索引即为频率最高的元素</span></span><br><span class="line">Z = np.random.randint(<span class="number">0</span>, <span class="number">10</span>, <span class="number">50</span>)</span><br><span class="line">print(np.bincount(Z).argmax())</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>从一个<code>10x10</code>的矩阵中提取出连续的<code>3x3</code>区块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># np.lib.stride_tricks.as_strided()</span></span><br><span class="line">Z = np.random.randint(<span class="number">0</span>, <span class="number">5</span>, (<span class="number">10</span>, <span class="number">10</span>))</span><br><span class="line">n = <span class="number">3</span></span><br><span class="line">i = <span class="number">1</span> + (Z.shape[<span class="number">0</span>]<span class="number">-3</span>)</span><br><span class="line">j = <span class="number">1</span> + (Z.shape[<span class="number">1</span>]<span class="number">-3</span>)</span><br><span class="line">C = np.lib.stride_tricks.as_strided(Z, shape=(i, j, n, n), strides=Z.strides + Z.strides)</span><br><span class="line">print(C)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[[<span class="number">1</span> <span class="number">4</span> <span class="number">4</span> <span class="number">4</span> <span class="number">3</span> <span class="number">4</span> <span class="number">0</span> <span class="number">4</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">3</span> <span class="number">0</span> <span class="number">3</span> <span class="number">0</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">4</span> <span class="number">4</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">2</span> <span class="number">2</span> <span class="number">0</span> <span class="number">2</span> <span class="number">4</span> <span class="number">1</span> <span class="number">2</span> <span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">2</span> <span class="number">4</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">0</span> <span class="number">3</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">3</span> <span class="number">4</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">1</span> <span class="number">0</span> <span class="number">4</span> <span class="number">4</span> <span class="number">4</span> <span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">0</span> <span class="number">4</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">0</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">0</span> <span class="number">3</span> <span class="number">2</span> <span class="number">0</span> <span class="number">4</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">4</span> <span class="number">3</span> <span class="number">4</span> <span class="number">4</span> <span class="number">0</span> <span class="number">2</span> <span class="number">4</span> <span class="number">4</span> <span class="number">2</span>]]</span><br><span class="line"></span><br><span class="line">[[[[<span class="number">1</span> <span class="number">4</span> <span class="number">4</span>]</span><br><span class="line">   [<span class="number">4</span> <span class="number">3</span> <span class="number">0</span>]</span><br><span class="line">   [<span class="number">0</span> <span class="number">2</span> <span class="number">2</span>]]</span><br><span class="line"></span><br><span class="line">  [[<span class="number">4</span> <span class="number">4</span> <span class="number">4</span>]</span><br><span class="line">   [<span class="number">3</span> <span class="number">0</span> <span class="number">3</span>]</span><br><span class="line">   [<span class="number">2</span> <span class="number">2</span> <span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line">  [[<span class="number">4</span> <span class="number">4</span> <span class="number">3</span>]</span><br><span class="line">   [<span class="number">0</span> <span class="number">3</span> <span class="number">0</span>]</span><br><span class="line">   [<span class="number">2</span> <span class="number">0</span> <span class="number">2</span>]]</span><br><span class="line"></span><br><span class="line">  [[<span class="number">4</span> <span class="number">3</span> <span class="number">4</span>]</span><br><span class="line">   [<span class="number">3</span> <span class="number">0</span> <span class="number">2</span>]</span><br><span class="line">   [<span class="number">0</span> <span class="number">2</span> <span class="number">4</span>]]</span><br><span class="line"></span><br><span class="line">  [[<span class="number">3</span> <span class="number">4</span> <span class="number">0</span>]</span><br><span class="line">   [<span class="number">0</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line">   [<span class="number">2</span> <span class="number">4</span> <span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line">  [[<span class="number">4</span> <span class="number">0</span> <span class="number">4</span>]</span><br><span class="line">   [<span class="number">2</span> <span class="number">3</span> <span class="number">1</span>]</span><br><span class="line">   [<span class="number">4</span> <span class="number">1</span> <span class="number">2</span>]]</span><br><span class="line"></span><br><span class="line">  [[<span class="number">0</span> <span class="number">4</span> <span class="number">0</span>]</span><br><span class="line">   [<span class="number">3</span> <span class="number">1</span> <span class="number">4</span>]</span><br><span class="line">   [<span class="number">1</span> <span class="number">2</span> <span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  [[<span class="number">3</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">   [<span class="number">0</span> <span class="number">1</span> <span class="number">0</span>]</span><br><span class="line">   [<span class="number">4</span> <span class="number">4</span> <span class="number">2</span>]]]]</span><br></pre></td></tr></table></figure></li><li><p>创建一个满足<code>Z[i,j]==Z[j,i]</code>的子类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 类的定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Symetric</span><span class="params">(np.ndarray)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, index, value)</span>:</span></span><br><span class="line">        i, j = index</span><br><span class="line">        super(Symetric, self).__setitem__((i, j), value)</span><br><span class="line">        super(Symetric, self).__setitem__((j, i), value)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">symetric</span><span class="params">(Z)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> np.asarray(Z + Z.T - np.diag(Z.diagonal())).view(Symetric)</span><br><span class="line">    </span><br><span class="line">S = Symetric(np.random.randint(<span class="number">0</span>, <span class="number">10</span>, (<span class="number">5</span>, <span class="number">5</span>)))</span><br><span class="line">S[<span class="number">2</span>, <span class="number">3</span>] = <span class="number">42</span></span><br><span class="line">print(S)</span><br><span class="line"></span><br><span class="line">结果：</span><br></pre></td></tr></table></figure></li><li><p>考虑<code>p</code>个<code>nxn</code>矩阵和一组形状为<code>(n,1)</code>的向量，如何直接计算<code>p</code>个矩阵的乘积<code>(n,1)</code>？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># np.tensordot() 沿指定轴计算张量的点积</span></span><br><span class="line">p, n = <span class="number">10</span>, <span class="number">20</span></span><br><span class="line">M = np.ones((p, n, n))</span><br><span class="line">V = np.ones((p, n, <span class="number">1</span>))</span><br><span class="line">S = np.tensordot(M, V, axes=[[<span class="number">0</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">1</span>]])</span><br><span class="line">print(S)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[[<span class="number">200.</span>]</span><br><span class="line"> [<span class="number">200.</span>]</span><br><span class="line"> [<span class="number">200.</span>]</span><br><span class="line"> [<span class="number">200.</span>]</span><br><span class="line"> [<span class="number">200.</span>]</span><br><span class="line"> [<span class="number">200.</span>]</span><br><span class="line"> [<span class="number">200.</span>]</span><br><span class="line"> [<span class="number">200.</span>]</span><br><span class="line"> [<span class="number">200.</span>]</span><br><span class="line"> [<span class="number">200.</span>]</span><br><span class="line"> [<span class="number">200.</span>]</span><br><span class="line"> [<span class="number">200.</span>]</span><br><span class="line"> [<span class="number">200.</span>]</span><br><span class="line"> [<span class="number">200.</span>]</span><br><span class="line"> [<span class="number">200.</span>]</span><br><span class="line"> [<span class="number">200.</span>]</span><br><span class="line"> [<span class="number">200.</span>]</span><br><span class="line"> [<span class="number">200.</span>]</span><br><span class="line"> [<span class="number">200.</span>]</span><br><span class="line"> [<span class="number">200.</span>]]</span><br></pre></td></tr></table></figure></li><li><p>对于一个<code>16x16</code>的数组，如何得到一个区域(block-sum)的和(区域大小为<code>4x4</code>)?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># np.add.reduceat() 功能等同于np.sum()，实际上np.sum()调用的就是前者</span></span><br><span class="line">Z = np.ones((<span class="number">16</span>, <span class="number">16</span>))</span><br><span class="line">k = <span class="number">4</span></span><br><span class="line">S = np.add.reduceat(np.add.reduceat(Z, np.arange(<span class="number">0</span>, Z.shape[<span class="number">0</span>], k), axis=<span class="number">0</span>), np.arange(<span class="number">0</span>, Z.shape[<span class="number">1</span>], k), axis=<span class="number">1</span>)</span><br><span class="line">print(S)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[[<span class="number">16.</span> <span class="number">16.</span> <span class="number">16.</span> <span class="number">16.</span>]</span><br><span class="line"> [<span class="number">16.</span> <span class="number">16.</span> <span class="number">16.</span> <span class="number">16.</span>]</span><br><span class="line"> [<span class="number">16.</span> <span class="number">16.</span> <span class="number">16.</span> <span class="number">16.</span>]</span><br><span class="line"> [<span class="number">16.</span> <span class="number">16.</span> <span class="number">16.</span> <span class="number">16.</span>]]</span><br></pre></td></tr></table></figure></li><li><p>如何利用<code>Numpy</code>数组实现<code>Game of Life</code>?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    生命游戏中，对于任意细胞：</span></span><br><span class="line"><span class="string">   每个细胞有两种状态：存活或死亡。每个细胞与以自身为中心的周围八格细胞产生互动。</span></span><br><span class="line"><span class="string">   1.当前细胞为存活状态时，当周围的活细胞低于2个时， 该细胞因孤独而死亡;</span></span><br><span class="line"><span class="string">   2.当前细胞为存活状态时，当周围有2个或3个活细胞时， 该细胞保持原样;</span></span><br><span class="line"><span class="string">   3.当前细胞为存活状态时，当周围有3个以上活细胞时，该细胞因资源匮乏而死亡;</span></span><br><span class="line"><span class="string">   4.当前细胞为死亡状态时，当周围有3个活细胞时，该细胞变成存活状态(模拟繁殖)。</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">iterate</span><span class="params">(Z)</span>:</span></span><br><span class="line"><span class="comment"># Count neighbours</span></span><br><span class="line">N = (Z[<span class="number">0</span>:<span class="number">-2</span>,<span class="number">0</span>:<span class="number">-2</span>] + Z[<span class="number">0</span>:<span class="number">-2</span>,<span class="number">1</span>:<span class="number">-1</span>] + Z[<span class="number">0</span>:<span class="number">-2</span>,<span class="number">2</span>:] +</span><br><span class="line">Z[<span class="number">1</span>:<span class="number">-1</span>,<span class="number">0</span>:<span class="number">-2</span>] + Z[<span class="number">1</span>:<span class="number">-1</span>,<span class="number">2</span>:] +</span><br><span class="line">Z[<span class="number">2</span>: ,<span class="number">0</span>:<span class="number">-2</span>] + Z[<span class="number">2</span>: ,<span class="number">1</span>:<span class="number">-1</span>] + Z[<span class="number">2</span>: ,<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Apply rules</span></span><br><span class="line">birth = (N==<span class="number">3</span>) &amp; (Z[<span class="number">1</span>:<span class="number">-1</span>,<span class="number">1</span>:<span class="number">-1</span>]==<span class="number">0</span>)</span><br><span class="line">survive = ((N==<span class="number">2</span>) | (N==<span class="number">3</span>)) &amp; (Z[<span class="number">1</span>:<span class="number">-1</span>,<span class="number">1</span>:<span class="number">-1</span>]==<span class="number">1</span>)</span><br><span class="line">Z[...] = <span class="number">0</span></span><br><span class="line">Z[<span class="number">1</span>:<span class="number">-1</span>,<span class="number">1</span>:<span class="number">-1</span>][birth | survive] = <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> Z</span><br><span class="line"></span><br><span class="line">Z = np.random.randint(<span class="number">0</span>,<span class="number">2</span>,(<span class="number">50</span>,<span class="number">50</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>): Z = iterate(Z)</span><br><span class="line"><span class="keyword">print</span> (Z)</span><br><span class="line">    </span><br><span class="line">结果：</span><br><span class="line">[[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> ... <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> ... <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> ... <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> ...</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> ... <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> ... <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> ... <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]]</span><br></pre></td></tr></table></figure></li><li><p>如何找到一个数组的第<code>n</code>个最大值?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># argsort()排序后读取倒数第n个值</span></span><br><span class="line">Z = np.arange(<span class="number">10000</span>)</span><br><span class="line">np.random.shuffle(Z)</span><br><span class="line">n = <span class="number">5</span></span><br><span class="line">print(Z[np.argsort(Z)[-n:]])</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[<span class="number">9995</span> <span class="number">9996</span> <span class="number">9997</span> <span class="number">9998</span> <span class="number">9999</span>]</span><br></pre></td></tr></table></figure></li><li><p>给定任意个数向量，创建笛卡尔积(每一个元素的每一种组合)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 笛卡尔积：两个集合的组合</span></span><br><span class="line"><span class="comment"># np.indices()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cartesian</span><span class="params">(arrays)</span>:</span></span><br><span class="line">    arrays = [np.asarray(a) <span class="keyword">for</span> a <span class="keyword">in</span> arrays]</span><br><span class="line">    shape = (len(x) <span class="keyword">for</span> x <span class="keyword">in</span> arrays)</span><br><span class="line">    ix = np.indices(shape, dtype=int)</span><br><span class="line">    ix = ix.reshape(len(arrays), <span class="number">-1</span>).T</span><br><span class="line">    <span class="keyword">for</span> n, arr <span class="keyword">in</span> enumerate(arrays):</span><br><span class="line">        ix[:, n] = arrays[n][ix[:, n]]</span><br><span class="line">    <span class="keyword">return</span> ix</span><br><span class="line"></span><br><span class="line">print(cartesian(([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>])))</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[[<span class="number">1</span> <span class="number">4</span> <span class="number">6</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">4</span> <span class="number">7</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">5</span> <span class="number">6</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">5</span> <span class="number">7</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">4</span> <span class="number">6</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">4</span> <span class="number">7</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">5</span> <span class="number">6</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">5</span> <span class="number">7</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span> <span class="number">6</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span> <span class="number">7</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">5</span> <span class="number">6</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">5</span> <span class="number">7</span>]]</span><br></pre></td></tr></table></figure></li><li><p>如何从一个正常数组创建记录数组(<code>record array</code>)?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># np.core.records.fromarrays()</span></span><br><span class="line">Z = np.array([(<span class="string">"Hello"</span>, <span class="number">2.5</span>, <span class="number">3</span>), (<span class="string">"World"</span>, <span class="number">3.6</span>, <span class="number">2</span>)])</span><br><span class="line">R = np.core.records.fromarrays(Z.T, names=<span class="string">'col1, col2, col3'</span>, formats=<span class="string">'S8, f8, i8'</span>)</span><br><span class="line">print(R)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[(<span class="string">b'Hello'</span>, <span class="number">2.5</span>, <span class="number">3</span>) (<span class="string">b'World'</span>, <span class="number">3.6</span>, <span class="number">2</span>)]</span><br></pre></td></tr></table></figure></li><li><p>考虑一个大向量<code>Z</code>, 用三种不同的方法计算它的立方</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># np.power() 对列表、矩阵、数组等求n次方</span></span><br><span class="line"><span class="comment"># '*'</span></span><br><span class="line"><span class="comment"># np.einsum() 将向量插入某一行或列</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法一</span></span><br><span class="line">x = np.random.rand()</span><br><span class="line">np.power(x, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二</span></span><br><span class="line">x*x*x</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法三</span></span><br><span class="line">np.einsum(<span class="string">'i, i, i-&gt;i'</span>, x,x,x)</span><br></pre></td></tr></table></figure></li><li><p>考虑两个形状分别为<code>(8,3)</code>和<code>(2,2)</code>的数组<code>A</code>和<code>B</code>. 如何在数组<code>A</code>中找到满足包含<code>B</code>中元素的行？(不考虑<code>B</code>中每行元素顺序)？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># np.where()</span></span><br><span class="line">A = np.random.randint(<span class="number">0</span>, <span class="number">5</span>, (<span class="number">8</span>, <span class="number">3</span>))</span><br><span class="line">B = np.random.randint(<span class="number">0</span>, <span class="number">5</span>, (<span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line">C = (A[..., np.newaxis, np.newaxis] == B)</span><br><span class="line"></span><br><span class="line">rows = np.where(C.any((<span class="number">3</span>, <span class="number">1</span>)).all(<span class="number">1</span>))[<span class="number">0</span>]</span><br><span class="line">print(rows)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[<span class="number">6</span> <span class="number">7</span>]</span><br></pre></td></tr></table></figure></li><li><p>考虑一个<code>10x3</code>的矩阵，分解出有不全相同值的行 (如<code>[2,2,3]</code>)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Z = np.random.randint(<span class="number">0</span>, <span class="number">5</span>, (<span class="number">10</span>, <span class="number">3</span>))</span><br><span class="line">print(Z)</span><br><span class="line"></span><br><span class="line">E = np.all(Z[:,<span class="number">1</span>:] == Z[:,:<span class="number">-1</span>], axis=<span class="number">1</span>)</span><br><span class="line">U = Z[~E]</span><br><span class="line">print(U)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">Z：</span><br><span class="line">[[<span class="number">4</span> <span class="number">0</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">3</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">0</span> <span class="number">4</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">0</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">2</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">2</span> <span class="number">4</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">4</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">1</span> <span class="number">2</span>]]</span><br><span class="line"></span><br><span class="line">U：</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">4</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">1</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">4</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">1</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">4</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">3</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">4</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]]</span><br></pre></td></tr></table></figure></li><li><p>将一个整数向量转换为二进制矩阵<code>matrix binary</code>的表现形式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># np.unpackbits() 把整数转化乘二进制</span></span><br><span class="line">I = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>])</span><br><span class="line">B = ((I.reshape(<span class="number">-1</span>, <span class="number">1</span>)&amp;(<span class="number">2</span>**np.arange(<span class="number">8</span>)))!=<span class="number">0</span>).astype(int)</span><br><span class="line">print(B[:,::<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]]</span><br></pre></td></tr></table></figure></li><li><p>给定一个二维数组，如何提取出唯一的(unique)行？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># np.ascontiguousarray() 将一个内存不连续存储的数组转化为内存连续存储的数组，加快运行速度</span></span><br><span class="line">Z = np.random.randint(<span class="number">0</span>,<span class="number">2</span>,(<span class="number">6</span>,<span class="number">3</span>))</span><br><span class="line">T = np.ascontiguousarray(Z).view(np.dtype((np.void, Z.dtype.itemsize * Z.shape[<span class="number">1</span>])))</span><br><span class="line"></span><br><span class="line">_, idx = np.unique(T, return_index=<span class="literal">True</span>)</span><br><span class="line">uZ = Z[idx]</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (uZ)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">1</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">1</span> <span class="number">0</span>]]</span><br></pre></td></tr></table></figure></li><li><p>考虑两个向量<code>A</code>和<code>B</code>，写出用<code>einsum</code>等式对应的<code>inner</code>, <code>outer</code>, <code>sum</code>, <code>mul</code>函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># np.einsum</span></span><br><span class="line">A = np.random.uniform(<span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">B = np.random.uniform(<span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'sum'</span>)</span><br><span class="line">print(np.einsum(<span class="string">'i-&gt;'</span>, A))</span><br><span class="line">结果：</span><br><span class="line">sum</span><br><span class="line"><span class="number">4.903677057922876</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'A * B'</span>)</span><br><span class="line">print(np.einsum(<span class="string">'i, i-&gt;i'</span>, A, B))</span><br><span class="line">结果：</span><br><span class="line">A * B</span><br><span class="line">[<span class="number">0.47153643</span> <span class="number">0.25317511</span> <span class="number">0.20142837</span> <span class="number">0.05835824</span> <span class="number">0.20308374</span> <span class="number">0.10641387</span></span><br><span class="line"> <span class="number">0.21122253</span> <span class="number">0.54794781</span> <span class="number">0.21782327</span> <span class="number">0.18996213</span>]</span><br><span class="line"></span><br><span class="line">print(<span class="string">'inner'</span>)</span><br><span class="line">print(np.einsum(<span class="string">'i, i'</span>, A, B))</span><br><span class="line">结果:</span><br><span class="line">inner</span><br><span class="line"><span class="number">2.4609515005732665</span>   </span><br><span class="line">    </span><br><span class="line">print(<span class="string">'outer'</span>)</span><br><span class="line">print(np.einsum(<span class="string">'i, j-&gt;ij'</span>, A, B))</span><br><span class="line">结果：</span><br><span class="line">outer</span><br><span class="line">[[<span class="number">0.47153643</span> <span class="number">0.22882703</span> <span class="number">0.27068423</span> <span class="number">0.41698768</span> <span class="number">0.22448079</span> <span class="number">0.33164545</span></span><br><span class="line">  <span class="number">0.67680915</span> <span class="number">0.39473786</span> <span class="number">0.37198788</span> <span class="number">0.35538228</span>]</span><br><span class="line"> [<span class="number">0.52170974</span> <span class="number">0.25317511</span> <span class="number">0.29948609</span> <span class="number">0.46135679</span> <span class="number">0.24836641</span> <span class="number">0.36693382</span></span><br><span class="line">  <span class="number">0.74882428</span> <span class="number">0.4367395</span>  <span class="number">0.41156883</span> <span class="number">0.39319634</span>]</span><br><span class="line"> [<span class="number">0.35089156</span> <span class="number">0.17028053</span> <span class="number">0.20142837</span> <span class="number">0.31029937</span> <span class="number">0.16704629</span> <span class="number">0.24679237</span></span><br><span class="line">  <span class="number">0.50364427</span> <span class="number">0.29374228</span> <span class="number">0.27681298</span> <span class="number">0.26445601</span>]</span><br><span class="line"> [<span class="number">0.06599245</span> <span class="number">0.03202479</span> <span class="number">0.03788279</span> <span class="number">0.05835824</span> <span class="number">0.03141652</span> <span class="number">0.04641443</span></span><br><span class="line">  <span class="number">0.09472076</span> <span class="number">0.05524434</span> <span class="number">0.05206043</span> <span class="number">0.04973644</span>]</span><br><span class="line"> [<span class="number">0.42659055</span> <span class="number">0.20701571</span> <span class="number">0.24488317</span> <span class="number">0.37724128</span> <span class="number">0.20308374</span> <span class="number">0.3000337</span></span><br><span class="line">  <span class="number">0.6122971</span>  <span class="number">0.35711226</span> <span class="number">0.33653076</span> <span class="number">0.32150798</span>]</span><br><span class="line"> [<span class="number">0.15130018</span> <span class="number">0.0734229</span>  <span class="number">0.08685347</span> <span class="number">0.13379732</span> <span class="number">0.07202834</span> <span class="number">0.10641387</span></span><br><span class="line">  <span class="number">0.2171653</span>  <span class="number">0.1266581</span>  <span class="number">0.1193584</span>  <span class="number">0.11403022</span>]</span><br><span class="line"> [<span class="number">0.14715983</span> <span class="number">0.07141367</span> <span class="number">0.08447671</span> <span class="number">0.13013594</span> <span class="number">0.07005727</span> <span class="number">0.10350184</span></span><br><span class="line">  <span class="number">0.21122253</span> <span class="number">0.12319208</span> <span class="number">0.11609214</span> <span class="number">0.11090977</span>]</span><br><span class="line"> [<span class="number">0.65455427</span> <span class="number">0.31764186</span> <span class="number">0.37574514</span> <span class="number">0.57883347</span> <span class="number">0.31160871</span> <span class="number">0.46036729</span></span><br><span class="line">  <span class="number">0.93949967</span> <span class="number">0.54794781</span> <span class="number">0.51636785</span> <span class="number">0.49331711</span>]</span><br><span class="line"> [<span class="number">0.27611547</span> <span class="number">0.13399321</span> <span class="number">0.15850335</span> <span class="number">0.2441736</span>  <span class="number">0.1314482</span>  <span class="number">0.19420014</span></span><br><span class="line">  <span class="number">0.39631609</span> <span class="number">0.23114487</span> <span class="number">0.21782327</span> <span class="number">0.2080996</span> ]</span><br><span class="line"> [<span class="number">0.25204989</span> <span class="number">0.12231468</span> <span class="number">0.14468857</span> <span class="number">0.22289201</span> <span class="number">0.11999149</span> <span class="number">0.17727411</span></span><br><span class="line">  <span class="number">0.36177412</span> <span class="number">0.21099883</span> <span class="number">0.19883831</span> <span class="number">0.18996213</span>]]</span><br></pre></td></tr></table></figure></li><li><p>考虑一个由两个向量描述的路径<code>(X,Y)</code>，如何用等距样例(equidistant samples)对其进行采样(sample)?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># np.sumsum(), np.interp</span></span><br><span class="line">phi = np.arange(<span class="number">0</span>, <span class="number">10</span>*np.pi, <span class="number">0.1</span>)</span><br><span class="line">a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">x = a*phi*np.cos(phi)</span><br><span class="line">y = a*phi*np.sin(phi)</span><br><span class="line"></span><br><span class="line">dr =(np.diff(x)**<span class="number">2</span> + np.diff(y)**<span class="number">2</span>)**<span class="number">.5</span></span><br><span class="line">r = np.zeros_like(x)</span><br><span class="line">r[<span class="number">1</span>:] = np.cumsum(dr) <span class="comment"># integrate path</span></span><br><span class="line"></span><br><span class="line">r_int = np.linspace(<span class="number">0</span>, r.max(), <span class="number">200</span>) <span class="comment"># regular spaced path</span></span><br><span class="line">x_int = np.interp(r_int, r, x) <span class="comment"># integrate path</span></span><br><span class="line">y_int = np.interp(r_int, r, y)</span><br><span class="line"></span><br><span class="line">结果：</span><br></pre></td></tr></table></figure></li></ol><ol start="19"><li><p>给定整数<code>n</code>和<code>2D</code>数组<code>X</code>，从<code>X</code>中选择可以解释为具有<code>n</code>度的多项分布的绘制的行，即，仅包含整数并且总和为<code>n</code>的行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># np.logical_and.reduce(), np.mod()</span></span><br><span class="line">X = np.asarray([[<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">3.0</span>, <span class="number">8.0</span>], [<span class="number">2.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>], [<span class="number">1.5</span>, <span class="number">2.5</span>, <span class="number">1.0</span>, <span class="number">1.0</span>]])</span><br><span class="line">n = <span class="number">4</span></span><br><span class="line">M = np.logical_and.reduce(np.mod(X, <span class="number">1</span>) == <span class="number">0</span>, axis=<span class="number">-1</span>)</span><br><span class="line">M &amp;= (X.sum(axis=<span class="number">-1</span>) == n)</span><br><span class="line">print(X[M])</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[[<span class="number">2.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">1.</span>]]</span><br></pre></td></tr></table></figure></li></ol><ol start="20"><li><p>计算<code>1D</code>阵列<code>X</code>的平均值的自举<code>95％</code>置信区间（即，对替换<code>N</code>次的阵列的元素进行重新采样，计算每个样本的平均值，然后计算均值上的百分位数）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">X = np.random.randn(<span class="number">100</span>) <span class="comment"># random 1D array</span></span><br><span class="line">N = <span class="number">1000</span> <span class="comment"># number of bootstrap samples</span></span><br><span class="line">idx = np.random.randint(<span class="number">0</span>, X.size, (N, X.size))</span><br><span class="line">means = X[idx].mean(axis=<span class="number">1</span>)</span><br><span class="line">confint = np.percentile(means, [<span class="number">2.5</span>, <span class="number">97.5</span>])</span><br><span class="line"><span class="keyword">print</span> (confint)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[<span class="number">0.06141008</span> <span class="number">0.46613253</span>]</span><br></pre></td></tr></table></figure></li></ol><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Numpy100题之61-80</title>
      <link href="/passages/numpy100-ti-zhi-61-80/"/>
      <url>/passages/numpy100-ti-zhi-61-80/</url>
      
        <content type="html"><![CDATA[<p>学习笔记</p><p>答案整理</p><p>原文地址：<a href="https://zhuanlan.zhihu.com/p/76186124" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/76186124</a></p><a id="more"></a><ol><li><p>从数组中的给定值中找出最近的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用到abs()、flat()、argmin()</span></span><br><span class="line"><span class="comment"># 功能分别为：取绝对值、返回一个数组的迭代器，可通过for循环访问、获取最小值的索引</span></span><br><span class="line"></span><br><span class="line">Z = np.random.uniform(<span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">z = <span class="number">0.5</span></span><br><span class="line">m = Z.flat[np.abs(Z-z).argmin()]</span><br><span class="line">print(m)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"><span class="number">0.5390768396166375</span></span><br></pre></td></tr></table></figure></li><li><p>如何用迭代器(iterator)计算两个分别具有形状<code>(1,3)</code>和<code>(3,1)</code>的数组?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># np.nditer()，传入的数组，返回一个可迭代的迭代器</span></span><br><span class="line">A = np.arange(<span class="number">3</span>).reshape(<span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line">B = np.arange(<span class="number">3</span>).reshape(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">it = np.nditer([A, B, <span class="literal">None</span>])</span><br><span class="line"><span class="keyword">for</span> x, y, z <span class="keyword">in</span> it:</span><br><span class="line">    z[...] = x + y</span><br><span class="line"></span><br><span class="line">print(it.operands[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]]</span><br></pre></td></tr></table></figure></li><li><p>创建一个具有<code>name</code>属性的数组类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 类的定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NamedArray</span><span class="params">(np.ndarray)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, array, name=<span class="string">"no name"</span>)</span>:</span></span><br><span class="line">        obj = np.asarray(array).view(cls)</span><br><span class="line">        obj.name = name</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__array_finalize__</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> obj <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.info = getattr(obj, <span class="string">'name'</span>, <span class="string">"no name"</span>)</span><br><span class="line">        </span><br><span class="line">Z = NameArray(np.arange(<span class="number">10</span>), <span class="string">"range_10"</span>)</span><br><span class="line">print(Z.name)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">range_10</span><br></pre></td></tr></table></figure></li><li><p>考虑一个给定的向量，如何对由第二个向量索引的每个元素加1(小心重复的索引)?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 题设要求对于重复给出的索引每次遇到均+1</span></span><br><span class="line"><span class="comment"># 使用bincount()函数，该函数可以对数组中出现的值的次数进行统计，反映在输出向量的相应下标的位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法一</span></span><br><span class="line">Z = np.ones(<span class="number">10</span>)<span class="comment"># 给定向量</span></span><br><span class="line">I = np.random.randint(<span class="number">0</span>, len(Z), <span class="number">20</span>)<span class="comment"># 索引向量</span></span><br><span class="line"></span><br><span class="line">Z += np.bincount(I, minlength=len(Z))</span><br><span class="line">print(Z)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[<span class="number">2.</span> <span class="number">4.</span> <span class="number">3.</span> <span class="number">1.</span> <span class="number">4.</span> <span class="number">2.</span> <span class="number">5.</span> <span class="number">6.</span> <span class="number">2.</span> <span class="number">1.</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二</span></span><br><span class="line"><span class="comment"># at() 对Z中的元素，根据I中的索引，每次+1</span></span><br><span class="line">np.add.at(Z, I, <span class="number">1</span>)</span><br><span class="line">print(Z)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[<span class="number">2.</span> <span class="number">4.</span> <span class="number">3.</span> <span class="number">1.</span> <span class="number">4.</span> <span class="number">2.</span> <span class="number">5.</span> <span class="number">6.</span> <span class="number">2.</span> <span class="number">1.</span>]</span><br></pre></td></tr></table></figure></li><li><p>根据索引列表(I)，如何将向量(X)的元素累加到数组(F)?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">X = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">I = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">F = np.bincount(I, X)</span><br><span class="line">print(F)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[<span class="number">0.</span> <span class="number">7.</span> <span class="number">0.</span> <span class="number">6.</span> <span class="number">5.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">3.</span>]</span><br></pre></td></tr></table></figure></li><li><p>考虑一个(<code>dtype=ubyte</code>) 的 <code>(w,h,3)</code>图像，计算其唯一颜色的数量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用unique()函数：对于数组或者列表，去除其中重复的元素，按元素由大到小返回一个无重复的列表或数组</span></span><br><span class="line">w, h = <span class="number">16</span>, <span class="number">16</span></span><br><span class="line">I = np.random.randint(<span class="number">0</span>, <span class="number">2</span>, (h, w, <span class="number">3</span>)).astype(np.ubyte)</span><br><span class="line"></span><br><span class="line">F = I[..., <span class="number">0</span>]*(<span class="number">256</span>*<span class="number">256</span>) + I[..., <span class="number">1</span>]*<span class="number">256</span> + I[..., <span class="number">2</span>]</span><br><span class="line">n = len(np.unique(F))</span><br><span class="line">print(n)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure></li><li><p>考虑一个四维数组，如何一次性计算出最后两个轴(axis)的和？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sum(axis=) 指定计算根据的的轴</span></span><br><span class="line">A = np.random.randint(<span class="number">0</span>, <span class="number">10</span>, (<span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">sum = A.sum(axis=(<span class="number">-2</span>, <span class="number">-1</span>))</span><br><span class="line">print(sum)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[[<span class="number">64</span> <span class="number">55</span> <span class="number">51</span> <span class="number">45</span>]</span><br><span class="line"> [<span class="number">38</span> <span class="number">55</span> <span class="number">48</span> <span class="number">53</span>]</span><br><span class="line"> [<span class="number">73</span> <span class="number">73</span> <span class="number">60</span> <span class="number">50</span>]]</span><br></pre></td></tr></table></figure></li><li><p>考虑一个一维向量<code>D</code>，如何使用相同大小的向量<code>S</code>来计算<code>D</code>子集的均值？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># np.bincount()</span></span><br><span class="line">D = np.random.uniform(<span class="number">0</span>, <span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">S = np.random.randint(<span class="number">0</span>, <span class="number">10</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">D_sums = np.bincount(S, weights=D)</span><br><span class="line">D_counts = np.bincount(S)</span><br><span class="line">D_means = D_sums / D_counts</span><br><span class="line"></span><br><span class="line">print(D_means)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[<span class="number">0.40365511</span> <span class="number">0.52710526</span> <span class="number">0.67046511</span> <span class="number">0.33109763</span> <span class="number">0.67705689</span> <span class="number">0.49109846</span></span><br><span class="line"> <span class="number">0.36351819</span> <span class="number">0.53482213</span> <span class="number">0.58558006</span> <span class="number">0.5682075</span> ]</span><br></pre></td></tr></table></figure></li><li><p>如何获得点积<code>dot prodcut</code>的对角线?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># diag()，当传入一维数组时，结果形成一个以一维数组为对角线元素的矩阵；当传入的是二维数组时，结果输出矩阵的对角线元素</span></span><br><span class="line">A = np.random.uniform(<span class="number">0</span>, <span class="number">1</span>, (<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">B = np.random.uniform(<span class="number">0</span>, <span class="number">1</span>, (<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line"><span class="comment"># 5*5与5*5矩阵的点乘积仍是5*5矩阵</span></span><br><span class="line">np.diag(np.dot(A, B))</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([<span class="number">0.70100234</span>, <span class="number">0.92730124</span>, <span class="number">1.89491706</span>, <span class="number">1.79228104</span>, <span class="number">1.48440929</span>])</span><br></pre></td></tr></table></figure></li><li><p>考虑一个向量<code>[1,2,3,4,5]</code>，如何建立一个新的向量，在这个新向量中每个值之间有3个连续的零？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个足够长度的0矩阵，将向量中的元素按每隔3个0替换一个</span></span><br><span class="line">A = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">nz = <span class="number">3</span></span><br><span class="line">A0 = np.zeros(len(A) + (len(A)<span class="number">-1</span>)*nz)</span><br><span class="line">A0[::nz+<span class="number">1</span>] = A</span><br><span class="line">print(A0)</span><br></pre></td></tr></table></figure></li><li><p>考虑一个维度<code>(5,5,3)</code>的数组，如何将其与一个<code>(5,5)</code>的数组相乘？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将B构造成第三个维度为None的三维数组</span></span><br><span class="line">A = np.ones((<span class="number">5</span>, <span class="number">5</span>, <span class="number">3</span>))</span><br><span class="line">B = <span class="number">2</span>*np.ones((<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">print(A * B[:,:,<span class="literal">None</span>])</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[[[<span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span>]</span><br><span class="line">  [<span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span>]</span><br><span class="line">  [<span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span>]</span><br><span class="line">  [<span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span>]</span><br><span class="line">  [<span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span>]]</span><br><span class="line"></span><br><span class="line"> [[<span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span>]</span><br><span class="line">  [<span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span>]</span><br><span class="line">  [<span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span>]</span><br><span class="line">  [<span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span>]</span><br><span class="line">  [<span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span>]]</span><br><span class="line"></span><br><span class="line"> [[<span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span>]</span><br><span class="line">  [<span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span>]</span><br><span class="line">  [<span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span>]</span><br><span class="line">  [<span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span>]</span><br><span class="line">  [<span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span>]]</span><br><span class="line"></span><br><span class="line"> [[<span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span>]</span><br><span class="line">  [<span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span>]</span><br><span class="line">  [<span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span>]</span><br><span class="line">  [<span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span>]</span><br><span class="line">  [<span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span>]]</span><br><span class="line"></span><br><span class="line"> [[<span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span>]</span><br><span class="line">  [<span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span>]</span><br><span class="line">  [<span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span>]</span><br><span class="line">  [<span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span>]</span><br><span class="line">  [<span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span>]]]</span><br></pre></td></tr></table></figure></li><li><p>如何对一个数组中任意两行做交换?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">A = np.arange(<span class="number">25</span>).reshape(<span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line">A[[<span class="number">0</span>, <span class="number">1</span>]] = A[[<span class="number">1</span>, <span class="number">0</span>]]</span><br><span class="line">print(A)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[[ <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>]</span><br><span class="line"> [ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>]</span><br><span class="line"> [<span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span>]</span><br><span class="line"> [<span class="number">15</span> <span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span>]</span><br><span class="line"> [<span class="number">20</span> <span class="number">21</span> <span class="number">22</span> <span class="number">23</span> <span class="number">24</span>]]</span><br></pre></td></tr></table></figure></li></ol><ol start="13"><li><p>考虑一个可以描述10个三角形的数组<code>triplets</code>，找到可以分割全部三角形的<code>line segment</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># repeat(axis=) 复制多维数组的每一个元素，axis来控制复制的行和列</span></span><br><span class="line"><span class="comment"># np.roll(array, shift, axis=) array沿axis的方向滚动shift长度 </span></span><br><span class="line"><span class="comment"># np.sort() 排序</span></span><br><span class="line"><span class="comment"># view() 区别与copy(),与原始数据共享一份内存</span></span><br><span class="line"><span class="comment"># np.unique() 返回列表或数组中不重复元素组成的列表或数组</span></span><br><span class="line"></span><br><span class="line">faces = np.random.randint(<span class="number">0</span>, <span class="number">100</span>, (<span class="number">10</span>, <span class="number">3</span>))</span><br><span class="line">F = np.roll(faces.repeat(<span class="number">2</span>, axis=<span class="number">1</span>), <span class="number">-1</span>, axis=<span class="number">1</span>)</span><br><span class="line">F = F.reshape(len(F)*<span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line">F = np.sort(F, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">G = F.view(dtype=[(<span class="string">'p0'</span>, F.dtype), (<span class="string">'p1'</span>, F.dtype)])</span><br><span class="line">G = np.unique(G)</span><br><span class="line">print(G)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[( <span class="number">5</span>, <span class="number">31</span>) ( <span class="number">5</span>, <span class="number">53</span>) (<span class="number">11</span>, <span class="number">25</span>) (<span class="number">11</span>, <span class="number">46</span>) (<span class="number">12</span>, <span class="number">37</span>) (<span class="number">12</span>, <span class="number">85</span>) (<span class="number">20</span>, <span class="number">35</span>) (<span class="number">20</span>, <span class="number">51</span>)</span><br><span class="line"> (<span class="number">20</span>, <span class="number">84</span>) (<span class="number">22</span>, <span class="number">47</span>) (<span class="number">22</span>, <span class="number">84</span>) (<span class="number">25</span>, <span class="number">46</span>) (<span class="number">27</span>, <span class="number">47</span>) (<span class="number">27</span>, <span class="number">66</span>) (<span class="number">31</span>, <span class="number">53</span>) (<span class="number">35</span>, <span class="number">84</span>)</span><br><span class="line"> (<span class="number">37</span>, <span class="number">85</span>) (<span class="number">47</span>, <span class="number">66</span>) (<span class="number">47</span>, <span class="number">84</span>) (<span class="number">51</span>, <span class="number">84</span>) (<span class="number">58</span>, <span class="number">63</span>) (<span class="number">58</span>, <span class="number">77</span>) (<span class="number">58</span>, <span class="number">95</span>) (<span class="number">58</span>, <span class="number">99</span>)</span><br><span class="line"> (<span class="number">63</span>, <span class="number">79</span>) (<span class="number">63</span>, <span class="number">92</span>) (<span class="number">63</span>, <span class="number">99</span>) (<span class="number">77</span>, <span class="number">95</span>) (<span class="number">79</span>, <span class="number">92</span>)]</span><br></pre></td></tr></table></figure></li><li><p>给定一个二进制的数组<code>C</code>，如何产生一个数组<code>A</code>满足<code>np.bincount(A)==C</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C = np.bincount([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">6</span>])</span><br><span class="line">A = np.repeat(np.arange(len(C)), C)</span><br><span class="line">print(A)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[<span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">4</span> <span class="number">6</span>]</span><br></pre></td></tr></table></figure></li><li><p>如何通过滑动窗口计算一个数组的平均数?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cumsum() 沿指定轴累加数组元素</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">moving_average</span><span class="params">(a, n=<span class="number">3</span>)</span>:</span></span><br><span class="line">    ret = np.cumsum(a, dtype=float)</span><br><span class="line">    ret[n:] = ret[n:] - ret[:-n]</span><br><span class="line">    <span class="keyword">return</span> ret[n<span class="number">-1</span>:]/n</span><br><span class="line"></span><br><span class="line">Z = np.arange(<span class="number">20</span>)</span><br><span class="line">print(moving_average(Z, n=<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[ <span class="number">1.</span>  <span class="number">2.</span>  <span class="number">3.</span>  <span class="number">4.</span>  <span class="number">5.</span>  <span class="number">6.</span>  <span class="number">7.</span>  <span class="number">8.</span>  <span class="number">9.</span> <span class="number">10.</span> <span class="number">11.</span> <span class="number">12.</span> <span class="number">13.</span> <span class="number">14.</span> <span class="number">15.</span> <span class="number">16.</span> <span class="number">17.</span> <span class="number">18.</span>]</span><br></pre></td></tr></table></figure></li><li><p>考虑一维数组<code>Z</code>，构建一个二维数组，其第一行是<code>(Z [0]，Z [1]，Z [2])</code>，每个后续行移1（最后一行应该是<code>(Z[-3], Z[-2], Z[-1])</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy.lib <span class="keyword">import</span> stride_tricks</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rolling</span><span class="params">(a, window)</span>:</span></span><br><span class="line">    shape = (a.size - window + <span class="number">1</span>, window)</span><br><span class="line">    strides = (a.itemsize, a.itemsize)</span><br><span class="line">    <span class="keyword">return</span> stride_tricks.as_strided(a, shape=shape, strides=strides)</span><br><span class="line"></span><br><span class="line">Z = rolling(np.arange(<span class="number">10</span>), <span class="number">3</span>)</span><br><span class="line">print(Z)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]</span><br><span class="line"> [<span class="number">5</span> <span class="number">6</span> <span class="number">7</span>]</span><br><span class="line"> [<span class="number">6</span> <span class="number">7</span> <span class="number">8</span>]</span><br><span class="line"> [<span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]]</span><br></pre></td></tr></table></figure></li><li><p>如何对布尔值取反，或者原位<code>(in-place)</code>改变浮点数的符号<code>(sign)</code>？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># lofical_not()逻辑非、negative()数值取反</span></span><br><span class="line"><span class="comment"># 方法一</span></span><br><span class="line"><span class="comment"># 随机整数</span></span><br><span class="line">Z = np.random.randint(<span class="number">0</span>, <span class="number">2</span>, <span class="number">100</span>)</span><br><span class="line">np.logical_not(Z, out = Z)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">       <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">       <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">       <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">       <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二：</span></span><br><span class="line"><span class="comment"># uniform() 均匀分布</span></span><br><span class="line">Z = np.random.uniform(<span class="number">-1.0</span>, <span class="number">1.0</span>, <span class="number">100</span>)</span><br><span class="line">np.negative(Z, out=Z)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([ <span class="number">0.05031312</span>,  <span class="number">0.97772171</span>, <span class="number">-0.67264233</span>, <span class="number">-0.04618383</span>, <span class="number">-0.75397481</span>,</span><br><span class="line">       <span class="number">-0.34317743</span>, <span class="number">-0.53194673</span>, <span class="number">-0.51918606</span>, <span class="number">-0.37304893</span>, <span class="number">-0.4663474</span> ,</span><br><span class="line">       <span class="number">-0.78875942</span>,  <span class="number">0.01936397</span>,  <span class="number">0.80160394</span>,  <span class="number">0.39005544</span>, <span class="number">-0.93873232</span>,</span><br><span class="line">        <span class="number">0.15195121</span>, <span class="number">-0.94860217</span>,  <span class="number">0.2568072</span> , <span class="number">-0.97441577</span>,  <span class="number">0.03277601</span>,</span><br><span class="line">        <span class="number">0.23323496</span>,  <span class="number">0.10736939</span>, <span class="number">-0.16071465</span>,  <span class="number">0.34222035</span>,  <span class="number">0.96903346</span>,</span><br><span class="line">        <span class="number">0.58671838</span>, <span class="number">-0.43651958</span>, <span class="number">-0.56495989</span>,  <span class="number">0.24749138</span>,  <span class="number">0.77204365</span>,</span><br><span class="line">        <span class="number">0.92396754</span>,  <span class="number">0.73266475</span>, <span class="number">-0.89578353</span>, <span class="number">-0.61700747</span>,  <span class="number">0.68577537</span>,</span><br><span class="line">        <span class="number">0.74575805</span>,  <span class="number">0.03375484</span>,  <span class="number">0.61118915</span>,  <span class="number">0.28219652</span>, <span class="number">-0.15861781</span>,</span><br><span class="line">        <span class="number">0.04221261</span>,  <span class="number">0.55310498</span>, <span class="number">-0.15580574</span>,  <span class="number">0.60873475</span>,  <span class="number">0.02851121</span>,</span><br><span class="line">        <span class="number">0.19668448</span>, <span class="number">-0.04052335</span>, <span class="number">-0.73228185</span>,  <span class="number">0.25773921</span>, <span class="number">-0.90191087</span>,</span><br><span class="line">       <span class="number">-0.74177161</span>, <span class="number">-0.25423155</span>, <span class="number">-0.25450614</span>,  <span class="number">0.44865308</span>, <span class="number">-0.21338786</span>,</span><br><span class="line">        <span class="number">0.59592018</span>, <span class="number">-0.29278901</span>,  <span class="number">0.16500941</span>,  <span class="number">0.28332166</span>, <span class="number">-0.2661733</span> ,</span><br><span class="line">       <span class="number">-0.93792278</span>,  <span class="number">0.29708284</span>,  <span class="number">0.35718338</span>, <span class="number">-0.70322395</span>, <span class="number">-0.71643805</span>,</span><br><span class="line">       <span class="number">-0.9543976</span> ,  <span class="number">0.65792415</span>,  <span class="number">0.35181269</span>, <span class="number">-0.78627817</span>,  <span class="number">0.48762508</span>,</span><br><span class="line">       <span class="number">-0.51068373</span>,  <span class="number">0.76540099</span>,  <span class="number">0.89172685</span>,  <span class="number">0.15993627</span>,  <span class="number">0.64279179</span>,</span><br><span class="line">        <span class="number">0.32152709</span>,  <span class="number">0.25847394</span>, <span class="number">-0.36426917</span>, <span class="number">-0.74235575</span>, <span class="number">-0.48144595</span>,</span><br><span class="line">        <span class="number">0.51877578</span>,  <span class="number">0.86605299</span>,  <span class="number">0.51672054</span>,  <span class="number">0.79402976</span>, <span class="number">-0.11626431</span>,</span><br><span class="line">       <span class="number">-0.34747431</span>,  <span class="number">0.59585038</span>,  <span class="number">0.1204304</span> ,  <span class="number">0.35118293</span>,  <span class="number">0.44558852</span>,</span><br><span class="line">        <span class="number">0.56999461</span>, <span class="number">-0.4820329</span> ,  <span class="number">0.81815528</span>, <span class="number">-0.29603943</span>,  <span class="number">0.68750352</span>,</span><br><span class="line">       <span class="number">-0.50152259</span>, <span class="number">-0.85042461</span>, <span class="number">-0.36994314</span>, <span class="number">-0.23032343</span>,  <span class="number">0.43806343</span>])</span><br></pre></td></tr></table></figure></li><li><p>考虑两组点集<code>P0</code>和<code>P1</code>去描述一组线(二维)和一个点<code>p</code>,如何计算点<code>p</code>到每一条线 <code>i(P0[i],P1[i])</code>的距离？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">distance</span><span class="params">(P0, P1, p)</span>:</span></span><br><span class="line">    <span class="comment"># 计算点到直线的距离</span></span><br><span class="line">    T = P1 - P0</span><br><span class="line">    L = (T**<span class="number">2</span>).sum(axis = <span class="number">1</span>)</span><br><span class="line">    U = -((P0[:, <span class="number">0</span>]-p[..., <span class="number">0</span>])*T[:, <span class="number">0</span>] + (P0[:, <span class="number">1</span>]-p[..., <span class="number">1</span>])*T[:, <span class="number">1</span>])/L</span><br><span class="line">    U = U.reshape(len(U), <span class="number">1</span>)</span><br><span class="line">    D = P0 + U*T - p</span><br><span class="line">    <span class="keyword">return</span> np.sqrt((D**<span class="number">2</span>).sum(axis=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">P0 = np.random.uniform(<span class="number">-10</span>, <span class="number">10</span>, (<span class="number">10</span>, <span class="number">2</span>))</span><br><span class="line">P1 = np.random.uniform(<span class="number">-10</span>, <span class="number">10</span>, (<span class="number">10</span>, <span class="number">2</span>))</span><br><span class="line">p = np.random.uniform(<span class="number">-10</span>, <span class="number">10</span>, (<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">print(disrance(P0, P1, p))</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[ <span class="number">6.46089551</span>  <span class="number">2.02019414</span>  <span class="number">7.64957844</span> <span class="number">10.26739442</span>  <span class="number">4.32840633</span>  <span class="number">5.87598718</span></span><br><span class="line">  <span class="number">3.46730169</span> <span class="number">10.69040697</span>  <span class="number">3.7238278</span>   <span class="number">9.71021116</span>]</span><br></pre></td></tr></table></figure></li></ol><ol start="19"><li><p>考虑两组点集<code>P0</code>和<code>P1</code>去描述一组线(二维)和一组点集<code>P</code>，如何计算每一个点 <code>j(P[j])</code> 到每一条线 <code>i (P0[i],P1[i])</code>的距离？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 区别于上一个题，这里的点更多</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">distance</span><span class="params">(P0, P1, p)</span>:</span></span><br><span class="line">    <span class="comment"># 计算点到直线的距离</span></span><br><span class="line">    T = P1 - P0</span><br><span class="line">    L = (T**<span class="number">2</span>).sum(axis = <span class="number">1</span>)</span><br><span class="line">    U = -((P0[:, <span class="number">0</span>]-p[..., <span class="number">0</span>])*T[:, <span class="number">0</span>] + (P0[:, <span class="number">1</span>]-p[..., <span class="number">1</span>])*T[:, <span class="number">1</span>])/L</span><br><span class="line">    U = U.reshape(len(U), <span class="number">1</span>)</span><br><span class="line">    D = P0 + U*T - p</span><br><span class="line">    <span class="keyword">return</span> np.sqrt((D**<span class="number">2</span>).sum(axis=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">P0 = np.random.uniform(<span class="number">-10</span>, <span class="number">10</span>, (<span class="number">10</span>, <span class="number">2</span>))</span><br><span class="line">P1 = np.random.uniform(<span class="number">-10</span>, <span class="number">10</span>, (<span class="number">10</span>, <span class="number">2</span>))</span><br><span class="line">p = np.random.uniform(<span class="number">-10</span>, <span class="number">10</span>, (<span class="number">10</span>, <span class="number">2</span>))</span><br><span class="line">print(np.array([distance(P0, P1, p_i) <span class="keyword">for</span> p_i <span class="keyword">in</span> p]))</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[[ <span class="number">5.40670646</span>  <span class="number">4.80013481</span> <span class="number">13.30601528</span>  <span class="number">8.6187585</span>   <span class="number">7.35755714</span> <span class="number">12.54151718</span></span><br><span class="line">   <span class="number">9.24071207</span>  <span class="number">5.34703263</span> <span class="number">14.54922937</span>  <span class="number">4.14588354</span>]</span><br><span class="line"> [ <span class="number">2.63018703</span>  <span class="number">0.08876084</span>  <span class="number">4.14888539</span>  <span class="number">1.65492189</span>  <span class="number">7.70382067</span>  <span class="number">7.36081638</span></span><br><span class="line">   <span class="number">6.90710177</span>  <span class="number">6.81786912</span>  <span class="number">1.07761109</span>  <span class="number">8.51096456</span>]</span><br><span class="line"> [ <span class="number">2.0266857</span>   <span class="number">4.72537985</span>  <span class="number">3.16720835</span>  <span class="number">2.75861123</span>  <span class="number">4.44025815</span>  <span class="number">3.15808096</span></span><br><span class="line">   <span class="number">7.75627919</span>  <span class="number">9.49123505</span>  <span class="number">2.26774137</span> <span class="number">11.02113161</span>]</span><br><span class="line"> [ <span class="number">0.34856518</span>  <span class="number">0.72250344</span>  <span class="number">3.4643871</span>   <span class="number">1.70975185</span>  <span class="number">1.83784162</span> <span class="number">10.92846839</span></span><br><span class="line">   <span class="number">0.64753047</span>  <span class="number">0.5347269</span>   <span class="number">6.3404948</span>   <span class="number">2.05269702</span>]</span><br><span class="line"> [<span class="number">12.82851216</span> <span class="number">14.21297741</span>  <span class="number">6.8487462</span>  <span class="number">14.30053038</span>  <span class="number">7.75964014</span>  <span class="number">0.48502181</span></span><br><span class="line">   <span class="number">1.07738736</span>  <span class="number">7.4534913</span>   <span class="number">3.65341342</span>  <span class="number">8.50158022</span>]</span><br><span class="line"> [ <span class="number">4.35980428</span>  <span class="number">5.21646493</span>  <span class="number">6.17805894</span>  <span class="number">6.46221918</span>  <span class="number">2.49150711</span>  <span class="number">8.03708833</span></span><br><span class="line">   <span class="number">1.71241686</span>  <span class="number">1.40535458</span>  <span class="number">7.06802357</span>  <span class="number">2.73535593</span>]</span><br><span class="line"> [<span class="number">12.91407892</span> <span class="number">14.72355803</span>  <span class="number">4.92113516</span> <span class="number">14.05365253</span>  <span class="number">6.65559267</span>  <span class="number">2.09719282</span></span><br><span class="line">   <span class="number">3.26734451</span>  <span class="number">9.57392312</span>  <span class="number">1.44886514</span> <span class="number">10.64497421</span>]</span><br><span class="line"> [ <span class="number">0.26278106</span>  <span class="number">4.226739</span>    <span class="number">9.6454433</span>   <span class="number">0.05753583</span>  <span class="number">9.3296571</span>   <span class="number">0.06745266</span></span><br><span class="line">  <span class="number">14.25882312</span> <span class="number">14.97942175</span>  <span class="number">8.66727328</span> <span class="number">16.65261174</span>]</span><br><span class="line"> [ <span class="number">1.44097653</span>  <span class="number">3.77673716</span>  <span class="number">1.70901896</span>  <span class="number">2.47012398</span>  <span class="number">3.90447614</span>  <span class="number">4.93446335</span></span><br><span class="line">   <span class="number">5.88189824</span>  <span class="number">7.47118652</span>  <span class="number">0.34370906</span>  <span class="number">9.000505</span>  ]</span><br><span class="line"> [ <span class="number">7.46966507</span> <span class="number">10.6966451</span>   <span class="number">3.60754571</span>  <span class="number">7.64953446</span>  <span class="number">1.57566894</span>  <span class="number">3.00667962</span></span><br><span class="line">  <span class="number">10.52316245</span> <span class="number">14.30615261</span>  <span class="number">5.43992693</span> <span class="number">15.66648646</span>]]</span><br></pre></td></tr></table></figure></li></ol><ol start="20"><li><p>考虑一个任意数组，写一个函数，提取一个固定形状的子部分，并以给定元素为中心（fill必要时填充一个值）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># minimum, maximum</span></span><br><span class="line"><span class="comment"># 在10*10的数组中，提取5*5的子部分，中心为0</span></span><br><span class="line">Z = np.random.randint(<span class="number">0</span>, <span class="number">10</span>, (<span class="number">10</span>, <span class="number">10</span>))</span><br><span class="line">shape = (<span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line">fill = <span class="number">0</span></span><br><span class="line">position = (<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">R = np.ones(shape, dtype=Z.dtype)*fill</span><br><span class="line">P = np.array(list(position)).astype(int)</span><br><span class="line">Rs = np.array(list(R.shape)).astype(int)</span><br><span class="line">Zs = np.array(list(Z.shape)).astype(int)</span><br><span class="line"></span><br><span class="line">R_start = np.zeros((len(shape),)).astype(int)</span><br><span class="line">R_stop = np.array(list(shape)).astype(int)</span><br><span class="line"></span><br><span class="line">Z_start = (P-Rs//<span class="number">2</span>)</span><br><span class="line">Z_stop = (P+Rs//<span class="number">2</span>)+Rs%<span class="number">2</span></span><br><span class="line"></span><br><span class="line">R_start = (R_start - np.minimum(Z_start,<span class="number">0</span>)).tolist()</span><br><span class="line">Z_start = (np.maximum(Z_start,<span class="number">0</span>)).tolist()</span><br><span class="line"></span><br><span class="line">R_stop = np.maximum(R_start, (R_stop - np.maximum(Z_stop-Zs,<span class="number">0</span>))).tolist()</span><br><span class="line">Z_stop = (np.minimum(Z_stop,Zs)).tolist()</span><br><span class="line"></span><br><span class="line">r = [slice(start,stop) <span class="keyword">for</span> start,stop <span class="keyword">in</span> zip(R_start,R_stop)]</span><br><span class="line">z = [slice(start,stop) <span class="keyword">for</span> start,stop <span class="keyword">in</span> zip(Z_start,Z_stop)]</span><br><span class="line">R[r] = Z[z]</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (Z)</span><br><span class="line"><span class="keyword">print</span> (R)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[[<span class="number">2</span> <span class="number">5</span> <span class="number">6</span> <span class="number">6</span> <span class="number">7</span> <span class="number">5</span> <span class="number">3</span> <span class="number">3</span> <span class="number">1</span> <span class="number">8</span>]</span><br><span class="line"> [<span class="number">5</span> <span class="number">7</span> <span class="number">0</span> <span class="number">5</span> <span class="number">6</span> <span class="number">3</span> <span class="number">8</span> <span class="number">2</span> <span class="number">4</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">5</span> <span class="number">5</span> <span class="number">0</span> <span class="number">5</span> <span class="number">8</span> <span class="number">3</span> <span class="number">0</span> <span class="number">9</span> <span class="number">1</span> <span class="number">4</span>]</span><br><span class="line"> [<span class="number">9</span> <span class="number">3</span> <span class="number">3</span> <span class="number">5</span> <span class="number">0</span> <span class="number">1</span> <span class="number">6</span> <span class="number">7</span> <span class="number">3</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">7</span> <span class="number">2</span> <span class="number">2</span> <span class="number">6</span> <span class="number">4</span> <span class="number">7</span> <span class="number">7</span> <span class="number">9</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">5</span> <span class="number">7</span> <span class="number">6</span> <span class="number">2</span> <span class="number">0</span> <span class="number">7</span> <span class="number">7</span> <span class="number">7</span> <span class="number">9</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">2</span> <span class="number">0</span> <span class="number">3</span> <span class="number">1</span> <span class="number">1</span> <span class="number">8</span> <span class="number">4</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">8</span> <span class="number">1</span> <span class="number">7</span> <span class="number">9</span> <span class="number">8</span> <span class="number">9</span> <span class="number">5</span> <span class="number">0</span> <span class="number">0</span> <span class="number">7</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">1</span> <span class="number">9</span> <span class="number">0</span> <span class="number">4</span> <span class="number">4</span> <span class="number">1</span> <span class="number">9</span> <span class="number">5</span> <span class="number">4</span>]</span><br><span class="line"> [<span class="number">5</span> <span class="number">1</span> <span class="number">0</span> <span class="number">7</span> <span class="number">6</span> <span class="number">9</span> <span class="number">4</span> <span class="number">1</span> <span class="number">3</span> <span class="number">6</span>]]</span><br><span class="line"></span><br><span class="line">[[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">2</span> <span class="number">5</span> <span class="number">6</span> <span class="number">6</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">5</span> <span class="number">7</span> <span class="number">0</span> <span class="number">5</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">5</span> <span class="number">5</span> <span class="number">0</span> <span class="number">5</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">9</span> <span class="number">3</span> <span class="number">3</span> <span class="number">5</span>]]</span><br></pre></td></tr></table></figure></li></ol><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Numpy之genfromtxt函数</title>
      <link href="/passages/numpy-zhi-genfromtxt-han-shu/"/>
      <url>/passages/numpy-zhi-genfromtxt-han-shu/</url>
      
        <content type="html"><![CDATA[<p>genfromtext</p><a id="more"></a><ul><li><p><code>genfromtxt()</code>函数位于<code>numpy.genfromtxt()</code></p></li><li><p>函数的完整形式为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.genfrom(fname, dtype= , comments=<span class="string">'#'</span>, delimiter=<span class="literal">None</span>, skip_header=<span class="number">0</span>, skip_footer=<span class="number">0</span>, converters=<span class="literal">None</span>, missing_values=<span class="literal">None</span>, filling_values=<span class="literal">None</span>, usecols=<span class="literal">None</span>, names=<span class="literal">None</span>, excludelist=<span class="literal">None</span>, deletechars=<span class="literal">None</span>, replace_space=<span class="string">'_'</span>, autostrip=Falsem, case_sensitive=<span class="literal">True</span>, defaultfmt=<span class="string">'f%i'</span>, unpack=<span class="literal">None</span>, usemask=<span class="literal">False</span>, loose=<span class="literal">True</span>, invalid_raise=<span class="literal">True</span>, max_rows=<span class="literal">None</span>)[source]</span><br></pre></td></tr></table></figure><ul><li>下面详细介绍各个参数的意义：</li><li><code>fname</code>：文件名</li><li><code>dtype</code>：表明数据的类型</li><li><code>comments</code>：参数是一个字符串，标志着一个注释的开始符号，默认是“#”</li><li><code>delimiter</code>：分隔符，可以是<code>str</code>、<code>int</code>、<code>sequence</code>、<code>optional</code></li><li><code>skip_header</code>：跳过页眉，参数值是个整数，表示跳过的行数，默认为0</li><li><code>skip_footer</code>：跳过页脚，参数值是个整数，表示跳过的行数，默认为0</li><li><code>converters</code>：用以定义转换函数</li><li><code>missing_values</code>：默认情况下空字符串都被标记为缺少，使用该参数可以将更多类型的字符串识别为缺少，例如N/A</li><li><code>filling_values</code>：将missing_values识别出的标记为缺少的位置替换为该参数提供的值，可以是单个值、值序列、字典</li><li><code>usecols</code>：参数是一个整数序列，选择读取哪些行</li><li><code>names</code>：处理表格是要为每一列分配一个名称，可以通过显式的dtype来设置；或者names参数接收以个关键字与逗号组成的字符串；将该参数设为True会将文件第一行的内容读作文件名，不管是是注释</li><li><code>exclueslist</code>：一系列要删除的</li><li><code>deletechars</code>：需要删除的连接符，默认为‘’<del>!@#$%^&amp;*()——+</del>=|]}({;:/?&gt;,&lt;</li><li><code>replace_space</code>：替换变量名称中的空格</li><li><code>autostrip</code>：设为True可以去掉序列中每一项前后的多余空格</li><li><code>case_sensitive</code>：字段名是否区分大小写</li><li><code>defaultfmt</code>：只有在名字没有定义式才会使用该属性，用以覆盖默认值‘f%i’</li><li><code>unpack</code>：是否对读取的数组进行转置</li><li><code>usemask</code>：构造布尔掩码来追踪丢失数据的出现，返回掩码序列；将该属性设为True后，有缺失数据为True，没有缺失数据则为False</li><li><code>loose</code>：不对无效之引发错误</li><li><code>invalid_raise</code>：如果为true，则在检测到列数不一致时引发异常。如果为false，将发出警告并跳过违规行</li><li><code>max_rows</code>：要读取的最大行数。不能同时与skip_footer一起使用。如果给定，值必须至少为1。默认值是读取整个文件</li></ul></li><li><p>一个例子（代码来自网络，仅作整理，添加注释）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 引入一个数据集</span></span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line">url = <span class="string">'http://aima.cs.berkeley.edu/data/iris.csv'</span></span><br><span class="line">u = urllib2.urlopen(url)</span><br><span class="line">localFile = open(<span class="string">'iris.csv'</span><span class="string">', '</span>w<span class="string">')</span></span><br><span class="line"><span class="string">localFile.write(u.read())</span></span><br><span class="line"><span class="string">localFile.close()</span></span><br><span class="line"><span class="string">                 </span></span><br><span class="line"><span class="string"># 将数据集导入到程序</span></span><br><span class="line"><span class="string">from numpy import genfromtxt,zeros</span></span><br><span class="line"><span class="string">data = genfomtxt('</span>iris.csv<span class="string">', delimiter='</span>,<span class="string">', usecols=(0, 1, 2, 3))</span></span><br><span class="line"><span class="string">target = genfromtxt('</span>iris.csv<span class="string">', delimiter='</span>,<span class="string">', usecols=(4), dtype=str)</span></span><br></pre></td></tr></table></figure></li></ul><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Numpy100题之41~60</title>
      <link href="/passages/numpy100-ti-zhi-41-60/"/>
      <url>/passages/numpy100-ti-zhi-41-60/</url>
      
        <content type="html"><![CDATA[<p>学习笔记</p><p>答案整理</p><p>原文地址：<a href="https://zhuanlan.zhihu.com/p/76186124" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/76186124</a></p><a id="more"></a><ol><li><p>对于一个小数组，如何用比<code>np.sum</code>更快的方式对其求和？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用np.add.reduce()，两者功能相同</span></span><br><span class="line"><span class="comment"># 但对于小型数组，np.add.reduce()的速度比np.sum()快两倍</span></span><br><span class="line">Z = np.arange(<span class="number">10</span>)</span><br><span class="line">np.add.reduce(Z)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"><span class="number">45</span></span><br></pre></td></tr></table></figure></li><li><p>对于两个随机数组A和B，检查它们是否相等</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># np.allclose()可判断两个array是不是每个元素都相等</span></span><br><span class="line"><span class="comment"># np.array_equal()判断两个数组是否相等</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建两个随机整型数组</span></span><br><span class="line">A = np.random.randint(<span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line">B = np.random.randint(<span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line">equal1 = np.allclose(A, B)</span><br><span class="line">equal2 = np.array_equal(A, B)</span><br><span class="line"></span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">equal1</span><br><span class="line">equal2</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">array([<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure></li><li><p>创建一个只读数组(read-only)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过设置数组的flags.writeable属性来指定数组是否只读</span></span><br><span class="line">Z = np.zeros(<span class="number">10</span>)</span><br><span class="line">Z.flags.writeable = <span class="literal">False</span></span><br></pre></td></tr></table></figure></li><li><p>将笛卡尔坐标下的一个<code>10x2</code>的矩阵转换为极坐标形式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用到开方函数np.sqrt()、反三角函数np.arctan2()函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机生成一个指教坐标系下的坐标</span></span><br><span class="line">Z = np.random.random((<span class="number">10</span>, <span class="number">2</span>))</span><br><span class="line">X, Y = Z[:, <span class="number">0</span>], Z[:, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">R = np.sqrt(X**<span class="number">2</span> + Y**<span class="number">2</span>)</span><br><span class="line">T = np.arctan2(Y, X)</span><br><span class="line">R</span><br><span class="line">T</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([<span class="number">0.3944447</span> , <span class="number">0.94777816</span>, <span class="number">0.83140372</span>, <span class="number">0.74598633</span>, <span class="number">0.91967574</span>,</span><br><span class="line">       <span class="number">0.75524468</span>, <span class="number">0.79999599</span>, <span class="number">0.6049436</span> , <span class="number">0.43862584</span>, <span class="number">1.09668726</span>])</span><br><span class="line">array([<span class="number">1.45680562</span>, <span class="number">0.40002162</span>, <span class="number">1.13268754</span>, <span class="number">1.00810909</span>, <span class="number">0.08777813</span>,</span><br><span class="line">       <span class="number">0.79438818</span>, <span class="number">0.19055149</span>, <span class="number">0.6108188</span> , <span class="number">0.61328375</span>, <span class="number">1.08466593</span>])</span><br></pre></td></tr></table></figure></li><li><p>创建一个长度为10的向量，并将向量中最大值替换为1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用argmax()获取想两种最大值的索引</span></span><br><span class="line">Z = np.random.random(<span class="number">10</span>)</span><br><span class="line">Z</span><br><span class="line"></span><br><span class="line">Z[Z.argmax()] = <span class="number">1</span></span><br><span class="line">Z</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([<span class="number">0.15094359</span>, <span class="number">0.9866758</span> , <span class="number">0.19716025</span>, <span class="number">0.753693</span>  , <span class="number">0.3756874</span> ,</span><br><span class="line">       <span class="number">0.61064317</span>, <span class="number">0.32985381</span>, <span class="number">0.37475131</span>, <span class="number">0.11217617</span>, <span class="number">0.71798767</span>])</span><br><span class="line"></span><br><span class="line">array([<span class="number">0.15094359</span>, <span class="number">1.</span>        , <span class="number">0.19716025</span>, <span class="number">0.753693</span>  , <span class="number">0.3756874</span> ,</span><br><span class="line">       <span class="number">0.61064317</span>, <span class="number">0.32985381</span>, <span class="number">0.37475131</span>, <span class="number">0.11217617</span>, <span class="number">0.71798767</span>])</span><br></pre></td></tr></table></figure></li><li><p>创建一个结构化数组，并实现<code>x</code>和<code>y</code>坐标覆盖<code>[0,1]x[0,1]</code>区域</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># np.meshgrid() 生成网格点坐标矩阵，把两个数组的笛卡尔积内的元素的第一二个坐标分别放入两个矩阵中</span></span><br><span class="line">Z = np.zeros((<span class="number">5</span>, <span class="number">5</span>), [(<span class="string">'x'</span>, float), (<span class="string">'y'</span>, float)])</span><br><span class="line"></span><br><span class="line">Z[<span class="string">'x'</span>], Z[<span class="string">'y'</span>] = np.meshgrid(np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>), np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>))</span><br><span class="line">Z</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([[(<span class="number">0.</span>  , <span class="number">0.</span>  ), (<span class="number">0.25</span>, <span class="number">0.</span>  ), (<span class="number">0.5</span> , <span class="number">0.</span>  ), (<span class="number">0.75</span>, <span class="number">0.</span>  ),</span><br><span class="line">        (<span class="number">1.</span>  , <span class="number">0.</span>  )],</span><br><span class="line">       [(<span class="number">0.</span>  , <span class="number">0.25</span>), (<span class="number">0.25</span>, <span class="number">0.25</span>), (<span class="number">0.5</span> , <span class="number">0.25</span>), (<span class="number">0.75</span>, <span class="number">0.25</span>),</span><br><span class="line">        (<span class="number">1.</span>  , <span class="number">0.25</span>)],</span><br><span class="line">       [(<span class="number">0.</span>  , <span class="number">0.5</span> ), (<span class="number">0.25</span>, <span class="number">0.5</span> ), (<span class="number">0.5</span> , <span class="number">0.5</span> ), (<span class="number">0.75</span>, <span class="number">0.5</span> ),</span><br><span class="line">        (<span class="number">1.</span>  , <span class="number">0.5</span> )],</span><br><span class="line">       [(<span class="number">0.</span>  , <span class="number">0.75</span>), (<span class="number">0.25</span>, <span class="number">0.75</span>), (<span class="number">0.5</span> , <span class="number">0.75</span>), (<span class="number">0.75</span>, <span class="number">0.75</span>),</span><br><span class="line">        (<span class="number">1.</span>  , <span class="number">0.75</span>)],</span><br><span class="line">       [(<span class="number">0.</span>  , <span class="number">1.</span>  ), (<span class="number">0.25</span>, <span class="number">1.</span>  ), (<span class="number">0.5</span> , <span class="number">1.</span>  ), (<span class="number">0.75</span>, <span class="number">1.</span>  ),</span><br><span class="line">        (<span class="number">1.</span>  , <span class="number">1.</span>  )]], dtype=[(<span class="string">'x'</span>, <span class="string">'&lt;f8'</span>), (<span class="string">'y'</span>, <span class="string">'&lt;f8'</span>)])</span><br></pre></td></tr></table></figure></li><li><p>给定两个数组<code>X</code>和<code>Y</code>，构造Cauchy矩阵C(每个元素：$C_{ij} =1/(x_i - y_j)$)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">X = np.arange(<span class="number">8</span>)</span><br><span class="line">Y = X + <span class="number">0.5</span></span><br><span class="line">C = <span class="number">1.0</span> / np.subtract.outer(X, Y)</span><br><span class="line">C</span><br><span class="line">print(np.linalg.det(C))</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([[<span class="number">-2.</span>        , <span class="number">-0.66666667</span>, <span class="number">-0.4</span>       , <span class="number">-0.28571429</span>, <span class="number">-0.22222222</span>,</span><br><span class="line">        <span class="number">-0.18181818</span>, <span class="number">-0.15384615</span>, <span class="number">-0.13333333</span>],</span><br><span class="line">       [ <span class="number">2.</span>        , <span class="number">-2.</span>        , <span class="number">-0.66666667</span>, <span class="number">-0.4</span>       , <span class="number">-0.28571429</span>,</span><br><span class="line">        <span class="number">-0.22222222</span>, <span class="number">-0.18181818</span>, <span class="number">-0.15384615</span>],</span><br><span class="line">       [ <span class="number">0.66666667</span>,  <span class="number">2.</span>        , <span class="number">-2.</span>        , <span class="number">-0.66666667</span>, <span class="number">-0.4</span>       ,</span><br><span class="line">        <span class="number">-0.28571429</span>, <span class="number">-0.22222222</span>, <span class="number">-0.18181818</span>],</span><br><span class="line">       [ <span class="number">0.4</span>       ,  <span class="number">0.66666667</span>,  <span class="number">2.</span>        , <span class="number">-2.</span>        , <span class="number">-0.66666667</span>,</span><br><span class="line">        <span class="number">-0.4</span>       , <span class="number">-0.28571429</span>, <span class="number">-0.22222222</span>],</span><br><span class="line">       [ <span class="number">0.28571429</span>,  <span class="number">0.4</span>       ,  <span class="number">0.66666667</span>,  <span class="number">2.</span>        , <span class="number">-2.</span>        ,</span><br><span class="line">        <span class="number">-0.66666667</span>, <span class="number">-0.4</span>       , <span class="number">-0.28571429</span>],</span><br><span class="line">       [ <span class="number">0.22222222</span>,  <span class="number">0.28571429</span>,  <span class="number">0.4</span>       ,  <span class="number">0.66666667</span>,  <span class="number">2.</span>        ,</span><br><span class="line">        <span class="number">-2.</span>        , <span class="number">-0.66666667</span>, <span class="number">-0.4</span>       ],</span><br><span class="line">       [ <span class="number">0.18181818</span>,  <span class="number">0.22222222</span>,  <span class="number">0.28571429</span>,  <span class="number">0.4</span>       ,  <span class="number">0.66666667</span>,</span><br><span class="line">         <span class="number">2.</span>        , <span class="number">-2.</span>        , <span class="number">-0.66666667</span>],</span><br><span class="line">       [ <span class="number">0.15384615</span>,  <span class="number">0.18181818</span>,  <span class="number">0.22222222</span>,  <span class="number">0.28571429</span>,  <span class="number">0.4</span>       ,</span><br><span class="line">         <span class="number">0.66666667</span>,  <span class="number">2.</span>        , <span class="number">-2.</span>        ]])</span><br><span class="line"></span><br><span class="line"><span class="number">3638.1636371179666</span></span><br></pre></td></tr></table></figure></li><li><p>打印每个<code>Numpy</code>标量类型的最小值和最大值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># np.iinfo：整型的机器限制，包括最大值最小值</span></span><br><span class="line"><span class="comment"># np.finfo, eps：浮点型的机器限制</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> dtype <span class="keyword">in</span> [np.int8, np.int32, np.int64]:</span><br><span class="line">    print(np.iinfo(dtype).min)</span><br><span class="line">    print(np.iinfo(dtype).max)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"><span class="number">-128</span></span><br><span class="line"><span class="number">127</span></span><br><span class="line"><span class="number">-2147483648</span></span><br><span class="line"><span class="number">2147483647</span></span><br><span class="line"><span class="number">-9223372036854775808</span></span><br><span class="line"><span class="number">9223372036854775807</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> dtype <span class="keyword">in</span> [np.float32, np.float64]:</span><br><span class="line">    print(np.finfo(dtype).min)</span><br><span class="line">print(np.finfo(dtype).max)</span><br><span class="line">print(np.finfo(dtype).eps)</span><br><span class="line">    </span><br><span class="line">结果：</span><br><span class="line"><span class="number">-3.4028235e+38</span></span><br><span class="line"><span class="number">3.4028235e+38</span></span><br><span class="line"><span class="number">1.1920929e-07</span></span><br><span class="line"><span class="number">-1.7976931348623157e+308</span></span><br><span class="line"><span class="number">1.7976931348623157e+308</span></span><br><span class="line"><span class="number">2.220446049250313e-16</span></span><br></pre></td></tr></table></figure></li><li><p>如何打印一个数组中的所有数值?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用np.set_printoptions(threshold=nan)设置打印时的显示方式</span></span><br><span class="line"><span class="comment"># 其中threashold=nan表示输出数组时完全输出，不会使用省略号省略中间数据</span></span><br><span class="line"></span><br><span class="line">np.set_printoptions(threshold=np.inf)</span><br><span class="line">Z = np.zeros((<span class="number">16</span>, <span class="number">16</span>))</span><br><span class="line">print(Z)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[[<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]]</span><br></pre></td></tr></table></figure></li><li><p>给定标量时，如何找到数组中最接近标量的值？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用argmin()获取最小值的下标</span></span><br><span class="line"><span class="comment"># 最接近指定标量的值，可以通过取每个值与指定标量的绝对值，然后取绝对值最小的</span></span><br><span class="line">Z =np.arange(<span class="number">100</span>)</span><br><span class="line">v = np.random.uniform(<span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">index = (np.abs(Z-v)).argmin()</span><br><span class="line">print(Z[index])</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">指定标量v为：<span class="number">33</span></span><br><span class="line">数组Z内容array([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>,</span><br><span class="line">       <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>,</span><br><span class="line">       <span class="number">34</span>, <span class="number">35</span>, <span class="number">36</span>, <span class="number">37</span>, <span class="number">38</span>, <span class="number">39</span>, <span class="number">40</span>, <span class="number">41</span>, <span class="number">42</span>, <span class="number">43</span>, <span class="number">44</span>, <span class="number">45</span>, <span class="number">46</span>, <span class="number">47</span>, <span class="number">48</span>, <span class="number">49</span>, <span class="number">50</span>,</span><br><span class="line">       <span class="number">51</span>, <span class="number">52</span>, <span class="number">53</span>, <span class="number">54</span>, <span class="number">55</span>, <span class="number">56</span>, <span class="number">57</span>, <span class="number">58</span>, <span class="number">59</span>, <span class="number">60</span>, <span class="number">61</span>, <span class="number">62</span>, <span class="number">63</span>, <span class="number">64</span>, <span class="number">65</span>, <span class="number">66</span>, <span class="number">67</span>,</span><br><span class="line">       <span class="number">68</span>, <span class="number">69</span>, <span class="number">70</span>, <span class="number">71</span>, <span class="number">72</span>, <span class="number">73</span>, <span class="number">74</span>, <span class="number">75</span>, <span class="number">76</span>, <span class="number">77</span>, <span class="number">78</span>, <span class="number">79</span>, <span class="number">80</span>, <span class="number">81</span>, <span class="number">82</span>, <span class="number">83</span>, <span class="number">84</span>,</span><br><span class="line">       <span class="number">85</span>, <span class="number">86</span>, <span class="number">87</span>, <span class="number">88</span>, <span class="number">89</span>, <span class="number">90</span>, <span class="number">91</span>, <span class="number">92</span>, <span class="number">93</span>, <span class="number">94</span>, <span class="number">95</span>, <span class="number">96</span>, <span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>])</span><br><span class="line"></span><br><span class="line"><span class="number">33</span></span><br></pre></td></tr></table></figure></li><li><p>创建一个表示位置<code>(x,y)</code>和颜色<code>(r,g,b)</code>的结构化数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 两个属性，分别是position和color</span></span><br><span class="line">Z = np.zeros(<span class="number">10</span>, [(<span class="string">'position'</span>, [(<span class="string">'x'</span>, float, <span class="number">1</span>), (<span class="string">'y'</span>, float, <span class="number">1</span>)]), (<span class="string">'color'</span>, [(<span class="string">'r'</span>, float, <span class="number">1</span>), (<span class="string">'g'</span>, float, <span class="number">1</span>), (<span class="string">'b'</span>, float, <span class="number">1</span>)])])</span><br><span class="line">print(Z)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[((<span class="number">0.</span>, <span class="number">0.</span>), (<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>)) ((<span class="number">0.</span>, <span class="number">0.</span>), (<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>))</span><br><span class="line"> ((<span class="number">0.</span>, <span class="number">0.</span>), (<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>)) ((<span class="number">0.</span>, <span class="number">0.</span>), (<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>))</span><br><span class="line"> ((<span class="number">0.</span>, <span class="number">0.</span>), (<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>)) ((<span class="number">0.</span>, <span class="number">0.</span>), (<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>))</span><br><span class="line"> ((<span class="number">0.</span>, <span class="number">0.</span>), (<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>)) ((<span class="number">0.</span>, <span class="number">0.</span>), (<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>))</span><br><span class="line"> ((<span class="number">0.</span>, <span class="number">0.</span>), (<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>)) ((<span class="number">0.</span>, <span class="number">0.</span>), (<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>))]</span><br></pre></td></tr></table></figure></li><li><p>对一个表示坐标形状为<code>(100,2)</code>的随机向量，找到点与点的距离</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># np.atleast_1d(), np.atleast_2d(), np.atleast_3d()</span></span><br><span class="line"><span class="comment"># 分别用于将输入转化为至少具有一个、两个、三个维度的数组</span></span><br><span class="line">Z = np.random.random((<span class="number">10</span>, <span class="number">2</span>))</span><br><span class="line">X , Y = np.atleast_2d(Z[:, <span class="number">0</span>], Z[:, <span class="number">1</span>])</span><br><span class="line">D = np.sqrt((X - X.T)**<span class="number">2</span>, (Y - Y.T)**<span class="number">2</span>)</span><br><span class="line">print(D)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[[<span class="number">0.</span>         <span class="number">0.38993115</span> <span class="number">0.01674273</span> <span class="number">0.1174607</span>  <span class="number">0.01335761</span> <span class="number">0.37033472</span></span><br><span class="line">  <span class="number">0.04442136</span> <span class="number">0.50701389</span> <span class="number">0.00334056</span> <span class="number">0.38674937</span>]</span><br><span class="line"> [<span class="number">0.38993115</span> <span class="number">0.</span>         <span class="number">0.40667389</span> <span class="number">0.50739185</span> <span class="number">0.40328876</span> <span class="number">0.01959643</span></span><br><span class="line">  <span class="number">0.34550979</span> <span class="number">0.11708273</span> <span class="number">0.38659059</span> <span class="number">0.00318179</span>]</span><br><span class="line"> [<span class="number">0.01674273</span> <span class="number">0.40667389</span> <span class="number">0.</span>         <span class="number">0.10071797</span> <span class="number">0.00338513</span> <span class="number">0.38707745</span></span><br><span class="line">  <span class="number">0.0611641</span>  <span class="number">0.52375662</span> <span class="number">0.02008329</span> <span class="number">0.4034921</span> ]</span><br><span class="line"> [<span class="number">0.1174607</span>  <span class="number">0.50739185</span> <span class="number">0.10071797</span> <span class="number">0.</span>         <span class="number">0.1041031</span>  <span class="number">0.48779542</span></span><br><span class="line">  <span class="number">0.16188206</span> <span class="number">0.62447459</span> <span class="number">0.12080126</span> <span class="number">0.50421007</span>]</span><br><span class="line"> [<span class="number">0.01335761</span> <span class="number">0.40328876</span> <span class="number">0.00338513</span> <span class="number">0.1041031</span>  <span class="number">0.</span>         <span class="number">0.38369232</span></span><br><span class="line">  <span class="number">0.05777897</span> <span class="number">0.52037149</span> <span class="number">0.01669817</span> <span class="number">0.40010697</span>]</span><br><span class="line"> [<span class="number">0.37033472</span> <span class="number">0.01959643</span> <span class="number">0.38707745</span> <span class="number">0.48779542</span> <span class="number">0.38369232</span> <span class="number">0.</span></span><br><span class="line">  <span class="number">0.32591336</span> <span class="number">0.13667917</span> <span class="number">0.36699416</span> <span class="number">0.01641465</span>]</span><br><span class="line"> [<span class="number">0.04442136</span> <span class="number">0.34550979</span> <span class="number">0.0611641</span>  <span class="number">0.16188206</span> <span class="number">0.05777897</span> <span class="number">0.32591336</span></span><br><span class="line">  <span class="number">0.</span>         <span class="number">0.46259252</span> <span class="number">0.0410808</span>  <span class="number">0.342328</span>  ]</span><br><span class="line"> [<span class="number">0.50701389</span> <span class="number">0.11708273</span> <span class="number">0.52375662</span> <span class="number">0.62447459</span> <span class="number">0.52037149</span> <span class="number">0.13667917</span></span><br><span class="line">  <span class="number">0.46259252</span> <span class="number">0.</span>         <span class="number">0.50367333</span> <span class="number">0.12026452</span>]</span><br><span class="line"> [<span class="number">0.00334056</span> <span class="number">0.38659059</span> <span class="number">0.02008329</span> <span class="number">0.12080126</span> <span class="number">0.01669817</span> <span class="number">0.36699416</span></span><br><span class="line">  <span class="number">0.0410808</span>  <span class="number">0.50367333</span> <span class="number">0.</span>         <span class="number">0.38340881</span>]</span><br><span class="line"> [<span class="number">0.38674937</span> <span class="number">0.00318179</span> <span class="number">0.4034921</span>  <span class="number">0.50421007</span> <span class="number">0.40010697</span> <span class="number">0.01641465</span></span><br><span class="line">  <span class="number">0.342328</span>   <span class="number">0.12026452</span> <span class="number">0.38340881</span> <span class="number">0.</span>        ]]</span><br></pre></td></tr></table></figure></li><li><p>如何将32位的浮点数(float)转换为对应的整数(integer)?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用astype(copy = False)修改数据类型</span></span><br><span class="line">Z = np.arange(<span class="number">10</span>, dtype=np.int32)</span><br><span class="line">Z = Z.astype(np.float32, copy=<span class="literal">False</span>)</span><br><span class="line">print(Z)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[<span class="number">0.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">3.</span> <span class="number">4.</span> <span class="number">5.</span> <span class="number">6.</span> <span class="number">7.</span> <span class="number">8.</span> <span class="number">9.</span>]</span><br></pre></td></tr></table></figure></li><li><p>如何读取以下文件?</p><p>见<code>genfromtxt</code>函数详细介绍的<a href="[http://www.zivblog.top/passages/Numpy%E4%B9%8Bgenfromtxt%E5%87%BD%E6%95%B0/](http://www.zivblog.top/passages/Numpy之genfromtxt函数/)">博客</a></p></li><li><p>对于<code>Numpy</code>数组，<code>enumerate</code>的等价操作是什么？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># enumerate指的是枚举</span></span><br><span class="line"><span class="comment"># numpy中可以通过np.ndenumerate()和np.ndindex()实现枚举</span></span><br><span class="line">Z = np.arange(<span class="number">9</span>).reshape(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> index, value <span class="keyword">in</span> np.ndenumerate(Z):</span><br><span class="line">    print(index, value)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">(<span class="number">0</span>, <span class="number">0</span>) <span class="number">0</span></span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>) <span class="number">1</span></span><br><span class="line">(<span class="number">0</span>, <span class="number">2</span>) <span class="number">2</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">0</span>) <span class="number">3</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">1</span>) <span class="number">4</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>) <span class="number">5</span></span><br><span class="line">(<span class="number">2</span>, <span class="number">0</span>) <span class="number">6</span></span><br><span class="line">(<span class="number">2</span>, <span class="number">1</span>) <span class="number">7</span></span><br><span class="line">(<span class="number">2</span>, <span class="number">2</span>) <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> np.ndindex(Z.shape):</span><br><span class="line">    print(index, Z[index])</span><br><span class="line">    </span><br><span class="line">结果：</span><br><span class="line">(<span class="number">0</span>, <span class="number">0</span>) <span class="number">0</span></span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>) <span class="number">1</span></span><br><span class="line">(<span class="number">0</span>, <span class="number">2</span>) <span class="number">2</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">0</span>) <span class="number">3</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">1</span>) <span class="number">4</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>) <span class="number">5</span></span><br><span class="line">(<span class="number">2</span>, <span class="number">0</span>) <span class="number">6</span></span><br><span class="line">(<span class="number">2</span>, <span class="number">1</span>) <span class="number">7</span></span><br><span class="line">(<span class="number">2</span>, <span class="number">2</span>) <span class="number">8</span></span><br></pre></td></tr></table></figure></li></ol><ol start="16"><li><p>生成一个通用的二维<code>Gaussian-like</code>数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># np.meshgrid() 生成网格点坐标矩阵，把两个数组的笛卡尔积内的元素的第一二个坐标分别放入两个矩阵中</span></span><br><span class="line">X, Y = np.meshgrid(np.linspace(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">10</span>), np.linspace(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">10</span>))</span><br><span class="line">D = np.sqrt(X*X + Y*Y)</span><br><span class="line">sigma, mu = <span class="number">1.0</span>, <span class="number">0.0</span></span><br><span class="line">G = np.exp(-((D-mu)**<span class="number">2</span>/(<span class="number">2.0</span>*sigma**<span class="number">2</span>)))</span><br><span class="line">print(G)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[[<span class="number">0.36787944</span> <span class="number">0.44822088</span> <span class="number">0.51979489</span> <span class="number">0.57375342</span> <span class="number">0.60279818</span> <span class="number">0.60279818</span></span><br><span class="line">  <span class="number">0.57375342</span> <span class="number">0.51979489</span> <span class="number">0.44822088</span> <span class="number">0.36787944</span>]</span><br><span class="line"> [<span class="number">0.44822088</span> <span class="number">0.54610814</span> <span class="number">0.63331324</span> <span class="number">0.69905581</span> <span class="number">0.73444367</span> <span class="number">0.73444367</span></span><br><span class="line">  <span class="number">0.69905581</span> <span class="number">0.63331324</span> <span class="number">0.54610814</span> <span class="number">0.44822088</span>]</span><br><span class="line"> [<span class="number">0.51979489</span> <span class="number">0.63331324</span> <span class="number">0.73444367</span> <span class="number">0.81068432</span> <span class="number">0.85172308</span> <span class="number">0.85172308</span></span><br><span class="line">  <span class="number">0.81068432</span> <span class="number">0.73444367</span> <span class="number">0.63331324</span> <span class="number">0.51979489</span>]</span><br><span class="line"> [<span class="number">0.57375342</span> <span class="number">0.69905581</span> <span class="number">0.81068432</span> <span class="number">0.89483932</span> <span class="number">0.9401382</span>  <span class="number">0.9401382</span></span><br><span class="line">  <span class="number">0.89483932</span> <span class="number">0.81068432</span> <span class="number">0.69905581</span> <span class="number">0.57375342</span>]</span><br><span class="line"> [<span class="number">0.60279818</span> <span class="number">0.73444367</span> <span class="number">0.85172308</span> <span class="number">0.9401382</span>  <span class="number">0.98773022</span> <span class="number">0.98773022</span></span><br><span class="line">  <span class="number">0.9401382</span>  <span class="number">0.85172308</span> <span class="number">0.73444367</span> <span class="number">0.60279818</span>]</span><br><span class="line"> [<span class="number">0.60279818</span> <span class="number">0.73444367</span> <span class="number">0.85172308</span> <span class="number">0.9401382</span>  <span class="number">0.98773022</span> <span class="number">0.98773022</span></span><br><span class="line">  <span class="number">0.9401382</span>  <span class="number">0.85172308</span> <span class="number">0.73444367</span> <span class="number">0.60279818</span>]</span><br><span class="line"> [<span class="number">0.57375342</span> <span class="number">0.69905581</span> <span class="number">0.81068432</span> <span class="number">0.89483932</span> <span class="number">0.9401382</span>  <span class="number">0.9401382</span></span><br><span class="line">  <span class="number">0.89483932</span> <span class="number">0.81068432</span> <span class="number">0.69905581</span> <span class="number">0.57375342</span>]</span><br><span class="line"> [<span class="number">0.51979489</span> <span class="number">0.63331324</span> <span class="number">0.73444367</span> <span class="number">0.81068432</span> <span class="number">0.85172308</span> <span class="number">0.85172308</span></span><br><span class="line">  <span class="number">0.81068432</span> <span class="number">0.73444367</span> <span class="number">0.63331324</span> <span class="number">0.51979489</span>]</span><br><span class="line"> [<span class="number">0.44822088</span> <span class="number">0.54610814</span> <span class="number">0.63331324</span> <span class="number">0.69905581</span> <span class="number">0.73444367</span> <span class="number">0.73444367</span></span><br><span class="line">  <span class="number">0.69905581</span> <span class="number">0.63331324</span> <span class="number">0.54610814</span> <span class="number">0.44822088</span>]</span><br><span class="line"> [<span class="number">0.36787944</span> <span class="number">0.44822088</span> <span class="number">0.51979489</span> <span class="number">0.57375342</span> <span class="number">0.60279818</span> <span class="number">0.60279818</span></span><br><span class="line">  <span class="number">0.57375342</span> <span class="number">0.51979489</span> <span class="number">0.44822088</span> <span class="number">0.36787944</span>]]</span><br></pre></td></tr></table></figure></li><li><p>对一个二维数组，如何在其内部随机放置<code>p</code>个元素?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># np.put(ind, [])：将数组中索引为ind的元素用[]中的元素代替</span></span><br><span class="line"><span class="comment"># 与之相对np.take(ind)：将数组中索引为ind的元素取出</span></span><br><span class="line"><span class="comment"># np.random.choice(a, size=,replace=True, p=None)：从a中随机选取size个元素，replace表示抽样之后是否放回，p为每个元素被选取的概率，默认等概率</span></span><br><span class="line"></span><br><span class="line">n = <span class="number">10</span></span><br><span class="line">p = <span class="number">3</span></span><br><span class="line">Z = np.zeros((n, n))</span><br><span class="line">np.put(Z, np.random.choice(range(n*n), p, replace=<span class="literal">False</span>), <span class="number">1</span>)</span><br><span class="line">print(Z)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[[<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]]</span><br></pre></td></tr></table></figure></li><li><p>减去一个矩阵中的每一行的平均值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># np.mean(a, axis, dtype, out, keepdims)</span></span><br><span class="line"><span class="comment"># axis不设置表示对所有元素求均值，axis为0表示对各列求均值，axis为1表示对各行求均值</span></span><br><span class="line"></span><br><span class="line">X = np.random.rand(<span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">Y = X - X.mean(axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line">print(Y)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[[<span class="number">-0.03275755</span> <span class="number">-0.03035167</span> <span class="number">-0.08707745</span> <span class="number">-0.25124861</span>  <span class="number">0.03642215</span> <span class="number">-0.04187207</span></span><br><span class="line">  <span class="number">-0.25630029</span>  <span class="number">0.49229668</span> <span class="number">-0.03462927</span>  <span class="number">0.20551809</span>]</span><br><span class="line"> [ <span class="number">0.08456354</span> <span class="number">-0.39740261</span>  <span class="number">0.2759206</span>  <span class="number">-0.22989044</span> <span class="number">-0.03611724</span> <span class="number">-0.59011478</span></span><br><span class="line">   <span class="number">0.23584573</span>  <span class="number">0.28327169</span>  <span class="number">0.09127001</span>  <span class="number">0.2826535</span> ]</span><br><span class="line"> [ <span class="number">0.3791585</span>   <span class="number">0.1788899</span>  <span class="number">-0.2672872</span>   <span class="number">0.17179428</span> <span class="number">-0.0422312</span>  <span class="number">-0.39381341</span></span><br><span class="line">  <span class="number">-0.45286872</span>  <span class="number">0.33314372</span>  <span class="number">0.35918018</span> <span class="number">-0.26596606</span>]</span><br><span class="line"> [ <span class="number">0.24243083</span> <span class="number">-0.4746942</span>   <span class="number">0.2044127</span>   <span class="number">0.2530425</span>  <span class="number">-0.15927489</span> <span class="number">-0.57245357</span></span><br><span class="line">   <span class="number">0.24327986</span> <span class="number">-0.00992776</span>  <span class="number">0.23649468</span>  <span class="number">0.03668986</span>]</span><br><span class="line"> [<span class="number">-0.25147254</span>  <span class="number">0.45156914</span>  <span class="number">0.28612509</span> <span class="number">-0.10173569</span> <span class="number">-0.08643743</span>  <span class="number">0.15675954</span></span><br><span class="line">   <span class="number">0.41942699</span> <span class="number">-0.42012685</span> <span class="number">-0.03718232</span> <span class="number">-0.41692593</span>]]</span><br></pre></td></tr></table></figure></li><li><p>如何通过第<code>n</code>列对一个数组进行排序?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># argsort()返回的是数组值从小到大的索引值</span></span><br><span class="line">Z = np.random.randint(<span class="number">1</span>, <span class="number">10</span>, (<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line">print(Z)</span><br><span class="line">print(Z[Z[:, <span class="number">1</span>].argsort()])</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[[<span class="number">6</span> <span class="number">7</span> <span class="number">6</span>]</span><br><span class="line"> [<span class="number">7</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">5</span> <span class="number">3</span> <span class="number">8</span>]]</span><br><span class="line"></span><br><span class="line">[[<span class="number">6</span> <span class="number">2</span> <span class="number">9</span>]</span><br><span class="line"> [<span class="number">6</span> <span class="number">5</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">5</span> <span class="number">8</span>]]</span><br></pre></td></tr></table></figure></li><li><p>如何检查一个二维数组是否有空列？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用any、~</span></span><br><span class="line"><span class="comment"># any()用于判断给定的可迭代参数是否全部为False，若全部为False则返回False</span></span><br><span class="line">Z = np.random.randint(<span class="number">0</span>, <span class="number">3</span>, (<span class="number">3</span>, <span class="number">10</span>))</span><br><span class="line">print((~Z.any(axis=<span class="number">0</span>)).any())</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure></li></ol><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Numpy100题之21-40</title>
      <link href="/passages/numpy100-ti-zhi-21-40/"/>
      <url>/passages/numpy100-ti-zhi-21-40/</url>
      
        <content type="html"><![CDATA[<p>学习笔记</p><p>答案整理</p><p>原文地址：<a href="https://zhuanlan.zhihu.com/p/76186124" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/76186124</a></p><a id="more"></a><ol start="21"><li><p>用<code>tile</code>函数去创建一个<code>8x8</code>的棋盘样式矩阵</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tile(array, num) 将原矩阵横向、纵向地复制</span></span><br><span class="line"><span class="comment"># 将array复制num次；若num是个n元组，则依次是各个维度上复制的次数</span></span><br><span class="line">Z = np.tile(np.array([[<span class="number">1</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">0</span>]]), (<span class="number">4</span>,<span class="number">4</span>))</span><br><span class="line">print(Z)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[[<span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span>]]</span><br></pre></td></tr></table></figure></li><li><p>对一个<code>5x5</code>的随机矩阵做归一化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 归一化：将数据转化乘(0, 1)或(-1, 1)之间的小数</span></span><br><span class="line"><span class="comment"># 归一化：(Z - Z.min)/(Z.max - Z.min)</span></span><br><span class="line">Z = np.random.random((<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">Zmax, Zmin = Z.max(), Z.min()</span><br><span class="line">Z = (Z - Zmin)/(Zmax - Zmin)</span><br><span class="line">print(Z)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[[<span class="number">0.49837306</span> <span class="number">0.08864194</span> <span class="number">0.68784483</span> <span class="number">0.84959538</span> <span class="number">0.53010616</span>]</span><br><span class="line"> [<span class="number">0.62847499</span> <span class="number">0.06661639</span> <span class="number">0.64068999</span> <span class="number">1.</span>         <span class="number">0.17954986</span>]</span><br><span class="line"> [<span class="number">0.73358673</span> <span class="number">0.</span>         <span class="number">0.04020008</span> <span class="number">0.95159169</span> <span class="number">0.14104298</span>]</span><br><span class="line"> [<span class="number">0.99773013</span> <span class="number">0.50224238</span> <span class="number">0.28422327</span> <span class="number">0.62605846</span> <span class="number">0.02929286</span>]</span><br><span class="line"> [<span class="number">0.91979782</span> <span class="number">0.81827956</span> <span class="number">0.19822701</span> <span class="number">0.78475044</span> <span class="number">0.54114787</span>]]</span><br></pre></td></tr></table></figure></li><li><p>创建一个将颜色描述为<code>(RGBA)</code>四个无符号字节的自定义<code>dtype</code>？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">color = np.dtype([(<span class="string">"r"</span>, np.ubyte, <span class="number">1</span>), (<span class="string">"g"</span>, np.ubyte, <span class="number">1</span>), (<span class="string">"b"</span>, np.ubyte, <span class="number">1</span>), (<span class="string">"a"</span>, np.ubyte, <span class="number">1</span>)])</span><br><span class="line">color</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">dtype([(<span class="string">'r'</span>, <span class="string">'u1'</span>), (<span class="string">'g'</span>, <span class="string">'u1'</span>), (<span class="string">'b'</span>, <span class="string">'u1'</span>), (<span class="string">'a'</span>, <span class="string">'u1'</span>)])</span><br></pre></td></tr></table></figure></li><li><p>一个<code>5x3</code>的矩阵与一个<code>3x2</code>的矩阵相乘，实矩阵乘积是什么？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用dot()进行矩阵间的点乘</span></span><br><span class="line">Z = np.dot(np.ones((<span class="number">5</span>, <span class="number">3</span>)), np.ones((<span class="number">3</span>, <span class="number">2</span>)))</span><br><span class="line">print(Z)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[[<span class="number">3.</span> <span class="number">3.</span>]</span><br><span class="line"> [<span class="number">3.</span> <span class="number">3.</span>]</span><br><span class="line"> [<span class="number">3.</span> <span class="number">3.</span>]</span><br><span class="line"> [<span class="number">3.</span> <span class="number">3.</span>]</span><br><span class="line"> [<span class="number">3.</span> <span class="number">3.</span>]]</span><br></pre></td></tr></table></figure></li><li><p>给定一个一维数组，对其在3到8之间的所有元素取相反数？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Z = np.arange(<span class="number">11</span>)</span><br><span class="line">Z[(<span class="number">3</span> &lt; Z)&amp;(Z &lt;= <span class="number">8</span>)] *= <span class="number">-1</span></span><br><span class="line">Z</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>, <span class="number">-4</span>, <span class="number">-5</span>, <span class="number">-6</span>, <span class="number">-7</span>, <span class="number">-8</span>,  <span class="number">9</span>, <span class="number">10</span>])</span><br></pre></td></tr></table></figure></li><li><p>下面脚本运行后的结果是什么?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意Python自带的sum()函数和numpy中的sum()函数的区别</span></span><br><span class="line"><span class="comment"># numpy中的sum()是对矩阵中所有元素的求和</span></span><br><span class="line"><span class="comment"># Python中的sum()传入的是参数列表，即对所有传入的数据全部加和</span></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line">print(sum(range(<span class="number">5</span>),<span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"><span class="number">10</span><span class="comment"># 即0~4累加</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(sum(range(<span class="number">5</span>),<span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"><span class="number">9</span><span class="comment"># 即0~4累加，再加-1</span></span><br></pre></td></tr></table></figure></li><li><p>考虑一个整数向量<code>Z</code>,下列表达合法的是哪个?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Z**Z<span class="comment"># 合法，结果为[  1,   1,   4,  27, 256]</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>&lt;&lt;Z&gt;&gt;<span class="number">2</span><span class="comment"># 不合法</span></span><br><span class="line"></span><br><span class="line">Z&lt;-Z<span class="comment"># 合法，结果为[False, False, False, False, False]</span></span><br><span class="line"></span><br><span class="line"><span class="number">1j</span>*Z<span class="comment"># 合法，结果为[0.+0.j, 0.+1.j, 0.+2.j, 0.+3.j, 0.+4.j]</span></span><br><span class="line"></span><br><span class="line">Z/<span class="number">1</span>/<span class="number">1</span><span class="comment"># 合法，结果为[0., 1., 2., 3., 4.]</span></span><br><span class="line"></span><br><span class="line">Z&lt;Z&gt;Z<span class="comment"># 不合法</span></span><br></pre></td></tr></table></figure></li><li><p>下列表达式的结果分别是什么?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">np.array(<span class="number">0</span>) /np.array(<span class="number">0</span>)</span><br><span class="line">结果：</span><br><span class="line">nan</span><br><span class="line"></span><br><span class="line">np.array(<span class="number">0</span>) //np.array(<span class="number">0</span>)</span><br><span class="line">结果：</span><br><span class="line"><span class="number">0</span><span class="comment">#但是0作为分母</span></span><br><span class="line"></span><br><span class="line">np.array([np.nan]).astype(int).astype(float)</span><br><span class="line">结果：</span><br><span class="line">array([<span class="number">-2.14748365e+09</span>])</span><br></pre></td></tr></table></figure></li><li><p>如何从零位对浮点数组做舍入?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个指定格式的随机数组</span></span><br><span class="line">Z = np.random.uniform(<span class="number">-10</span>, +<span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line">Z</span><br><span class="line">结果：</span><br><span class="line">array([ <span class="number">2.4142539</span> ,  <span class="number">6.56990199</span>,  <span class="number">8.70723106</span>,  <span class="number">5.97495463</span>, <span class="number">-5.30474813</span>,</span><br><span class="line">       <span class="number">-0.69522623</span>,  <span class="number">0.69668324</span>, <span class="number">-7.06029374</span>, <span class="number">-8.52539933</span>,  <span class="number">5.67250038</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (np.copysign(np.ceil(np.abs(Z)), Z))</span><br><span class="line">结果：</span><br><span class="line">[ <span class="number">3.</span>  <span class="number">7.</span>  <span class="number">9.</span>  <span class="number">6.</span> <span class="number">-6.</span> <span class="number">-1.</span>  <span class="number">1.</span> <span class="number">-8.</span> <span class="number">-9.</span>  <span class="number">6.</span>]</span><br></pre></td></tr></table></figure></li><li><p>如何找到两个数组中的共同元素?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建两个数组</span></span><br><span class="line">Z1 = np.random.randint(<span class="number">0</span>,<span class="number">10</span>,<span class="number">10</span>)</span><br><span class="line">Z2 = np.random.randint(<span class="number">0</span>,<span class="number">10</span>,<span class="number">10</span>)</span><br><span class="line">Z1</span><br><span class="line">Z2</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([<span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line">array([<span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">6</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用intersect1d()函数求两个数组的交集</span></span><br><span class="line">print(np.intersect1d(Z1,Z2))</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[<span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span>]</span><br></pre></td></tr></table></figure></li><li><p>如何忽略所有的<code>Numpy</code>警告(尽管不建议这么做)?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以忽略python的所有警告</span></span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">"ignore"</span>)</span><br></pre></td></tr></table></figure></li><li><p>下面的表达式是正确的吗?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 虚数</span></span><br><span class="line">np.sqrt(<span class="number">-1</span>) ==np.emath.sqrt(<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure></li><li><p>如何得到昨天，今天，明天的日期?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用到np.datetime64和np.timedelta64</span></span><br><span class="line">yesterday = np.datetime64(<span class="string">'today'</span>, <span class="string">'D'</span>) - np.timedelta64(<span class="number">1</span>, <span class="string">'D'</span>)</span><br><span class="line">today = np.datetime64(<span class="string">'today'</span>, <span class="string">'D'</span>)</span><br><span class="line">tomorrow = np.datetime64(<span class="string">'today'</span>, <span class="string">'D'</span>) + np.timedelta64(<span class="number">1</span>, <span class="string">'D'</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Yesterday is '</span> + str(yesterday))</span><br><span class="line">print(<span class="string">'Today is '</span> + str(today))</span><br><span class="line">print(<span class="string">'Tomorrow is '</span> + str(tomorrow))</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">Yesterday <span class="keyword">is</span> <span class="number">2019</span><span class="number">-08</span><span class="number">-21</span></span><br><span class="line">Today <span class="keyword">is</span> <span class="number">2019</span><span class="number">-08</span><span class="number">-22</span></span><br><span class="line">Tomorrow <span class="keyword">is</span> <span class="number">2019</span><span class="number">-08</span><span class="number">-23</span></span><br></pre></td></tr></table></figure></li><li><p>如何得到所有与2016年7月对应的日期?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用arange()，设置起始点为七月和八月，元素类型设为datetime64的日</span></span><br><span class="line">Z = np.arange(<span class="string">'2016-07'</span>, <span class="string">'2016-08'</span>,dtype=<span class="string">'datetime64[D]'</span>)</span><br><span class="line">print(Z)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[<span class="string">'2016-07-01'</span> <span class="string">'2016-07-02'</span> <span class="string">'2016-07-03'</span> <span class="string">'2016-07-04'</span> <span class="string">'2016-07-05'</span></span><br><span class="line"> <span class="string">'2016-07-06'</span> <span class="string">'2016-07-07'</span> <span class="string">'2016-07-08'</span> <span class="string">'2016-07-09'</span> <span class="string">'2016-07-10'</span></span><br><span class="line"> <span class="string">'2016-07-11'</span> <span class="string">'2016-07-12'</span> <span class="string">'2016-07-13'</span> <span class="string">'2016-07-14'</span> <span class="string">'2016-07-15'</span></span><br><span class="line"> <span class="string">'2016-07-16'</span> <span class="string">'2016-07-17'</span> <span class="string">'2016-07-18'</span> <span class="string">'2016-07-19'</span> <span class="string">'2016-07-20'</span></span><br><span class="line"> <span class="string">'2016-07-21'</span> <span class="string">'2016-07-22'</span> <span class="string">'2016-07-23'</span> <span class="string">'2016-07-24'</span> <span class="string">'2016-07-25'</span></span><br><span class="line"> <span class="string">'2016-07-26'</span> <span class="string">'2016-07-27'</span> <span class="string">'2016-07-28'</span> <span class="string">'2016-07-29'</span> <span class="string">'2016-07-30'</span></span><br><span class="line"> <span class="string">'2016-07-31'</span>]</span><br></pre></td></tr></table></figure></li><li><p>如何直接在位计算<code>(A+B)\*(-A/2)</code>(不建立副本)?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用函数add()计算加法，使用negative()计算取负值，使用multiply()计算乘法，使用divide()计算除法</span></span><br><span class="line"><span class="comment"># 并且使用这些函数的out属性指定输出的矩阵，不再自动创建新矩阵</span></span><br><span class="line"><span class="comment"># 创建三个数组</span></span><br><span class="line">A = np.ones(<span class="number">3</span>)*<span class="number">1</span></span><br><span class="line">B = np.ones(<span class="number">3</span>)*<span class="number">2</span></span><br><span class="line">C = np.ones(<span class="number">3</span>)*<span class="number">3</span></span><br><span class="line"></span><br><span class="line">np.add(A, B, out=B)</span><br><span class="line">np.divide(A, <span class="number">2</span>, out=A)</span><br><span class="line">np.negative(A, out=A)</span><br><span class="line">np.multiply(A, B, out=A)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.add(A, B, out=B)</span><br><span class="line">array([<span class="number">3.</span>, <span class="number">3.</span>, <span class="number">3.</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.divide(A, <span class="number">2</span>, out=A)</span><br><span class="line">array([<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.negative(A, out=A)</span><br><span class="line">array([<span class="number">-0.5</span>, <span class="number">-0.5</span>, <span class="number">-0.5</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.multiply(A, B, out=A)</span><br><span class="line">array([<span class="number">-1.5</span>, <span class="number">-1.5</span>, <span class="number">-1.5</span>])</span><br></pre></td></tr></table></figure></li><li><p>用五种不同的方法去提取一个随机数组的整数部分？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># %, np.floor, np.ceil, astype, np.trunc</span></span><br><span class="line"><span class="comment"># 创建随机数组</span></span><br><span class="line">Z = np.random.uniform(<span class="number">0</span>, <span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(Z - Z%<span class="number">1</span>)</span><br><span class="line">[<span class="number">3.</span> <span class="number">6.</span> <span class="number">1.</span> <span class="number">4.</span> <span class="number">8.</span> <span class="number">7.</span> <span class="number">5.</span> <span class="number">6.</span> <span class="number">5.</span> <span class="number">5.</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(np.floor(Z))</span><br><span class="line">[<span class="number">3.</span> <span class="number">6.</span> <span class="number">1.</span> <span class="number">4.</span> <span class="number">8.</span> <span class="number">7.</span> <span class="number">5.</span> <span class="number">6.</span> <span class="number">5.</span> <span class="number">5.</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(np.ceil(Z)<span class="number">-1</span>)</span><br><span class="line">[<span class="number">3.</span> <span class="number">6.</span> <span class="number">1.</span> <span class="number">4.</span> <span class="number">8.</span> <span class="number">7.</span> <span class="number">5.</span> <span class="number">6.</span> <span class="number">5.</span> <span class="number">5.</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(Z.astype(int))</span><br><span class="line">[<span class="number">3</span> <span class="number">6</span> <span class="number">1</span> <span class="number">4</span> <span class="number">8</span> <span class="number">7</span> <span class="number">5</span> <span class="number">6</span> <span class="number">5</span> <span class="number">5</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(np.trunc(Z))</span><br><span class="line">[<span class="number">3.</span> <span class="number">6.</span> <span class="number">1.</span> <span class="number">4.</span> <span class="number">8.</span> <span class="number">7.</span> <span class="number">5.</span> <span class="number">6.</span> <span class="number">5.</span> <span class="number">5.</span>]</span><br></pre></td></tr></table></figure></li></ol><ol start="37"><li><p>创建一个<code>5x5</code>的矩阵，其中每行的数值范围从0到4</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先创建全为0的矩阵，再讲0~4依次加到每一行</span></span><br><span class="line">Z = np.zeros((<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">Z += np.arange(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">print(Z)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[[<span class="number">0.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">3.</span> <span class="number">4.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">3.</span> <span class="number">4.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">3.</span> <span class="number">4.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">3.</span> <span class="number">4.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">3.</span> <span class="number">4.</span>]]</span><br></pre></td></tr></table></figure></li><li><p>通过一个可生成10个整数的函数，来构建一个数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用np.fromiter()函数从一个可迭代对象创建一个一维数组</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        <span class="keyword">yield</span> x</span><br><span class="line"></span><br><span class="line">Z = np.fromiter(generate(), dtype=float, count=<span class="number">-1</span>)</span><br><span class="line">print(Z)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[<span class="number">0.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">3.</span> <span class="number">4.</span> <span class="number">5.</span> <span class="number">6.</span> <span class="number">7.</span> <span class="number">8.</span> <span class="number">9.</span>]</span><br></pre></td></tr></table></figure></li><li><p>创建一个长度为10的随机向量，其值域范围从0到1，但是不包括0和1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用linspace(start, end, num, endpoint=)</span></span><br><span class="line"><span class="comment"># 创建一个指定起始点的元素个数为num的间隔均匀的数组，endpoint指定数组中是否包含end</span></span><br><span class="line">Z = np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">11</span>, endpoint=<span class="literal">False</span>)[<span class="number">1</span>:]</span><br><span class="line">Z</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([<span class="number">0.09090909</span>, <span class="number">0.18181818</span>, <span class="number">0.27272727</span>, <span class="number">0.36363636</span>, <span class="number">0.45454545</span>,</span><br><span class="line">       <span class="number">0.54545455</span>, <span class="number">0.63636364</span>, <span class="number">0.72727273</span>, <span class="number">0.81818182</span>, <span class="number">0.90909091</span>])</span><br></pre></td></tr></table></figure></li><li><p>创建一个长度为10的随机向量，并将其排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用sort()函数对数组排序</span></span><br><span class="line">Z = np.random.random(<span class="number">10</span>)</span><br><span class="line">Z.sort()</span><br><span class="line">print(Z)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[<span class="number">0.09179728</span> <span class="number">0.39609427</span> <span class="number">0.39989882</span> <span class="number">0.52910508</span> <span class="number">0.5780039</span>  <span class="number">0.66504509</span></span><br><span class="line"> <span class="number">0.73527613</span> <span class="number">0.77932581</span> <span class="number">0.9451393</span>  <span class="number">0.99063504</span>]</span><br></pre></td></tr></table></figure></li></ol><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Numpy100题之1~20</title>
      <link href="/passages/numpy100-ti-zhi-1-20/"/>
      <url>/passages/numpy100-ti-zhi-1-20/</url>
      
        <content type="html"><![CDATA[<p>学习笔记</p><p>答案整理</p><p>原文地址：<a href="https://zhuanlan.zhihu.com/p/76186124" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/76186124</a></p><a id="more"></a><ol><li><p>导入<code>Numpy</code>并简写为<code>np</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure></li><li><p>打印<code>Numpy</code>的<strong>版本信息</strong>和<strong>配置说明</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 版本信息</span></span><br><span class="line">print(np.__version__)</span><br><span class="line"><span class="comment"># 配置说明</span></span><br><span class="line">np.show_config</span><br></pre></td></tr></table></figure></li><li><p>创建长度为<code>10</code>的空向量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 空向量使用zeros()函数创建</span></span><br><span class="line">Z = np.zeros(<span class="number">10</span>)</span><br><span class="line">print(Z)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br></pre></td></tr></table></figure></li><li><p>如何找到任意数组的内存大小</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义大小为10*10的空数组</span></span><br><span class="line">Z = np.zeros((<span class="number">10</span>*<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出内存大小</span></span><br><span class="line">print(Z.size * Z.itemsize)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"><span class="number">800</span></span><br></pre></td></tr></table></figure></li><li><p>从命令行得到<code>Numpy</code>中<code>add</code>函数的说明文档</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">np.info(np.add)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">add(x1, x2, /, out=<span class="literal">None</span>, *, where=<span class="literal">True</span>, casting=<span class="string">'same_kind'</span>, order=<span class="string">'K'</span>, dtype=<span class="literal">None</span>, subok=<span class="literal">True</span>[, signature, extobj])</span><br><span class="line"></span><br><span class="line">Add arguments element-wise.</span><br><span class="line"></span><br><span class="line">Parameters</span><br><span class="line">----------</span><br><span class="line">x1, x2 : array_like</span><br><span class="line">    The arrays to be added.  If ``x1.shape != x2.shape``, they must be</span><br><span class="line">    broadcastable to a common shape (which may be the shape of one <span class="keyword">or</span></span><br><span class="line">    the other).</span><br><span class="line">out : ndarray, <span class="literal">None</span>, <span class="keyword">or</span> tuple of ndarray <span class="keyword">and</span> <span class="literal">None</span>, optional</span><br><span class="line">    A location into which the result <span class="keyword">is</span> stored. If provided, it must have</span><br><span class="line">    a shape that the inputs broadcast to. If <span class="keyword">not</span> provided <span class="keyword">or</span> `<span class="literal">None</span>`,</span><br><span class="line">    a freshly-allocated array <span class="keyword">is</span> returned. A tuple (possible only <span class="keyword">as</span> a</span><br><span class="line">    keyword argument) must have length equal to the number of outputs.</span><br><span class="line">where : array_like, optional</span><br><span class="line">    Values of <span class="literal">True</span> indicate to calculate the ufunc at that position, values</span><br><span class="line">    of <span class="literal">False</span> indicate to leave the value <span class="keyword">in</span> the output alone.</span><br><span class="line">**kwargs</span><br><span class="line">    For other keyword-only arguments, see the</span><br><span class="line">    :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span><br><span class="line"></span><br><span class="line">Returns</span><br><span class="line">-------</span><br><span class="line">add : ndarray <span class="keyword">or</span> scalar</span><br><span class="line">    The sum of `x1` <span class="keyword">and</span> `x2`, element-wise.</span><br><span class="line">    This <span class="keyword">is</span> a scalar <span class="keyword">if</span> both `x1` <span class="keyword">and</span> `x2` are scalars.</span><br></pre></td></tr></table></figure></li><li><p>创建一个长度为<code>10</code>并且除了第五个值为<code>1</code>的空向量 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Z = np.zeros(<span class="number">10</span>)</span><br><span class="line">Z[<span class="number">4</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Z</span><br><span class="line">结果：</span><br><span class="line">array([<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>])</span><br></pre></td></tr></table></figure></li><li><p>创建一个值域范围从<code>10</code>到<code>49</code>的向量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Z = np.arange(<span class="number">10</span>, <span class="number">50</span>)</span><br><span class="line">Z</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>,</span><br><span class="line">       <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>, <span class="number">36</span>, <span class="number">37</span>, <span class="number">38</span>, <span class="number">39</span>, <span class="number">40</span>, <span class="number">41</span>, <span class="number">42</span>, <span class="number">43</span>,</span><br><span class="line">       <span class="number">44</span>, <span class="number">45</span>, <span class="number">46</span>, <span class="number">47</span>, <span class="number">48</span>, <span class="number">49</span>])</span><br></pre></td></tr></table></figure></li><li><p>反转一个向量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Z = np.arange(<span class="number">50</span>)</span><br><span class="line">Z = Z[::<span class="number">-1</span>]</span><br><span class="line">Z</span><br><span class="line">‘’‘</span><br><span class="line">解释：</span><br><span class="line">np.array[起点:终点:步长]</span><br><span class="line">若起点终点未给出则自动设为最小值和最大值，步长为<span class="number">-1</span>则表示倒序</span><br><span class="line">‘’‘</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([<span class="number">49</span>, <span class="number">48</span>, <span class="number">47</span>, <span class="number">46</span>, <span class="number">45</span>, <span class="number">44</span>, <span class="number">43</span>, <span class="number">42</span>, <span class="number">41</span>, <span class="number">40</span>, <span class="number">39</span>, <span class="number">38</span>, <span class="number">37</span>, <span class="number">36</span>, <span class="number">35</span>, <span class="number">34</span>, <span class="number">33</span>,</span><br><span class="line">       <span class="number">32</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">29</span>, <span class="number">28</span>, <span class="number">27</span>, <span class="number">26</span>, <span class="number">25</span>, <span class="number">24</span>, <span class="number">23</span>, <span class="number">22</span>, <span class="number">21</span>, <span class="number">20</span>, <span class="number">19</span>, <span class="number">18</span>, <span class="number">17</span>, <span class="number">16</span>,</span><br><span class="line">       <span class="number">15</span>, <span class="number">14</span>, <span class="number">13</span>, <span class="number">12</span>, <span class="number">11</span>, <span class="number">10</span>,  <span class="number">9</span>,  <span class="number">8</span>,  <span class="number">7</span>,  <span class="number">6</span>,  <span class="number">5</span>,  <span class="number">4</span>,  <span class="number">3</span>,  <span class="number">2</span>,  <span class="number">1</span>,  <span class="number">0</span>])</span><br></pre></td></tr></table></figure></li><li><p>创建一个<code>3*3</code>并且值从<code>0</code>到<code>8</code>的矩阵</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以先创建0~8的一维矩阵，再利用reshape()函数调整矩阵形状</span></span><br><span class="line">Z = np.arange(<span class="number">9</span>).reshape(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">Z</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">       [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]])</span><br></pre></td></tr></table></figure></li><li><p>找到数组<code>[1, 2, 0, 0, 4, 0]</code>中非<code>0</code>元素的位置索引</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用nonzero()函数，可返回非0元素索引</span></span><br><span class="line">z = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>])</span><br><span class="line">nz = np.nonzero(z)</span><br><span class="line">print(nz)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure></li><li><p>创建<code>3*3</code>的单位矩阵</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用函数eye()创建单位矩阵</span></span><br><span class="line">Z = np.eye(<span class="number">3</span>)</span><br><span class="line">Z</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line"> [<span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>],</span><br><span class="line"> [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>]]</span><br></pre></td></tr></table></figure></li><li><p>创建一个<code>3*3*3</code>的随机矩阵</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用random()函数创建随机矩阵</span></span><br><span class="line">Z = np.random.random((<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line">Z</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([[[<span class="number">0.46112045</span>, <span class="number">0.8449696</span> , <span class="number">0.93452669</span>],</span><br><span class="line">        [<span class="number">0.40335357</span>, <span class="number">0.19589526</span>, <span class="number">0.06190673</span>],</span><br><span class="line">        [<span class="number">0.59191213</span>, <span class="number">0.5485013</span> , <span class="number">0.04418769</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">0.19128822</span>, <span class="number">0.87667495</span>, <span class="number">0.52180477</span>],</span><br><span class="line">        [<span class="number">0.20406144</span>, <span class="number">0.24655701</span>, <span class="number">0.5104405</span> ],</span><br><span class="line">        [<span class="number">0.10757664</span>, <span class="number">0.29771709</span>, <span class="number">0.03340503</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">0.18824317</span>, <span class="number">0.70162351</span>, <span class="number">0.98969992</span>],</span><br><span class="line">        [<span class="number">0.05169308</span>, <span class="number">0.10910609</span>, <span class="number">0.26606144</span>],</span><br><span class="line">        [<span class="number">0.16278269</span>, <span class="number">0.4546617</span> , <span class="number">0.86494887</span>]]])</span><br></pre></td></tr></table></figure></li><li><p>创建一个<code>10*10</code>的随机矩阵并找到矩阵中的最大值和最小值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用max()、min()函数获取矩阵中的极值</span></span><br><span class="line">Z = np.random.random((<span class="number">10</span>*<span class="number">10</span>))</span><br><span class="line">Zmin, Zmax = Z.min(), Z.max()</span><br><span class="line">Zmin</span><br><span class="line">Zmax</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"><span class="number">0.0018839812664321887</span></span><br><span class="line"><span class="number">0.9990252431012059</span></span><br></pre></td></tr></table></figure></li><li><p>创建一个长度为<code>30</code>的随机向量并找到它的平均值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用random()创建随机向量，使用mean()计算平均值</span></span><br><span class="line">Z = np.random.random(<span class="number">30</span>)</span><br><span class="line">m = Z.mean()</span><br><span class="line">Z</span><br><span class="line">m</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([<span class="number">0.65300995</span>, <span class="number">0.20141719</span>, <span class="number">0.14618305</span>, <span class="number">0.04388761</span>, <span class="number">0.11318013</span>,</span><br><span class="line">       <span class="number">0.69235091</span>, <span class="number">0.21181151</span>, <span class="number">0.57945835</span>, <span class="number">0.65998752</span>, <span class="number">0.53460023</span>,</span><br><span class="line">       <span class="number">0.73048382</span>, <span class="number">0.06537182</span>, <span class="number">0.09899469</span>, <span class="number">0.24646227</span>, <span class="number">0.1852686</span> ,</span><br><span class="line">       <span class="number">0.39034113</span>, <span class="number">0.83176693</span>, <span class="number">0.61448157</span>, <span class="number">0.50298701</span>, <span class="number">0.67282915</span>,</span><br><span class="line">       <span class="number">0.59650845</span>, <span class="number">0.22505482</span>, <span class="number">0.69479162</span>, <span class="number">0.62462672</span>, <span class="number">0.24771051</span>,</span><br><span class="line">       <span class="number">0.17731379</span>, <span class="number">0.8212477</span> , <span class="number">0.00564217</span>, <span class="number">0.21590246</span>, <span class="number">0.69027938</span>])</span><br><span class="line"></span><br><span class="line"><span class="number">0.41579836854559904</span></span><br></pre></td></tr></table></figure></li><li><p>创建一个二维数组，其中边界值为<code>1</code>，其余值为<code>0</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个全为1的数组，再将中间的数字改为0</span></span><br><span class="line">Z = np.ones((<span class="number">10</span>, <span class="number">10</span>))</span><br><span class="line">Z[<span class="number">1</span>:<span class="number">-1</span>,<span class="number">1</span>:<span class="number">-1</span>] = <span class="number">0</span></span><br><span class="line">Z</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([[<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>]])</span><br></pre></td></tr></table></figure></li><li><p>对于一个存在在数组，如何添加一个用0填充的边界?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用pad(array, pad_width, mode, **kwargs)填充矩阵边界</span></span><br><span class="line">Z = np.ones((<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">Z = np.pad(Z, pad_width=<span class="number">1</span>, mode=<span class="string">'constant'</span>, constant_values=<span class="number">0</span>)</span><br><span class="line">print(Z)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[[<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]]</span><br><span class="line"></span><br><span class="line">Z = np.pad(Z, pad_width=<span class="number">2</span>, mode=<span class="string">'constant'</span>, constant_values=<span class="number">0</span>)</span><br><span class="line">Z</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>]])</span><br></pre></td></tr></table></figure></li></ol><ol start="17"><li><p>以下表达式运行的结果分别是什么?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># NaN: not a number, inf: infinity</span></span><br><span class="line"><span class="number">0</span>*np.nan</span><br><span class="line">结果：</span><br><span class="line">nan</span><br><span class="line"></span><br><span class="line">np.nan == np.nan</span><br><span class="line">结果：</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line">np.nan <span class="keyword">is</span> np.nan</span><br><span class="line">结果：</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line">np.inf &gt; np.nan</span><br><span class="line">结果：</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line">np.nan-np.nan</span><br><span class="line">结果：</span><br><span class="line">nan</span><br><span class="line"></span><br><span class="line"><span class="number">0.3</span> == <span class="number">3</span>*<span class="number">0.1</span></span><br><span class="line">结果：</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure></li><li><p>创建一个<code>5x5</code>的矩阵，并设置值<code>1,2,3,4</code>落在其对角线下方位置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用diag(v, k=0)函数创建对角阵</span></span><br><span class="line"><span class="comment"># v是对角线元素</span></span><br><span class="line"><span class="comment"># k默认为0.k&gt;0则对角线之上，k&lt;0则对角线之下</span></span><br><span class="line">Z = np.diag(<span class="number">1</span>+np.arange(<span class="number">4</span>), k=<span class="number">-1</span>)</span><br><span class="line">Z</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>]])</span><br></pre></td></tr></table></figure></li></ol><ol start="19"><li><p>创建一个<code>8x8</code>的矩阵，并且设置成棋盘样式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用zeros()先创建0矩阵，再填充为1的位置</span></span><br><span class="line">Z = np.zeros((<span class="number">8</span>, <span class="number">8</span>), dtype=int)</span><br><span class="line">Z[<span class="number">1</span>::<span class="number">2</span>,::<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">Z[::<span class="number">2</span>, <span class="number">1</span>::<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">Z</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]])</span><br></pre></td></tr></table></figure></li></ol><ol start="20"><li><p>考虑一个 <code>(6,7,8)</code> 形状的数组，其第100个元素的索引<code>(x,y,z)</code>是什么?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用unravel_index(num,array.shape)求指定形状的矩阵中第num个元素的索引</span></span><br><span class="line">print(np.unravel_index(<span class="number">100</span>, (<span class="number">6</span>, <span class="number">7</span> ,<span class="number">8</span>)))</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">(<span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure></li></ol><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python之lambda匿名函数</title>
      <link href="/passages/python-zhi-lambda-ni-ming-han-shu/"/>
      <url>/passages/python-zhi-lambda-ni-ming-han-shu/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><ul><li>什么是匿名函数？</li></ul><p>匿名函数，顾名思义就是具体的函数名但是有函数功能的函数或子程序。lambda函数可以接收任意多个参数并且返回单个表达式的值。</p><ul><li>为什么要使用匿名函数？</li></ul><p>在函数功能不是很复杂的情况下，如果不想去费神命名一个函数时，可以使用匿名函数。也就是说匿名函数可以使代码变得更简洁，但是相对应的会增加阅读代码时的难度，所以不要盲目的使用匿名函数。</p><ul><li><p>使用ambda定义匿名函数有什么要注意的？</p><ul><li>lambda函数不能包含命令</li><li>包含的表达式不能超过一个</li></ul></li><li><p>使用lambda定义匿名函数的格式？</p></li></ul><p>lambda 参数列表 : 表达式</p><ul><li>使用lambda定义匿名函数和常规函数定义的区别？</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 常规函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用lambda定义</span></span><br><span class="line">add = <span class="keyword">lambda</span> x, y : x + y</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><ul><li>lambda的用法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 将<span class="keyword">lambda</span>函数赋值给一个变量，通过这个变量简洁调用<span class="keyword">lambda</span>函数</span><br><span class="line">add = <span class="keyword">lambda</span> x, y : x + y</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 将<span class="keyword">lambda</span>函数赋值给其他函数，从而将其他函数用该<span class="keyword">lambda</span>函数替换</span><br><span class="line"><span class="comment"># 例如对标准库中的函数time.sleep，可以使用lambda将其覆盖掉，下一次调用sleep的使用就是定义的lambda函数的内容了</span></span><br><span class="line">time.sleep = <span class="keyword">lambda</span> x:<span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 将<span class="keyword">lambda</span>函数作为其他函数的返回值</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x, y : x + y</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 将<span class="keyword">lambda</span>函数作为参数传递给其他函数</span><br><span class="line"><span class="comment"># 部分Python内置函数接收函数作为参数，例如：</span></span><br><span class="line">filter函数</span><br><span class="line">sorted函数</span><br><span class="line">map函数</span><br><span class="line">reduce函数</span><br></pre></td></tr></table></figure><ul><li>另外，lambda是Python的关键字，Python的关键字还有：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> keyword</span><br><span class="line">keyword.kwlist</span><br><span class="line"></span><br><span class="line">[<span class="string">'False'</span>, <span class="string">'None'</span>, <span class="string">'True'</span>, <span class="string">'and'</span>, <span class="string">'as'</span>, <span class="string">'assert'</span>, <span class="string">'break'</span>, <span class="string">'class'</span>, <span class="string">'continue'</span>, <span class="string">'def'</span>, <span class="string">'del'</span>, <span class="string">'elif'</span>, <span class="string">'else'</span>, <span class="string">'except'</span>, <span class="string">'finally'</span>, <span class="string">'for'</span>, <span class="string">'from'</span>, <span class="string">'global'</span>, <span class="string">'if'</span>, <span class="string">'import'</span>, <span class="string">'in'</span>, <span class="string">'is'</span>, <span class="string">'lambda'</span>, <span class="string">'nonlocal'</span>, <span class="string">'not'</span>, <span class="string">'or'</span>, <span class="string">'pass'</span>, <span class="string">'raise'</span>, <span class="string">'return'</span>, <span class="string">'try'</span>, <span class="string">'while'</span>, <span class="string">'with'</span>, <span class="string">'yield'</span>]</span><br></pre></td></tr></table></figure><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Numpy学习笔记（进阶）</title>
      <link href="/passages/numpy-xue-xi-bi-ji-jin-jie/"/>
      <url>/passages/numpy-xue-xi-bi-ji-jin-jie/</url>
      
        <content type="html"><![CDATA[<p>学习笔记</p><p>参考资料：Numpy官方文档</p><a id="more"></a><h3 id="进阶操作"><a href="#进阶操作" class="headerlink" title="进阶操作"></a>进阶操作</h3><h4 id="广播法则"><a href="#广播法则" class="headerlink" title="广播法则"></a>广播法则</h4><ul><li>使用广播法则能使通用函数处理不具有相同形状的输入<ul><li>广播第一法则：如果所有的输入数组维度均不相同，会填充<code>1</code>在较小维度的数组上，使所有的数组拥有一样的维度。</li><li>广播第二法则：确定长度为1的数组沿着特殊的方向表现的好像它有沿着该方向最大形状的大小。对于数组来说，沿着该维度的数组元素的值理应相同。</li><li>应用了广播法则之后，所有的数组的大小就会匹配了。</li></ul></li></ul><h4 id="索引技巧"><a href="#索引技巧" class="headerlink" title="索引技巧"></a>索引技巧</h4><ul><li><p>除了Python本身提供的索引整数和切片，数组还可以被整数数组和布尔数组索引。</p></li><li><p>通过数组索引，例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建数组</span></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line">a = arange(<span class="number">12</span>)**<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用一维数组索引，得到的结果也是一维数组</span></span><br><span class="line">i = array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">5</span>])</span><br><span class="line">a[i]</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([ <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">9</span>, <span class="number">64</span>, <span class="number">25</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用二维数组索引，得到的结果也是二维数组</span></span><br><span class="line">j = array([[<span class="number">3</span>, <span class="number">4</span>], [<span class="number">9</span>, <span class="number">7</span>]])</span><br><span class="line">a[j]</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([[ <span class="number">9</span>, <span class="number">16</span>],</span><br><span class="line">       [<span class="number">81</span>, <span class="number">49</span>]])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 若被索引的数组是多维时，每个索引数列指向a的第一维</span></span><br><span class="line"><span class="comment"># 在这里，每个索引数列中的元素指定其中的一行</span></span><br><span class="line">palette = array( [ [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],                </span><br><span class="line">                   [<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>],              </span><br><span class="line">                   [<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>],              </span><br><span class="line">                   [<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>],              </span><br><span class="line">                   [<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>] ] )       </span><br><span class="line">image = array( [ [ <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span> ],          </span><br><span class="line">                 [ <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span> ]  ] )</span><br><span class="line">palette[image]    </span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([[[  <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>],</span><br><span class="line">        [<span class="number">255</span>,   <span class="number">0</span>,   <span class="number">0</span>],</span><br><span class="line">        [  <span class="number">0</span>, <span class="number">255</span>,   <span class="number">0</span>],</span><br><span class="line">        [  <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>]],</span><br><span class="line"></span><br><span class="line">       [[  <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>],</span><br><span class="line">        [  <span class="number">0</span>,   <span class="number">0</span>, <span class="number">255</span>],</span><br><span class="line">        [<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>],</span><br><span class="line">        [  <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>]]])</span><br></pre></td></tr></table></figure></li><li><p>索引可以不止一维，但每一维的索引数组形状需要相同</p></li><li><p>例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建数组</span></span><br><span class="line">a = arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">a</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多维索引</span></span><br><span class="line">i = array([[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">2</span>]])</span><br><span class="line">j = array([[<span class="number">2</span>, <span class="number">1</span>], [<span class="number">3</span>, <span class="number">3</span>]])</span><br><span class="line">a[i, j]</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([[ <span class="number">2</span>,  <span class="number">5</span>],</span><br><span class="line">       [ <span class="number">7</span>, <span class="number">11</span>]])</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">得到的是a[0, 2],a[1, 1], a[1, 3], a[2, 3],</span></span><br><span class="line"><span class="string">且两个为一组</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">a[i, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([[ <span class="number">2</span>,  <span class="number">6</span>],</span><br><span class="line">       [ <span class="number">6</span>, <span class="number">10</span>]])</span><br><span class="line"></span><br><span class="line">a[:, j]</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([[[ <span class="number">2</span>,  <span class="number">1</span>],</span><br><span class="line">        [ <span class="number">3</span>,  <span class="number">3</span>]],</span><br><span class="line"></span><br><span class="line">       [[ <span class="number">6</span>,  <span class="number">5</span>],</span><br><span class="line">        [ <span class="number">7</span>,  <span class="number">7</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">10</span>,  <span class="number">9</span>],</span><br><span class="line">        [<span class="number">11</span>, <span class="number">11</span>]]])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以借助列表先将两个索引组合起来，使用列表进行索引</span></span><br><span class="line">l = [i, j]</span><br><span class="line">a[l]</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([[ <span class="number">2</span>,  <span class="number">5</span>],</span><br><span class="line">       [ <span class="number">7</span>, <span class="number">11</span>]])</span><br><span class="line"><span class="comment"># 这里不能使用数组将i，j组合起来，因为外层数组会被当作索引的第一维，报错或得到的结果不正确</span></span><br></pre></td></tr></table></figure></li><li><p>使用数组索引作为目标来赋值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建数组</span></span><br><span class="line">a = arange(<span class="number">5</span>)</span><br><span class="line">a</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">a[[<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>]] = <span class="number">0</span></span><br><span class="line">a</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line"><span class="comment"># 多次赋值以最后一次赋值为结果</span></span><br></pre></td></tr></table></figure></li><li><p>通过布尔数组索引</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建数组</span></span><br><span class="line">a = arange(<span class="number">12</span>).reshape(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">b = a &gt; <span class="number">4</span></span><br><span class="line">b</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([[<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>],</span><br><span class="line">       [<span class="literal">False</span>,  <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>],</span><br><span class="line">       [ <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>]], dtype=bool)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际上是返回所有为True的位置的元素值</span></span><br><span class="line">a[b]</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([ <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此功能可用于赋值，比如，将a中所有大于4的值赋值为0</span></span><br><span class="line">b = a &gt; <span class="number">4</span></span><br><span class="line">a[b] = <span class="number">0</span></span><br><span class="line">a</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对每一个维度给一个一维布尔数组来选择我们想要的切片</span></span><br><span class="line">a = arange(<span class="number">12</span>).reshape(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">b1 = array([<span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">True</span>])</span><br><span class="line">b2 = array([<span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">False</span>])</span><br><span class="line">a[b1, :]</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([[ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"></span><br><span class="line">a[b1]</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([[ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a[:, b2]</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">2</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">6</span>],</span><br><span class="line">       [ <span class="number">8</span>, <span class="number">10</span>]])</span><br><span class="line"></span><br><span class="line">a[b1,b2]                                  </span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([ <span class="number">4</span>, <span class="number">10</span>])</span><br></pre></td></tr></table></figure></li><li><p>注意：<strong>一维数组的长度必须和想要切片的维度或轴的长度一致</strong>，前面的例子中，<code>b1</code>是一个秩为1长度为三的数组(a的行数)，<code>b2</code>(长度为4)与a的第二秩(列)相一致</p></li></ul><h4 id="ix-函数"><a href="#ix-函数" class="headerlink" title="ix_()函数"></a>ix_()函数</h4><ul><li><p><code>ix_()</code>函数可以组合不同向量以得到多元组的结果，例如使用向量a、b、c组成的三元组来计算<code>a+b*c</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建向量</span></span><br><span class="line">a = array([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">b = array([<span class="number">8</span>, <span class="number">5</span>, <span class="number">4</span>])</span><br><span class="line">c = array([<span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">3</span>])</span><br><span class="line">ax, bx, cx = ix_(a, b, c)</span><br><span class="line"></span><br><span class="line">ax</span><br><span class="line">bx</span><br><span class="line">cx</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"><span class="comment"># 从形式上来看转化了向量的形状，使之符合计算的需求</span></span><br><span class="line">array([[[<span class="number">2</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">3</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">4</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">5</span>]]])</span><br><span class="line"></span><br><span class="line">array([[[<span class="number">8</span>],</span><br><span class="line">        [<span class="number">5</span>],</span><br><span class="line">        [<span class="number">4</span>]]])</span><br><span class="line"></span><br><span class="line">array([[[<span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">3</span>]]])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ax.shape</span><br><span class="line">bx.shape</span><br><span class="line">cx.shape</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">(<span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">result = ax + bx * cx</span><br><span class="line">result</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([[[<span class="number">42</span>, <span class="number">34</span>, <span class="number">50</span>, <span class="number">66</span>, <span class="number">26</span>],</span><br><span class="line">        [<span class="number">27</span>, <span class="number">22</span>, <span class="number">32</span>, <span class="number">42</span>, <span class="number">17</span>],</span><br><span class="line">        [<span class="number">22</span>, <span class="number">18</span>, <span class="number">26</span>, <span class="number">34</span>, <span class="number">14</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">43</span>, <span class="number">35</span>, <span class="number">51</span>, <span class="number">67</span>, <span class="number">27</span>],</span><br><span class="line">        [<span class="number">28</span>, <span class="number">23</span>, <span class="number">33</span>, <span class="number">43</span>, <span class="number">18</span>],</span><br><span class="line">        [<span class="number">23</span>, <span class="number">19</span>, <span class="number">27</span>, <span class="number">35</span>, <span class="number">15</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">44</span>, <span class="number">36</span>, <span class="number">52</span>, <span class="number">68</span>, <span class="number">28</span>],</span><br><span class="line">        [<span class="number">29</span>, <span class="number">24</span>, <span class="number">34</span>, <span class="number">44</span>, <span class="number">19</span>],</span><br><span class="line">        [<span class="number">24</span>, <span class="number">20</span>, <span class="number">28</span>, <span class="number">36</span>, <span class="number">16</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">45</span>, <span class="number">37</span>, <span class="number">53</span>, <span class="number">69</span>, <span class="number">29</span>],</span><br><span class="line">        [<span class="number">30</span>, <span class="number">25</span>, <span class="number">35</span>, <span class="number">45</span>, <span class="number">20</span>],</span><br><span class="line">        [<span class="number">25</span>, <span class="number">21</span>, <span class="number">29</span>, <span class="number">37</span>, <span class="number">17</span>]]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取结果中的一个元素</span></span><br><span class="line">result[<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"><span class="number">17</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用向量中的一个值进行计算</span></span><br><span class="line">a[<span class="number">3</span>] + b[<span class="number">2</span>] * c[<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"><span class="number">4</span> + <span class="number">5</span> * <span class="number">3</span> = <span class="number">17</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h4><ul><li><p>数组运算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入数组计算的的包和函数</span></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> numpy.linalg <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数组</span></span><br><span class="line">a = array([[<span class="number">1.0</span>, <span class="number">2.0</span>], [<span class="number">3.0</span>, <span class="number">4.0</span>]])</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[[ <span class="number">1.</span>  <span class="number">2.</span>]</span><br><span class="line"> [ <span class="number">3.</span>  <span class="number">4.</span>]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 求转置</span></span><br><span class="line">a.transpose()</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([[ <span class="number">1.</span>,  <span class="number">3.</span>],</span><br><span class="line">       [ <span class="number">2.</span>,  <span class="number">4.</span>]])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 求逆矩阵</span></span><br><span class="line">inv(a)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([[<span class="number">-2.</span> ,  <span class="number">1.</span> ],</span><br><span class="line">       [ <span class="number">1.5</span>, <span class="number">-0.5</span>]])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成对角矩阵</span></span><br><span class="line">u = eye(<span class="number">2</span>)<span class="comment"># 2*2</span></span><br><span class="line">u</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([[<span class="number">1.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">1.</span>]])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 求点积</span></span><br><span class="line">j = array([[<span class="number">0.0</span>, <span class="number">-1.0</span>], [<span class="number">1.0</span>, <span class="number">0.0</span>]])</span><br><span class="line">dot (j, j)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([[<span class="number">-1.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">0.</span>, <span class="number">-1.</span>]])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 求矩阵的迹（特征值之和）</span></span><br><span class="line">trace(u)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"><span class="number">2.0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 求解线性矩阵方程</span></span><br><span class="line">y = array([[<span class="number">5.</span>], [<span class="number">7.</span>]])</span><br><span class="line">solve(a, y)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([[<span class="number">-3.</span>],</span><br><span class="line">       [ <span class="number">4.</span>]])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算矩阵特征值、特征向量</span></span><br><span class="line">eig(j)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">(array([ <span class="number">0.</span>+<span class="number">1.j</span>,  <span class="number">0.</span><span class="number">-1.j</span>]),</span><br><span class="line"> array([[ <span class="number">0.70710678</span>+<span class="number">0.j</span>        ,  <span class="number">0.70710678</span><span class="number">-0.j</span>        ],</span><br><span class="line">        [ <span class="number">0.00000000</span><span class="number">-0.70710678j</span>,  <span class="number">0.00000000</span>+<span class="number">0.70710678j</span>]]))</span><br></pre></td></tr></table></figure></li><li><p>矩阵类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建矩阵</span></span><br><span class="line">A = matrix(<span class="string">'1.0 2.0; 3.0 4.0'</span>)</span><br><span class="line">A</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">matrix([[ <span class="number">1.</span>,  <span class="number">2.</span>],</span><br><span class="line">        [ <span class="number">3.</span>,  <span class="number">4.</span>]])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断类型</span></span><br><span class="line">type(A)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">numpy.matrixlib.defmatrix.matrix</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 求矩阵的转置</span></span><br><span class="line">A.T</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">matrix([[ <span class="number">1.</span>,  <span class="number">3.</span>],</span><br><span class="line">        [ <span class="number">2.</span>,  <span class="number">4.</span>]])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">X = matrix(<span class="string">'5.0 7.0'</span>)</span><br><span class="line">Y = X.T</span><br><span class="line">Y</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">matrix([[ <span class="number">5.</span>],</span><br><span class="line">        [ <span class="number">7.</span>]])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 矩阵相乘</span></span><br><span class="line">print(A*Y)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[[ <span class="number">19.</span>]</span><br><span class="line"> [ <span class="number">43.</span>]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 求逆矩阵</span></span><br><span class="line">print(A.I)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[[<span class="number">-2.</span>   <span class="number">1.</span> ]</span><br><span class="line"> [ <span class="number">1.5</span> <span class="number">-0.5</span>]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 求解线性矩阵方程</span></span><br><span class="line">solve(A, Y)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">matrix([[<span class="number">-3.</span>],</span><br><span class="line">        [ <span class="number">4.</span>]])</span><br></pre></td></tr></table></figure></li><li><p><strong>注意</strong></p><ul><li><code>Numpy</code>的两个基本对象：N维数组对象，通用函数对象</li><li>矩阵继承自数组对象的二维数组对象</li></ul></li><li><p>直方图</p><ul><li>可以使用<code>histogram</code>函数应用到一个数组会返回：直方图数组和箱式向量</li><li>注意这里只返回数据，并直接绘制出具体的图形</li></ul></li></ul><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Numpy学习笔记（基础）</title>
      <link href="/passages/numpy-xue-xi-bi-ji-ji-chu/"/>
      <url>/passages/numpy-xue-xi-bi-ji-ji-chu/</url>
      
        <content type="html"><![CDATA[<p>笔记</p><p>学习笔记</p><p>参考资料：Numpy官方文档</p><a id="more"></a><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ul><li><p><code>Numpy</code>是用来处理多维数组的工具，在<code>Numpy</code>中，维度叫做轴，轴的个数叫做秩。</p><ul><li>例如，<code>[1, 2, 3]</code>是一个秩为1的数组，因为它只有一个维度，即一个轴。轴的长度为3.</li><li>而<code>[[1, 0, 0], [0, 1, 2]]</code>的秩为2，即两个轴。第一个轴的长度为2，第二个轴的长度为3。</li></ul></li><li><p><code>Numpy</code>的数组类叫做<code>ndarray</code>，可以处理多维的数组。需要注意的是<code>numpy.array</code>和<code>array.array</code>,后者只能处理简单的一维数组。ndarray的对象属性有：</p><ul><li><p><code>ndarray.ndim</code>：数组轴的个数，即秩。</p></li><li><p><code>ndarray.shape</code>：数组在每一个维度上大小的维度，是一个元组，例如：一个n排m列的数组的shape是<code>(n, m)</code>，这个元组的长度是秩，因为这个数组只有两个轴。</p></li><li><p><code>ndarray.size</code>：数组元素的总和，等于shape属性元组中元素的乘积。</p></li><li><p><code>ndarray.dtype</code>：数组中元素类型。注意一个数组中的元素类型是统一的。</p></li><li><p><code>ndarray.itemsize</code>：元素的字节大小。</p></li><li><p><code>ndarray.data</code>：包含实际数组元素的缓冲区。</p></li><li><p>例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># 创建一个长为15且内容为0~14的数组，并转化成3*5的数组</span></span><br><span class="line">a = arange(<span class="number">15</span>).reshape(<span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'a.ndim is '</span>,a.ndim)</span><br><span class="line">print(<span class="string">'a.dtype is '</span>, a.dtype)</span><br><span class="line">print(<span class="string">'a.shape is '</span>, a.shape)</span><br><span class="line">print(<span class="string">'a.itemsize is '</span>, a.itemsize)</span><br><span class="line">print(<span class="string">'a.size is '</span>, a.size)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>]</span><br><span class="line"> [ <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>]</span><br><span class="line"> [<span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span>]]</span><br><span class="line"> </span><br><span class="line">a.ndim <span class="keyword">is</span>  <span class="number">2</span></span><br><span class="line">a.dtype <span class="keyword">is</span>  int32</span><br><span class="line">a.shape <span class="keyword">is</span>  (<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">a.itemsize <span class="keyword">is</span>  <span class="number">4</span></span><br><span class="line">a.size <span class="keyword">is</span>  <span class="number">15</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h4><ul><li>使用<code>array()</code>函数将常规的Python列表和元组转化为数组，数组类型可在创建时指定</li><li>例子：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line">        </span><br><span class="line">a = array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">或</span><br><span class="line">b = array((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">或</span><br><span class="line">c = array([(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)])</span><br></pre></td></tr></table></figure><ul><li>使用可用于创建指定数组的函数，数组类型可在创建时指定</li><li>例子：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建全为0的指定形式的数组</span></span><br><span class="line">zeros((<span class="number">3</span>, <span class="number">5</span>))</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 创建全为1的指定形式和类型的数组</span></span><br><span class="line">ones((<span class="number">3</span>, <span class="number">4</span>,), dtype=int32)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 创建内容随机的指定形式的数组</span></span><br><span class="line">empty((<span class="number">4</span>, <span class="number">3</span>))</span><br><span class="line">        </span><br><span class="line"><span class="comment"># arange()函数，返回的是数组而非列表</span></span><br><span class="line">arange(<span class="number">10</span>, <span class="number">40</span>, <span class="number">6</span>)</span><br><span class="line">        </span><br><span class="line">random.random((<span class="number">2</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure><h4 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h4><ul><li>数组间的运算是按照元素来进行的，将结果存入新的数组</li><li>例子：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line">a = array([(<span class="number">2</span>, <span class="number">4</span>), (<span class="number">6</span>, <span class="number">8</span>)])</span><br><span class="line">b = arange(<span class="number">4</span>).reshape((<span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 对应元素值之差</span></span><br><span class="line">c = a - b</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br><span class="line">print(c)</span><br><span class="line">        </span><br><span class="line">结果：</span><br><span class="line">[[<span class="number">2</span> <span class="number">4</span>]</span><br><span class="line"> [<span class="number">6</span> <span class="number">8</span>]]</span><br><span class="line">        </span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">3</span>]] </span><br><span class="line">        </span><br><span class="line">[[<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span>]]</span><br><span class="line">        </span><br><span class="line"><span class="comment"># b^2</span></span><br><span class="line">b**<span class="number">2</span></span><br><span class="line">结果：</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">9</span>]], dtype=int32)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># sin(a)</span></span><br><span class="line">sin(a)</span><br><span class="line">结果：</span><br><span class="line">array([[ <span class="number">0.90929743</span>, <span class="number">-0.7568025</span> ],</span><br><span class="line">       [<span class="number">-0.2794155</span> ,  <span class="number">0.98935825</span>]])</span><br><span class="line"></span><br><span class="line"><span class="number">10</span>*sin(a)</span><br><span class="line">结果：</span><br><span class="line">array([[ <span class="number">9.09297427</span>, <span class="number">-7.56802495</span>],</span><br><span class="line">       [<span class="number">-2.79415498</span>,  <span class="number">9.89358247</span>]])</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 判断每个元素是否符合要求</span></span><br><span class="line">a &lt; <span class="number">3</span></span><br><span class="line">结果：</span><br><span class="line">array([[ <span class="literal">True</span>, <span class="literal">False</span>],</span><br><span class="line">       [<span class="literal">False</span>, <span class="literal">False</span>]])</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 3*a</span></span><br><span class="line">a *= <span class="number">3</span></span><br><span class="line">结果：</span><br><span class="line">[[<span class="number">4</span>, <span class="number">8</span>],</span><br><span class="line"> [<span class="number">12</span>, <span class="number">16</span>]]</span><br></pre></td></tr></table></figure><ul><li>注意矩阵乘法需要使用<code>dot()</code>函数或创建矩阵对象实现，<strong>直接相乘得到的是元素对应相乘</strong></li><li>例子：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 元素对应乘积</span></span><br><span class="line">a*b</span><br><span class="line">结果：</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">4</span>],</span><br><span class="line">       [<span class="number">12</span>, <span class="number">24</span>]])</span><br><span class="line">      </span><br><span class="line"><span class="comment"># 矩阵点乘</span></span><br><span class="line">dot(a, b)</span><br><span class="line">结果：</span><br><span class="line">array([[ <span class="number">8</span>, <span class="number">14</span>],</span><br><span class="line">       [<span class="number">16</span>, <span class="number">30</span>]])</span><br></pre></td></tr></table></figure><ul><li>若两个矩阵相加使用<code>+=</code>，则<strong>精度更精确</strong>的要作为接收的数组</li><li>用于计算的函数</li><li>例子：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># e^x</span></span><br><span class="line">d = exp(a*<span class="number">1j</span>)</span><br><span class="line">d</span><br><span class="line">结果：</span><br><span class="line">array([[<span class="number">-0.41614684</span>+<span class="number">0.90929743j</span>, <span class="number">-0.65364362</span><span class="number">-0.7568025j</span> ],</span><br><span class="line">       [ <span class="number">0.96017029</span><span class="number">-0.2794155j</span> , <span class="number">-0.14550003</span>+<span class="number">0.98935825j</span>]])</span><br><span class="line">             </span><br><span class="line">d.dtype.name</span><br><span class="line">      </span><br><span class="line">结果：</span><br><span class="line"><span class="string">'complex128'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数组中元素值之和</span></span><br><span class="line">a = random.random((<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">print(<span class="string">'the sum of a is '</span>, a.sum())</span><br><span class="line">​      </span><br><span class="line">结果：</span><br><span class="line">array([[<span class="number">0.89005106</span>, <span class="number">0.20091997</span>, <span class="number">0.35641668</span>],</span><br><span class="line">       [<span class="number">0.15765842</span>, <span class="number">0.16708008</span>, <span class="number">0.38590499</span>]])</span><br><span class="line">      </span><br><span class="line">the sum of a <span class="keyword">is</span> <span class="number">2.1580312015631193</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      </span><br><span class="line"><span class="comment"># 数组中元素的最大值</span></span><br><span class="line">a.max()</span><br><span class="line">     </span><br><span class="line">结果：</span><br><span class="line"><span class="number">0.8900510634052407</span></span><br><span class="line">      </span><br><span class="line"><span class="comment"># 按第一个坐标轴求最大值（每列中的最大值）</span></span><br><span class="line">a.max(axis=<span class="number">0</span>)</span><br><span class="line">      </span><br><span class="line">结果：</span><br><span class="line">array([<span class="number">0.89005106</span>, <span class="number">0.20091997</span>, <span class="number">0.38590499</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      </span><br><span class="line"><span class="comment"># 指定坐标轴进行计算</span></span><br><span class="line">b = arange(<span class="number">12</span>).reshape(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">b</span><br><span class="line">      </span><br><span class="line">print(<span class="string">'b.shape is '</span>, b.shape</span><br><span class="line"><span class="comment"># 按第一个坐标轴计算，即按列加和</span></span><br><span class="line">b.sum(axis=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 按第二个坐标轴计算，即按行加和</span></span><br><span class="line">b.sum(axis=<span class="number">1</span>)</span><br><span class="line">      </span><br><span class="line">结果：</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line">b.shape <span class="keyword">is</span> (<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">      </span><br><span class="line">array([<span class="number">12</span>, <span class="number">15</span>, <span class="number">18</span>, <span class="number">21</span>])</span><br><span class="line">      </span><br><span class="line">array([<span class="number">6</span>, <span class="number">22</span>, <span class="number">38</span>])</span><br><span class="line"></span><br><span class="line">           </span><br><span class="line"><span class="comment"># 求数组中的最小值</span></span><br><span class="line">print(<span class="string">'b.min is '</span>, b.min())</span><br><span class="line">print(<span class="string">'b.min in each row '</span>, b.min(axis=<span class="number">1</span>))</span><br><span class="line">      </span><br><span class="line">结果：</span><br><span class="line">b.min <span class="keyword">is</span> <span class="number">0</span></span><br><span class="line">b.min <span class="keyword">in</span> each row <span class="keyword">is</span> [<span class="number">0</span>, <span class="number">4</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      </span><br><span class="line"><span class="comment"># 矩阵累积和（顺序自矩阵中元素之和）</span></span><br><span class="line">b.cumsum()</span><br><span class="line">结果：</span><br><span class="line">array([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">3</span>,  <span class="number">6</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">21</span>, <span class="number">28</span>, <span class="number">36</span>, <span class="number">45</span>, <span class="number">55</span>, <span class="number">66</span>], dtype=int32)</span><br><span class="line">            </span><br><span class="line"><span class="comment"># 按行计算</span></span><br><span class="line">b.cumsum(axis=<span class="number">1</span>)</span><br><span class="line">结果：</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">3</span>,  <span class="number">6</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">9</span>, <span class="number">15</span>, <span class="number">22</span>],</span><br><span class="line">       [ <span class="number">8</span>, <span class="number">17</span>, <span class="number">27</span>, <span class="number">38</span>]], dtype=int32)</span><br><span class="line">      </span><br><span class="line"><span class="comment"># 按列计算</span></span><br><span class="line">b.cumsum(axis=<span class="number">0</span>)</span><br><span class="line">结果：</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">6</span>,  <span class="number">8</span>, <span class="number">10</span>],</span><br><span class="line">       [<span class="number">12</span>, <span class="number">15</span>, <span class="number">18</span>, <span class="number">21</span>]], dtype=int32)</span><br></pre></td></tr></table></figure><ul><li>通用函数</li><li>常见的有<code>sin()</code>，<code>cos()</code>，<code>exp()</code>等，作用于数组时按元素计算，返回结果仍是数组。</li><li>常见的有</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exp(A), sqrt(A), add(A, B), all(), alltrue(), any(), apply(), along axis(), argmax(), argmin(), argsort(), average(), bincount(), ceil(), clip(), conj(), conjugate(), corrcoef(), cov(), cross(), cumprod(), cumsum(), diff(), dot(), floor(), inner(), inv(), lexsort(), max(), maximum(), mean(), median(), min(), minimum(), nonzero(), outer(), prod(), re(), round(), sometrue(), sort(), std(), sum(), trace(), transpose(), var(), vdot(), vectorize(), where()</span><br></pre></td></tr></table></figure><ul><li>此类函数的使用详情请到官网查询<a href="https://numpy.org/" target="_blank" rel="noopener">官网</a></li><li>求逆矩阵：<code>np.linalg.inv(arr)</code></li><li>求行列式：<code>np.linalg.det(arr)</code></li><li>求特征值与特征向量：<code>e,v = np.linalg.eig(arr)</code></li><li></li></ul><h4 id="切片、索引和迭代"><a href="#切片、索引和迭代" class="headerlink" title="切片、索引和迭代"></a>切片、索引和迭代</h4><ul><li><p>一维数组可以被索引、切片和迭代，与列表和其他Python序列操作相同</p></li><li><p>例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 迭代</span></span><br><span class="line">a = arange(<span class="number">10</span>)**<span class="number">3</span></span><br><span class="line">a</span><br><span class="line"></span><br><span class="line">结果:</span><br><span class="line">array([  <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">8</span>,  <span class="number">27</span>,  <span class="number">64</span>, <span class="number">125</span>, <span class="number">216</span>, <span class="number">343</span>, <span class="number">512</span>, <span class="number">729</span>], dtype=int32)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据索引访问数组内容</span></span><br><span class="line">a[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"><span class="number">8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切片</span></span><br><span class="line">a[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([ <span class="number">8</span>, <span class="number">27</span>, <span class="number">64</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 前6个元素，每两个有一个设置为-1000</span></span><br><span class="line">a[:<span class="number">6</span>:<span class="number">2</span>] = <span class="number">-1000</span></span><br><span class="line">a</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([<span class="number">-1000</span>, <span class="number">1</span>, <span class="number">-1000</span>, <span class="number">27</span>, <span class="number">-1000</span>, <span class="number">125</span>, <span class="number">216</span>, <span class="number">242</span>, <span class="number">512</span>, <span class="number">729</span>], dtype=int32)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 逆置数组</span></span><br><span class="line">a[::<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([<span class="number">729</span>, <span class="number">512</span>, <span class="number">343</span>, <span class="number">216</span>, <span class="number">125</span>,  <span class="number">64</span>,  <span class="number">27</span>,   <span class="number">8</span>,   <span class="number">1</span>,   <span class="number">0</span>], dtype=int32)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历数组</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[  <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">8</span>,  <span class="number">27</span>,  <span class="number">64</span>, <span class="number">125</span>, <span class="number">216</span>, <span class="number">343</span>, <span class="number">512</span>, <span class="number">729</span>]</span><br></pre></td></tr></table></figure></li><li><p>多维数组可以每个轴有一个索引，这些索引由一个逗号分割的元素给出</p></li><li><p>例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用fromfunction创建数组</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    retuen <span class="number">10</span>*x + y</span><br><span class="line"><span class="comment"># f是函数，(5, 4)是数组的形状，得到的数组内容是下标在函数中经过计算得到的值</span></span><br><span class="line">b = fromfunction(f, (<span class="number">5</span>, <span class="number">4</span>), dtype=int)</span><br><span class="line">b</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>],</span><br><span class="line">       [<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>],</span><br><span class="line">       [<span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>],</span><br><span class="line">       [<span class="number">40</span>, <span class="number">41</span>, <span class="number">42</span>, <span class="number">43</span>]])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 索引访问数组内容</span></span><br><span class="line">b[<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"><span class="number">23</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对一个维度使用切片</span></span><br><span class="line"><span class="comment"># 读取第二列的内容</span></span><br><span class="line">b[:<span class="number">5</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([ <span class="number">1</span>, <span class="number">11</span>, <span class="number">21</span>, <span class="number">31</span>, <span class="number">41</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多个维度上使用切片</span></span><br><span class="line"><span class="comment"># 读取第2、3行</span></span><br><span class="line">b[<span class="number">1</span>:<span class="number">3</span>, :]</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([[<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>],</span><br><span class="line">       [<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>]])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 缺失的索引默认为全部</span></span><br><span class="line"><span class="comment"># 读取倒数第一行</span></span><br><span class="line">b[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([<span class="number">40</span>, <span class="number">41</span>, <span class="number">42</span>, <span class="number">43</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多维数组的迭代是以第一个轴为基准的</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> b:</span><br><span class="line">    print(row)</span><br><span class="line">    </span><br><span class="line">结果：</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line">[<span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span>]</span><br><span class="line">[<span class="number">20</span> <span class="number">21</span> <span class="number">22</span> <span class="number">23</span>]</span><br><span class="line">[<span class="number">30</span> <span class="number">31</span> <span class="number">32</span> <span class="number">33</span>]</span><br><span class="line">[<span class="number">40</span> <span class="number">41</span> <span class="number">42</span> <span class="number">43</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对数组中每个元素进行计算，使用flat(迭代器)</span></span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> b.flat:</span><br><span class="line">    print(element, end=<span class="string">','</span>)</span><br><span class="line">    </span><br><span class="line">结果：</span><br><span class="line"><span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">32</span>,<span class="number">33</span>,<span class="number">40</span>,<span class="number">41</span>,<span class="number">42</span>,<span class="number">43</span>,</span><br></pre></td></tr></table></figure></li></ul><h4 id="形状操作"><a href="#形状操作" class="headerlink" title="形状操作"></a>形状操作</h4><ul><li><p>改变数组形状，目标形状包含的元素个数要与原数组的元素个数相同</p></li><li><p>例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建数组</span></span><br><span class="line"><span class="comment"># floor()函数：向下取整</span></span><br><span class="line">a = floor(<span class="number">10</span>*random.random((<span class="number">3</span>, <span class="number">4</span>)))</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([[ <span class="number">6.</span>,  <span class="number">7.</span>,  <span class="number">4.</span>,  <span class="number">3.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">2.</span>,  <span class="number">6.</span>],</span><br><span class="line">       [ <span class="number">7.</span>,  <span class="number">7.</span>,  <span class="number">8.</span>,  <span class="number">6.</span>]])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 转化成一维数组</span></span><br><span class="line">a.reval()</span><br><span class="line">a</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([ <span class="number">6.</span>,  <span class="number">7.</span>,  <span class="number">4.</span>,  <span class="number">3.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">2.</span>,  <span class="number">6.</span>,  <span class="number">7.</span>,  <span class="number">7.</span>,  <span class="number">8.</span>,  <span class="number">6.</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改形状</span></span><br><span class="line"><span class="comment"># 转化成6*2,但不修改真正的数组内容</span></span><br><span class="line">a.reshape(<span class="number">6</span>, <span class="number">2</span>)</span><br><span class="line">结果：</span><br><span class="line">array([[<span class="number">6.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">5.</span>, <span class="number">5.</span>],</span><br><span class="line">       [<span class="number">5.</span>, <span class="number">6.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">3.</span>],</span><br><span class="line">       [<span class="number">4.</span>, <span class="number">7.</span>],</span><br><span class="line">       [<span class="number">6.</span>, <span class="number">4.</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用resize()直接修改数组本身</span></span><br><span class="line">a.resize((<span class="number">2</span>, <span class="number">6</span>))</span><br><span class="line">结果：</span><br><span class="line">array([[ <span class="number">6.</span>,  <span class="number">7.</span>,  <span class="number">4.</span>,  <span class="number">3.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">2.</span>,  <span class="number">6.</span>,  <span class="number">7.</span>,  <span class="number">7.</span>,  <span class="number">8.</span>,  <span class="number">6.</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转置</span></span><br><span class="line">a.shape = (<span class="number">6</span>, <span class="number">2</span>)</span><br><span class="line">a.transpace()</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([[ <span class="number">6.</span>,  <span class="number">4.</span>,  <span class="number">0.</span>,  <span class="number">2.</span>,  <span class="number">7.</span>,  <span class="number">8.</span>],</span><br><span class="line">       [ <span class="number">7.</span>,  <span class="number">3.</span>,  <span class="number">0.</span>,  <span class="number">6.</span>,  <span class="number">7.</span>,  <span class="number">6.</span>]])</span><br></pre></td></tr></table></figure></li></ul><h4 id="组合不同的数组（stack）"><a href="#组合不同的数组（stack）" class="headerlink" title="组合不同的数组（stack）"></a>组合不同的数组（stack）</h4><ul><li><p>可以沿不同轴将数组堆叠在一起</p></li><li><p>例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建数组</span></span><br><span class="line">a = floor(<span class="number">10</span>*random.random((<span class="number">2</span>, <span class="number">3</span>)))</span><br><span class="line">a</span><br><span class="line"></span><br><span class="line">b = floor*(<span class="number">10</span>*random.random(<span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line">b</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([[ <span class="number">1.</span>,  <span class="number">5.</span>],</span><br><span class="line">       [ <span class="number">6.</span>,  <span class="number">7.</span>]])</span><br><span class="line"></span><br><span class="line">array([[ <span class="number">5.</span>,  <span class="number">5.</span>],</span><br><span class="line">       [ <span class="number">4.</span>,  <span class="number">5.</span>]])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 组合</span></span><br><span class="line"><span class="comment"># 按行组合</span></span><br><span class="line">vstack((a, b))</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([[ <span class="number">1.</span>,  <span class="number">5.</span>],</span><br><span class="line">       [ <span class="number">6.</span>,  <span class="number">7.</span>],</span><br><span class="line">       [ <span class="number">5.</span>,  <span class="number">5.</span>],</span><br><span class="line">       [ <span class="number">4.</span>,  <span class="number">5.</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按列组合</span></span><br><span class="line">hstack((a, b))</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([[ <span class="number">1.</span>,  <span class="number">5.</span>,  <span class="number">5.</span>,  <span class="number">5.</span>],</span><br><span class="line">       [ <span class="number">6.</span>,  <span class="number">7.</span>,  <span class="number">4.</span>,  <span class="number">5.</span>]])</span><br></pre></td></tr></table></figure></li><li><p>另一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">a = array([<span class="number">4</span>, <span class="number">2</span>])</span><br><span class="line">b = array([<span class="number">2</span>, <span class="number">8</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># newaxis相当于创建了一个维度，这里是将a由1*2转化成2*1</span></span><br><span class="line"><span class="comment"># 可以用于从多维数组中取一列，但并不改变列的信息，不会取出来之后变成了一维数组</span></span><br><span class="line">a[:,newaxis]</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([[ <span class="number">4.</span>],</span><br><span class="line">       [ <span class="number">2.</span>]])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将两个一维数组组合起来</span></span><br><span class="line">column_stack((a[:, newaxis], b[:, newaxis]))</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([[ <span class="number">4.</span>,  <span class="number">2.</span>],</span><br><span class="line">       [ <span class="number">2.</span>,  <span class="number">8.</span>]])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vstack((a[:, newaxis], b[:, newaxis]))</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([[ <span class="number">4.</span>],</span><br><span class="line">       [ <span class="number">2.</span>],</span><br><span class="line">       [ <span class="number">2.</span>],</span><br><span class="line">       [ <span class="number">8.</span>]])</span><br></pre></td></tr></table></figure></li></ul><h4 id="将数组分割成几个小数组（split）"><a href="#将数组分割成几个小数组（split）" class="headerlink" title="将数组分割成几个小数组（split）"></a>将数组分割成几个小数组（split）</h4><ul><li><p>可以沿水平轴分割(<code>hsplit()</code>)，或者指定返回相同形状的数组的个数，或者指定在那些列之后进行分割</p></li><li><p>例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建数组</span></span><br><span class="line">a = floor(<span class="number">10</span>*random.random((<span class="number">2</span>,<span class="number">12</span>)))</span><br><span class="line">a</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([[ <span class="number">3.</span>,  <span class="number">7.</span>,  <span class="number">0.</span>,  <span class="number">6.</span>,  <span class="number">0.</span>,  <span class="number">6.</span>,  <span class="number">8.</span>,  <span class="number">5.</span>,  <span class="number">8.</span>,  <span class="number">2.</span>,  <span class="number">7.</span>,  <span class="number">1.</span>],</span><br><span class="line">       [ <span class="number">7.</span>,  <span class="number">7.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>,  <span class="number">4.</span>,  <span class="number">8.</span>,  <span class="number">8.</span>,  <span class="number">5.</span>,  <span class="number">2.</span>,  <span class="number">5.</span>,  <span class="number">5.</span>,  <span class="number">4.</span>]])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 沿水平轴分割，分割成三个形状相同的数组</span></span><br><span class="line">hsplit(a, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[array([[ <span class="number">3.</span>,  <span class="number">7.</span>,  <span class="number">0.</span>,  <span class="number">6.</span>],</span><br><span class="line">        [ <span class="number">7.</span>,  <span class="number">7.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>]]), array([[ <span class="number">0.</span>,  <span class="number">6.</span>,  <span class="number">8.</span>,  <span class="number">5.</span>],</span><br><span class="line">        [ <span class="number">4.</span>,  <span class="number">8.</span>,  <span class="number">8.</span>,  <span class="number">5.</span>]]), array([[ <span class="number">8.</span>,  <span class="number">2.</span>,  <span class="number">7.</span>,  <span class="number">1.</span>],</span><br><span class="line">        [ <span class="number">2.</span>,  <span class="number">5.</span>,  <span class="number">5.</span>,  <span class="number">4.</span>]])]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在第三列、第四列之后进行分割</span></span><br><span class="line">hsplit(a, (<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[array([[ <span class="number">3.</span>,  <span class="number">7.</span>,  <span class="number">0.</span>],</span><br><span class="line">        [ <span class="number">7.</span>,  <span class="number">7.</span>,  <span class="number">2.</span>]]), array([[ <span class="number">6.</span>],</span><br><span class="line">        [ <span class="number">3.</span>]]), array([[ <span class="number">0.</span>,  <span class="number">6.</span>,  <span class="number">8.</span>,  <span class="number">5.</span>,  <span class="number">8.</span>,  <span class="number">2.</span>,  <span class="number">7.</span>,  <span class="number">1.</span>],</span><br><span class="line">        [ <span class="number">4.</span>,  <span class="number">8.</span>,  <span class="number">8.</span>,  <span class="number">5.</span>,  <span class="number">2.</span>,  <span class="number">5.</span>,  <span class="number">5.</span>,  <span class="number">4.</span>]])]</span><br></pre></td></tr></table></figure></li></ul><h4 id="复制和视图"><a href="#复制和视图" class="headerlink" title="复制和视图"></a>复制和视图</h4><ul><li><p>对数组进行处理是，它们的有时不会拷贝到新数组</p></li><li><p>完全不拷贝</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a = arange(<span class="number">12</span>)</span><br><span class="line">b = a</span><br><span class="line">print(b <span class="keyword">is</span> a)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line">b.shape = <span class="number">3</span>, <span class="number">4</span></span><br><span class="line">a.shape</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">b就是a本身</span><br></pre></td></tr></table></figure></li><li><p>视图和浅复制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不同的数组对象分享同一个数据。视图方法创造一个新的数组对象指向同一数据</span></span><br><span class="line">c = a.view()</span><br><span class="line">c <span class="keyword">is</span> a </span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">Flase</span><br><span class="line"></span><br><span class="line"><span class="comment"># c是a的视图，则a是c的base</span></span><br><span class="line">c.base <span class="keyword">is</span> a</span><br><span class="line">结果：</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># c是否有自身的数据</span></span><br><span class="line">c.flags.owndata</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 视图的形状改变不影响数组本身</span></span><br><span class="line">c.shape = <span class="number">2</span>, <span class="number">6</span></span><br><span class="line">a.shape</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 视图内容的改变会改变原数组</span></span><br><span class="line">c[<span class="number">0</span>, <span class="number">4</span>] = <span class="number">1234</span></span><br><span class="line">a</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([[   <span class="number">0</span>,    <span class="number">1</span>,    <span class="number">2</span>,    <span class="number">3</span>],</span><br><span class="line">       [<span class="number">1234</span>,    <span class="number">5</span>,    <span class="number">6</span>,    <span class="number">7</span>],</span><br><span class="line">       [   <span class="number">8</span>,    <span class="number">9</span>,   <span class="number">10</span>,   <span class="number">11</span>]])</span><br></pre></td></tr></table></figure></li><li><p>深复制</p><ul><li><p>完全复制数组和它的数据</p></li><li><p>例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 完全拷贝，d与a是完全无关的两个实体</span></span><br><span class="line">d = a.copy()</span><br><span class="line">d <span class="keyword">is</span> a</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># d也不是a的视图</span></span><br><span class="line">d.base <span class="keyword">is</span> a</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># d的内容的修改也不会影响a</span></span><br><span class="line">d[<span class="number">0</span>, <span class="number">0</span>] = <span class="number">9999</span></span><br><span class="line">a</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">array([[   <span class="number">0</span>,   <span class="number">10</span>,   <span class="number">10</span>,    <span class="number">3</span>],</span><br><span class="line">       [<span class="number">1234</span>,   <span class="number">10</span>,   <span class="number">10</span>,    <span class="number">7</span>],</span><br><span class="line">       [   <span class="number">8</span>,   <span class="number">10</span>,   <span class="number">10</span>,   <span class="number">11</span>]])</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="方法总览"><a href="#方法总览" class="headerlink" title="方法总览"></a>方法总览</h4><ul><li><p>创建数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arange, array, copy, empty, empty_like, eye, fromfile, fromfunction, identity, </span><br><span class="line">linspace, logspace, mgrid, ogrid, ones, ones_like, r , zeros, zeros_like</span><br></pre></td></tr></table></figure></li><li><p>转化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">astype, atleast <span class="number">1</span>d, atleast <span class="number">2</span>d, atleast <span class="number">3</span>d, mat</span><br></pre></td></tr></table></figure></li><li><p>操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array split, column stack, concatenate, diagonal, dsplit, dstack, hsplit, hstack, item, </span><br><span class="line">newaxis, ravel, repeat, reshape, resize, squeeze, swapaxes, take, transpose, vsplit, vstack</span><br></pre></td></tr></table></figure></li><li><p>询问（判断）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">all, any, nonzero, where</span><br></pre></td></tr></table></figure></li><li><p>排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">argmax, argmin, argsort, max, min, ptp, searchsorted, sort</span><br></pre></td></tr></table></figure></li><li><p>运算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">choose, compress, cumprod, cumsum, inner, fill, imag, prod, put, putmask, real, sum</span><br></pre></td></tr></table></figure></li><li><p>基本统计</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cov, mean, std, var</span><br></pre></td></tr></table></figure></li><li><p>基本线性代数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cross, dot, outer, svd, vdot</span><br></pre></td></tr></table></figure></li></ul><!--more--><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>乌合之众</title>
      <link href="/passages/wu-he-zhi-zhong/"/>
      <url>/passages/wu-he-zhi-zhong/</url>
      
        <content type="html"><![CDATA[<p>乌合之众</p><a id="more"></a><p>《乌合之众》庞勒<br>&emsp;&emsp;群体是有共同目的的人的集合，群体智力低下，盲目而极端，保守又善变，充满原始的暴力和嗜血的欲望。<br>&emsp;&emsp;“多数人永远正确”的认识，理应受到更多的思考。切记要保留独立思考的能力，不能因为入群之后便将人云亦云视为了理所当然。</p><p>不做过多评价，下面是一些摘抄</p><blockquote><p>除了破坏之外，群体的施威无法起到任何作用。</p></blockquote><blockquote><p>群体对理性并不适应，却急于行动。</p></blockquote><blockquote><p>科学向我们许诺真理，但科学从未向我们许诺过和平和幸福。</p></blockquote><blockquote><p>群体无法接受任何观点，只能骗。</p></blockquote><blockquote><p>群体成员的思想感性有一种相互统一的倾向，自觉的个性消失了，出现了一个群体心理。</p></blockquote><blockquote><p>分散的千万个体在受到强烈的情绪冲击是，在特定时刻也会变成群体。</p></blockquote><blockquote><p>孤立的个人具有主宰自己的反应行为的能力，群体则缺乏这种能力。</p></blockquote><blockquote><p>在才智层面完全不同的个体，拥有的本能、情绪和情感却非常相似。</p></blockquote><blockquote><p>群体并不叠加智慧，叠加出来的都是愚蠢。</p></blockquote><blockquote><p>在群体中，任何情绪和行为都会传染，而且传染性很大，大到个体会欣然为了群体利益而牺牲个人利益。</p></blockquote><blockquote><p>群体急于遵循任何冲动，完全不考虑是否对自己有利。</p></blockquote><blockquote><p>群体认为一切都是确定的，怀疑什么什么就是真的，并走极端。</p></blockquote><blockquote><p>任何信仰的胜利都需要血流成河，群体则提供血液。</p></blockquote><blockquote><p>群体的渴望虽然狂热，但从不持久。</p></blockquote><blockquote><p>群体的言论易受暗示影响，暗示的起点一般是某个人大脑里制造出的模模糊糊的幻觉，如果这第一份错觉随后被第二个人肯定，就会发生交叉感染。所以目击证人最多的事一定是最可疑的事。</p></blockquote><blockquote><p>群体表达情感时，总表现出简单化、极端化的特点，不是极爱就是极恨。</p></blockquote><blockquote><p>群体习惯了夸张的情绪，所以只能对极端情感有反应</p></blockquote><blockquote><p>群体随时准备背叛弱者，在强权面前卑躬屈膝。</p></blockquote><blockquote><p>一套思想对社会的影响与它包含多少真理无关。</p></blockquote><blockquote><p>向群众灌输思想，其表现形式必须很绝对、很强硬、很直白，否则就会不起作用。</p></blockquote><blockquote><p>群体推理的特征，就是把表面有点儿相似的不同东西联系起来，并瞬间把具体经验普遍化。</p></blockquote><blockquote><p>群体只能进行形象思维，只被形象打动。</p></blockquote><blockquote><p>在群体中，好感会迅速变成崇拜，讨厌刚一产生就变成了仇恨。</p></blockquote><blockquote><p>群体新年的特征是盲目服从、强烈的排异性以及狂热的扩散欲。</p></blockquote><blockquote><p>传统支配人，尤其是群体中的人。</p></blockquote><blockquote><p>以暴力革命为代价无疑能改变制度的命哼，但制度的本质不会发生变化。</p></blockquote><blockquote><p>在生活中成功的条件是拥有判断力、经历、进取精神和意志，这些东西都是书本里学不到的。</p></blockquote><blockquote><p>幻想无疑都是虚假的影子，可幻想最终推动者各个民族创造了最自豪的艺术和最伟大的文明。</p></blockquote><blockquote><p>各个民族进化的主要因素从来都不是真理，而是谬误。</p></blockquote><blockquote><p>知道如何影响群体的演说家从不诉诸理性，而是操纵情绪。</p></blockquote><blockquote><p>创造文明的主因是情感而不是理性，理性一般不起作用，这些情感的东西包括荣耀、牺牲、信仰、爱国以及对光荣的热爱。</p></blockquote><blockquote><p>任何聚集成群的动物都有服从领袖的本能。</p></blockquote><blockquote><p>群体领袖都很专制，实际上专制才是拥有追随者的前提条件。</p></blockquote><blockquote><p>简单、纯粹的断言，不带任何逻辑，没有任何根据，是洗脑群体最有效的方法之一。</p></blockquote><blockquote><p>反复的断言，会是信息以特别的方式深入人心，并最终能被人接受为不证自明的真理。</p></blockquote><blockquote><p>当一个人遭受争议时，就不再拥有气场，为了让群众敬畏，必须预期保持距离。</p></blockquote><blockquote><p>当信念的力量完全消失，一切上层家住才会迅速土崩瓦解。</p></blockquote><blockquote><p>群体中的人，一旦被取悦就容易被说服，跟他说什么他都特别愿意接受。</p></blockquote><blockquote><p>人们并不会因为彼此相信而彼此相似，但他们因为相似，所以几乎无限地相信公众的判断力。</p></blockquote><blockquote><p>断言永远不会太狠，恐吓的话永远也不过分。</p></blockquote><blockquote><p>群体永远需要主任，并本能的在经历旺盛、信念坚定的人中寻找。</p></blockquote><blockquote><p>演讲成功与否完全取决于一个人的气场而不是他说了什么。</p></blockquote><blockquote><p>表面自由的增加必然以真正自由的减少为代价。</p></blockquote><blockquote><p>为了追求理想，从野蛮走向文明；当理想失去了价值，从文明走向衰落和灭亡。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书&amp;电影 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql解压版安装配置</title>
      <link href="/passages/mysql-jie-ya-ban-an-zhuang-pei-zhi/"/>
      <url>/passages/mysql-jie-ya-ban-an-zhuang-pei-zhi/</url>
      
        <content type="html"><![CDATA[<p>mysql安装时有安装版和解压版两种方式，本文讲解的是解压版的配置过程。</p><p>本文使用的<code>mysql5.5</code>，你可以选则喜欢的版本进行下载。</p><a id="more"></a><h3 id="下载Mysql"><a href="#下载Mysql" class="headerlink" title="下载Mysql"></a>下载Mysql</h3><ul><li>在<a href="http://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">这里</a>下载<code>mysql</code>，并解压到你喜欢的目录下。</li></ul><h3 id="配置Mysql"><a href="#配置Mysql" class="headerlink" title="配置Mysql"></a>配置Mysql</h3><ul><li><p>将<code>mysql</code>主文件夹下的<code>my.default.ini</code>改名为<code>my.ini</code>并移动到<code>bin</code>目录下</p></li><li><p>如果没有则创建<code>my.ini</code>并移动到<code>bin</code>目录下</p></li><li><p>添加以下内容</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Client]</span></span><br><span class="line"><span class="attr">port</span> = <span class="number">3306</span></span><br><span class="line"></span><br><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="comment"># 端口</span></span><br><span class="line"><span class="attr">port</span> = <span class="number">3306</span></span><br><span class="line"><span class="comment"># 安装目录</span></span><br><span class="line"><span class="attr">basedir</span>=D:\mysql-<span class="number">5.5</span>.<span class="number">62</span></span><br><span class="line"><span class="comment"># 数据存放目录</span></span><br><span class="line"><span class="attr">datadir</span>=D:\mysql-<span class="number">5.5</span>.<span class="number">62</span>\data</span><br><span class="line"><span class="comment"># 最大连接数</span></span><br><span class="line"><span class="attr">max_connections</span>=<span class="number">200</span></span><br><span class="line"><span class="comment"># 服务器端默认字符集</span></span><br><span class="line"><span class="attr">character-set-server</span>=utf8</span><br><span class="line"><span class="comment"># 创建新表时使用的默认存储引擎</span></span><br><span class="line"><span class="attr">default-storage-engine</span>=INNODB</span><br><span class="line"><span class="attr">sql_mode</span>=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</span><br><span class="line"> </span><br><span class="line"><span class="section">[mysql]</span></span><br><span class="line"><span class="comment"># 客户端默认字符集</span></span><br><span class="line"><span class="attr">default-character-set</span>=utf8</span><br></pre></td></tr></table></figure></li><li><p>将<code>mysql</code>下的<code>bin</code>目录添加到<code>Path</code>环境变量中</p></li></ul><h3 id="安装Mysql服务"><a href="#安装Mysql服务" class="headerlink" title="安装Mysql服务"></a>安装Mysql服务</h3><ul><li><p>以管理员打开<code>cmd</code></p></li><li><p>将目录切换到<code>mysql</code>下的<code>bin</code>目录</p></li><li><p>执行<code>mysqld install</code></p><p><img src="/.top//mysql%E8%A7%A3%E5%8E%8B%E7%89%88%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%5Ccmd.png" alt="cmd"></p></li><li><p>启动mysql服务</p><ul><li>控制面板-&gt;管理工具-&gt;服务 -&gt; mysql -&gt; 启动</li></ul></li></ul><h3 id="填坑"><a href="#填坑" class="headerlink" title="填坑"></a>填坑</h3><ul><li><p>原有mysql服务卸载不完全</p><p><img src="/.top//mysql%E8%A7%A3%E5%8E%8B%E7%89%88%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%5Cfail.png" alt="fail"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行</span><br><span class="line">sc delete mysql</span><br></pre></td></tr></table></figure></li></ul><br><br><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 工具配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pycharm2017版激活</title>
      <link href="/passages/pycharm2017-ban-ji-huo/"/>
      <url>/passages/pycharm2017-ban-ji-huo/</url>
      
        <content type="html"><![CDATA[<p>本教程仅供个人学习使用，如有需要，请前往官方渠道购买正版产品。</p><a id="more"></a><h3 id="Pycharm下载"><a href="#Pycharm下载" class="headerlink" title="Pycharm下载"></a>Pycharm下载</h3><ul><li><p>在<a href="https://www.jetbrains.com/pycharm/download/previous.html" target="_blank" rel="noopener">这里</a>选择2017版的<code>pycharm</code>下载，注意要选择<code>professional</code>版本的。</p></li><li><p><code>communtiy</code>版本的是可以免费使用的，基本功能都有，可以满足日常使用。</p></li><li><p>下载完成后按指示安装即可。</p></li><li><p>安装完成后打开如下图所示</p><p><img src="Pycharm2017%E7%89%88%E6%BF%80%E6%B4%BB%5Cwzc.png" alt="wjh"></p></li></ul><h3 id="Pycharm激活"><a href="#Pycharm激活" class="headerlink" title="Pycharm激活"></a>Pycharm激活</h3><ul><li><p>从<a href="http://idea.lanyus.com/help/help.html" target="_blank" rel="noopener">这里</a>下载<a href="http://idea.lanyus.com/jar/JetbrainsCrack-2.6.2.jar" target="_blank" rel="noopener">http://idea.lanyus.com/jar/JetbrainsCrack-2.6.2.jar</a></p></li><li><p>将下载的jar包放在<code>Pycharm</code>安装目录下的<code>bin</code>目录下</p></li><li><p>修改<code>pycharm.exe.vmoptions</code>和<code>pycharm64.exe.vmoptions</code>文件，使用记事本打开即可</p></li><li><p>在其文件末尾添加<code>-javaagent:你的pycharm安装目录\bin\JetbrainsCrack-2.6.10-release-enc.jar</code></p></li><li><p>重新启动<code>Pycharm</code>，选择<code>Activiate code</code>，输入以下内容</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BIG3CLIK6F-eyJsaWNlbnNlSWQiOiJCSUczQ0xJSzZGIiwibGljZW5zZWVOYW1lIjoibGFuIHl1IiwiYXNzaWduZWVOYW1lIjoiIiwiYXNzaWduZWVFbWFpbCI6IiIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IkZvciBlZHVjYXRpb25hbCB1c2Ugb25seSIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiQUMiLCJwYWlkVXBUbyI6IjIwMTctMTEtMjMifSx7ImNvZGUiOiJETSIsInBhaWRVcFRvIjoiMjAxNy0xMS0yMyJ9LHsiY29kZSI6IklJIiwicGFpZFVwVG8iOiIyMDE3LTExLTIzIn0seyJjb2RlIjoiUlMwIiwicGFpZFVwVG8iOiIyMDE3LTExLTIzIn0seyJjb2RlIjoiV1MiLCJwYWlkVXBUbyI6IjIwMTctMTEtMjMifSx7ImNvZGUiOiJEUE4iLCJwYWlkVXBUbyI6IjIwMTctMTEtMjMifSx7ImNvZGUiOiJSQyIsInBhaWRVcFRvIjoiMjAxNy0xMS0yMyJ9LHsiY29kZSI6IlBTIiwicGFpZFVwVG8iOiIyMDE3LTExLTIzIn0seyJjb2RlIjoiREMiLCJwYWlkVXBUbyI6IjIwMTctMTEtMjMifSx7ImNvZGUiOiJEQiIsInBhaWRVcFRvIjoiMjAxNy0xMS0yMyJ9LHsiY29kZSI6IlJNIiwicGFpZFVwVG8iOiIyMDE3LTExLTIzIn0seyJjb2RlIjoiUEMiLCJwYWlkVXBUbyI6IjIwMTctMTEtMjMifSx7ImNvZGUiOiJDTCIsInBhaWRVcFRvIjoiMjAxNy0xMS0yMyJ9XSwiaGFzaCI6IjQ3NzU1MTcvMCIsImdyYWNlUGVyaW9kRGF5cyI6MCwiYXV0b1Byb2xvbmdhdGVkIjpmYWxzZSwiaXNBdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlfQ&#x3D;&#x3D;-iygsIMXTVeSyYkUxAqpHmymrgwN5InkOfeRhhPIPa88FO9FRuZosIBTY18tflChACznk3qferT7iMGKm7pumDTR4FbVVlK&#x2F;3n1ER0eMKu2NcaXb7m10xT6kLW1Xb3LtuZEnuis5pYuEwT1zR7GskeNWdYZ0dAJpNDLFrqPyAPo5s1KLDHKpw+VfVd4uf7RMjOIzuJhAAYAG+amyivQt61I9aYiwpHQvUphvTwi0X0qL&#x2F;oDJHAQbIv4Qwscyo4aYZJBKutYioZH9rgOP6Yw&#x2F;sCltpoPWlJtDOcw&#x2F;iEWYiCVG1pH9AWjCYXZ9AbbEBOWV71IQr5VWrsqFZ7cg7hLEJ3A&#x3D;&#x3D;-MIIEPjCCAiagAwIBAgIBBTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE1MTEwMjA4MjE0OFoXDTE4MTEwMTA4MjE0OFowETEPMA0GA1UEAwwGcHJvZDN5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO&#x2F;5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij&#x2F;78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB&#x2F;xVy&#x2F;VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE&#x2F;EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl&#x2F;GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9</span><br></pre></td></tr></table></figure><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><h4 id="failed-to-create-JVM-error-code-1"><a href="#failed-to-create-JVM-error-code-1" class="headerlink" title="failed to create JVM: error code -1"></a>failed to create JVM: error code -1</h4><ul><li><p>在网上查阅了一些经验，最终是以以下方案解决的。</p></li><li><p>卸载java并删除注册表：</p><ul><li>卸载java并删除环境变量</li><li>win+r，输入regedit启动注册表管理器</li><li>删除HKEY_CURRENT_USER\Software\JavaSoft</li><li>删除HKEY_LOCAL_MACHINE\SOFTWARE\JavaSoft</li></ul></li><li><p>重新安装java并配置环境变量</p><ul><li>从<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">这里</a>下载java8并安装</li><li>我的电脑-&gt;右键属性-&gt;高级系统设置-&gt;环境变量</li><li>系统变量中新建<code>JAVA_HOME</code>变量，值为你的java安装目录</li><li>选中系统变量中的Path，点击编辑，新建两条路径</li></ul><p><img src="Pycharm2017%E7%89%88%E6%BF%80%E6%B4%BB%5Chjbl1.png" alt="hjbl1"></p></li></ul><p>  <img src="Pycharm2017%E7%89%88%E6%BF%80%E6%B4%BB%5Chjbl2.png" alt="hjbl2"></p><ul><li>打开cmd，依次输入<code>java</code>、<code>javac</code>、<code>java -version</code>确认安装配置正确</li></ul><ul><li>重新激活即可</li></ul><h4 id="key-is-invalid"><a href="#key-is-invalid" class="headerlink" title="key is invalid"></a>key is invalid</h4><ul><li>从<a href="http://idea.lanyus.com/" target="_blank" rel="noopener">http://idea.lanyus.com/</a>下载最新的补丁</li><li>删除 `C:/Users/用户名/.PycharmXXXX.XX文件</li><li>重新进入就不会有问题了</li></ul></br></br><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 工具配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客主题配置</title>
      <link href="/passages/hexo-bo-ke-zhu-ti-pei-zhi/"/>
      <url>/passages/hexo-bo-ke-zhu-ti-pei-zhi/</url>
      
        <content type="html"><![CDATA[<p>hexo博客主题配置</p><a id="more"></a><ul><li><p>在<a href="https://hexo.io/themes/" target="_blank" rel="noopener">这里</a>，挑选一款自己喜欢的主题，下载。</p></li><li><p>解压，将整个主题文件夹放到博客主文件夹下的<code>themes</code>文件夹下。</p></li><li><p>将主配置文件中的theme字段后的<code>landscapes</code>改为你主题文件夹的名称。</p><p><img src="/.top//hexo%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%5Czhuti1.png" alt="zhuti1"></p></li><li><p>配置主题文件夹中的<code>config.yml</code>。</p></li><li><p>具体配置在主题的文档中都有，各个主题的配置过程都大同小异，请参照文档配置。</p></li><li><p>本站使用的主题是<code>ad</code>，欢迎来信交流。</p></li></ul><br><br><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 博客相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pycharm使用小技巧</title>
      <link href="/passages/pycharm-shi-yong-xiao-ji-qiao/"/>
      <url>/passages/pycharm-shi-yong-xiao-ji-qiao/</url>
      
        <content type="html"><![CDATA[<p>Pycharm的一些使用技巧</p><p>不断更新中</p><a id="more"></a><h3 id="打开时显示最后一次打开的项目or显示欢迎界面"><a href="#打开时显示最后一次打开的项目or显示欢迎界面" class="headerlink" title="打开时显示最后一次打开的项目or显示欢迎界面"></a>打开时显示最后一次打开的项目or显示欢迎界面</h3><ul><li><p>file -&gt; settings -&gt; Appearance&amp;Behavior -&gt; System steeings -&gt; Reopen …     勾选or取消勾选</p><p><img src="pycharm%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7%5Chyjm.png" alt="1"></p></li></ul><h3 id="Pycharm使用conda虚拟环境"><a href="#Pycharm使用conda虚拟环境" class="headerlink" title="Pycharm使用conda虚拟环境"></a>Pycharm使用conda虚拟环境</h3><ul><li><p>使用<code>conda env list</code>可以查看创建的虚拟环境</p><p><img src="pycharm%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7%5Cconda.png" alt="conda"></p></li><li><p>File -&gt; Settings -&gt; Project XXXX -&gt; Project Interpreter -&gt; add local Python Interpreter</p></li><li><p>选择Existing environment -&gt; XXXX/Anaconda/envs/your_env_name/python.exe</p><p><img src="pycharm%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7%5Cadd.png" alt="add"></p></li></ul><h3 id="设置Pycharm文件编码"><a href="#设置Pycharm文件编码" class="headerlink" title="设置Pycharm文件编码"></a>设置Pycharm文件编码</h3><ul><li>file -&gt; settings -&gt; Editor -&gt; File Encodings</li><li>按照自己的意愿设置即可</li></ul><h3 id="设置文件模版"><a href="#设置文件模版" class="headerlink" title="设置文件模版"></a>设置文件模版</h3><ul><li><p>file -&gt; Settings -&gt; Editor -&gt; File and Code Templates</p><p><img src="pycharm%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7%5Ccode_templates.png" alt="code1"></p></li><li><p>此处以设置python文件模板为例</p></li><li><p>点击“Python Script”</p><p><img src="pycharm%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7%5Ccode_templates2.png" alt="code2"></p></li><li><p>字段解释</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$&#123;USER&#125;   当前系统用户</span><br><span class="line"></span><br><span class="line">$&#123;DATE&#125;   当前系统日期</span><br><span class="line"></span><br><span class="line">$&#123;TIME&#125;   当前系统时间</span><br><span class="line"></span><br><span class="line">$&#123;PRODUCT_NAME&#125;   创建文件的IDE名称</span><br><span class="line"></span><br><span class="line">也可直接添加文本信息</span><br><span class="line"></span><br><span class="line">其他可用：</span><br><span class="line">$&#123;PROJECT_NAME&#125; - 当前项目的名称。</span><br><span class="line">$&#123;NAME&#125; - 在文件创建过程中在“新建文件”对话框中指定的新文件的名称。</span><br><span class="line">$&#123;YEAR&#125; - 今年。</span><br><span class="line">$&#123;MONTH&#125; - 当月。</span><br><span class="line">$&#123;DAY&#125; - 当月的当天。</span><br><span class="line">$&#123;HOUR&#125; - 目前的小时。</span><br><span class="line">$&#123;MINUTE&#125; - 当前分钟。</span><br><span class="line">$&#123;PRODUCT_NAME&#125; - 将在其中创建文件的IDE的名称。</span><br><span class="line">$&#123;MONTH_NAME_SHORT&#125; - 月份名称的前<span class="number">3</span>个字母。 示例：一月，二月等</span><br><span class="line">$&#123;MONTH_NAME_FULL&#125; - 一个月的全名。 示例：一月，二月等</span><br></pre></td></tr></table></figure></li></ul></br></br><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 工具配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>苏州大学计算机考研初复试总结</title>
      <link href="/passages/su-zhou-da-xue-ji-suan-ji-kao-yan-chu-fu-shi-zong-jie/"/>
      <url>/passages/su-zhou-da-xue-ji-suan-ji-kao-yan-chu-fu-shi-zong-jie/</url>
      
        <content type="html"><![CDATA[<p>苏州大学计算机考研初复试总结</p><a id="more"></a><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>很早就想写一篇总结了，一直没有着手，一来是没有构思好具体的结构，另一方面是成绩还没出来，总觉得这个时候发篇总结容易打脸。</p><p>先介绍一下自己的情况吧。本科山东某双非本科，今年报考的是苏州大学的计算机专硕，专业课代号872。初试分数365，排名15。</p><p>典型工科男，没什么文笔，写的可能像是流水账一样，大家多担待。</p><p>今年由于政策变动，录取结果出的可能会晚一些。</p><p>今年统考全日制软件专硕取消了，不过计算机专硕最终扩招了，整体名额和去年差不多。</p><hr><p>4月8日更新</p><p>成绩出来了，有幸上岸，感谢感谢。</p><h3 id="备考时间安排"><a href="#备考时间安排" class="headerlink" title="备考时间安排"></a>备考时间安排</h3><ul><li><p>正式开始大约是在4月中旬，在之前也有看过一些高数，寒假结束之前差不多听完了朱伟的恋练有词。</p></li><li><p>英语真题从5月份开始，大约一周做一年的真题。</p></li><li><p>6月结束之前看完了汤老师的高数基础班和李永乐老师的线性代数。</p></li><li><p>暑假的时候看了一遍王道的数据结构和操作系统，听完了线代和高数的强化班。</p></li><li><p>九月份开始听徐涛的政治强化班并开始做数学的真题。</p></li><li><p>十月份开始刷肖秀荣的1000题并做了苏大近15年的真题。</p></li><li><p>十一月主要回顾了一遍高数和线代的笔记。</p></li><li><p>十一月中旬开始背作文和政治的大题。</p></li><li><p>每天的有效学习时间一般在8~9个小时。</p></li></ul><h3 id="使用参考书"><a href="#使用参考书" class="headerlink" title="使用参考书"></a>使用参考书</h3><ul><li><p>英语：《恋练有词》、真题黄皮书（英一、英二）、《恋练有辞写作宝典》</p></li><li><p>政治：《核心考案》（徐涛）、《1000题》（肖秀荣）、《冲刺背诵笔记》（徐涛）、《肖四》、《肖八》</p></li><li><p>数学：《高数复习讲义》（汤家凤）、《线性代数辅导讲义》（李永乐）、《1800题》（汤家凤）、《真题》（张宇）、《张宇八套卷》</p></li><li><p>专业课：王道考研的《数据结构》和《操作系统》、近15年真题</p></li></ul><h3 id="视频网课"><a href="#视频网课" class="headerlink" title="视频网课"></a>视频网课</h3><ul><li><p>恋练有词（18年）。不建议看最新的，太拖了。</p></li><li><p>语法（唐静）。有时间可以看一下，开倍速或者跳着看都行。</p></li><li><p>阅读（唐迟）。可以针对实在看不懂的阅读来看一下，没必要全看。</p></li><li><p>徐涛政治强化班。不建议看基础班。</p></li><li><p>徐涛时政押题直播班。b站就可以看，一般直播之后过一天就有了。</p></li><li><p>汤家凤高数基础班、强化班。个人感觉跟着汤老师还是很踏实的，就是方言比较严重。</p></li><li><p>李永乐线代基础班、强化班。</p></li><li><p>汤家凤公众号的一些直播录像。</p></li></ul><h3 id="几点建议"><a href="#几点建议" class="headerlink" title="几点建议"></a>几点建议</h3><ul><li><p>专业课请务必重视专业课真题，尤其是操作系统，个人感觉苏大的专业课个性化很强，想拿高分不是很容易，有时间和机会的化可以看一下苏大本科的期末考试题。</p></li><li><p>英语阅读要认真练，每一篇文章都要认真去读。建议做完一遍之后隔几天再拿出来当作翻译精读一下。</p></li><li><p>英语重点就是阅读，请多花些时间在上面。</p></li><li><p>肖秀荣的四套卷一定要做，很真题。说实话都有些怀疑他是不是被派来泄题的（滑稽保命）。</p></li><li><p>李永乐的线代讲义一定要做，这么多年线代辅导独一份不是盖的，有时间可以听一下李永乐的强化班，有些技巧书里没有。</p></li><li><p>汤家凤的高数还是很踏实的，就是有点方言，个人比较推荐看一下他中值定理部分的强化班，很详细。</p></li><li><p>数学必须必须必须多做题，做真题，模拟题不建议做。真题值得刷好几遍（注意控制时间，模拟考场氛围）。</p></li><li><p>政治1000题的主要作用就是巩固知识点，不要太较真了，如果嫌多的话可以做徐涛的优题库，题量小一点。</p></li><li><p>政治马原建议看一下视频，其中的一些政治经济学的东西自己不太好懂。</p></li><li><p>政治看视频的话建议徐涛强化班，比较生动有趣。</p></li><li><p>没学过操作系统的，建议看<a href="https://www.icourse163.org/course/SUDA-1001752241" target="_blank" rel="noopener">mooc</a>，苏大的老师讲的。</p></li></ul><p>想到再来补充吧</p><h3 id="经验之谈"><a href="#经验之谈" class="headerlink" title="经验之谈"></a>经验之谈</h3><ul><li><p>考研不仅是知识上的较量，更是心态的较量，考研期间保持心情愉快是很关键的。</p></li><li><p>考研过程中收获的也不仅仅是最终的录取结果，还有心态和眼界上的提升。</p></li><li><p>请务必合理评估自己的实力，选择一个能通过半年多努力上岸的学校，这点很重要也很现实。</p></li><li><p>一个合适的研友对你来说不仅是学习上的陪伴，还是精神上的陪伴。一定要找一个肯沉下心学习的一起学习，如果你自制力强的也可以自己进行。</p></li><li><p>做规划是很有必要的，长短期都要大致有个计划。比如今天回宿舍前将明天的计划做一下，每个月结束前对上个月总结以下，对下个月计划一下。</p></li><li><p>数学和专业课值得花最多的时间去准备，英语学习需要贯穿整个备考过程。</p></li><li><p>不管初试复试分数占比如何，初试分数高一些总归是有好处的。根据今年的政策来说，初试成绩高一点可以让你更容易选到心仪的导师。</p></li><li><p>有问题一定要及时解决，不要害怕去请教别人，不要嫌请教别人花时间，给别人讲题也能加深你对知识的认识。</p></li><li><p>政治不建议暑假结束之前看，没必要，更会占用暑假最珍贵的数学强化时间。</p></li><li><p>政治和英语作文在最后两个月开始就行，时间很足够。</p></li><li><p>最后两个月基本就是政治和英语作文，其他题型的练习了，所以数学一定要在暑假结束之前打好底子，不然后期会手忙脚乱。</p></li><li><p>心态平和，按照自己的计划一步一步的进行，不要被别人的进度影响。</p></li><li><p>苏大的报名人数还是挺多的，不过不要害怕，做好自己就好了。</p></li><li><p>不要太过于追求技巧和方法，脚踏实地的练习才是最关键的。</p></li></ul><p>文笔一般，大家凑活看吧，有问题可以联系我，本文也会继续补充。</p><h3 id="下面的是复试的一点总结"><a href="#下面的是复试的一点总结" class="headerlink" title="下面的是复试的一点总结"></a>下面的是复试的一点总结</h3><p>复试成绩不是很理想，就不谈什么经验了，说一下复试的流程吧。</p><p>今年是先选导师后复试，初试成绩高一点对联系导师还是有些优势的。</p><h4 id="时间安排"><a href="#时间安排" class="headerlink" title="时间安排"></a>时间安排</h4><ul><li><a href="http://scst.suda.edu.cn/ac/d7/c11205a306391/page.htm?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">复试通知</a></li><li><a href="http://scst.suda.edu.cn/ac/d8/c11225a306392/page.htm" target="_blank" rel="noopener">招生计划</a></li><li>资格审查</li><li><a href="http://scst.suda.edu.cn/16/fb/c11205a268027/page.htm" target="_blank" rel="noopener">上机</a></li><li>面试</li><li>体检</li><li>一共是两天的时间</li></ul><h4 id="联系导师"><a href="#联系导师" class="headerlink" title="联系导师"></a>联系导师</h4><ul><li>注意有礼貌</li><li>不要同时联系多个同组的老师，会很尴尬（别问我为什么知道=_=）</li><li>有条件的话可以联系几个目标院校的学长学姐问一下。</li><li><a href="http://scst.suda.edu.cn/11252/list.htm" target="_blank" rel="noopener">研究方向</a></li><li><a href="http://scst.suda.edu.cn/11250/list.htm" target="_blank" rel="noopener">导师简介</a></li><li><a href="http://scst.suda.edu.cn/16/e3/c11225a268003/page.htm" target="_blank" rel="noopener">学院导师联系方式</a></li></ul><h4 id="笔试（上机-选择）"><a href="#笔试（上机-选择）" class="headerlink" title="笔试（上机+选择）"></a>笔试（上机+选择）</h4><ul><li>前15年的上机真题很多考验群里都有，我在<a href="https://www.zivblog.top" target="_blank" rel="noopener">博客</a>上也有整理（其实就是稍微整理了一下思路）。</li><li>主要就是文件操作和一些简单数据处理。</li><li>最后提交的程序一定要编译通过，有步骤分的。</li><li>进机房需要鞋套，可以提前买，学校里面的超市里也有卖的。</li><li>选择题刷二级c语言单选就可以了，但是还是有点区别的。总之二级c语言刷一段时间，40+应该没问题。</li><li>19年的上机题我有记过，一并放在本站了，需要的自取。</li><li>复试主要拉分的就是机试，一定要好好准备。</li></ul><h4 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h4><ul><li>面试分为三块：自我介绍（英文）、文献翻译、专业课知识（抽题，最多三次）。</li><li>今年专硕分了4组，面试顺序按成绩的升序排的。</li><li>今年的自我介绍要求用ppt来讲，时间在5分钟以内。</li><li>文献翻译大致就是一些数据结构和操作系统的知识，平时注意一些专业名词即可。</li><li>专业课知识包含的面很广，本科学的都有机会问到，还有一些当前的热点事件等。</li><li>据说跨考的同学答不上来的话会问一些本科本专业学的东西，所以不用害怕。</li><li>面试拉分不大，成绩给的也都挺高的。</li></ul><p>其实面试不用紧张，尽可能去说就可以了，不会的可以说以下自己的看法，注意礼貌。</p><h3 id="关于本科院校"><a href="#关于本科院校" class="headerlink" title="关于本科院校"></a>关于本科院校</h3><p>其实大家根本不用担心什么本科院校歧视什么的。</p><p>本科院校好的话顶多在联系导师的时候占点优势，在其他地方没什么差别。</p><p>一来初试和上机对于本科是哪里的根本没有关系，就看谁肯下功夫。</p><p>二来复试中的面试根本不会看你的成绩单之类的东西。</p><p>现阶段把初试的分数尽量考高点就是最大的优势了。</p><h3 id="你们最关心的"><a href="#你们最关心的" class="headerlink" title="你们最关心的"></a>你们最关心的</h3><ul><li><p>总结了一下最近被问到的问题</p></li><li><p>面试时是否会问大学时的项目经验？</p><ul><li>我面试的时候，下面打分的老师们几乎都不讲话，也没有提问，全程只有一个助理在指导你该干什么。进去的时候不让带奖状、证书、成绩单等，老师们根本没时间看。还有就是你的初试分数如果低一点的话可以在自我介绍是适当加一些自己的各种经历，可能会是加分项。</li></ul></li><li><p>上机题只能用c语言么？</p><ul><li>是的。20年的暂时还不知道，不过之前都是c语言程序设计。只能用有限的头文件，c++里的stl都不能用。主要考察的是文件操作，把历年的上机题敲两遍就差不多了。</li></ul></li><li><p>上机使用什么工具？</p><ul><li>上机只能用vs2010，因为这边的机房电脑上只有这个，提前熟悉一下，有突发情况的话可以现场问监考的老师。</li></ul></li><li><p>上机题必须全部做出来才有分么？</p><ul><li>不是。上机题一般有一道，但分为很多问，或者要求实现多个函数（今年）。每一问、每个函数都有分数。值得注意的是提交的程序必须是编译通过并且有输出的。</li></ul></li><li><p>我去年4月份的进度？</p><ul><li>去年四月份差不多才算正儿八经的开始。刚听完去年学长们的经验分享。进度大约是高数听完了汤家凤的基础班，英语听完了恋练有词。</li></ul></li><li><p>需不需要初试之前联系导师，与什么要注意的？</p><ul><li>个人感觉初试之前联系必要性不高，除非是很抢手的导师。毕竟连初试能不能过都不确定，导师那边也不好给答复，这个时候联系最大的作用就是留个印象。</li><li>联系导师首先要有礼貌，邮件里注意礼貌用于，将自己的意图表达清楚，附上自己的简历。</li><li>不要同时给多个同组的导师发邮件，在一个导师确定没有机会或长时间没有回复时再联系下一个。</li></ul></li><li><p>看数据结构之前需不需要先看c语言的相关内容？</p><ul><li>数据结构主要考察的是思想，解决问题的思路。</li><li>数据结构答题时用伪代码即可，不用过分注意语法错误，达到能在注释的帮助下使别人看懂你的代码即可。</li><li>如果看数据结构的时候看不懂书上的代码，相应的查以下即可，主要就是循环、顺序、选择几种结构。</li></ul></li><li><p>专业课是围绕真题还是以课本/辅导书为主？</p><ul><li>首先我的专业课成绩刚刚够三位数，在这里直说几点教训。</li><li>操作系统要重视真题，适应苏大的出题方式。</li><li>数据结构要重视每一个点，不要有遗漏。</li><li>我是直接看的王道，看完之后做了一遍真题，做的时候又回顾的知识点，最后又过了一遍知识点和真题。</li></ul></li><li><p>出初试成绩后联系导师的模版</p><blockquote><p>尊敬的XX教授：</p><p>​    您好，我叫XXX，就读于XX，目前为大四在读。</p><p>​    我今年参加了贵校计算机专业硕士的入学考试，总成绩为XXX分，专业排名为XX，其中数学XXX，英语XX，专业课XXX，政治XX。按照往年的分数线，我将有机会参加贵校的研究生复试，我希望能够有幸攻读您2019年的研究生，所以十分冒昧给您发这封邮件。</p><p>​    我大学期间成绩在专业前XX%，专业课成绩良好，曾多次获得校级二等奖学金，优秀学生干部等荣誉。我已经通过了英语六级考试，具备一定的英文文献阅读能力，相信这对以后的科研工作会有所帮助。</p><p>​    大学课余期间我积极学习知识，具有对未知领域强烈的好奇心和一定的自学能力。曾自学一段时间的机器学习算法和python，参加过相关的线上比赛。后来接触到XX，十分感兴趣，希望能跟随一名该方面的专家进行研究学习，在这个方向上有所建树。</p><p>​    我目前正在积极准备研究生复试和毕业设计，毕业设计是XX的研究。</p><p>​    冒昧请问老师您是否还有统招名额，如果我能够通过取得苏州大学的研究生入学资格，希望能有机会攻读您的2019级研究生。如果能有幸攻读您的研究生，我将踏实学好专业知识并努力完成您下达的任务，竭力向您一样在行业内取得不俗的成就。</p><p>​    再次感谢您能在百忙之中阅读我的邮件，并对冒昧打扰致以歉意，同时期待收到您的回复。随邮件附个人简历及成绩证明。</p><p>​    祝老师生活工作愉快。</p><p>​    此致敬礼</p><p>​    学生：XXX</p><p>​    XXXX年X月X日</p></blockquote></li><li><p>复试之前需要联系导师么？</p><ul><li>今年的政策不一样，复试之前必须先填一个表，必须导师那边同意之后才能填的，因为每个老师名额有限。</li><li>今年的情况是，只要复试前联系好导师，最后上岸后就确定是你联系的导师了，一般不能再改了。</li><li>由此看来，初试成绩高一点对选导师还是很友好的。</li></ul></li><li><p>硕导和博导的区别？</p><ul><li>说实话我也不是很清楚，但是从另一个角度来说，有博士生招生资格的一般资历比较老，而且这样的话你就会有同门的博士生师兄，还是比较好的。</li></ul></li><li><p>学硕和专硕在选导师时有没有区别？</p><ul><li>只要注意老师是的招生名额里是否有专硕招生，因为有的导师是不收专硕的。</li><li>其他的没有区别，放手去联系吧，说不定有大佬就同意了呢。</li></ul></li><li><p>读研的方向怎么确定？</p><ul><li>学硕的化报名的时候就填一个方向，专硕报名时不用填。</li><li>根据你选的实验室和联系的导师的方向而定。</li></ul></li><li><p>专业课面试如何准备？</p><ul><li>说实话，到时候就算不会也没什么问题，如实说就行了，比如说：学过去的时间比较长了，而且用的也不多，忘得差不多了。</li><li>最好是会。</li><li>想复习的话看看本科期间学过的专业课，比如数据库等（我今年就抽了两个数据库的题，都不会。。。）</li><li>再关注一些计算机方面的热点新闻即可。</li></ul></li><li><p>对跨考是否友好</p><ul><li>专业课考两门，如果有些基础的话，这一点可以忽略。</li><li>初试解决了专业课，其实大家都差不多。</li><li>复试好好准备上机就可以了，面试还是很友好的。</li></ul></li></ul><h3 id="福利"><a href="#福利" class="headerlink" title="福利"></a>福利</h3><ul><li>准备初试和复试的一点电子版的资料，有些是考研群里的，搬运整理了一下。</li><li><a href="https://share.weiyun.com/59Lov6S" target="_blank" rel="noopener">请自取</a></li></ul><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>别人的经历和经验用来听听，或者吸取一些有用的部分就好了，找到自己的复习节奏和方法才能事半功倍。</p><p>谢谢你的观看，考研过程中有问题可以联系我，我会尽力给出一点建议。</p><p>发邮件或加qq都可以。</p><p>就这样，祝大家都能成功上岸。</p><br><br><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 研究生复试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 研究生复试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019上机题回忆</title>
      <link href="/passages/2019-nian-shang-ji-ti-hui-yi/"/>
      <url>/passages/2019-nian-shang-ji-ti-hui-yi/</url>
      
        <content type="html"><![CDATA[<p>2019上机题回忆</p><a id="more"></a><ul><li>数据放在D盘根目录下名为Data.txt的文本文件中。</li><li>文件中存储有100个不超过32768的非负整数。</li><li>编写函数<code>read_file()</code>：读取文件中的数据，按文件中顺序存放在<code>arr</code>中</li><li>编写函数<code>print()</code>：将<code>arr</code>中的内容显示在屏幕上，每行10个数，每个整数占6列</li><li>编写函数<code>count()</code>：统计0~9在<code>arr</code>中所有整数中出现的次数，并存放到<code>res</code>中</li><li>编写函数<code>print_res()</code>：将<code>res</code>输出，每行5个元素，可复用<code>print()</code></li><li>编写函数<code>sort_array()</code>：将<code>arr中的整数按因子和升序排列，因子和相等的则按原大小排列（1和其本身也是因子）</code></li><li>编写函数<code>filter_array()</code>：对<code>arr</code>进行筛选，将偶数筛选出来放在头部，其他的放在后面。若使用辅助数组扣10分</li><li>编写函数<code>write_file()</code>：将偶数质数分解，每个数占一行写到<code>output.txt</code>中</li><li>给定主函数，修改一处扣5分。</li><li>满分100分。</li></ul><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 研究生复试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 研究生复试 </tag>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo+github博客绑定域名</title>
      <link href="/passages/hexo-zhi-github-bo-ke-bang-ding-yu-ming/"/>
      <url>/passages/hexo-zhi-github-bo-ke-bang-ding-yu-ming/</url>
      
        <content type="html"><![CDATA[<p>从阿里云购买域名，绑定到托管在Github上的博客。</p><a id="more"></a><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>由于我们的网站主题是托管在github上的，也就相当于服务器在国外的情况，所以购买的域名并不需要备案，只需要实名认证一下就可以了。实名认证的时间大约在1~2天，速度还是很快的。</p><h3 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h3><ul><li><p>首先我们需要注册一个阿里云账户，在<a href="https://account.aliyun.com/register/register.htm" target="_blank" rel="noopener">这里</a>注册。可以使用支付宝账户登录。</p></li><li><p>注册完之后进行实名认证等工作。</p></li><li><p>依次选择产品-&gt;精选-&gt;域名注册，输入你想要的域名进行购买。（这里建议可以一次多买几年，因为之后再续费的话费用会变高）</p><p><img src="/.top//hexo-github%E5%8D%9A%E5%AE%A2%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D%5Cymzc.png" alt="域名注册"></p></li></ul><ul><li><p>在阿里云的控制台中选择域名进行管理。</p><ul><li>一开始的话，域名的状态是未实名认证的，认证以下就可以了，过程就不赘述了。</li></ul></li></ul><h3 id="域名绑定"><a href="#域名绑定" class="headerlink" title="域名绑定"></a>域名绑定</h3><ul><li><p>域名实名认证之后就可以开始下面的操作了。</p></li><li><p>首先在本地的博客主目录下的<code>source</code>文件夹下创建<code>CNAME</code>文件（注意是大写，并且没有文件后缀名）。</p></li><li><p>将你注册的域名写入<code>CNAME</code></p></li><li><p>在github上托管你的博客的仓库的<code>setting</code>中，找到<code>github pages</code>，在<code>custom domain</code>中填入的你域名。</p></li></ul><p><img src="/.top//hexo-github%E5%8D%9A%E5%AE%A2%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D%5Cgymbd.png" alt="域名绑定2"></p><ul><li><p>进入阿里云控制台域名管理界面，点击解析。</p><p><img src="/.top//hexo-github%E5%8D%9A%E5%AE%A2%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D%5Cymbd1.png" alt="域名绑定1"></p></li><li><p>添加两条记录。</p></li></ul><p><img src="/.top//hexo-github%E5%8D%9A%E5%AE%A2%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D%5Cymbd2.png" alt="域名绑定2"></p><p><img src="/.top//hexo-github%E5%8D%9A%E5%AE%A2%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D%5Cymbd3.png" alt="域名绑定3"></p><ul><li>其中要填入的记录值可以通过ping你的github耳机域名获得</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping yourname.github.io</span><br></pre></td></tr></table></figure><ul><li><p>再次在本地将你的博客生成一遍，同步到github上之后就可以用你自己的域名访问啦。</p></li><li><p>基本命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo clean清空数据库和生成的静态网页文件</span><br><span class="line">hexo g生成静态网站</span><br><span class="line">hexo s本地预览网页情况（通过localhost:4000访问）</span><br><span class="line">hexo d同步到github上</span><br></pre></td></tr></table></figure></li></ul><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 博客相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客中添加图片</title>
      <link href="/passages/hexo-bo-ke-zhong-tian-jia-tu-pian/"/>
      <url>/passages/hexo-bo-ke-zhong-tian-jia-tu-pian/</url>
      
        <content type="html"><![CDATA[<p>本文使用的是安装插件的方式添加图片，需要其他方式的请另行百度。</p><a id="more"></a><ul><li><p>首先在主配置文件中将<code>post_asset_folder</code>设置为<code>true</code>。<br><img src="hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87%5Cconfig.png" alt="config"> </p></li><li><p>修改设置之后每次用<code>hexo n &quot;&quot;</code>创建文件是都会生成一个同名的文件夹，你所有的相关资源都应该放在这里面。</p></li><li><p>接下来需要安装一个插件，使用<code>npm install hexo-asset-image --save</code>安装。<br><img src="hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87%5Cchajian.png" alt="插件"></p></li><li><p>出现上述提示就表示安装好了，下面的warning可以不用在意。</p></li><li><p><a href="https://github.com/dangxuandev/hexo-asset-image" target="_blank" rel="noopener">插件位置</a></p></li><li><p>在文件中引用图片时使用<code>![文件替代文字](文件夹名/图片名)</code>即可。</p></li></ul><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 博客相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>苏州大学2018年复试上机题</title>
      <link href="/passages/su-zhou-da-xue-2018-nian-fu-shi-shang-ji-ti/"/>
      <url>/passages/su-zhou-da-xue-2018-nian-fu-shi-shang-ji-ti/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><ul><li>读取文件中的20000个数字，求其最大子集</li><li>子集中的数字互不为倍数，互不为因数，最大公约数为1</li><li>不允许使用预设的排序函数<code>qsort()</code></li></ul><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><ul><li><p>从二进制文件中读取数据（wb，rb）</p></li><li><p>排序（任意，这里使用的是选择排序）</p></li><li><p>首先判断是否为素数，加入结果集</p></li><li><p>对于非素数的数字，求其与结果集中的各个数字是否最大公约数全为1，加入结果集</p></li><li><p>将结果集写入文件中</p></li></ul><h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><ul><li><p><code>void make_data()</code></p><ul><li>生成数据集（1~500，排除3,5,7）</li></ul></li><li><p><code>void swap(int *a, int *b)</code></p><ul><li>交换传入的两个整数</li></ul></li><li><p><code>int compare(int a, int b)</code></p><ul><li>比较两个整数的大小</li></ul></li><li><p><code>int selection_sort(int *ptr)</code></p><ul><li>选择排序</li></ul></li><li><p><code>int is_prime(int n)</code></p><ul><li>判断传入的数字是否为素数</li></ul></li><li><p><code>int gcd(int a, int b)</code></p><ul><li>求两个数的最大公约数</li></ul></li><li><p><code>void filter_data(int *data, int *result)</code></p><ul><li>筛选符合条件的数据</li></ul></li><li><p><code>void display(int *ptr, int n)</code></p><ul><li>输出传入的数据集</li></ul></li><li><p><code>void output(int *result, int count)</code></p><ul><li>将结果集输出到文件</li></ul></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="comment">// 数据文件路径</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA_PATH <span class="meta-string">"C://Users//Y//Desktop//data.dat"</span></span></span><br><span class="line"><span class="comment">// 输出文件路径</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OUTPUT_PATH <span class="meta-string">"C://Users//Y//Desktop//output.txt"</span></span></span><br><span class="line"><span class="comment">// 文件中共20000条数据</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 20000</span></span><br><span class="line"><span class="comment">// 文件中数据的值位于1~500之间</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 500</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_data</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        生成数据</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 申请数据空间</span></span><br><span class="line">    <span class="keyword">int</span> *num = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*N);</span><br><span class="line">    <span class="keyword">int</span> i, n = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    FILE *fp = fopen(DATA_PATH, <span class="string">"wb"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成20000条数据</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">500</span>)</span><br><span class="line">            n = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">3</span> || n == <span class="number">5</span> || n == <span class="number">7</span>)</span><br><span class="line">            n++;</span><br><span class="line"></span><br><span class="line">        num[i] = n;</span><br><span class="line">        <span class="comment">// debug</span></span><br><span class="line">        <span class="comment">// printf("%d ", num[i]);</span></span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printf("source:\n");</span></span><br><span class="line">    <span class="comment">// display(num, N);</span></span><br><span class="line">    <span class="comment">// 将数据写入文件中</span></span><br><span class="line">    fwrite(num, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), N, fp);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(num);</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        交换传入的两个数字</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        比较传入的两个数字的大小</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(a &lt; b)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a == b)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span> *ptr)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        选择排序</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = i + <span class="number">1</span>; j &lt; N; j++)</span><br><span class="line">            <span class="keyword">if</span>(compare(ptr[i], ptr[j]) &gt; <span class="number">0</span>)</span><br><span class="line">                swap(&amp;ptr[i], &amp;ptr[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_prime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        判断传入的数字是否为素数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>; i*i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        求两个数字的最大公约数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(a % b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">return</span> gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">filter_data</span><span class="params">(<span class="keyword">int</span> *data, <span class="keyword">int</span> *result)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        筛选数据</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> result_count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="comment">// printf("data[%d] = %d\n", i, data[i]);</span></span><br><span class="line">        <span class="keyword">if</span>(data[i] &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(is_prime(data[i]))&#123;</span><br><span class="line">            <span class="comment">// 素数，且未在结果集中</span></span><br><span class="line">            <span class="comment">// printf("\nis prime\n");</span></span><br><span class="line">            <span class="keyword">for</span>(j = result_count - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(data[i] == result[j])</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">-1</span>)</span><br><span class="line">                <span class="comment">// debug</span></span><br><span class="line">                <span class="comment">// printf("result_count = %d", result_count);</span></span><br><span class="line"></span><br><span class="line">                result[result_count++] = data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 是否与结果集最大公约均数为1</span></span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; result_count; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(gcd(data[i], result[j]) != <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j == result_count)</span><br><span class="line">                result[result_count++] = data[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result_count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *data, <span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        输出传入的整数集</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *result, <span class="keyword">int</span> result_count)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        将结果集输出到文件中</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    FILE *fp = fopen(OUTPUT_PATH, <span class="string">"w"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; result_count; i++)&#123;</span><br><span class="line">        <span class="comment">// printf("%d ", result[i]);</span></span><br><span class="line">        <span class="built_in">fprintf</span>(fp, <span class="string">"%d "</span>, result[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *data, *result;</span><br><span class="line">    <span class="keyword">int</span> result_count;</span><br><span class="line">    FILE* fp;</span><br><span class="line"></span><br><span class="line">    data = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*N);</span><br><span class="line">    result = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成数据</span></span><br><span class="line">    make_data();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取数据</span></span><br><span class="line">    fp = fopen(DATA_PATH, <span class="string">"rb"</span>);</span><br><span class="line">    fread(data, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), N, fp);</span><br><span class="line">    <span class="comment">// 输出读取的数据</span></span><br><span class="line">    <span class="comment">// printf("\ndata: \n");</span></span><br><span class="line">    <span class="comment">// display(data, N);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    selection_sort(data);</span><br><span class="line">    <span class="comment">// 排序后的数据</span></span><br><span class="line">    <span class="comment">// printf("\nsort:\n");</span></span><br><span class="line">    <span class="comment">// display(data, N);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 筛选数据，返回数据个数</span></span><br><span class="line">    result_count = filter_data(data, result);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\nresult_count: %d\n"</span>, result_count);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结果输出到文件</span></span><br><span class="line">    output(result, result_count);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    display(result, result_count);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(result);</span><br><span class="line">    <span class="built_in">free</span>(data);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 研究生复试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 研究生复试 </tag>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu下安装docker</title>
      <link href="/passages/ubuntu-xia-an-zhuang-docker/"/>
      <url>/passages/ubuntu-xia-an-zhuang-docker/</url>
      
        <content type="html"><![CDATA[<p>ubuntu &amp; docker</p><a id="more"></a><h3 id="ubuntu中安装的docker"><a href="#ubuntu中安装的docker" class="headerlink" title="ubuntu中安装的docker"></a>ubuntu中安装的docker</h3><ul><li><p>系统版本ubuntu server 16.04</p></li><li><p>卸载可能存在的旧版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get remove docker docker-engine docker-ce docker.io</span></span><br></pre></td></tr></table></figure></li><li><p>更新apt包索引</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get update</span></span><br></pre></td></tr></table></figure></li><li><p>安装以下包使apt可以通过https使用存储库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install -y apt-transport-https ca-certificates curl software-properties-common</span></span><br></pre></td></tr></table></figure></li><li><p>添加docker官方GPG密钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span></span><br></pre></td></tr></table></figure></li><li><p>设置<strong>stable</strong>存储库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo add-apt-repository <span class="string">"deb [arch=amd64] https://download.docker.com/linux/ubuntu <span class="variable">$(lsb_release -cs)</span> stable"</span></span></span><br></pre></td></tr></table></figure></li><li><p>更新apt索引包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get update</span></span><br></pre></td></tr></table></figure></li><li><p>安装最新版本的Docker CE</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> apt-cache madison docker-ce</span></span><br></pre></td></tr></table></figure></li><li><p>可安装列表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> apt-cache madison docker-ce</span></span><br></pre></td></tr></table></figure></li><li><p>安装指定版本的docker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install docker-ce=&lt;VERSION&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="docker基本命令"><a href="#docker基本命令" class="headerlink" title="docker基本命令"></a>docker基本命令</h3><ul><li><p>启动docker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl start docker</span></span><br></pre></td></tr></table></figure></li><li><p>查看docker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> systemctl status docker</span></span><br></pre></td></tr></table></figure></li><li><p>关闭docker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl stop docker</span></span><br></pre></td></tr></table></figure></li></ul><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 工具配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xshell连接虚拟机</title>
      <link href="/passages/xshell-lian-jie-xu-ni-ji/"/>
      <url>/passages/xshell-lian-jie-xu-ni-ji/</url>
      
        <content type="html"><![CDATA[<p>xshell</p><a id="more"></a><ul><li><p>查看虚拟机ip</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ipconfig</span></span><br></pre></td></tr></table></figure></li><li><p>从<a href="https://pan.baidu.com/s/1OlBSYFjdk9oDXot_V9VZUg" target="_blank" rel="noopener">这里</a>下载xshell6。</p></li><li><p>启动xshell6，依次选择<code>文件-&gt;新建</code>，协议选择ssh，ip填入第一步查找到的ip，端口为22。</p></li><li><p>ubuntu中安装<code>openssh</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install openssh-server</span><br></pre></td></tr></table></figure></li><li><p>安装openssh报错</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree       </span><br><span class="line">Reading state information... Done</span><br><span class="line">Some packages could not be installed. This may mean that you have</span><br><span class="line">requested an impossible situation or if you are using the unstable</span><br><span class="line">distribution that some required packages have not yet been created</span><br><span class="line">or been moved out of Incoming.</span><br><span class="line">The following information may help to resolve the situation:</span><br><span class="line"></span><br><span class="line">The following packages have unmet dependencies:</span><br><span class="line"> openssh-server : Depends: openssh-client (= 1:7.2p2-4ubuntu2.8)</span><br><span class="line">                  Depends: openssh-sftp-server but it is not going to be installed</span><br><span class="line">                  Recommends: ssh-import-id but it is not going to be installed</span><br><span class="line">E: Unable to correct problems, you have held broken packages.</span><br></pre></td></tr></table></figure><ul><li><p>需卸载掉默认安装的openssh-client（因版本较新，而openssh-server依赖的版本较旧）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get  autoremove  openssh-client</span><br></pre></td></tr></table></figure></li><li><p>然后再重新安装它们：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-client openssh-server</span><br></pre></td></tr></table></figure></li><li><p>启动sshd服务:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/ssh start</span><br></pre></td></tr></table></figure></li><li><p>查看ssh是否成功启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service sshd status</span><br></pre></td></tr></table></figure></li><li><p>设置ssh开机自启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig sshd on</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 工具配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vs2010的简单使用</title>
      <link href="/passages/vs2010-de-jian-dan-shi-yong/"/>
      <url>/passages/vs2010-de-jian-dan-shi-yong/</url>
      
        <content type="html"><![CDATA[<p>复试的上机要求使用vs2010编写c语言控制台程序。之前没有用过这款软件，与codeblocks还是有很大差异的，这里记录一些使用的方法，希望对后来人有帮助。</p><p>研究生复试的上机要求使用vs2010编写c语言控制台程序。之前没有用过这款软件，与codeblocks还是有很大差异的，这里记录一些使用的方法，希望对后来人有帮助。</p><a id="more"></a><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><ul><li>打开vs2010，在右上方菜单栏选择<code>文件-&gt;新建-&gt;项目</code>。</li><li>选择<code>win32控制台应用程序</code>，填写项目名称，文件存储位置。</li><li>在应用程序向导中注意<code>应用程序类型</code>选择<code>控制台应用程序</code>，<code>附加选项</code>勾选<code>空项目</code>，取消勾选<code>预编译头</code>。</li></ul><h3 id="添加源文件"><a href="#添加源文件" class="headerlink" title="添加源文件"></a>添加源文件</h3><ul><li>在项目文件夹中<code>源文件</code>文件夹上选择<code>添加-&gt;新建项</code>。</li><li>选择<code>c++文件</code>，填写文件名即可。</li></ul><h3 id="生成程序"><a href="#生成程序" class="headerlink" title="生成程序"></a>生成程序</h3><ul><li>编写完代码后，点击上方工具栏中的<code>生成-&gt;编译</code>完成<strong>编译</strong>工作。</li><li>编译完成后在菜单栏选择<code>项目-&gt;仅用于项目-&gt;仅链接“项目名”</code>完成<strong>链接</strong>工作。</li><li>可在文件夹中点击<code>文件名.exe</code>执行，也可以直接使用<code>F5</code>运行。</li></ul><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><ul><li>找到一个位置，<code>右键-&gt;断点-&gt;插入断点</code>。</li><li>按<code>F5</code>运行程序，程序会运行到断点位置，软件面板下方看到当前变量 的值</li><li>按<code>ctrl + F11</code>快捷键，程序会单步执行，下方显示变量的当前值</li><li>在调试过程中鼠标悬停在变量上可以查看变量当前的值</li><li>选中变量可以添加监视，在下方<code>监视</code>中查看</li></ul><h3 id="关于安全周期检测"><a href="#关于安全周期检测" class="headerlink" title="关于安全周期检测"></a>关于安全周期检测</h3><ul><li>使用<code>scanf</code>和<code>printf</code>，在编译时会提醒<code>该方法不安全</code>，需要使用<code>scanf_s</code></li><li>在项目文件夹上右键<code>属性-&gt;配置属性-&gt;C\C++-&gt;预处理器-&gt;右侧下拉菜单中点击编辑-&gt;添加——CRT_SECURE_NO_DEPRECATE</code> </li></ul><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 工具配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu修改软件源</title>
      <link href="/passages/ubuntu-xiu-gai-ruan-jian-yuan/"/>
      <url>/passages/ubuntu-xiu-gai-ruan-jian-yuan/</url>
      
        <content type="html"><![CDATA[<p>ubuntu软件源</p><a id="more"></a><h3 id="图形界面下"><a href="#图形界面下" class="headerlink" title="图形界面下"></a>图形界面下</h3><ol><li>在设置中的”软件和更新“中</li><li>修改Download from为Other</li><li>在弹出框汇中选择China</li><li>选择mirrors.aliyun.com</li><li>点击 Choose Server</li></ol><h3 id="非图形界面下"><a href="#非图形界面下" class="headerlink" title="非图形界面下"></a>非图形界面下</h3><ul><li>备份/etc/apt/sources.list<br><code>cp /etc/apt/sources.list    /etc/apt/souces.list.bak</code></li><li>修改文件内容<code>sudo gedit /etc/apt/sources.list</code>修改为：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial main restricted universe multiverse </span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-security main restricted universe multiverse </span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-updates main restricted universe multiverse </span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-backports main restricted universe multiverse ##测试版源 </span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-proposed main restricted universe multiverse # 源码 </span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial main restricted universe multiverse </span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-security main restricted universe multiverse </span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-updates main restricted universe multiverse </span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-backports main restricted universe multiverse ##测试版源 </span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-proposed main restricted universe multiverse # Canonical 合作伙伴和附加 </span><br><span class="line">deb http:&#x2F;&#x2F;archive.canonical.com&#x2F;ubuntu&#x2F; xenial partner </span><br><span class="line">deb http:&#x2F;&#x2F;extras.ubuntu.com&#x2F;ubuntu&#x2F; xenial main</span><br></pre></td></tr></table></figure><ul><li>保存 退出</li><li>运行<code>sudo apt update</code>使更新生效</li></ul><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 工具配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>win7下安装ubuntu双系统</title>
      <link href="/passages/win7-xia-an-zhuang-ubuntu-shuang-xi-tong/"/>
      <url>/passages/win7-xia-an-zhuang-ubuntu-shuang-xi-tong/</url>
      
        <content type="html"><![CDATA[<p>windows &amp; ubuntu</p><a id="more"></a><ul><li><p>工具：</p><ul><li><p>ubuntu16.04 64位</p></li><li><p>easyBCD</p><ul><li>UltraISO</li></ul></li></ul></li><li><p>步骤：</p><ul><li><p>在硬盘上划分区域</p><ul><li><p>我的电脑-&gt;右键-&gt;管理-&gt;磁盘管理</p></li><li><p>选择较大的盘符-&gt;右键-&gt;压缩卷-&gt;选择压缩的大小（用于安装系统的磁盘）</p></li></ul></li><li><p>制作启动盘：</p><ul><li><p>格式化u盘，注意选择fat32格式</p></li><li><p>打开UltraISO软件</p></li><li><p>选择ubuntu16.04镜像</p></li><li><p>点击启动-&gt;写入硬盘镜像</p></li><li><p>写入方式为usb-HDD+</p></li><li><p>点击便捷启动-&gt;写入新的驱动器引导扇区-&gt;Syslinux</p></li><li><p>点击写入，等待文件拷贝完成</p></li></ul></li><li><p>安装系统</p><ul><li><p>将系统启动盘插在电脑上</p></li><li><p>重启电脑，进入启动项选择，选择U盘启动</p></li><li><p>进入安装界面-&gt;选择中文或英文-&gt;点击安装Ubuntu</p></li><li><p>准备界面，可以联网安装，也可以安装完成后手动更I型呢</p></li><li><p>安装类型-&gt;选择其他选项</p></li><li><p>分区设置-&gt;选中刚才分好的空闲分区（可能不是“空闲“，点击“-”即可）</p></li><li><p>新建分区-&gt;点击”+“-&gt;”用于“设置成交换空间，分区类型-&gt;逻辑分区（小于物理机内存即可，例如8000M）,</p></li><li><p>新建分区-&gt;点击”+“-&gt;设置ubuntu的启动引导分区（200M差不多就够了），用于Ext4日志文件系统，挂载点/boot</p></li><li><p>新建分区-&gt;设置”/“主分区，相当于Win7的系统C盘,同样的方法,将剩余空间设置“/home”分区,用于存在文件。</p></li><li><p>点击”继续“-&gt;”继续“-&gt;安装</p></li></ul></li></ul></li><li><p>easyBCD修改系统启动项</p><ul><li>添加新引导-&gt;选择linux-&gt;Drive选择刚才设置的/boot分区</li></ul></li></ul><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 工具配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centos6下升级内核并安装docker</title>
      <link href="/passages/centos6-xia-nei-he-sheng-ji-ji-docker-an-zhuang/"/>
      <url>/passages/centos6-xia-nei-he-sheng-ji-ji-docker-an-zhuang/</url>
      
        <content type="html"><![CDATA[<p>centos内核升级及docker安装</p><a id="more"></a><h3 id="升级内核"><a href="#升级内核" class="headerlink" title="升级内核"></a>升级内核</h3><ul><li><p>查看系统版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/issue</span><br></pre></td></tr></table></figure></li><li><p>查看内核版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure></li><li><p>导入<code>public key</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</span><br></pre></td></tr></table></figure></li><li><p>安装ml内核（主线最新版本）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum --enablerepo=elrepo-kernel -y install kernel-ml</span><br></pre></td></tr></table></figure></li><li><p>安装lt内核（长期支持版本）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum --enablerepo=elrepo-kernel -y install kernel-lt</span><br></pre></td></tr></table></figure></li></ul><p><strong>以上两个版本二选一即可</strong></p><ul><li><p>修改主配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;grub,conf</span><br><span class="line"></span><br><span class="line">将default&#x3D;1改为default&#x3D;0</span><br></pre></td></tr></table></figure></li><li><p>重启系统即可</p></li></ul><ul><li>导入<code>public key</code>时若报错</li></ul><blockquote><p>error: <a href="https://www.elrepo.org/RPM-GPG-KEY-elrepo.org" target="_blank" rel="noopener">https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</a>: import read failed(2).</p><p>使用<strong>yum -y update nss</strong>即可</p></blockquote><h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><ul><li><p>使用<code>yum install docker-io</code>安装</p></li><li><p>报错</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">No package docker-io available.</span><br><span class="line">Error: Nothing to do</span><br></pre></td></tr></table></figure></li><li><p><code>yum install docker-io</code>，这句话是用源安装docker，可是源一般是国外源，用这个命令因为GFW被墙，根本安装不了。</p></li><li><p>使用以下命令安装即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install https:&#x2F;&#x2F;get.docker.com&#x2F;rpm&#x2F;1.7.1&#x2F;centos-6&#x2F;RPMS&#x2F;x86_64&#x2F;docker-engine-1.7.1-1.el6.x86_64.rpm</span><br></pre></td></tr></table></figure></li></ul><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 工具配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>苏州大学2013年复试上机题</title>
      <link href="/passages/su-zhou-da-xue-2013-nian-fu-shi-shang-ji-ti/"/>
      <url>/passages/su-zhou-da-xue-2013-nian-fu-shi-shang-ji-ti/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><ul><li><p>从一个文件中读取航班信息，从另一个文件中读取航班路径请求，并输出需要的信息。</p></li><li><p>判断一个特定的机场能否经过指定次数的跳数到达指定机场。一次跳跃是指从始发机场到目的地之间的一次任意两个机场之间的航行</p></li><li><p>例如：<code>PVG</code>到<code>PEK</code>是<code>PVG-&gt;CAN-&gt;PEK</code>。所以<code>PVG-&gt;CAN</code>是一跳，<code>CAN-&gt;PEK</code>也是一跳。</p></li><li><p>路径输入文件<code>PathInput_2013.txt</code>，文件包含多对始发点与终点的序列，文件第一行有一个数字，表示有多少个数据对。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">[PVG, CAN]</span><br><span class="line">[CAN, PEK]</span><br><span class="line">[PVG, CTU]</span><br><span class="line">[CTU, DLC]</span><br><span class="line">[DLC, HAK]</span><br><span class="line">[HAK, LXA]</span><br></pre></td></tr></table></figure></li><li><p>路径请求文件<code>PathRequest_2013.txt</code>，文件中包含一系列序列[起始点，终点]及最大跳数，第一行是一个数字，表示有多少个序列。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line">[PVG, DLC, <span class="number">2</span>]</span><br><span class="line">[PVG, LXA, <span class="number">2</span>]</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>输出文件<code>Output.txt</code>，对于请求文件中的每个请求，输出请求并在其后跟<code>YES</code>或<code>NO</code>,表示是否能在指定跳数之内完成请求。</p></li><li><p>每个机场名均为三个大写字母，任意[起始/终点]对之间均是单向的。</p></li></ul><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><ul><li>使用图解决问题</li><li>图使用邻接表存储图</li><li>根据<code>Pathinput.txt</code>中的序列建立邻接表</li><li>使用深度优先遍历判断图中初始点和终点之间是否有同路且跳数是否符合要求</li></ul><h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><ul><li><code>struct Edge</code>：边结点</li><li><code>struct Vertex</code>：顶点</li><li><code>struct Graph</code>：图</li><li><code>int find(Vertex* vertices, int count, char  src[4])</code>：从顶点表中查找指定的结点，并返回下标</li><li><code>void add_edge(Graph* g, char src[4], char dst[4])</code>：构造邻接表</li><li><code>bool is_possible(Graph* g, bool* visited, char src[4], char dst[4],int step)</code>：<ul><li>判断两个点之间是否可达</li><li>深度优先遍历</li></ul></li><li><code>void destruct(Graph* g)</code>：释放邻接表</li><li><code>void display(Graph* g)</code>：输出图</li><li><code>int main()</code>：<ul><li>打开文件</li><li>读取<code>PathInput.txt</code>文件</li><li>读取<code>PathRequest.txt</code>文件</li><li>判断是否满足</li></ul></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接表数据结构</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="comment">// 边结点</span></span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">char</span> city[<span class="number">4</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;Edge;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="comment">// 顶点</span></span><br><span class="line">    <span class="keyword">char</span> city[<span class="number">4</span>];</span><br><span class="line">    Edge* first;</span><br><span class="line">&#125;Vertex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="comment">// 图中的结点</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line">    Vertex* vertices;</span><br><span class="line">&#125;Graph;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(Vertex* vertices, <span class="keyword">int</span> count, <span class="keyword">char</span> src[<span class="number">4</span>])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从顶点表中查找指定的结点，并返回下标</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(src, vertices[i].city) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(Graph* g, <span class="keyword">char</span> src[<span class="number">4</span>], <span class="keyword">char</span> dst[<span class="number">4</span>])</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    Edge* e;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加起始点</span></span><br><span class="line">    i = <span class="built_in">find</span>(g-&gt;vertices, g-&gt;<span class="built_in">size</span>, src);</span><br><span class="line">    <span class="keyword">if</span>(i == g-&gt;<span class="built_in">size</span>)&#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(g-&gt;vertices[g-&gt;<span class="built_in">size</span>].city, src);</span><br><span class="line">        g-&gt;vertices[g-&gt;<span class="built_in">size</span>].first = <span class="literal">NULL</span>;</span><br><span class="line">        g-&gt;<span class="built_in">size</span>++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加终点</span></span><br><span class="line">    j = <span class="built_in">find</span>(g-&gt;vertices, g-&gt;<span class="built_in">size</span>, dst);</span><br><span class="line">    <span class="keyword">if</span>(j == g-&gt;<span class="built_in">size</span>)&#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(g-&gt;vertices[g-&gt;<span class="built_in">size</span>].city, dst);</span><br><span class="line">        g-&gt;vertices[g-&gt;<span class="built_in">size</span>].first = <span class="literal">NULL</span>;</span><br><span class="line">        g-&gt;<span class="built_in">size</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找终点</span></span><br><span class="line">    <span class="keyword">for</span>(e = g-&gt;vertices[i].first; e != <span class="literal">NULL</span>; e = e-&gt;next)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(e-&gt;city, dst) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 图中未发现终点，将其添加到图的首部</span></span><br><span class="line">    <span class="keyword">if</span>(e == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        e = (Edge*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Edge));</span><br><span class="line">        <span class="built_in">strcpy</span>(e-&gt;city, dst);</span><br><span class="line">        e-&gt;index = j;</span><br><span class="line">        e-&gt;next = g-&gt;vertices[i].first;</span><br><span class="line">        g-&gt;vertices[i].first = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_possible</span><span class="params">(Graph* g, <span class="keyword">bool</span>* visited, <span class="keyword">char</span> src[], <span class="keyword">char</span> dst[], <span class="keyword">int</span> <span class="built_in">step</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        判断两个节点之间是否可达</span></span><br><span class="line"><span class="comment">        深度优先遍历</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> current;</span><br><span class="line">    Edge* e;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在图中查找起始点</span></span><br><span class="line">    current = <span class="built_in">find</span>(g-&gt;vertices, g-&gt;<span class="built_in">size</span>, src);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已经被访问过或</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">step</span> == <span class="number">0</span> || visited[current])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        visited[current] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(e = g-&gt;vertices[current].first; e != <span class="literal">NULL</span>; e = e-&gt;next)&#123;</span><br><span class="line">            <span class="comment">// 以起始点直接可达的点钟是否有终点</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strcmp</span>(e-&gt;city, dst) == <span class="number">0</span> &amp;&amp; <span class="built_in">step</span> == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(is_possible(g, visited, e-&gt;city, dst, <span class="built_in">step</span> - <span class="number">1</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[current] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destruct</span><span class="params">(Graph* g)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        释放图的内存空间</span></span><br><span class="line"><span class="comment">        按行消除</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; g-&gt;<span class="built_in">size</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(g-&gt;vertices[i].first != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            Edge* e = g-&gt;vertices[i].first-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(g-&gt;vertices[i].first);</span><br><span class="line">            g-&gt;vertices[i].first = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(g-&gt;vertices);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(Graph* g)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    Edge* edge;</span><br><span class="line">    <span class="comment">// 邻接列表</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"adjacency list:\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; g-&gt;<span class="built_in">size</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s: "</span>, g-&gt;vertices[i].city);</span><br><span class="line">        <span class="keyword">for</span>(edge = g-&gt;vertices[i].first; edge != <span class="literal">NULL</span>; edge = edge-&gt;next)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s "</span>, edge-&gt;city);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FILE* fpi = fopen(<span class="string">"PathInput_2013.txt"</span>, <span class="string">"r"</span>);</span><br><span class="line">    FILE* fpr = fopen(<span class="string">"PathRequest_2013.txt"</span>, <span class="string">"r"</span>);</span><br><span class="line">    FILE* fpo = fopen(<span class="string">"Output_2013.txt"</span>, <span class="string">"w"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">line</span>[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">char</span> src[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">char</span> dst[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span>* visited;  <span class="comment">// 访问标识</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">step</span>;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    Graph g;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 三个文件均被成功打开</span></span><br><span class="line">    <span class="keyword">if</span>(!fpi || !fpr || !fpo)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"failed to open files.\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全部初试化为0</span></span><br><span class="line">    <span class="built_in">memset</span>(<span class="built_in">line</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="built_in">line</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从文件中读取第一行的数字</span></span><br><span class="line">    <span class="keyword">if</span>(fgets(<span class="built_in">line</span>, <span class="keyword">sizeof</span>(<span class="built_in">line</span>), fpi) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        g.<span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 将字符串转化成int</span></span><br><span class="line">        g.capacity = atoi(<span class="built_in">line</span>) * <span class="number">2</span>;</span><br><span class="line">        g.vertices = (Vertex*)<span class="built_in">malloc</span>(g.capacity * <span class="keyword">sizeof</span>(Vertex));</span><br><span class="line">        <span class="built_in">memset</span>(g.vertices, <span class="number">0</span>, g.capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取序列并用邻接表</span></span><br><span class="line">    <span class="keyword">while</span>(fgets(<span class="built_in">line</span>, <span class="keyword">sizeof</span>(<span class="built_in">line</span>), fpi) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">// 读取起始点</span></span><br><span class="line">        <span class="built_in">memcpy</span>(src, <span class="built_in">line</span> + <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">        src[<span class="number">3</span>] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="comment">// 读取终点</span></span><br><span class="line">        <span class="built_in">memcpy</span>(dst, <span class="built_in">line</span> + <span class="number">6</span>, <span class="number">3</span>);</span><br><span class="line">        dst[<span class="number">3</span>] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="comment">// 添加边</span></span><br><span class="line">        add_edge(&amp;g, src, dst);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">display</span>(&amp;g);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出航班信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"flight info:\n"</span>);</span><br><span class="line">    visited = (<span class="keyword">bool</span>*)<span class="built_in">malloc</span>(g.<span class="built_in">size</span>);</span><br><span class="line">    <span class="keyword">if</span>(fgets(<span class="built_in">line</span>, <span class="keyword">sizeof</span>(<span class="built_in">line</span>), fpr) != <span class="literal">NULL</span>)</span><br><span class="line">        num = atoi(<span class="built_in">line</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取请求文件</span></span><br><span class="line">    <span class="keyword">while</span>(fgets(<span class="built_in">line</span>, <span class="keyword">sizeof</span>(<span class="built_in">line</span>), fpr) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(src, <span class="built_in">line</span> + <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">        src[<span class="number">3</span>] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(dst, <span class="built_in">line</span> + <span class="number">6</span>, <span class="number">3</span>);</span><br><span class="line">        dst[<span class="number">3</span>] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="built_in">step</span> = <span class="built_in">line</span>[<span class="number">11</span>] - <span class="string">'0'</span>;</span><br><span class="line">        <span class="built_in">memset</span>(visited, <span class="literal">false</span>, g.<span class="built_in">size</span>);</span><br><span class="line">        <span class="comment">// 判断是否可行</span></span><br><span class="line">        <span class="keyword">if</span>(is_possible(&amp;g, visited, src, dst, <span class="built_in">step</span>))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[%s, %s, %d, YES]\n"</span>, src, dst, <span class="built_in">step</span>);</span><br><span class="line">            <span class="built_in">fprintf</span>(fpo, <span class="string">"[%s, %s, YES]\n"</span>, src, dst);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[%s, %s, %d, NO]\n"</span>, src, dst, <span class="built_in">step</span>);</span><br><span class="line">            <span class="built_in">fprintf</span>(fpo, <span class="string">"[%s, %s, NO]\n"</span>, src, dst);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放内存和关闭文件</span></span><br><span class="line">    destruct(&amp;g);</span><br><span class="line">    <span class="built_in">free</span>(visited);</span><br><span class="line">    fclose(fpi);</span><br><span class="line">    fclose(fpr);</span><br><span class="line">    fclose(fpo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 研究生复试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 研究生复试 </tag>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>苏州大学2017年保研上机题</title>
      <link href="/passages/su-zhou-da-xue-2017-nian-bao-yan-shang-ji-ti/"/>
      <url>/passages/su-zhou-da-xue-2017-nian-bao-yan-shang-ji-ti/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><ul><li><p>文本文件<code>input.txt</code>里面放了一堆整数，仅仅以空格分割，其中第一个整数为<code>k</code>，第二个整数代表维度，剩余的整数作为点的坐标。</p></li><li><p>读取整数<code>k</code>和维度，并读取剩余的整数组成指定维度的点。</p></li><li><p>从所有点钟找到距离最近的两个点并输出它们的坐标和距离。</p></li><li><p>分别输出距离这两个点最近的<code>k</code>个点的坐标。</p></li></ul><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><ul><li>先读取文件中的前两个数，第一个k，第二个是dimension，后面每dimension个数字组成一个点</li><li>循环计算距离最近的两个点，输出这两个点及其距离</li><li>对这两个点分别计算所有点到其距离，输出最近的k个</li><li>一开始点的维数未知，故点的结构体中使用指针存储坐标，每读取一个点申请一个整形的空间</li></ul><h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><ul><li><code>struct Point</code>：坐标点的结构体</li><li><code>double distance(Point* a,Point* b)</code>：计算两个点之间的距离</li><li><code>void swap(Point* a, Point* b)</code>：交换传入的两个坐标点</li><li><code>int compare(Point* a, Point* b)</code>：比较传入的两个点与指定点之间的距离</li><li><code>void selection_sort(Point* points, int begin, int end)</code>：选择排序</li><li><code>void sorted_by_distance(Point* points, int begin, int end, int pivot)</code>：根据与指定点知道见的距离排序</li><li><code>void display_point(Point* p)</code>：显示一个点</li><li><code>void display_all(Point* points, int count)</code>：显示所有点</li><li><code>display_nearest(Point* points, int count, int pivot, int k)</code>：显示离指定点最近的k个点</li><li><code>int main()</code>：<ul><li>统计文件中的整数个数</li><li>读取前两个数字</li><li>按照维度读取每个坐标点</li><li>双循环查找最近的两个坐标点</li><li>查找并输出离这两个点最近的k个点</li></ul></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;float.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span>* <span class="built_in">vector</span>;    <span class="comment">// 坐标维度未知，使用指针</span></span><br><span class="line">    <span class="keyword">int</span> dimension;  <span class="comment">// 坐标维度</span></span><br><span class="line">&#125;Point;</span><br><span class="line"></span><br><span class="line">Point <span class="built_in">point</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">distance</span><span class="params">(Point* a, Point* b)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        求传入的两个点之间的距离</span></span><br><span class="line"><span class="comment">        fabs(), 求浮点数的绝对值</span></span><br><span class="line"><span class="comment">        pow(x, y),求x的y次方</span></span><br><span class="line"><span class="comment">        sqrt(),开根号</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">double</span> dist = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; a-&gt;dimension; i++)&#123;</span><br><span class="line">        dist += <span class="built_in">pow</span>(<span class="built_in">fabs</span>(a-&gt;<span class="built_in">vector</span>[i] - b-&gt;<span class="built_in">vector</span>[i])*<span class="number">1.0</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(dist);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Point* a, Point* b)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        交换传入的两个点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    Point temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(Point* a, Point* b)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        比较传入的两点浴指定点之间的距离</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">double</span> dista = distance(a, &amp;<span class="built_in">point</span>);</span><br><span class="line">    <span class="keyword">double</span> distb = distance(b, &amp;<span class="built_in">point</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dista &lt; distb)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(dista &gt; distb)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(dista == distb)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(Point* points, <span class="keyword">int</span> <span class="built_in">begin</span>, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        根据与指定点之间的距离选择排序</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="built_in">begin</span>; i &lt; <span class="built_in">end</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = i+<span class="number">1</span>; j &lt; <span class="built_in">end</span>; j++)</span><br><span class="line">            <span class="keyword">if</span>(compare(&amp;points[i], &amp;points[j]) &gt; <span class="number">0</span>)</span><br><span class="line">                swap(&amp;points[i], &amp;points[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sorted_by_distance</span><span class="params">(Point* points, <span class="keyword">int</span> <span class="built_in">begin</span>, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">int</span> pivot)</span></span>&#123;</span><br><span class="line">    <span class="built_in">point</span> = points[pivot];</span><br><span class="line">    selection_sort(points, <span class="built_in">begin</span>, <span class="built_in">end</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_point</span><span class="params">(Point* p)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        输出一个点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"("</span>);</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; p-&gt;dimension - <span class="number">1</span>; j++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%2d, "</span>, p-&gt;<span class="built_in">vector</span>[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%2d)"</span>, p-&gt;<span class="built_in">vector</span>[p-&gt;dimension<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_all</span><span class="params">(Point* points, <span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        输出所有点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">        display_point(&amp;points[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_nearest</span><span class="params">(Point* points, <span class="keyword">int</span> count, <span class="keyword">int</span> pivot, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        输出离指定点最近的k个点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    sorted_by_distance(points, <span class="number">0</span>, count, pivot);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"the nearest %d points to "</span>, k);</span><br><span class="line">    display_point(&amp;points[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line">        display_point(&amp;points[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FILE* fp = fopen(<span class="string">"input_2017bao.txt"</span>, <span class="string">"r"</span>);</span><br><span class="line">    Point* points;</span><br><span class="line">    <span class="keyword">int</span> k, dimension, val, count, point_count;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计文件中国的数字个数</span></span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">fscanf</span>(fp, <span class="string">"%s"</span>, &amp;val) != EOF)</span><br><span class="line">        count++;</span><br><span class="line">    rewind(fp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取k和维度</span></span><br><span class="line">    <span class="built_in">fscanf</span>(fp, <span class="string">"%d"</span>, &amp;k);</span><br><span class="line">    <span class="built_in">fscanf</span>(fp, <span class="string">"%d"</span>, &amp;dimension);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"k = %d\ndimension = %d\n"</span>, k, dimension);</span><br><span class="line">    <span class="comment">// 计算点的个数</span></span><br><span class="line">    point_count = (count - <span class="number">2</span>) / dimension;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申请存储空间</span></span><br><span class="line">    points = (Point*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Point) * point_count);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; point_count; i++)&#123;</span><br><span class="line">        points[i].dimension = dimension;</span><br><span class="line">        <span class="comment">// 申请一个点的存储空间</span></span><br><span class="line">        points[i].<span class="built_in">vector</span> = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*)*dimension);</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; dimension; j++)</span><br><span class="line">            <span class="built_in">fscanf</span>(fp, <span class="string">"%d"</span>, &amp;points[i].<span class="built_in">vector</span>[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 显示所有点</span></span><br><span class="line">    display_all(points, point_count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lhs, rhs, pivot;</span><br><span class="line">    <span class="keyword">double</span> <span class="built_in">min</span> = distance(&amp;points[<span class="number">0</span>], &amp;points[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(pivot = <span class="number">0</span>; pivot &lt; point_count - <span class="number">1</span>; pivot++)&#123;</span><br><span class="line">        sorted_by_distance(points, pivot + <span class="number">1</span>, point_count, pivot);</span><br><span class="line">        <span class="keyword">if</span>(distance(&amp;points[pivot], &amp;points[pivot+<span class="number">1</span>]) &lt; <span class="built_in">min</span>)&#123;</span><br><span class="line">            lhs = pivot;</span><br><span class="line">            rhs = pivot + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">min</span> = distance(&amp;points[pivot], &amp;points[pivot + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"the shortest distance: %f\n"</span>, <span class="built_in">min</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"the nearest two points:\n"</span>);</span><br><span class="line">    display_point(&amp;points[lhs]);</span><br><span class="line">    display_point(&amp;points[rhs]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    display_nearest(points, point_count, lhs, k);</span><br><span class="line">    display_nearest(points, point_count, <span class="number">1</span>, k);</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 研究生复试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 研究生复试 </tag>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>苏州大学2016年保研上机题</title>
      <link href="/passages/su-zhou-da-xue-2016-nian-bao-yan-shang-ji-ti/"/>
      <url>/passages/su-zhou-da-xue-2016-nian-bao-yan-shang-ji-ti/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><ul><li><p>从服务器上将两个数据文件<code>input.txt</code>和<code>words.txt</code>下载到本地电脑根文件夹。</p></li><li><p>在<code>words.txt</code>中存储了不超过<code>30000</code>条的英文单词，每个单词占一行。单词最大长度为<code>20</code>，且单词内没有空格，文件中无重复单词。</p></li><li><p><code>input.txt</code>中存储了一个<code>丢失了空格和标点符号的英文文章。每行不超过</code>128`个字符，请将第一行和最后一行显示在屏幕上。</p></li><li><p>将<code>words.txt</code>中的最后三行显示在屏幕上。</p></li><li><p>利用<code>words.txt</code>中的单词作为字典，采用正向最大匹配切分单词算法（从左往右匹配，尽量取长词）对<code>input.txt</code>中的文本进行单词切分。且粉饰注意单词大小写，切分分割标记采用空格，将切分后的结果写入到<code>out.txt</code>中。</p></li><li><p>正想最大匹配切分算法（例）：有待切分字符串<code>abcdefg</code>，单词最大长度为5，则先判断<code>abcde</code>是否为单词，若不是则舍弃最后一个字母接着判断，即判断<code>abcd</code>是否为单词；<strong>只有一个字母时可直接认定是单词</strong>。</p></li><li><p>给定主函数为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> words[SIZE][<span class="number">24</span>];</span><br><span class="line">    <span class="keyword">clock_t</span> start, finish;<span class="comment">// 计算程序使用的时间</span></span><br><span class="line">    start = clock();</span><br><span class="line">    showFirstAndLastLine(<span class="string">"input_2016b.txt"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将input文件的第一行和最后一行显示在屏幕上</span></span><br><span class="line">    <span class="keyword">int</span> count = ReadWords(<span class="string">"words_2016b.txt"</span>, words);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取英文字典，并返回单词数量</span></span><br><span class="line">    showTheLastThreeLines(count, words);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此处可以添加处理逻辑以实现题目的第3点要求</span></span><br><span class="line">    <span class="comment">//建议将需要的功能实现为多个函数后在此直接或者间接调用</span></span><br><span class="line">    maxMatch(words, count, <span class="string">"input_2016b.txt"</span>, <span class="string">"output_2016b.txt"</span>);</span><br><span class="line">    finish = clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Total time:%lf\n"</span>, (<span class="keyword">double</span>)(finish - start) / CLOCKS_PER_SEC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>不允许修改主函数内容，不允许使用以下头文件之外的头文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br></pre></td></tr></table></figure></li></ul><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><ul><li>问题3：文件中单词之间没有分隔符，可直接使用fgets(字符数组，长度，文件指针)按行读取读取并输出。</li><li>问题4：文件中单词按行存储，可使用格式化读取fscanf(文件指针，格式，字符数组)的方式读取到一个单词数组中，输出最后三行（即最后三个单词）。</li><li>使用<code>qsort()</code>对单词数组进行排序，使用<code>bsearch()</code>在指定数组中查询单词是否存在</li></ul><h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><ul><li><p><code>void showFirstAndLastLine(const char filename[])</code>：</p><ul><li>输出<code>input.txt</code>文件中第一行和第三行的内容</li></ul></li><li><p><code>int ReadWords(const char filename[], char Words[SIZE][24])</code></p><ul><li>读取<code>words.txt</code>中的单词</li></ul></li><li><p><code>void showTheLastThreeLines(int count, char Words[SIZE][24])</code></p><ul><li>输出<code>words.txt</code>中最后三行的内容（即最后三个单词）</li></ul></li><li><p><code>int compare(const void* a, const void* b)</code></p><ul><li>比较传入的两个字符</li></ul></li><li><p><code>void maxMatch(char Words[SIZE][24], int count, const char input[], const char output[])</code>：</p><ul><li>获取单词整箱最大匹配</li></ul></li><li><p><code>int main()</code></p></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 30000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showFirstAndLastLine</span><span class="params">(<span class="keyword">char</span> filename[])</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        输出input.txt中的第一行和最后一行的内容</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    FILE* fp = fopen(filename, <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">char</span> temp[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出第一行的内容</span></span><br><span class="line">    <span class="keyword">if</span>(fgets(buf, <span class="number">128</span>, fp) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出最后一行的内容</span></span><br><span class="line">    <span class="keyword">while</span>((fgets(temp, <span class="number">128</span>, fp) != <span class="literal">NULL</span>))</span><br><span class="line">        <span class="built_in">strcpy</span>(buf, temp);</span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ReadWords</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> filename[], <span class="keyword">char</span> words[SIZE][<span class="number">24</span>])</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        读取word.txt的内容</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">24</span>];</span><br><span class="line">    FILE* fp = fopen(filename, <span class="string">"r"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">fscanf</span>(fp, <span class="string">"%s"</span>, buf) != EOF)</span><br><span class="line">        <span class="built_in">strcpy</span>(words[count++], buf);</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showTheLastThreeLines</span><span class="params">(count, words)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        输出最后的word.txt的三行</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, words[count - i]);</span><br><span class="line">        i ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* a, <span class="keyword">const</span> coid* b)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 顺序比较两个字符串</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>((<span class="keyword">char</span>*)a, (<span class="keyword">char</span>*)b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maxMatch</span><span class="params">(<span class="keyword">char</span> words[SIZE][<span class="number">24</span>], <span class="keyword">int</span> count, <span class="keyword">const</span> <span class="keyword">char</span> input[], <span class="keyword">const</span> <span class="keyword">char</span> output[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">char</span> substr[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">char</span> *result;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">begin</span>, length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    FILE* fin = fopen(input, <span class="string">"r"</span>);</span><br><span class="line">    FILE* fout = fopen(output, <span class="string">"w"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对words进行升序排序</span></span><br><span class="line">    qsort(words, count, <span class="keyword">sizeof</span>(words[<span class="number">0</span>]), compare);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取文件内容</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">fscanf</span>(fin, <span class="string">"%s"</span>, buf) != EOF)&#123;</span><br><span class="line">        <span class="built_in">begin</span> = <span class="number">0</span>;</span><br><span class="line">        length = <span class="built_in">strlen</span>(buf);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">begin</span> != length)&#123;</span><br><span class="line">            <span class="comment">// 将buf+begin中的20个字符复制到substr中</span></span><br><span class="line">            <span class="built_in">memcpy</span>(substr, buf+<span class="built_in">begin</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">20</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">                substr[i] = <span class="string">'\0'</span>;</span><br><span class="line">                <span class="comment">// 从大到小，按个数在words中找substr</span></span><br><span class="line">                <span class="keyword">if</span>(bsearch(substr, words, count, <span class="keyword">sizeof</span>(substr), compare))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 输出到文件</span></span><br><span class="line">            <span class="built_in">fprintf</span>(fout, <span class="string">"%s"</span>, substr);</span><br><span class="line">            <span class="comment">// 指针后移</span></span><br><span class="line">            <span class="built_in">begin</span> += <span class="built_in">strlen</span>(substr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fprintf</span>(fout, <span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fin);</span><br><span class="line">    fclose(fout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> words[SIZE][<span class="number">24</span>];</span><br><span class="line">    <span class="keyword">clock_t</span> start, finish;</span><br><span class="line">    start = clock();</span><br><span class="line">    showFirstAndLastLine(<span class="string">"input_2016b.txt"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将input文件的第一行和最后一行显示在屏幕上</span></span><br><span class="line">    <span class="keyword">int</span> count = ReadWords(<span class="string">"words_2016b.txt"</span>, words);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取英文字典，并返回单词数量</span></span><br><span class="line">    showTheLastThreeLines(count, words);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此处可以添加处理逻辑以实现题目的第3点要求</span></span><br><span class="line">    <span class="comment">//建议将需要的功能实现为多个函数后在此直接或者间接调用</span></span><br><span class="line">    maxMatch(words, count, <span class="string">"input_2016b.txt"</span>, <span class="string">"output_2016b.txt"</span>);</span><br><span class="line">    finish = clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Total time:%lf\n"</span>, (<span class="keyword">double</span>)(finish - start) / CLOCKS_PER_SEC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 研究生复试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 研究生复试 </tag>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>苏州大学2017年复试上机题</title>
      <link href="/passages/su-zhou-da-xue-2017-nian-fu-shi-shang-ji-ti/"/>
      <url>/passages/su-zhou-da-xue-2017-nian-fu-shi-shang-ji-ti/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><ul><li><p>二进制数据文件<code>data.bin</code>中存放了若干整数，编写程序：</p></li><li><p>读取所有数据。</p></li><li><p>每相邻的两个整数为一对坐标，构成二维平面上的坐标点</p></li><li><p>以每个坐标点为圆心，以该点与其后面第一个点的欧氏距离为半径r，计算每个圆包含的坐标点数，计算最后一个点时以其和第一个点的<strong>欧式距离</strong>为半径。</p></li><li><p>计算所有圆的点密度值，输出密度值最大的5个坐标点，以及院中包含的点数和点密度值</p><table><thead><tr><th>坐标点</th><th>包含点数</th><th>点密度</th></tr></thead><tbody><tr><td>(x坐标, y坐标)</td><td>(占5列, 右对齐)</td><td>(占7列, 右对齐, 保留2位小数)</td></tr></tbody></table></li><li><p>圆的点密度为：圆包含的点除以圆面积，在圆上也包含该点，$\pi = 3.14$</p></li></ul><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><ul><li>二进制文件读取时用<code>fread(data, sizeof(int), count, fp)</code>函数每四位读做一个整数</li><li>每两个整数为一个坐标</li><li>定义结构体存储坐标和密度值</li><li>利用文件位置标记计算文件中的整数个数，申请整数数组、坐标数组的空间</li><li>按密度值按降序排序</li></ul><h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><ul><li><p><code>struct Coordinate</code></p><ul><li>坐标点结构体</li></ul></li><li><p><code>struct Circle</code></p><ul><li>圆结构体</li><li>包含：圆心坐标、半径、圆中点的个数、点密度</li></ul></li><li><p><code>static int compare(const Circle* a, const Circle* b)</code></p><ul><li>比较传入的圆的点密度</li></ul></li><li><p><code>static void swap(Circle* a, Circle* b)</code></p><ul><li>交换传入的两个圆的位置</li></ul></li><li><p><code>void selection_sort(Circle *ptr, int count)</code></p><ul><li>跟据圆的点密度进行选择排序</li></ul></li><li><p><code>int read_file(const char* filename, const char* mode, int* data)</code></p><ul><li>根据文件中的点的个数申请空间</li><li>读取文件内容</li></ul></li><li><p><code>double distance(Coordinate* a, Coordinate* b)</code></p><ul><li>计算两个点之间的距离</li></ul></li><li><p><code>double area(Circle* a)</code></p><ul><li>计算圆的面积</li></ul></li><li><p><code>void display(Circle* circles, int count)</code></p><ul><li>输出圆的圆心坐标，圆中包含的点的个数，点密度</li></ul></li><li><p><code>int create_circles(int * data, int coune, Circle* circles)</code></p><ul><li>初始化圆的信息，包括圆心坐标、圆中点的个数、点密度</li></ul></li><li><p><code>int main()</code></p><ul><li>读取文件</li><li>输出坐标点</li><li>计算圆的相关属性</li><li>按照点密度排序</li><li>输出点密度最高的5个</li></ul></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;Coordinate;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> r;   <span class="comment">// 半径</span></span><br><span class="line">    Coordinate <span class="built_in">point</span>;   <span class="comment">// 坐标</span></span><br><span class="line">    <span class="keyword">int</span> points_num;  <span class="comment">// 范围内坐标点个数</span></span><br><span class="line">    <span class="keyword">double</span> density; <span class="comment">// 圆密度</span></span><br><span class="line">&#125;Circle;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Circle* a, <span class="keyword">const</span> Circle* b)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        比较传入的圆的圆密度</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(a-&gt;density &gt; b-&gt;density)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a-&gt;density &lt; b-&gt;density)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Circle* a, Circle* b)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        交换传入的两个圆</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Circle temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(Circle *ptr, <span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        根据圆密度进行选择排序</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = i + <span class="number">1</span>; j &lt; count; j++)</span><br><span class="line">            <span class="keyword">if</span>(compare(&amp;ptr[i], &amp;ptr[j]) &gt; <span class="number">0</span>)</span><br><span class="line">                swap(&amp;ptr[i], &amp;ptr[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_file</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename, <span class="keyword">const</span> <span class="keyword">char</span>* mode, <span class="keyword">int</span>* data)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        读取文件</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    FILE* fp = fopen(filename, mode);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!fp)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"failes to open file.\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算文件中的整数个数，申请内存空间</span></span><br><span class="line">    fseek(fp, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    count = ftell(fp) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    data = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*count);</span><br><span class="line">    rewind(fp);</span><br><span class="line"></span><br><span class="line">    fread(data, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), count, fp);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">distance</span><span class="params">(Coordinate* a, Coordinate* b)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        计算两个坐标之间的距离</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    val = (a-&gt;x - b-&gt;x) * (a-&gt;x - b-&gt;x) +</span><br><span class="line">        (a-&gt;y - b-&gt;y) * (a-&gt;y - b-&gt;y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((<span class="keyword">double</span>)val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">area</span><span class="params">(Circle* c)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 计算圆的面积</span></span><br><span class="line">    <span class="keyword">return</span> (c-&gt;r * c-&gt;r) *PI;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(Circle* circles, <span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        输出传入的圆</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"(%d, %d) %5d %7.2f\n"</span>,</span><br><span class="line">               circles[i].<span class="built_in">point</span>.x,</span><br><span class="line">               circles[i].<span class="built_in">point</span>.y,</span><br><span class="line">               circles[i].points_num,</span><br><span class="line">               circles[i].density);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">create_circles</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> count, Circle* circles)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> circles_num = count - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 申请存储圆的数组空间</span></span><br><span class="line">    circles = (Circle*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Circle) * circles_num);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化圆数组</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; circles_num; i++)&#123;</span><br><span class="line">        circles[i].<span class="built_in">point</span>.x = data[i];</span><br><span class="line">        circles[i].<span class="built_in">point</span>.y = data[i + <span class="number">1</span>];</span><br><span class="line">        circles[i].points_num = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算圆的半径（与后面点之间的距离为r）</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; circles_num; i++)&#123;</span><br><span class="line">        circles[i].r = distance(&amp;circles[i].<span class="built_in">point</span>, &amp;circles[(i+<span class="number">1</span>)%circles_num].<span class="built_in">point</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 统计在圆内的点的个数（与该点之间距离小于半径）</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; circles_num; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; circles_num; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(distance(&amp;circles[i].<span class="built_in">point</span>, &amp;circles[j].<span class="built_in">point</span>) &lt;= circles[i].r)</span><br><span class="line">                circles[i].points_num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算圆的圆密度</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; circles_num; i++)&#123;</span><br><span class="line">        circles[i].density = circles[i].points_num / area(&amp;circles[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> circles_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *data = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> circles_num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    Circle* circles = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取文件，返回圆的个数</span></span><br><span class="line">    count = read_file(<span class="string">"data_2017.bin"</span>, <span class="string">"rb"</span>, data);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"data:\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出坐标点</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算圆的半径，圆中的坐标点个数，圆密度</span></span><br><span class="line">    circles_num = create_circles(data, count, circles);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 按圆密度排序</span></span><br><span class="line">    selection_sort(circles, circles_num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"result:\n"</span>);</span><br><span class="line">    <span class="comment">// 输出密度最高的前五个</span></span><br><span class="line">    <span class="built_in">display</span>(circles, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 研究生复试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 研究生复试 </tag>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>苏州大学2016年复试上机题</title>
      <link href="/passages/su-zhou-da-xue-2016-nian-fu-shi-shang-ji-ti/"/>
      <url>/passages/su-zhou-da-xue-2016-nian-fu-shi-shang-ji-ti/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><ul><li>文本文件<code>input.txt</code>由若干英文单词和分隔符（空格、回车、换行）组成，根据如下说明编写程序统计不同单词出现的次数（频度）。将统计结果按出现频度从高到低排序，并将出现频度大于5的单词及其频度输出到文件<code>output.txt</code>中。</li><li>文件格式<code>单词,次数</code>，每个单词占一行</li><li>多个连续分隔符被视为一个分隔符</li><li>大小写敏感，即大小写不同的为两个单词</li><li>每个单词长度不超过20个字符</li><li>单词的数量未知，使用静态大数组将扣5分</li></ul><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><ul><li><p>不允许使用静态大数组，先读取一遍文件，统计单词个数；或者每发现一个新单词，动态申请空间</p></li><li><p>分割符不用处理，使用以下函数按单词读取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fscanf(fp, &quot;%s&quot;, buf);</span><br></pre></td></tr></table></figure></li><li><p>定义结构体，存储单词及其频度</p></li><li><p>根据频度降序排序</p></li></ul><h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><ul><li><p><code>struct Word</code>：</p><ul><li>单词，频度结构体</li></ul></li><li><p><code>int compare(const Word* lhs, const Word* rhs)</code>：</p><ul><li>比较传入的两个字符的出现次数</li></ul></li><li><p><code>void swap(Word* a, Word* b)</code>：</p><ul><li>交换传入的两个字母的顺序</li></ul></li><li><p><code>void insertion_sort(Word* ptr, int count)</code></p><ul><li>插入排序</li></ul></li><li><p><code>int find(Word* words, int count, char* str)</code></p><ul><li>在words中查找str，并返回下标</li><li>若没有则返回数组的长度</li></ul></li><li><p><code>int main()</code>：</p><ul><li>打开文件</li><li>统计文件中的单词个数</li><li>申请存储空间</li><li>读取文件内容，并统计相同单词的个数</li><li>按单词的出现频度排序</li><li>输出单词及其频度，并输出到文件</li></ul></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> freq;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">20</span>];</span><br><span class="line">&#125;Word;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Word* lhs, <span class="keyword">const</span> Word* rhs)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        比较传入的两个字符的出现次数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(lhs-&gt;freq &gt; rhs-&gt;freq)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(lhs-&gt;freq &lt; rhs-&gt;freq)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Word* a, Word* b)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        交换传入的两个字母的顺序</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Word temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(Word* ptr, <span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        插入排序</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; count; i++)&#123;</span><br><span class="line">        j = i;</span><br><span class="line">        Word ref = ptr[i];</span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; compare(&amp;ptr[j - <span class="number">1</span>], &amp;ref) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            ptr[j] = ptr[j - <span class="number">1</span>];</span><br><span class="line">            j --;</span><br><span class="line">        &#125;</span><br><span class="line">        ptr[j] = ref;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(Word* words, <span class="keyword">int</span> count, <span class="keyword">char</span>* str)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 在words中查找str，并返回下标</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">        <span class="comment">// 比较两个单词是否相等</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(words[i].str, str) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FILE* fpr = fopen(<span class="string">"input_2016.txt"</span>, <span class="string">"r"</span>);</span><br><span class="line">    FILE* fpw = fopen(<span class="string">"output_2016.txt"</span>, <span class="string">"w"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    Word* words;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计该文件中共有多少单词</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">fscanf</span>(fpr, <span class="string">"%s"</span>, buf) != EOF)&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 申请空间</span></span><br><span class="line">    words = (Word*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Word)*count);</span><br><span class="line">    rewind(fpr);</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按单词读取文件内容，并统计个数</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">fscanf</span>(fpr, <span class="string">"%s"</span>, buf) != EOF)&#123;</span><br><span class="line">        <span class="comment">// 判断之前的单词中是否有与当前单词相同的</span></span><br><span class="line">        i = <span class="built_in">find</span>(words, count, buf);</span><br><span class="line">        <span class="keyword">if</span>(i == count)&#123;</span><br><span class="line">            <span class="comment">// 复制</span></span><br><span class="line">            <span class="built_in">strcpy</span>(words[count].str, buf);</span><br><span class="line">            words[count].freq = <span class="number">0</span>;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        words[i].freq++;</span><br><span class="line">    &#125;</span><br><span class="line">    insertion_sort(words, count);</span><br><span class="line">    <span class="comment">// 将频度大于5的单词写入文件并输出</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; count &amp;&amp; words[i].freq &gt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(fpw, <span class="string">"%s, %d\n"</span>, words[i].str, words[i].freq);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s, %d\n"</span>, words[i].str, words[i].freq);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(words);</span><br><span class="line">    fclose(fpr);</span><br><span class="line">    fclose(fpw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 研究生复试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 研究生复试 </tag>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>苏州大学2015年复试上机题</title>
      <link href="/passages/su-zhou-da-xue-2015-nian-fu-shi-shang-ji-ti/"/>
      <url>/passages/su-zhou-da-xue-2015-nian-fu-shi-shang-ji-ti/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><ul><li>从网页上下载<code>input.dat</code>文件，里面是用二进制编写的，里面放了一堆<code>int</code>型的数，每个数占<code>4</code>字节，每次读取两个，这两个数构成一个坐标。</li><li>处于第一象限的坐标为有效点，问其中有多少个有效点。</li><li>从键盘输入<code>k</code>和<code>n</code>，从第一问中的有效点中找出距离小于n，距离小于n的点的个数要大于k，将它们以文本格式输出到文件中。</li></ul><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><ul><li><p>文件中的数据用二进制编写，故要用<code>fread()</code>读取</p></li><li><p>读取时每两个点做成一个坐标</p></li><li><p>要定义结构体，用于存储坐标点</p></li><li><p>要动态申请空间，不能使用大数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">判断整数数组大小</span><br><span class="line">fseek(fp, <span class="number">0</span>, SEEK_END); <span class="comment">// 文件标记指针指向文末</span></span><br><span class="line">total = ftell(fp);<span class="comment">// 获取文件标记指针位置，即文件的位数</span></span><br><span class="line">count = total / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);<span class="comment">// 计算整数个数</span></span><br><span class="line">coord_count = count / <span class="number">2</span>;<span class="comment">// 计算坐标点个数</span></span><br><span class="line"></span><br><span class="line">num = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*count);<span class="comment">// 为整数数组申请空间</span></span><br><span class="line">xy = (Coordinate*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Coordinate)* coord_count);<span class="comment">// 为坐标数组申请空间</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><ul><li><code>struct Coordinate</code>：<ul><li>坐标点结构体</li></ul></li><li><code>double distance(const Coordinate* a, const Coordinate* b)</code>：<ul><li>计算传入的两点之间的距离</li></ul></li><li><code>void swap(Coordinate* a, Coordinate* b)</code>：<ul><li>交换传入的两点的位置</li></ul></li><li><code>int comapre(const Coordinate* a, const Coordinate *b)</code>：<ul><li>比较传入的两点与指定点之间的距离</li></ul></li><li><code>void selection_sort(Coordinate *ptr, int begin, int end)</code>：<ul><li>根据各点与指定点之间的距离进行排序</li></ul></li><li><code>void display(Coordinate *ptr, int count)</code><ul><li>输出传入的坐标数组</li></ul></li><li><code>void make_data()</code>：<ul><li>生成随机数据</li></ul></li><li><code>int main()</code>：<ul><li>读取文件，生成整数数组和坐标数组</li><li>遍历，判断有效点并计数</li><li>根据输入的k和n找出符合的坐标点，输出并写入文件</li></ul></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;Coordinate;</span><br><span class="line"></span><br><span class="line">Coordinate <span class="built_in">point</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">distance</span><span class="params">(<span class="keyword">const</span> Coordinate *a, <span class="keyword">const</span> Coordinate *b)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        计算两个坐标点的距离</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    val = (a-&gt;x - b-&gt;x)*(a-&gt;x - b-&gt;x) + (a-&gt;y - b-&gt;y)*(a-&gt;y - b-&gt;y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((<span class="keyword">double</span>)val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Coordinate* a, Coordinate* b)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        交换传入的两个坐标点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Coordinate temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Coordinate* a, <span class="keyword">const</span> Coordinate* b)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        比较传入两个坐标点与指定点之间的距离</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">double</span> dista = distance(a, &amp;<span class="built_in">point</span>);</span><br><span class="line">    <span class="keyword">double</span> distb = distance(b, &amp;<span class="built_in">point</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dista &gt; distb)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(dista &lt; distb)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(dista == distb)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(Coordinate *ptr, <span class="keyword">int</span> <span class="built_in">begin</span>, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        根据距离选择排序</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="built_in">begin</span>; i &lt; <span class="built_in">end</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = i+<span class="number">1</span>; j &lt; <span class="built_in">end</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(compare(&amp;ptr[i], &amp;ptr[j]) &gt; <span class="number">0</span>)</span><br><span class="line">                swap(&amp;ptr[i], &amp;ptr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_data</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        生成随机数据</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    FILE* fp;</span><br><span class="line">    <span class="keyword">int</span> *num;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    fp = fopen(<span class="string">"org_2015.dat"</span>, <span class="string">"wb"</span>);</span><br><span class="line"></span><br><span class="line">    num = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">128</span>);</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++)</span><br><span class="line">        num[i] = rand() % <span class="number">128</span> - <span class="number">64</span>;</span><br><span class="line">    <span class="comment">// 二进制方式写入文件</span></span><br><span class="line">    fwrite(num, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">128</span>, fp);</span><br><span class="line">    <span class="built_in">free</span>(num);</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(Coordinate* ptr, <span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        输出传入的坐标点数组</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"(%2d, %2d) "</span>, ptr[i].x, ptr[i].y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FILE* fp;</span><br><span class="line"></span><br><span class="line">    Coordinate* xy;</span><br><span class="line">    <span class="keyword">int</span>* num;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> count, coord_count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成数据文件</span></span><br><span class="line">    make_data();</span><br><span class="line"></span><br><span class="line">    fp = fopen(<span class="string">"org_2015.dat"</span>, <span class="string">"rb"</span>);</span><br><span class="line">    <span class="comment">//申请空间</span></span><br><span class="line">    fseek(fp, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    count = ftell(fp) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    coord_count = count / <span class="number">2</span>;</span><br><span class="line">    num = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*count);</span><br><span class="line">    xy = (Coordinate*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Coordinate)* coord_count);</span><br><span class="line">    rewind(fp);</span><br><span class="line">    <span class="comment">// 读取文件</span></span><br><span class="line">    fread(num, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), count, fp);</span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有效点计数和存储</span></span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    fp = fopen(<span class="string">"output_2015.txt"</span>, <span class="string">"w"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; count; i += <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num[i] &gt; <span class="number">0</span> &amp;&amp; num[i+<span class="number">1</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            xy[valid].x = num[i];</span><br><span class="line">            xy[valid].y = num[i+<span class="number">1</span>];</span><br><span class="line">            valid++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"valid points:\n"</span>);</span><br><span class="line">    <span class="built_in">display</span>(xy, valid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"total: %d\n"</span>, valid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k, n, pivot;</span><br><span class="line">    <span class="comment">// 获取k，n的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"k = "</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"n = "</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    pivot = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 遍历有效点</span></span><br><span class="line">    <span class="keyword">while</span>(pivot &lt; valid)&#123;</span><br><span class="line">        <span class="comment">// 挨个点判断</span></span><br><span class="line">        <span class="built_in">point</span>.x = xy[pivot].x;</span><br><span class="line">        <span class="built_in">point</span>.y = xy[pivot].y;</span><br><span class="line">        pivot ++;</span><br><span class="line">        <span class="comment">// 根据与point点的距离将xy排序</span></span><br><span class="line">        selection_sort(xy, pivot, valid);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"the points with a distance of less than %d to (%2d, %2d) are:\n"</span>, n, <span class="built_in">point</span>.x, <span class="built_in">point</span>.y);</span><br><span class="line">        <span class="built_in">fprintf</span>(fp, <span class="string">"the points with a distance of less than %d to (%2d, %2d) are:\n"</span>,  n, <span class="built_in">point</span>.x, <span class="built_in">point</span>.y);</span><br><span class="line">        <span class="comment">// 到指定点距离至少为n，且距离至少为n的点不少于k的指定点</span></span><br><span class="line">        <span class="comment">// 若排序后的xy中第k个点到指定点距离仍小于n，则遍历输出</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 统计符合条件的点的个数</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; valid &amp;&amp; distance(&amp;xy[i], &amp;<span class="built_in">point</span>) &lt; (<span class="keyword">double</span>)n)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt; k)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j &lt;= i)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"(%2d, %2d) %7.2f\n"</span>, xy[j].x, xy[j].y, distance(&amp;xy[j], &amp;<span class="built_in">point</span>));</span><br><span class="line">                <span class="built_in">fprintf</span>(fp, <span class="string">"(%2d, %2d) %7.2f\n"</span>, xy[j].x, xy[j].y, distance(&amp;xy[j], &amp;<span class="built_in">point</span>));</span><br><span class="line">                j ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 研究生复试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 研究生复试 </tag>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pytorch更新与安装</title>
      <link href="/passages/pytorch-geng-xin-yu-an-zhuang/"/>
      <url>/passages/pytorch-geng-xin-yu-an-zhuang/</url>
      
        <content type="html"><![CDATA[<p>pytorch 更新与卸载</p><a id="more"></a><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><ul><li>本文讲解的是pytorch 更新与卸载</li><li>使用pip和conda进行操作</li></ul><h3 id="Pytorch更新"><a href="#Pytorch更新" class="headerlink" title="Pytorch更新"></a>Pytorch更新</h3><ul><li><p>使用pip更新</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列举可更新的包</span></span><br><span class="line">pip list --otdated --format=legacy</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 更新</span></span><br><span class="line">pip install --upgrade pytorch torchvision</span><br></pre></td></tr></table></figure></li><li><p>使用conda更新</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加源服务器</span></span><br><span class="line">conda config --add channels soumith</span><br><span class="line"><span class="meta">#</span><span class="bash">更新</span></span><br><span class="line">conda update pytorch torchvision</span><br></pre></td></tr></table></figure></li></ul><h3 id="Pytorch卸载"><a href="#Pytorch卸载" class="headerlink" title="Pytorch卸载"></a>Pytorch卸载</h3><ul><li><p>使用pip卸载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip uninstall torch</span><br></pre></td></tr></table></figure></li><li><p>使用conda卸载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda uninstall pytorch</span><br><span class="line"></span><br><span class="line">conda uninstall libtorch</span><br></pre></td></tr></table></figure></li></ul><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 工具配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之两数相加</title>
      <link href="/passages/leetcode-zhi-liang-shu-xiang-jia/"/>
      <url>/passages/leetcode-zhi-liang-shu-xiang-jia/</url>
      
        <content type="html"><![CDATA[<p>Add Two Nums</p><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><ul><li>题目详情见：<a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">两数相加</a></li><li>题目难度：中等</li><li>相关标签：链表，数学</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>很遗憾，不能将链表中的元素读出来形成整数再相加，这样会内存泄漏</li><li>只能按照作者的思路，按位相加，计算本位的结果和进位的值</li><li>要注意每一位的结果都应该是整数，不是浮点数</li><li>python中<code>//</code>是取整除操作，向下取整</li><li>代码一是笔者实现的，其中有些地方不够简练，没有体现python的简洁的特点</li><li>代码二是leetcode评论区的大神实现的，思路与笔者相同，不过代码看起来更简练</li></ul><h3 id="代码一"><a href="#代码一" class="headerlink" title="代码一"></a>代码一</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">            :type l1 ListNode</span></span><br><span class="line"><span class="string">            :type l2 ListNode</span></span><br><span class="line"><span class="string">            :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 结果链表</span></span><br><span class="line">        re = ListNode(<span class="number">0</span>);</span><br><span class="line">        <span class="comment"># 结果列表工作指针</span></span><br><span class="line">        r = re</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 进位</span></span><br><span class="line">        carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1 <span class="keyword">or</span> l2):</span><br><span class="line">            <span class="comment"># 读取该位的数据</span></span><br><span class="line">            <span class="keyword">if</span> l1:</span><br><span class="line">                x = l1.val</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                x = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> l2:</span><br><span class="line">                y = l2.val</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                y = <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 计算</span></span><br><span class="line">            s = carry + x + y</span><br><span class="line">            <span class="comment"># 计算进位和结果</span></span><br><span class="line">            carry = s // <span class="number">10</span>     <span class="comment">#取整除</span></span><br><span class="line">            r.next = ListNode(s%<span class="number">10</span>)</span><br><span class="line">            </span><br><span class="line">            r = r.next</span><br><span class="line">            <span class="comment"># 原链表的指针后移</span></span><br><span class="line">            <span class="keyword">if</span>(l1 != <span class="literal">None</span>): </span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">if</span>(l2 != <span class="literal">None</span>): </span><br><span class="line">                l2 = l2.next</span><br><span class="line">        <span class="keyword">if</span>(carry &gt; <span class="number">0</span>):</span><br><span class="line">            r.next = ListNode(<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> re.next</span><br></pre></td></tr></table></figure><h3 id="代码二"><a href="#代码二" class="headerlink" title="代码二"></a>代码二</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        re = ListNode(<span class="number">0</span>)</span><br><span class="line">        r=re</span><br><span class="line">        carry=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(l1 <span class="keyword">or</span> l2):</span><br><span class="line">            x= l1.val <span class="keyword">if</span> l1 <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            y= l2.val <span class="keyword">if</span> l2 <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            s=carry+x+y</span><br><span class="line">            carry=s//<span class="number">10</span></span><br><span class="line">            r.next=ListNode(s%<span class="number">10</span>)</span><br><span class="line">            r=r.next</span><br><span class="line">            <span class="keyword">if</span>(l1!=<span class="literal">None</span>):l1=l1.next</span><br><span class="line">            <span class="keyword">if</span>(l2!=<span class="literal">None</span>):l2=l2.next</span><br><span class="line">        <span class="keyword">if</span>(carry&gt;<span class="number">0</span>):</span><br><span class="line">            r.next=ListNode(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> re.next</span><br></pre></td></tr></table></figure><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>苏州大学2014年复试上机题</title>
      <link href="/passages/su-zhou-da-xue-2014-nian-fu-shi-shang-ji-ti/"/>
      <url>/passages/su-zhou-da-xue-2014-nian-fu-shi-shang-ji-ti/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><ul><li>从网页上下载input.dat文件，这里面是用二进制编写的，里面放了一堆int类型的数，每个数占4个字节，每次读取两个，这两个数构成一个坐标。</li><li>规定处以第一象限的数是有效点（x &gt; 0&amp;&amp;y &gt; 0）,问共有 多少个有效点。</li><li>现用户从键盘输入一个左边和数字k，输出k个离该点最近的点的坐标和每个坐标到该点的距离，写入output.txt中。</li></ul><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><ul><li>文件使用二进制编写，读取的时候要使用fread(buffer, size, count, fp)函数。</li><li>定义坐标点结构体，用该结构体定义坐标点数组。</li><li>定义计算输入点到各个点的距离的函数，判断距离是否符合条件，符合者输出。</li></ul><h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Coordinate</span>)# 坐标点的结构</span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class"><span class="title">double</span> <span class="title">distance</span>(<span class="title">const</span> <span class="title">Coordinate</span>* <span class="title">a</span>, <span class="title">const</span> <span class="title">Coordinate</span>* <span class="title">b</span>)# 计算两个点之间的距离</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">swap</span>(<span class="title">Coordinate</span>* <span class="title">a</span>, <span class="title">Coordinate</span>* <span class="title">b</span>)# 交换传入的两个坐标</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">compare</span>(<span class="title">const</span> <span class="title">Coordinate</span>* <span class="title">a</span>, <span class="title">const</span> <span class="title">Coordinate</span>* <span class="title">b</span>)# 比较传入的两个坐标点与指定坐标点距离的大小</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">selection_sort</span>(<span class="title">Coordinate</span> *<span class="title">ptr</span>, <span class="title">int</span> <span class="title">begin</span>, <span class="title">int</span> <span class="title">end</span>)# 根据与传入点的距离排序</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">display</span>(<span class="title">Coordinate</span>* <span class="title">ptr</span>, <span class="title">int</span> <span class="title">count</span>)# 输出传入的坐标点</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">make_data</span>()# 生成随机数据</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">main</span>()</span></span><br><span class="line"><span class="class">    生成数据</span></span><br><span class="line"><span class="class">    计算文件中有多少整数，多少坐标点</span></span><br><span class="line"><span class="class">    根据整数个数和坐标点个数申请空间</span></span><br><span class="line"><span class="class">    统计合法点个数</span></span><br><span class="line"><span class="class">    筛选距指定坐标点最近的<span class="title">k</span>个坐标点</span></span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;Coordinate;</span><br><span class="line"></span><br><span class="line">Coordinate <span class="built_in">point</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">distance</span><span class="params">(<span class="keyword">const</span> Coordinate* a, <span class="keyword">const</span> Coordinate* b)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        计算两个点之间的距离</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> val = (a-&gt;x - b-&gt;x) * (a-&gt;x - b-&gt;x) +</span><br><span class="line">                (a-&gt;y - b-&gt;y) * (a-&gt;y - b-&gt;y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((<span class="keyword">double</span>) val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Coordinate* a, Coordinate* b)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        交换传入的两个坐标</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Coordinate temp = *a;</span><br><span class="line"></span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Coordinate* a, <span class="keyword">const</span> Coordinate* b)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        比较两个传入的点与指定点的距离</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">double</span> dista = distance(a, &amp;<span class="built_in">point</span>);</span><br><span class="line">    <span class="keyword">double</span> distb = distance(b, &amp;<span class="built_in">point</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dista &lt; distb)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(dista &gt; distb)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(Coordinate* ptr, <span class="keyword">int</span> <span class="built_in">begin</span>, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        选择排序</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="built_in">begin</span>; i &lt; <span class="built_in">end</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = i+<span class="number">1</span>; j &lt; <span class="built_in">end</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(compare(&amp;ptr[i], &amp;ptr[j]))</span><br><span class="line">                swap(&amp;ptr[i], &amp;ptr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(Coordinate* ptr, <span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        输出传入的坐标数组</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"(%2d, %2d) "</span>, ptr[i].x, ptr[i].y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_date</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        生成数据</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    FILE *fp = fopen(<span class="string">"org_2014.dat"</span>, <span class="string">"wb"</span>);</span><br><span class="line">    <span class="keyword">int</span> *num;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// 大小为128的数组</span></span><br><span class="line">    num = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">128</span>);</span><br><span class="line">    <span class="comment">// 初始化随机种子</span></span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++)</span><br><span class="line">        num[i] = rand()%<span class="number">128</span> - <span class="number">64</span>;</span><br><span class="line">    <span class="comment">// 以二进制的方式读取数据</span></span><br><span class="line">    fwrite(num, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">128</span>, fp);</span><br><span class="line">    <span class="comment">// 释放空间</span></span><br><span class="line">    <span class="built_in">free</span>(num);</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FILE* fp;</span><br><span class="line">    Coordinate* xy;</span><br><span class="line">    <span class="keyword">int</span> *num;</span><br><span class="line">    <span class="keyword">int</span> count, coord_count;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// 生成随机数据</span></span><br><span class="line">    make_date();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取数据</span></span><br><span class="line">    fp = fopen(<span class="string">"org_2014.dat"</span>, <span class="string">"rb"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求文件有多少整数</span></span><br><span class="line">    <span class="comment">// 使文件指针指向文件结尾</span></span><br><span class="line">    fseek(fp, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    <span class="comment">// 获取当前文件指针位置相对于文件首的偏移字节数</span></span><br><span class="line">    count = ftell(fp) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 坐标点个数</span></span><br><span class="line">    coord_count = count / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据坐标点个数申请内存空间</span></span><br><span class="line">    num = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*count);</span><br><span class="line">    xy = (Coordinate*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Coordinate) * coord_count);</span><br><span class="line">    <span class="comment">// 文件指针回到文件首</span></span><br><span class="line">    rewind(fp);</span><br><span class="line">    <span class="comment">// 二进制方式按四个字节为一个数读取</span></span><br><span class="line">    fread(num, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), count, fp);</span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出读取的结果</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; count; i+=<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"(%2d, %2d) \n"</span>, num[i], num[i+<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计合法坐标的个数</span></span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    fp = fopen(<span class="string">"output_2014.txt"</span>, <span class="string">"w"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; count; i += <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num[i] &gt; <span class="number">0</span> &amp;&amp; num[i + <span class="number">1</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            xy[valid].x = num[i];</span><br><span class="line">            xy[valid].y = num[i + <span class="number">1</span>];</span><br><span class="line">            valid++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出合法坐标</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"valid points:\n"</span>);</span><br><span class="line">    <span class="built_in">display</span>(xy, valid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"total: %d\n"</span>, valid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KNN</span></span><br><span class="line">    <span class="comment">// 找离指定坐标最近的k个坐标点</span></span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Coordinate: "</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;<span class="built_in">point</span>.x, &amp;<span class="built_in">point</span>.y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"k = "</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line"></span><br><span class="line">    selection_sort(xy, <span class="number">0</span>, valid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"the nearest %d points to (%d, %d) are:\n"</span>, k, <span class="built_in">point</span>.x, <span class="built_in">point</span>.y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"(%2d, %2d) %7.2f\n"</span>, xy[i].x, xy[i].y, distance(&amp;xy[i], &amp;<span class="built_in">point</span>));</span><br><span class="line">        <span class="built_in">fprintf</span>(fp, <span class="string">"(%2d, %2d) %7.2f\n"</span>, xy[i].x, xy[i].y, distance(&amp;xy[i], &amp;<span class="built_in">point</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 研究生复试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 研究生复试 </tag>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode之两数之和</title>
      <link href="/passages/leetcode-zhi-liang-shu-zhi-he/"/>
      <url>/passages/leetcode-zhi-liang-shu-zhi-he/</url>
      
        <content type="html"><![CDATA[<p>leetcode之twoSum</p><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><ul><li><p>题目详情见：<a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">两数之和</a></p></li><li><p>题目难度：简单</p></li><li><p>相关标签：数组、哈希表</p></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li><p>先说题目要求，不能重复利用数组中的相同元素，所以想使用双层循环的同学在内层循环中不能再次访问外层循环正在访问的元素</p></li><li><p>问题解决的关键在于，计算当前值与指定target的差，并快速判断差是否在给定的数组中（这样，我们自然而然的就想到了python中的字典）。实现见代码一。</p></li><li><p>另一种思路是使用首尾递进查找：需要列表是有序的（假设为升序）。首先将首尾元素加起来，若大于target，则tail–；若小于target，则head–。实现见代码二</p></li></ul><h3 id="代码一"><a href="#代码一" class="headerlink" title="代码一"></a>代码一</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        hashmap = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> index, num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            another_num = target - num;</span><br><span class="line">            <span class="keyword">if</span> another_num <span class="keyword">in</span> hashmap:</span><br><span class="line">                <span class="keyword">return</span> [hashmap[another_num], index]</span><br><span class="line">            hashmap[num] = index</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 说明</span></span><br><span class="line">“”“</span><br><span class="line">enumerate()：用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在<span class="keyword">for</span>循环当中。</span><br><span class="line">”“”</span><br></pre></td></tr></table></figure><h3 id="代码二"><a href="#代码二" class="headerlink" title="代码二"></a>代码二</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">sorted_id = sorted(range(len(nums)), key=<span class="keyword">lambda</span> k: nums[k])</span><br><span class="line"></span><br><span class="line">head = <span class="number">0</span></span><br><span class="line">tail = len(nums) - <span class="number">1</span></span><br><span class="line">sum_result = nums[sorted_id[head]] + nums[sorted_id[tail]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> sum_result != target:</span><br><span class="line">    <span class="keyword">if</span> sum_result &gt; target:</span><br><span class="line">        tail -= <span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> sum_result &lt; target:</span><br><span class="line">        head += <span class="number">1</span></span><br><span class="line">    sum_result = nums[sorted_id[head]] + nums[sorted_id[tail]]</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> [sorted_id[head], sorted_id[tail]]</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 说明</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">sorted(iterable, key=None, reverse=False)：对传入的列表进行排序操作，返回的是一个新的列表，不对原列表进行操作；默认升序</span></span><br><span class="line"><span class="string">sort()：在原列表上操作</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>苏州大学2012年复试上机题</title>
      <link href="/passages/su-zhou-da-xue-2012-nian-fu-shi-shang-ji-ti/"/>
      <url>/passages/su-zhou-da-xue-2012-nian-fu-shi-shang-ji-ti/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><ul><li><p>从服务器上下载数据文件org.dat，文件以二进制方式存放一系列整数，每个整数占4个字节，从第一个整数开始，每两个整数组成一个坐标点。</p></li><li><p>规定处于第一象限的坐标点为有效点，统计文件中由多少个点，多少个有效点。</p></li><li><p>每个有效点与坐标原点构成一个矩形，求最小矩形的面积。</p></li><li><p>找出符合该条件的点：以该点为原点，其他有效点仍是有效点</p></li><li><p>对有效点进行分组，每个有效点仅属于一个分组，组内：若对组内所有点的x进行排序，当x1 &gt; x2时，y1 &gt; y2。</p></li></ul><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><ul><li><p>读取文件，两个整数为一个点，四位为1个整数</p></li><li><p>判断有效点（第一象限）并得到最小的x和y</p></li><li><p>对有效点排序，并输出</p></li><li><p>找合适的有效点：x1 &gt; x2 &amp;&amp; y1 &gt; y2</p></li></ul><h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Corrdinate</span>点的结构体</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">swap</span>(<span class="title">Coordinate</span> *<span class="title">a</span>, <span class="title">Coordinate</span> *<span class="title">b</span>)</span></span><br><span class="line"><span class="class">交换传入的两个点</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">compare</span>(<span class="title">const</span> <span class="title">Coordinate</span> *<span class="title">lhs</span>, <span class="title">const</span> <span class="title">Coordinate</span> *<span class="title">rhs</span>)</span></span><br><span class="line"><span class="class">比较两个点，根据其<span class="title">x</span>坐标</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">selection_sort</span>(<span class="title">Coordinate</span> *<span class="title">ptr</span>, <span class="title">int</span> <span class="title">begin</span>, <span class="title">int</span> <span class="title">end</span>)</span></span><br><span class="line"><span class="class">选择排序</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">display</span>(<span class="title">Coordinate</span> *<span class="title">ptr</span>, <span class="title">int</span> <span class="title">count</span>)</span></span><br><span class="line"><span class="class">展示坐标点</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">make_data</span>()</span></span><br><span class="line"><span class="class">生成数据</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">main</span>()</span></span><br><span class="line"><span class="class">读取文件，两位读作一个坐标点</span></span><br><span class="line"><span class="class">得到其中的有效点（第一象限）</span></span><br><span class="line"><span class="class">排序</span></span><br><span class="line"><span class="class">最小矩形即最小的<span class="title">x</span>*<span class="title">y</span></span></span><br><span class="line"><span class="class">对有效点：</span></span><br><span class="line"><span class="class">选择排序</span></span><br><span class="line"><span class="class"><span class="title">x1</span> &gt; <span class="title">x2</span> &amp;&amp; <span class="title">y1</span> &gt; <span class="title">y2</span></span></span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;Coordinate;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Coordinate *a, Coordinate *b)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        交换传入的两个数据</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Coordinate temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Coordinate *lhs, <span class="keyword">const</span> Coordinate *rhs)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        比较传入的点</span></span><br><span class="line"><span class="comment">        根据x坐标比较</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(lhs-&gt;x &lt; rhs-&gt;x)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(lhs-&gt;x &gt; rhs-&gt;x)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(Coordinate *ptr, <span class="keyword">int</span> <span class="built_in">begin</span>, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        选择排序</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="built_in">begin</span>; i &lt; <span class="built_in">end</span>; i++)</span><br><span class="line">        <span class="keyword">for</span>(j = i+<span class="number">1</span>; j &lt; <span class="built_in">end</span>; j++)</span><br><span class="line">            <span class="keyword">if</span>(compare(&amp;ptr[i], &amp;ptr[j]) &gt; <span class="number">0</span>)</span><br><span class="line">                swap(&amp;ptr[i], &amp;ptr[j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(Coordinate *ptr, <span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        展示坐标点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"(%2d, %2d) "</span>, ptr[i].x, ptr[i].y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_data</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        生成数据</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    FILE *fp = fopen(<span class="string">"org_2012.dat"</span>, <span class="string">"wb"</span>);</span><br><span class="line">    <span class="keyword">int</span> *num = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">128</span>);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 随机数生成其初始化</span></span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++)</span><br><span class="line">        num[i] = rand() % <span class="number">128</span> - <span class="number">64</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 二进制方式写入文件</span></span><br><span class="line">    fwrite(num, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">128</span>, fp);</span><br><span class="line">    <span class="built_in">free</span>(num);</span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    Coordinate *xy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *num;</span><br><span class="line">    <span class="keyword">int</span> n, count;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 随机生成数据</span></span><br><span class="line">    make_data();</span><br><span class="line"></span><br><span class="line">    fp = fopen(<span class="string">"org_2012.dat"</span>, <span class="string">"rb"</span>);</span><br><span class="line">    <span class="comment">// 函数设置文件指针stream的位置</span></span><br><span class="line">    fseek(fp, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    <span class="comment">// ftell(): 得到文件位置指针当前位置相对于文件首的偏移字节数</span></span><br><span class="line">    <span class="comment">// 计算有多少个整型数据</span></span><br><span class="line">    count = ftell(fp) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">    n = count / <span class="number">2</span>;</span><br><span class="line">    num = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * count);</span><br><span class="line">    xy = (Coordinate*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Coordinate)*n);</span><br><span class="line">    <span class="comment">// 将文件指针重置</span></span><br><span class="line">    rewind(fp);</span><br><span class="line">    <span class="comment">// 二进制形式兑取文件</span></span><br><span class="line">    fread(num, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), count, fp);</span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>, j, i;</span><br><span class="line">    <span class="comment">// RAND_MAX：rand返回的最大值</span></span><br><span class="line">    <span class="keyword">int</span> minx = RAND_MAX;</span><br><span class="line">    <span class="keyword">int</span> miny = RAND_MAX;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取文件内容，两个一组</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; count; i += <span class="number">2</span>)&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span>(num[i] &gt; <span class="number">0</span> &amp;&amp; num[i + <span class="number">1</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            xy[k].x = num[i];</span><br><span class="line">            xy[k].y = num[i + <span class="number">1</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 得到最大值和最小值</span></span><br><span class="line">            <span class="keyword">if</span>(minx &gt; xy[k].x)</span><br><span class="line">                minx = xy[k].x;</span><br><span class="line">            <span class="keyword">if</span>(miny &gt; xy[k].y)</span><br><span class="line">                miny = xy[k].y;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 第一象限点的个数</span></span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    selection_sort(xy, <span class="number">0</span>, k);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出所有点</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"valid points:\n"</span>);</span><br><span class="line">    <span class="built_in">display</span>(xy, k);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 点的个数和第一象限的点的个数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"n - %d k = %d\n"</span>, n, k);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"min area = %d\n"</span>, minx * miny);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sorted = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 有效点中的符合条件的点</span></span><br><span class="line">    <span class="keyword">while</span>(sorted &lt; k)&#123;</span><br><span class="line">        selection_sort(xy, sorted, k);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"points grouped by (%2d, %2d):"</span>, xy[sorted].x, xy[sorted].y);</span><br><span class="line"></span><br><span class="line">        miny = xy[sorted++].y;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i = sorted; i &lt; k; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(xy[i].y &gt;= miny)&#123;</span><br><span class="line">                miny = xy[i].y;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"(%2d, %2d) "</span>, xy[i].x, xy[i].y);</span><br><span class="line"></span><br><span class="line">                swap(&amp;xy[i], &amp;xy[sorted++]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 研究生复试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 研究生复试 </tag>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>苏州大学2010年复试上机题</title>
      <link href="/passages/su-zhou-da-xue-2010-nian-fu-shi-shang-ji-ti/"/>
      <url>/passages/su-zhou-da-xue-2010-nian-fu-shi-shang-ji-ti/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><ul><li>从ftp上下载make.exe和org.dat，运行make.exe，输入准考证后三位生成data.txt，文件为二进制编码。</li><li>data.txt中存有2048个整数，其中前n个为非0数，收2048-n个为0，将其读入数组，计算非0数的个数。</li><li>选出n个数中的最大数和最小数。</li><li>选出n个数中的最大素数。</li><li>将n个数从大到小排序，平均分成三段，选出中间一段的最大值和最小值。</li></ul><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><ul><li>遍历寻找非0数与0的位置，并记录其索引。</li><li>遍历数据，寻找数据中的最大值和最小值以及最大素数。</li><li>将数据排序，划分为三段，截取中间一段，读取其最大值和最小值</li><li>注意二进制编码的文件要用fread读取.</li></ul><h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_prime</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line">判断传入的数字是否为素数</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line">比较传入的两个数的大小关系</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span> *ptr, <span class="keyword">int</span> count)</span></span></span><br><span class="line">对传入的数组进行选择排序</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_data</span><span class="params">()</span></span></span><br><span class="line">产生随机数据</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line">读取数据</span><br><span class="line">寻找最大值、最小值、最大素数</span><br><span class="line">划分数据，获取中间一段的最大值、最小值</span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_prime</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        判断传入的数字是否为素数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>; i*i &lt;= num; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        交换传入的两个数的值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        比较传入的两个数的大小关系</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(a &lt; b)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a == b)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span> *ptr, <span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        选择排序</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = i + <span class="number">1</span>; j &lt; count; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(compare(&amp;ptr[i], &amp;ptr[j]) &gt; <span class="number">0</span>)</span><br><span class="line">                swap(&amp;ptr[i], &amp;ptr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_data</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 制造数据,xieru data文件</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> num[<span class="number">2048</span>];</span><br><span class="line">    FILE *fp = fopen(<span class="string">"data_2010.txt"</span>, <span class="string">"wb"</span>);</span><br><span class="line">    <span class="keyword">if</span>(!fp)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"File opening failed"</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">        num[i] = rand() % <span class="number">4096</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1000</span>; i &lt; <span class="number">2048</span>; i++)</span><br><span class="line">        num[i] = <span class="number">0</span>;</span><br><span class="line">    fwrite(num, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">2048</span>, fp);</span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">int</span> num[<span class="number">2048</span>];</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">min</span> = RAND_MAX;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> max_prime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">//制造数据</span></span><br><span class="line">    make_data();</span><br><span class="line">    <span class="comment">// 读取数据</span></span><br><span class="line">    fp = fopen(<span class="string">"data_2010.txt"</span>, <span class="string">"rb"</span>);</span><br><span class="line">    <span class="keyword">if</span>(!fp)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"File opening failed"</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fread(num, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">2048</span>, fp);</span><br><span class="line">    <span class="comment">// 判断有多少非0数</span></span><br><span class="line">    <span class="keyword">for</span>(n = <span class="number">0</span>; n &lt; <span class="number">2048</span>; n++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num[n] == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"n = %d\n"</span>, n);</span><br><span class="line">    <span class="comment">// 找最大值，最小值，最大素数</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">min</span> &gt; num[i])</span><br><span class="line">            <span class="built_in">min</span> = num[i];</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">max</span> &lt; num[i])</span><br><span class="line">            <span class="built_in">max</span> = num[i];</span><br><span class="line">        <span class="keyword">if</span>(is_prime(num[i]) &amp;&amp; num[i] &gt; max_prime)</span><br><span class="line">            max_prime = num[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"min = %d,\nmax = %d,\nmax_prime = %d\n"</span>, <span class="built_in">min</span>, <span class="built_in">max</span>, max_prime);</span><br><span class="line">    selection_sort(num, n);</span><br><span class="line">    <span class="comment">// 中间一段的最大值和最小值（降序排列）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"min in mid_seg = %d\nmax in mid_seg = %d\n"</span>, num[n/<span class="number">3</span>*<span class="number">2</span><span class="number">-1</span>],num[n/<span class="number">3</span>]);</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 研究生复试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 研究生复试 </tag>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>苏州大学2011年复试上机题</title>
      <link href="/passages/su-zhou-da-xue-2011-nian-fu-shi-shang-ji-ti/"/>
      <url>/passages/su-zhou-da-xue-2011-nian-fu-shi-shang-ji-ti/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><ul><li>该数位于1000~9999之间。</li><li>该数是素数。</li><li>十位数和个位数所组成的数是素数，百位数和个位数组成的数是素数。</li><li>个位数和百位数组成的数是素数，个位数和十位数组成的数是素数。</li><li>例：1991，需分别判断1991，91，91，19，19</li></ul><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><ul><li><p>分别取需判断数字的百位，十位，个位数存入一个三维数组中</p></li><li><p>组成指定数字进行判断</p></li><li><p>符合条件的输出</p></li></ul><h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_prime</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line">判断传入的数字是否是素数</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> num[])</span></span></span><br><span class="line">获取n的各个位置的数，存储在num中</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_prime</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        判断传入的数字是否是素数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>; i*i &lt; num; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf("%d is prime. \n", num);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> num[])</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        拆分数字，分别获取其各个位上的数字</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">        num[i] = n % <span class="number">10</span>;</span><br><span class="line">        n = n / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> num[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1000</span>; i &lt; <span class="number">9999</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(is_prime(i))&#123;</span><br><span class="line">            <span class="comment">// 直接传入num数组，之后就可以访问</span></span><br><span class="line">            split(i, num);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 依次分别为百位和个位，十位和个位，个位和百位，个位和十位</span></span><br><span class="line">            <span class="keyword">if</span>(is_prime(num[<span class="number">1</span>]*<span class="number">10</span> + num[<span class="number">0</span>]) &amp;&amp;</span><br><span class="line">                is_prime(num[<span class="number">2</span>]*<span class="number">10</span> + num[<span class="number">0</span>]) &amp;&amp;</span><br><span class="line">                is_prime(num[<span class="number">0</span>]*<span class="number">10</span> + num[<span class="number">2</span>]) &amp;&amp;</span><br><span class="line">                is_prime(num[<span class="number">0</span>]*<span class="number">10</span> + num[<span class="number">1</span>]))</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 研究生复试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 研究生复试 </tag>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matplotlib实践</title>
      <link href="/passages/matplotlib-shi-jian/"/>
      <url>/passages/matplotlib-shi-jian/</url>
      
        <content type="html"><![CDATA[<p>折线图&amp;散点图</p><a id="more"></a><ul><li><p>用matplotlib绘制折线图和散点图</p></li><li><p>更多图的绘制请见<a href="http://matplotlib.org" target="_blank" rel="noopener">这里</a></p></li></ul><h3 id="使用matplotlib绘制折线图"><a href="#使用matplotlib绘制折线图" class="headerlink" title="使用matplotlib绘制折线图"></a>使用matplotlib绘制折线图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">input_value = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">squares = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 传入squares列表，指定线条粗细为5</span></span><br><span class="line"></span><br><span class="line">plt.plot(input_value, squares, linewidth=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置标题,指定字体为24号</span></span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">"Squares Numbers"</span>, fontsize=<span class="number">24</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置x轴和y轴的标题</span></span><br><span class="line"></span><br><span class="line">plt.xlabel(<span class="string">"Value"</span>, fontsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">plt.ylabel(<span class="string">"Squares of Value"</span>, fontsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置刻度标记的大小</span></span><br><span class="line"></span><br><span class="line">plt.tick_params(axis=<span class="string">'both'</span>, labelsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开matplotlib显示器</span></span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h3 id="使用matplotlib绘制散点图"><a href="#使用matplotlib绘制散点图" class="headerlink" title="使用matplotlib绘制散点图"></a>使用matplotlib绘制散点图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x_values = list(range(<span class="number">1001</span>))</span><br><span class="line"></span><br><span class="line">y_values = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> x_values]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制散点图，设置点的颜色为(0, 0, 0.8),点的外围颜色为黑色，指定点的大小为40</span></span><br><span class="line"><span class="comment"># plt.scatter(x_value, y_value, c=(0, 0, 0.8), edgecolors='black', s=40)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用颜色映射</span></span><br><span class="line">plt.scatter(x_values, y_values, c=y_values, cmap=plt.cm.Blues, edgecolors=<span class="string">'none'</span>, s=<span class="number">40</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置标题并给坐标轴加上标签</span></span><br><span class="line">plt.title(<span class="string">"Square Number"</span>, fontsize=<span class="number">24</span>)</span><br><span class="line"></span><br><span class="line">plt.xlabel(<span class="string">"Value"</span>, fontsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">plt.ylabel(<span class="string">"Square of Value"</span>, fontsize=<span class="number">24</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置刻度标记的大小</span></span><br><span class="line">plt.tick_params(axis=<span class="string">'both'</span>, which=<span class="string">'major'</span>, labelsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动保存图表</span></span><br><span class="line"></span><br><span class="line">plt.savefig(<span class="string">'squares_plot.png'</span>, bbox_inches=<span class="string">'tight'</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python随机漫步</title>
      <link href="/passages/python-sui-ji-man-bu/"/>
      <url>/passages/python-sui-ji-man-bu/</url>
      
        <content type="html"><![CDATA[<p>随机漫步：每一步都是随机决策</p><a id="more"></a><ul><li><p>所谓随机漫步，每次行走都完全是随机的，没有明确的方向，结果是由一系列随机决策决定的，</p></li><li><p>例如：漂浮在水滴上的花粉因不断受到水分子的挤压而在水面上的移动</p></li></ul><h3 id="randomwalk-py"><a href="#randomwalk-py" class="headerlink" title="randomwalk.py"></a>randomwalk.py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choice</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomWalk</span><span class="params">()</span>:</span></span><br><span class="line"> <span class="string">'''</span></span><br><span class="line"><span class="string">  生成随机漫步数据的类</span></span><br><span class="line"><span class="string"> '''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num_points=<span class="number">5000</span>)</span>:</span></span><br><span class="line">        <span class="comment"># 初始化随机漫步属性</span></span><br><span class="line">self.num_points = num_points</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 所有随机漫步都始于(0,0)</span></span><br><span class="line">self.x_values = [<span class="number">0</span>]</span><br><span class="line">self.y_values = [<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fill_walk</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="comment"># 计算随机漫步包含的所有点</span></span><br><span class="line"></span><br><span class="line"> <span class="comment"># 不断漫步，直至达到列表的指定长度</span></span><br><span class="line"><span class="keyword">while</span> len(self.x_values) &lt; self.num_points:</span><br><span class="line"></span><br><span class="line"><span class="comment"># 决定前进方向以及沿这个方向上的距离</span></span><br><span class="line"><span class="comment"># 方向在左：1，右：-1上选择</span></span><br><span class="line"> x_direction = choice([<span class="number">1</span>, <span class="number">-1</span>])</span><br><span class="line"><span class="comment"># 距离在1~4中间选择</span></span><br><span class="line">x_distance = choice([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">x_step = x_direction * x_distance</span><br><span class="line"></span><br><span class="line"> y_direction = choice([<span class="number">1</span>, <span class="number">-1</span>])</span><br><span class="line">y_distance = choice([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"> y_step = y_direction * y_distance</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拒绝原地踏步</span></span><br><span class="line"> <span class="keyword">if</span> x_step == <span class="number">0</span> <span class="keyword">and</span> y_step == <span class="number">0</span>:</span><br><span class="line"> <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算下一个点的x和y值</span></span><br><span class="line">next_x = self.x_values[<span class="number">-1</span>] + x_step</span><br><span class="line">next_y = self.y_values[<span class="number">-1</span>] + y_step</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将计算得到的下一个点的值添加到列表中</span></span><br><span class="line">self.x_values.append(next_x)</span><br><span class="line">self.y_values.append(next_y)</span><br></pre></td></tr></table></figure><h3 id="rw-visual-py"><a href="#rw-visual-py" class="headerlink" title="rw_visual.py"></a>rw_visual.py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> randomwalk <span class="keyword">import</span> RandomWalk</span><br><span class="line"></span><br><span class="line">number = <span class="number">0</span></span><br><span class="line"><span class="comment"># 不断模拟随机漫步</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">rw = RandomWalk(<span class="number">50000</span>)</span><br><span class="line">rw.fill_walk()</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 设置绘图窗口大小</span></span><br><span class="line">plt.figure(dpi=<span class="number">128</span>, figsize=(<span class="number">10</span>, <span class="number">6</span>))</span><br><span class="line"></span><br><span class="line">point_numbers = list(range(rw.num_points))</span><br><span class="line">plt.title(<span class="string">"No."</span> + str(number) + <span class="string">" RandomWalk"</span>)</span><br><span class="line">plt.scatter(rw.x_values, rw.y_values,c=point_numbers,cmap=plt.cm.Blues,</span><br><span class="line">edgecolors=<span class="string">'none'</span>, s=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 突出起点和终点</span></span><br><span class="line">plt.scatter(<span class="number">0</span>, <span class="number">0</span>, c=<span class="string">'green'</span>, edgecolors=<span class="string">'none'</span>, s=<span class="number">100</span>)</span><br><span class="line">plt.scatter(rw.x_values[<span class="number">-1</span>], rw.y_values[<span class="number">-1</span>], c=<span class="string">'red'</span>, edgecolors=<span class="string">'none'</span>, s=<span class="number">100</span>)</span><br><span class="line"><span class="comment"># 隐藏坐标轴</span></span><br><span class="line">plt.axes().get_xaxis().set_visible(<span class="literal">False</span>)</span><br><span class="line">  plt.axes().get_yaxis().set_visible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">keep_running = input(<span class="string">"Make another walk ? (y/n)"</span>)</span><br><span class="line"><span class="keyword">if</span> keep_running == <span class="string">'n'</span>:</span><br><span class="line"><span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python函数的几点注意</title>
      <link href="/passages/python-han-shu-de-ji-dian-zhu-yi/"/>
      <url>/passages/python-han-shu-de-ji-dian-zhu-yi/</url>
      
        <content type="html"><![CDATA[<p>函数定义及传参的几点注意<br>《Python编程从入门到精通》笔记</p><a id="more"></a><h3 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a><strong>函数的定义</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用关键字'def'标识,函数体内的语句都要至少比函数名一个缩进</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"hello world"</span>)</span><br><span class="line"></span><br><span class="line">greet()</span><br></pre></td></tr></table></figure><h3 id="实参和形参"><a href="#实参和形参" class="headerlink" title="实参和形参"></a>实参和形参</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调用时传入的参数时实参，定义时的参数时形参</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面的username是形参，而tom是实参</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet</span><span class="params">(username)</span>:</span></span><br><span class="line">    print(<span class="string">"hello"</span> + username)</span><br><span class="line"></span><br><span class="line">greet(<span class="string">"tom"</span>)</span><br></pre></td></tr></table></figure><h3 id="几种传参方式"><a href="#几种传参方式" class="headerlink" title="几种传参方式"></a>几种传参方式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#位置实参：</span></span><br><span class="line">    即基于顺序的参数传递，传递参数时实参的顺序必须与形参的顺序完全一致</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet</span><span class="params">(username, age)</span>:</span></span><br><span class="line">    print(username + <span class="string">" is "</span>+ str(age) + <span class="string">"years old"</span>)</span><br><span class="line"></span><br><span class="line">greet(<span class="string">"tom"</span>, <span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关键字实参：</span></span><br><span class="line">    即传递时传递的是名称-值对（不同于键值对，键值对的键必须时字符串），直接在传参时将名称和值关联起来了，也就不需要顺序完全一致了</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet</span><span class="params">(username, age)</span>:</span></span><br><span class="line">    print(username + <span class="string">" is "</span> + str(age) + <span class="string">"years old"</span>)</span><br><span class="line"></span><br><span class="line">greet(username=<span class="string">"tom"</span>, age=<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#默认值：</span></span><br><span class="line">即在形参处设置默认值，当调用时未传入该形参对应的参数时使用默认值</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet</span><span class="params">(username=<span class="string">"tom"</span>, age)</span>:</span></span><br><span class="line"></span><br><span class="line">    print(username + <span class="string">" is "</span> + str(age) + <span class="string">"years old"</span>)</span><br><span class="line">    </span><br><span class="line">greet(age=<span class="number">12</span>)</span><br></pre></td></tr></table></figure><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><ul><li>返回值可以是字符串，数字，字典，列表等</li></ul><h3 id="传递列表和字典"><a href="#传递列表和字典" class="headerlink" title="传递列表和字典"></a><strong>传递列表和字典</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 传入列表</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet</span><span class="params">(*username, age)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> username:</span><br><span class="line">    print(name + <span class="string">" is "</span> + str(age) + <span class="string">"years old"</span>)</span><br><span class="line"></span><br><span class="line">username = [<span class="string">'bob'</span>, <span class="string">'cindy'</span>, <span class="string">'flank'</span>]</span><br><span class="line"></span><br><span class="line">greet(username, <span class="number">12</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 传入字典</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet</span><span class="params">(**message)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> name,age <span class="keyword">in</span> message.items():</span><br><span class="line">        print(name + <span class="string">" is "</span>+ str(age) + <span class="string">"years old"</span>)</span><br><span class="line"></span><br><span class="line">message = &#123;<span class="string">'bob'</span>:<span class="number">12</span>, <span class="string">'cindy'</span>:<span class="number">13</span>, <span class="string">'flank'</span>:<span class="number">14</span>&#125;</span><br><span class="line"></span><br><span class="line">greet(message)</span><br></pre></td></tr></table></figure><ul><li><p>形参设置成列表可以实现传入任意数量的参数的功能</p></li><li><p>形参设置成字典可以实现传入任意数量的名称-值对的功能</p></li></ul><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python用户输入及while</title>
      <link href="/passages/python-yong-hu-shu-ru-ji-while/"/>
      <url>/passages/python-yong-hu-shu-ru-ji-while/</url>
      
        <content type="html"><![CDATA[<p>while及编程语言</p><p>《Python编程从入门到精通》笔记</p><a id="more"></a><h3 id="用户输入"><a href="#用户输入" class="headerlink" title="用户输入"></a><strong>用户输入</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取用户输入</span></span><br><span class="line">message = input(<span class="string">"Please input something:"</span>)</span><br><span class="line"></span><br><span class="line">print(message)</span><br></pre></td></tr></table></figure><h3 id="while循环的使用"><a href="#while循环的使用" class="headerlink" title="while循环的使用"></a><strong>while循环的使用</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># while循环</span></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> num &lt; <span class="number">5</span>:</span><br><span class="line">    sum = sum + num</span><br><span class="line">    num = num + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(sum)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用户选择何时退出</span></span><br><span class="line">mess = <span class="string">""</span> <span class="comment">#必须事先定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> mess != <span class="string">"quit"</span>:</span><br><span class="line">    mess = input(<span class="string">"Please input something1:\n"</span>)</span><br><span class="line">    <span class="keyword">if</span> mess != <span class="string">"quit"</span>:</span><br><span class="line">        print(mess)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用标志</span></span><br><span class="line">active = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> active:</span><br><span class="line">    mess = input(<span class="string">"Please input something2:\n"</span>)</span><br><span class="line">    <span class="keyword">if</span> mess == <span class="string">"quit"</span>:</span><br><span class="line">        active = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(mess)</span><br></pre></td></tr></table></figure><h3 id="break-amp-continue"><a href="#break-amp-continue" class="headerlink" title="break &amp; continue"></a><strong>break &amp; continue</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 循环中使用break跳出循环</span></span><br><span class="line">mess = <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    mess = input()</span><br><span class="line">    <span class="keyword">if</span> mess == <span class="string">"quit"</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(mess)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环中使用continue直接跳到下一次循环</span></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> num &lt; <span class="number">10</span>:</span><br><span class="line">    num = num + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 跳过偶数</span></span><br><span class="line">    <span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    </span><br><span class="line">    print(num)</span><br></pre></td></tr></table></figure><h3 id="while循环的一些应用"><a href="#while循环的一些应用" class="headerlink" title="while循环的一些应用"></a><strong>while循环的一些应用</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列表间元素的移动</span></span><br><span class="line"></span><br><span class="line">unfirmed_name = [<span class="string">'alice'</span>,<span class="string">'amy'</span>,<span class="string">'lili'</span>]</span><br><span class="line"></span><br><span class="line">firmed_name = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> unfirmed_name:</span><br><span class="line"></span><br><span class="line">    username = unfirmed_name.pop()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"Verifying name :"</span> + username.title())</span><br><span class="line"></span><br><span class="line">    firmed_name.append(username)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"\nThe following name is confirmed:"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> firmed_name:</span><br><span class="line">    print(firmed_name.pop())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除列表中的多个相同的元素</span></span><br><span class="line">animals = [<span class="string">'dog'</span>,<span class="string">'cat'</span>,<span class="string">'pig'</span>,<span class="string">'chicken'</span>,<span class="string">'cat'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="string">'cat'</span> <span class="keyword">in</span> animals:</span><br><span class="line">    animals.remove(<span class="string">'cat'</span>) <span class="comment">#remove()只能每次删除第一个符合要求的元素</span></span><br><span class="line">    print(<span class="string">'Removed a cat'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用输入填充字典</span></span><br><span class="line">responses = &#123;&#125;</span><br><span class="line"></span><br><span class="line">name = input(<span class="string">"What's your name ?\n"</span>)</span><br><span class="line"></span><br><span class="line">responses[<span class="string">'name'</span>] = name</span><br><span class="line"></span><br><span class="line">age = input(<span class="string">"what's your age ?\n"</span>)</span><br><span class="line"></span><br><span class="line">responses[<span class="string">'age'</span>] = age</span><br><span class="line"></span><br><span class="line">print(responses[<span class="string">'name'</span>].title() + <span class="string">"'s age is "</span> + responses[<span class="string">'age'</span>])</span><br></pre></td></tr></table></figure><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python字典操作</title>
      <link href="/passages/python-zi-dian-cao-zuo/"/>
      <url>/passages/python-zi-dian-cao-zuo/</url>
      
        <content type="html"><![CDATA[<p>Python字典操作</p><p>《Python编程从入门到精通》笔记</p><a id="more"></a><h3 id="创建字典"><a href="#创建字典" class="headerlink" title="创建字典"></a><strong>创建字典</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#字典由'&#123;&#125;'标识，其中的元素是键值对</span></span><br><span class="line"><span class="comment"># 键必须是字符串，值可以是任何类型</span></span><br><span class="line"></span><br><span class="line">dic = &#123;<span class="string">"name"</span>:<span class="string">"ziv"</span>, <span class="string">"age"</span>:<span class="number">22</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="字典的操作"><a href="#字典的操作" class="headerlink" title="字典的操作"></a>字典的操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 访问字典的值</span></span><br><span class="line">print(dic[<span class="string">'name'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改值</span></span><br><span class="line">dic[<span class="string">"age"</span>] = <span class="number">21</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加键值对</span></span><br><span class="line">dic[<span class="string">"sex"</span>] = <span class="string">"male"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除键值对</span></span><br><span class="line"><span class="keyword">del</span> dic[<span class="string">"sex"</span>]</span><br></pre></td></tr></table></figure><h3 id="遍历字典"><a href="#遍历字典" class="headerlink" title="遍历字典"></a>遍历字典</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 键值同时遍历</span></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> dic.items():</span><br><span class="line">    print(key+<span class="string">":"</span>+value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 仅遍历字典的键</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> dic.keys():</span><br><span class="line">    print(key)   </span><br><span class="line"></span><br><span class="line"><span class="comment"># 仅遍历字典的值</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> dic.values():</span><br><span class="line">    print(value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按排序顺序遍历字典的键</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> sorted(dic.values()):</span><br><span class="line">    print(value)</span><br></pre></td></tr></table></figure><h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a><strong>嵌套</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建30个外星人字典：列表中嵌套字典</span></span><br><span class="line">aliens = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> alien_num <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">31</span>):</span><br><span class="line">    alien = &#123;<span class="string">'color'</span>:<span class="string">'green'</span>, <span class="string">'age'</span>:<span class="string">'14'</span>, <span class="string">'point'</span>:<span class="string">'5'</span>, <span class="string">'number'</span>:alien_num&#125;</span><br><span class="line"></span><br><span class="line">aliens.append(alien)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改前3个，用到切片</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> alien <span class="keyword">in</span> aliens[:<span class="number">3</span>]:</span><br><span class="line">    <span class="keyword">if</span> alien[<span class="string">'color'</span>] == <span class="string">'green'</span>:</span><br><span class="line">        alien[<span class="string">'color'</span>] = <span class="string">'blue'</span></span><br><span class="line">        alien[<span class="string">'age'</span>] = <span class="string">'20'</span></span><br><span class="line">        alien[<span class="string">'point'</span>] = <span class="string">'10'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> alien <span class="keyword">in</span> aliens:</span><br><span class="line">    print(alien)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 披萨店的点餐：字典中嵌套列表</span></span><br><span class="line">pizza = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="string">'crust'</span>:<span class="string">'thick'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">'toppings'</span>:[<span class="string">'mushrooms'</span>, <span class="string">'extra cheese'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 仅访问其中的列表</span></span><br><span class="line"><span class="keyword">for</span> topping <span class="keyword">in</span> pizza[<span class="string">'toppings'</span>]:</span><br><span class="line">    print(topping)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 网站用户登记：字典中嵌套字典</span></span><br><span class="line">users = &#123;</span><br><span class="line">    <span class="string">'aeinstein'</span>: &#123;</span><br><span class="line">        <span class="string">'first'</span>: <span class="string">'albert'</span>,</span><br><span class="line">        <span class="string">'last'</span>: <span class="string">'einstein'</span>,</span><br><span class="line">        <span class="string">'location'</span>: <span class="string">'princeton'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="string">'mcurie'</span>: &#123;</span><br><span class="line">        <span class="string">'first'</span>: <span class="string">'marie'</span>,</span><br><span class="line">        <span class="string">'last'</span>: <span class="string">'curie'</span>,</span><br><span class="line">        <span class="string">'location'</span>: <span class="string">'paris'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> username, user_info <span class="keyword">in</span> users.items():</span><br><span class="line">    print(<span class="string">"\nUsername: "</span> + username)</span><br><span class="line">    </span><br><span class="line">    full_name = user_info[<span class="string">'first'</span>] + <span class="string">" "</span> + user_info[<span class="string">'last'</span>]</span><br><span class="line">    </span><br><span class="line">    location = user_info[<span class="string">'location'</span>]</span><br><span class="line">    </span><br><span class="line">    print(<span class="string">"\tFull name: "</span> + full_name.title())</span><br><span class="line">    print(<span class="string">"\tLocation: "</span> + location.title())</span><br></pre></td></tr></table></figure><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python条件语句</title>
      <link href="/passages/python-tiao-jian-yu-ju/"/>
      <url>/passages/python-tiao-jian-yu-ju/</url>
      
        <content type="html"><![CDATA[<p>Python条件语句</p><p>《Python编程从入门到精通》笔记</p><a id="more"></a><h3 id="if判断相等"><a href="#if判断相等" class="headerlink" title="if判断相等"></a><strong>if判断相等</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数字</span></span><br><span class="line"><span class="keyword">if</span> <span class="number">1</span> == <span class="number">2</span></span><br><span class="line">    print(<span class="string">"1==2"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"1!=2"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">"asd"</span> == <span class="string">"zxc"</span>:</span><br><span class="line">    print(<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 若要忽略大小写判断字符串是否相等，可以通过将两个字符串同时转换为小写之后再判断：lower()函数</span></span><br></pre></td></tr></table></figure><h3 id="if判不等"><a href="#if判不等" class="headerlink" title="if判不等"></a><strong>if判不等</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 判不等使用!=，格式与判等相同</span></span><br><span class="line"><span class="keyword">if</span> <span class="number">1</span> != <span class="number">2</span>:</span><br><span class="line">    print(<span class="string">"1 != 2"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"1 == 2"</span>)</span><br></pre></td></tr></table></figure><h3 id="if-elif-else结构"><a href="#if-elif-else结构" class="headerlink" title="if-elif-else结构"></a>if-elif-else结构</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cars = (<span class="string">"audi"</span>, <span class="string">"bwm"</span>, <span class="string">"loslis"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> car[<span class="number">1</span>] == <span class="string">"audi"</span>:</span><br><span class="line">    print(<span class="string">"1"</span>)</span><br><span class="line"><span class="keyword">elif</span> car[<span class="number">2</span>] == <span class="string">"bwm"</span>:</span><br><span class="line">    print(<span class="string">"2"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"3"</span>)</span><br></pre></td></tr></table></figure><h3 id="检查元素是否在列表中"><a href="#检查元素是否在列表中" class="headerlink" title="检查元素是否在列表中"></a>检查元素是否在列表中</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cars = [<span class="string">"audi"</span>, <span class="string">"bwm"</span>, <span class="string">"loslis"</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">"audi"</span> <span class="keyword">in</span> cars:</span><br><span class="line"></span><br><span class="line">print(<span class="string">"audi is in cars"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">"audi"</span> <span class="keyword">not</span> <span class="keyword">in</span> cars:</span><br><span class="line"></span><br><span class="line">print(<span class="string">"audi is not in cars"</span>)</span><br></pre></td></tr></table></figure><h3 id="布尔表达式"><a href="#布尔表达式" class="headerlink" title="布尔表达式"></a><strong>布尔表达式</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 布尔表达是只有两个值：True和False，且两者首字母必须要大写</span></span><br><span class="line"></span><br><span class="line">bool_ = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">bool__ = <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python列表（List）操作</title>
      <link href="/passages/python-lie-biao-list-cao-zuo/"/>
      <url>/passages/python-lie-biao-list-cao-zuo/</url>
      
        <content type="html"><![CDATA[<p>python、List</p><p>《Python编程从入门到精通》笔记</p><a id="more"></a><h3 id="列表的定义"><a href="#列表的定义" class="headerlink" title="列表的定义"></a><strong>列表的定义</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">message = [<span class="string">"hello"</span>,<span class="string">"this"</span>,<span class="string">"is"</span>,<span class="string">"a"</span>,<span class="string">"demo"</span>]</span><br></pre></td></tr></table></figure><h3 id="访问及修改列表"><a href="#访问及修改列表" class="headerlink" title="访问及修改列表"></a>访问及修改列表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接通过索引访问</span></span><br><span class="line">print(message[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接对要修改位置的元素赋值</span></span><br><span class="line">message[<span class="number">2</span>] = <span class="string">"change"</span></span><br></pre></td></tr></table></figure><h3 id="列表的插入"><a href="#列表的插入" class="headerlink" title="列表的插入"></a>列表的插入</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在列表末尾插入</span></span><br><span class="line">message.append(<span class="string">"append"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按指定索引插入</span></span><br><span class="line">message.insert(<span class="number">0</span>,<span class="string">"insert"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定索引位置若有元素，则该元素及其后续元素顺序后移</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定缩影位置若超过原有索引的范围，则一律添加到列表末尾</span></span><br></pre></td></tr></table></figure><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用del 删除指定位置的元素</span></span><br><span class="line"><span class="keyword">del</span> message[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用pop()弹出末尾元素并使用</span></span><br><span class="line">pop = message.pop()</span><br><span class="line"></span><br><span class="line">print(pop)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用remove()删除指定值的元素</span></span><br><span class="line">message.remove(<span class="string">"this"</span>)</span><br></pre></td></tr></table></figure><h3 id="排序列表"><a href="#排序列表" class="headerlink" title="排序列表"></a>排序列表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#用sort()对列表进行永久性排序</span></span><br><span class="line">message.sort()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用sorted()对列表进行临时性排序</span></span><br><span class="line">print(message.sorted())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用reverse()将列表倒置</span></span><br><span class="line">message.reserve()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用len()获取列表长度</span></span><br><span class="line">print(len(message))</span><br></pre></td></tr></table></figure><h3 id="列表切片"><a href="#列表切片" class="headerlink" title="列表切片"></a><strong>列表切片</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">message = [<span class="string">"hello"</span>, <span class="string">"this"</span>, <span class="string">"is"</span>, <span class="string">"a"</span>, <span class="string">"demo"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定起始和结束位置</span></span><br><span class="line">mess1 = message[<span class="number">1</span>:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不指定起始位置，默认从列表头开始</span></span><br><span class="line">mess2 = message[:<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不指定结束位置，默认从到列表尾</span></span><br><span class="line">mess3 = message[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定倒数几个</span></span><br><span class="line">mess4 = message[<span class="number">-2</span>:]</span><br></pre></td></tr></table></figure><h3 id="复制列表"><a href="#复制列表" class="headerlink" title="复制列表"></a><strong>复制列表</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 复制列表看似有两种方式，实则真正复制了列表的只有一种。下面第一种方式是创建了两个相同的列表，列表之间的操作相互独立，不会影响到另一方；第二种方式只是将两个变量指向同一个列表，其实质还是一个列表，两者的操作都会体现在同一个列表上</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过切片复制列表(一个包含所有元素的切片)</span></span><br><span class="line">copy_message = message[:]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过赋值复制列表</span></span><br><span class="line">message1 = message</span><br></pre></td></tr></table></figure><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 元组实际上可以理解为布允许改变的列表；列表通过'[]'标识，元组通过'()'标识；虽然元组不允许修改，但允许赋值：可以理解为元组不允许改变单个元素，但是可以整体赋值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 元组的定义</span></span><br><span class="line">cars = (<span class="string">"bwm"</span>, <span class="string">"audi"</span>, <span class="string">"toyota"</span>, <span class="string">"loslis"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 元组的遍历</span></span><br><span class="line"><span class="keyword">for</span> car <span class="keyword">in</span> cars:</span><br><span class="line">    print(car)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 元组不允许切片</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 元组的赋值（必须一次修改所有的值）</span></span><br><span class="line">cars = (<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>)</span><br></pre></td></tr></table></figure><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python字符串操作</title>
      <link href="/passages/python-zi-fu-chuan-cao-zuo/"/>
      <url>/passages/python-zi-fu-chuan-cao-zuo/</url>
      
        <content type="html"><![CDATA[<p>Python字符串操作</p><p>《Python编程从入门到精通》笔记</p><a id="more"></a><h3 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"this is a &#123;&#125;"</span>.format(<span class="string">"demo"</span>))</span><br></pre></td></tr></table></figure><h3 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title() 将字符串中每个单词的首字母改为大写</span><br><span class="line"></span><br><span class="line">upper() 将字符串全部字母改为大写</span><br><span class="line"></span><br><span class="line">lower() 将字符串所有字母改为小写</span><br></pre></td></tr></table></figure><h3 id="空格删除"><a href="#空格删除" class="headerlink" title="空格删除"></a>空格删除</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">strip() 同时删除字符串首部和尾部的空格</span><br><span class="line"></span><br><span class="line">lstrip() 删除字符串首部的空格</span><br><span class="line"></span><br><span class="line">rstrip() 删除字符串尾部的空格</span><br></pre></td></tr></table></figure><h3 id="转化为字符串"><a href="#转化为字符串" class="headerlink" title="转化为字符串"></a>转化为字符串</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str()将传入的数据转化为对应的字符串</span><br></pre></td></tr></table></figure><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><blockquote><p>单行注释 注释跟在‘#’后</p><p>多行注释 前后各三个‘“’将要注释部分包起来</p><p>中文注释 在文件首部加 #coding=utf-8</p></blockquote><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python程序运行时间计算</title>
      <link href="/passages/python-cheng-xu-yun-xing-shi-jian-ji-suan/"/>
      <url>/passages/python-cheng-xu-yun-xing-shi-jian-ji-suan/</url>
      
        <content type="html"><![CDATA[<p>Python程序运行时间计算</p><a id="more"></a><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">starttime = datetime.datetime.now()</span><br><span class="line"></span><br><span class="line"><span class="comment"># long running</span></span><br><span class="line"></span><br><span class="line">endtime = datetime.datetime.now()</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (endtime - starttime).seconds</span><br></pre></td></tr></table></figure><h3 id="方法-2"><a href="#方法-2" class="headerlink" title="方法 2"></a>方法 2</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">start = time.time()</span><br><span class="line"></span><br><span class="line">run_fun()</span><br><span class="line"></span><br><span class="line">end = time.time()</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> end-start</span><br></pre></td></tr></table></figure><h3 id="方法3"><a href="#方法3" class="headerlink" title="方法3"></a>方法3</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">start = time.clock()</span><br><span class="line"></span><br><span class="line">run_fun()</span><br><span class="line"></span><br><span class="line">end = time.clock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> end-start</span><br></pre></td></tr></table></figure><ul><li><p>方法1和方法2都包含了其他程序使用CPU的时间，是程序开始到程序结束的运行时间。</p></li><li><p>方法3算只计算了程序运行的CPU时间</p></li></ul><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>苏州大学2009年复试编程题</title>
      <link href="/passages/su-zhou-da-xue-2009-nian-fu-shi-bian-cheng-ti/"/>
      <url>/passages/su-zhou-da-xue-2009-nian-fu-shi-bian-cheng-ti/</url>
      
        <content type="html"><![CDATA[<ul><li>字符串转数字</li><li>排序</li><li>分词</li></ul><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><ul><li>用IE浏览器从ftp上下载org.dat，并保存在D盘目录下</li><li>此文件中存放了一段文章，其中由若干长度小于15的十进制或八进制的数字，数字之间用“,”隔开，数字内部存在且仅存在空格。</li><li>八进制以起始位0作为标识与十进制数区分。</li><li>顺序读取这些数字并将它们转变为十进制，排序后输出到文件new.txt，每个数字占一行。</li><li>例：<code>_235_,34_2,_043_1,1_3</code>，分别是十进制235，十进制342，八进制342，十进制13，_代表空格。</li></ul><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><ul><li>根据分隔符（逗号），将文章分割成单个的字符串（c中的字符串即字符数组）</li><li>根据标识将八进制、十进制的字符串转化成十进制的数字</li><li>将十进制的数组使用选择排序按升序排序</li><li>将数组写入文件中，每个数字一行</li></ul><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><h4 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span>:</span></span><br><span class="line">交换传入的两个数字</span><br><span class="line"><span class="number">2.</span> <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span>:</span></span><br><span class="line">比较传入的两个数字的大小</span><br><span class="line"><span class="number">3.</span> <span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span> *ptr, <span class="keyword">int</span> count)</span>:</span></span><br><span class="line">选择排序</span><br><span class="line"><span class="number">4.</span> <span class="function"><span class="keyword">bool</span> <span class="title">is_num</span><span class="params">(<span class="keyword">char</span> c)</span>:</span></span><br><span class="line">判断传入的字符是否是数字</span><br><span class="line"><span class="number">5.</span> <span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">(<span class="keyword">char</span> c)</span>:</span></span><br><span class="line">判断传入字符是否合法，数字或空格</span><br><span class="line"><span class="number">6.</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">打开文件</span><br><span class="line">按分隔符读取数字（按字符串存）</span><br><span class="line">将数字转化成十进制</span><br><span class="line">排序</span><br><span class="line">将排序结果存入文件</span><br></pre></td></tr></table></figure><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    交换传入的两个数字</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        比较传入的两个数字的大小</span></span><br><span class="line"><span class="comment">        前者小返回-1</span></span><br><span class="line"><span class="comment">        相等返回0</span></span><br><span class="line"><span class="comment">        前者大返回1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(a &lt; b)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a == b)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span> *ptr, <span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        ptr为数组</span></span><br><span class="line"><span class="comment">        count为数组元素个数</span></span><br><span class="line"><span class="comment">        使用选择排序对数组中的元素进行升序排序</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = i + <span class="number">1</span>; j &lt; count; j++)&#123;</span><br><span class="line">            <span class="comment">// 前者比后者大</span></span><br><span class="line">            <span class="keyword">if</span>(compare(&amp;ptr[i], &amp;ptr[j]) &gt; <span class="number">0</span>)</span><br><span class="line">                swap(&amp;ptr[i], &amp;ptr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断传入字符 是否是数字</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_num</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断传入的字符是否合法：数字或空格</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> is_num(c) || c == <span class="string">' '</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FILE *fprog = fopen(<span class="string">"org_2009.dat"</span>, <span class="string">"r"</span>);</span><br><span class="line">    FILE *fpnew = fopen(<span class="string">"new_2009.txt"</span>, <span class="string">"w"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">char</span> num[<span class="number">15</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"org_2009.dat:\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((c = fgetc(fprog)) != EOF)&#123;</span><br><span class="line">        <span class="keyword">if</span>(is_num(c))&#123;</span><br><span class="line">            i = <span class="number">0</span>;</span><br><span class="line">            num[i++] = c;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                读取一个数字</span></span><br><span class="line"><span class="comment">                按字符读：空格或数字</span></span><br><span class="line"><span class="comment">                    只将数字存入num，用'\0'结束</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">while</span>((c = fgetc(fprog)) != EOF &amp;&amp; valid(c))</span><br><span class="line">                <span class="keyword">if</span>(is_num(c))</span><br><span class="line">                    num[i++] = c;</span><br><span class="line">            num[i] = <span class="string">'\0'</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, num);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                long int strtol(const char *nptr, char **endptr, int base)</span></span><br><span class="line"><span class="comment">                将传入的字符串按base指示转化成long int</span></span><br><span class="line"><span class="comment">                可以被转换的合法字符依据base而定，举例来说，当base为2时，合法字符为‘0’，‘1’；</span></span><br><span class="line"><span class="comment">                base为8时，合法字符为‘0’，‘1’，……‘7’；base为10时，合法字符为‘0’，‘1’，……‘9’；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                事实上base指定的是传入字符串的进制，函数会自动转化乘10进制</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            arr[count++] = num[<span class="number">0</span>] == <span class="string">'0'</span> ?</span><br><span class="line">                            strtol(num, <span class="literal">NULL</span>, <span class="number">8</span>) :</span><br><span class="line">                            strtol(num, <span class="literal">NULL</span>, <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    selection_sort(arr, count);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将排序后的数组写入文件</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">        <span class="built_in">fprintf</span>(fpnew, <span class="string">"%d\n"</span>, arr[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    fclose(fprog);</span><br><span class="line">    fclose(fpnew);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取结果文件并输出</span></span><br><span class="line">    fpnew = fopen(<span class="string">"new_2009.txt"</span>, <span class="string">"r"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"new_2009.txt:\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fgets(num, <span class="keyword">sizeof</span>(num), fpnew))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>, num);</span><br><span class="line">    fclose(fpnew);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><h4 id="代码结构-1"><a href="#代码结构-1" class="headerlink" title="代码结构"></a>代码结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">char</span> *a, <span class="keyword">char</span> digit[][<span class="number">15</span>], <span class="keyword">int</span> *p)</span></span></span><br><span class="line">将传入的字符串（包含整个文章内容）分成单词</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">char</span> digit[][<span class="number">15</span>], <span class="keyword">int</span> n)</span></span></span><br><span class="line">冒泡排序，升序排序</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">convert</span><span class="params">(<span class="keyword">char</span> *a)</span></span></span><br><span class="line">将字符串单词转化成10进制或八进制，这里可以选择使用strtol方法</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line">读入文件内容</span><br><span class="line">分词</span><br><span class="line">转化成十进制数字</span><br><span class="line">排序</span><br><span class="line">学如文件</span><br></pre></td></tr></table></figure><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">char</span> *a, <span class="keyword">char</span> digit[][<span class="number">15</span>], <span class="keyword">int</span> *p)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        对传入的字符串形式的数组按分隔符进行分词</span></span><br><span class="line"><span class="comment">        按逗号分词</span></span><br><span class="line"><span class="comment">        去除数字中间的空格</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(a[i] != <span class="string">'\0'</span>)&#123;</span><br><span class="line">        <span class="comment">// 字符非法，跳过</span></span><br><span class="line">        <span class="keyword">while</span>(a[i] &lt; <span class="string">'0'</span> || a[i] &gt; <span class="string">'9'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] == <span class="string">'\0'</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[i] == <span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 读取单词，存到二维数组中</span></span><br><span class="line">        <span class="keyword">while</span>((a[i] &gt;= <span class="string">'0'</span> &amp;&amp; a[i] &lt;= <span class="string">'9'</span>) || (a[i] == <span class="string">' '</span>))&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] == <span class="string">' '</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                digit[j][k++] = <span class="string">'\0'</span>;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 单词个数</span></span><br><span class="line">        *p = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">char</span> digit[][<span class="number">15</span>], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        冒泡排序</span></span><br><span class="line"><span class="comment">        外层控制趟数，内层控制比较次数</span></span><br><span class="line"><span class="comment">        升序排列</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">char</span> temp[<span class="number">15</span>];</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(convert(digit[j]) &gt; convert(digit[j+<span class="number">1</span>]))&#123;</span><br><span class="line">                <span class="built_in">strcpy</span>(temp, digit[j]);</span><br><span class="line">                <span class="built_in">strcpy</span>(digit[j], digit[j+<span class="number">1</span>]);</span><br><span class="line">                <span class="built_in">strcpy</span>(digit[j+<span class="number">1</span>], temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">convert</span><span class="params">(<span class="keyword">char</span> *a)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">讲字符串中的单词转化成十进制整数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>] == <span class="string">'0'</span>)&#123;</span><br><span class="line">        <span class="comment">// 八进制</span></span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">while</span>(a[i] != <span class="string">'\0'</span>)&#123;</span><br><span class="line">            number = <span class="number">8</span> * number + a[i++] - <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 十进制</span></span><br><span class="line">        <span class="keyword">while</span>(a[i] != <span class="string">'\0'</span>)&#123;</span><br><span class="line">            number = <span class="number">10</span> * number +a[i++] - <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">30</span>];</span><br><span class="line">    <span class="keyword">char</span> digit[<span class="number">10</span>][<span class="number">15</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开待处理文件</span></span><br><span class="line">    <span class="keyword">if</span>((fp = fopen(<span class="string">"org_2009.dat"</span>, <span class="string">"r"</span>)) == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"cannot open the file"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取文件，存储到一个字符串中</span></span><br><span class="line">    <span class="keyword">while</span>(!feof(fp))&#123;</span><br><span class="line">        a[i++] = fgetc(fp);</span><br><span class="line">    &#125;</span><br><span class="line">    a[i - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分词</span></span><br><span class="line">    divide(a, digit, &amp;j);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"#%s#\n"</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, j);</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="comment">// 输出分词结果</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; j; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"#%s#\n"</span>, digit[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    sort(digit, j);</span><br><span class="line">    <span class="keyword">if</span>((fp = fopen(<span class="string">"new_200.txt"</span>, <span class="string">"w"</span>)) == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"cannot open the file"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出排序结果并写入文件</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; j; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"#%s#\n"</span>, digit[i]);</span><br><span class="line">        <span class="built_in">fprintf</span>(fp, <span class="string">"%s\n"</span>, digit[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 研究生复试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 研究生复试 </tag>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows下搭建基于hexo的个人博客</title>
      <link href="/passages/windows-xia-da-jian-ji-yu-hexo-de-ge-ren-bo-ke/"/>
      <url>/passages/windows-xia-da-jian-ji-yu-hexo-de-ge-ren-bo-ke/</url>
      
        <content type="html"><![CDATA[<h3 id="Hexo搭建步骤"><a href="#Hexo搭建步骤" class="headerlink" title="Hexo搭建步骤"></a>Hexo搭建步骤</h3><ul><li>安装Git</li><li>安装Node.js</li><li>安装Hexo及项目搭建</li><li>Github创建个人仓库</li><li>生成ssh添加到Github</li><li>将hexo部署到github</li><li>个人域名绑定</li><li>发布文章</li><li>踩坑</li></ul><a id="more"></a><h3 id="1-安装Git"><a href="#1-安装Git" class="headerlink" title="1. 安装Git"></a>1. 安装Git</h3><ul><li><p>windows用户到<a href="https://gitforwindows.org/" target="_blank" rel="noopener">这里</a>下载Git并安装</p></li><li><p>验证Git安装成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git --version</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-安装Nodejs"><a href="#2-安装Nodejs" class="headerlink" title="2. 安装Nodejs"></a>2. 安装Nodejs</h3><ul><li><p>windows用户到<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">这里</a>下载并安装</p></li><li><p>验证Nodejs安装成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> node -v</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm -v</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-安装Hexo及项目搭建"><a href="#3-安装Hexo及项目搭建" class="headerlink" title="3. 安装Hexo及项目搭建"></a>3. 安装Hexo及项目搭建</h3><ul><li><p>输入以下命令安装Hexo并测试是否安装成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install -g hexo-cli</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo -v</span></span><br></pre></td></tr></table></figure></li><li><p>创建项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo init ziv_blog</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ziv_blog</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install</span></span><br></pre></td></tr></table></figure></li><li><p>在初始化的时候可能会比较慢，或者有时候会出现连接超时的情况，这时候切换为npm国内源就好了（2019.10.09更新）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install -g cnpm --registry=https://registry.npm.taobao.org</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 还可以使用以下命令验证是否切换成功</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm info express</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>本地目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 查看目录结构</span><br><span class="line">$ tree -L 1</span><br><span class="line">.</span><br><span class="line">├── _config.yml# 网站配置文件</span><br><span class="line">├── db.json</span><br><span class="line">├── node_modules# 依赖包</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json# 应用程序信息</span><br><span class="line">├── public  # 静态站点存放于此</span><br><span class="line">├── scaffolds# 模板文件夹，新建文章时会使用此文件夹下的文件作为模板</span><br><span class="line">├── source# 存放用户资源的地方</span><br><span class="line">├── themes# 主题</span><br><span class="line">└── yarn.lock</span><br></pre></td></tr></table></figure></li></ul><h3 id="Github搭建个人仓库"><a href="#Github搭建个人仓库" class="headerlink" title="Github搭建个人仓库"></a>Github搭建个人仓库</h3><ul><li><p>注册Github账户，<a href="https://github.com/" target="_blank" rel="noopener">这里</a></p></li><li><p>创建仓库（new repository）</p><ul><li>仓库名要与你的用户名相同，后面加.github.io。例如：<code>myname.github.io</code></li></ul></li><li><p>生成ssh添加到Github</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.name <span class="string">"your name"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.email <span class="string">"your email"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 核对</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config user.name</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config user.email</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建SSH</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen -t rsa -C <span class="string">"your email"</span></span></span><br></pre></td></tr></table></figure></li><li><p>生成的ssh在你的用户目录下的.ssh文件夹中（该文件夹默认隐藏）</p></li><li><p>其中id_rsa是你的私人密钥，id_rsa.pub是公钥，将公钥上传到Github</p></li><li><p>Github的setting -&gt; SSH key -&gt; new SSH key -&gt; 添加你的公钥（title随便起）</p></li><li><p>测试Github是否连接成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -T git@github.com</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="将hexo部署到github上"><a href="#将hexo部署到github上" class="headerlink" title="将hexo部署到github上"></a>将hexo部署到github上</h3><ul><li><p>将Hexo和Github关联起来，打开config.yml，添加以下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/YourgithubName/YourgithubName.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li><li><p>安装deploy-git，便于以后用命令部署</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li><li><p>hexo基本操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g# 生成静态站点放在public文件夹中</span><br><span class="line"></span><br><span class="line">$ hexo s# 本地启动服务，预览，访问localhost:4000</span><br><span class="line"></span><br><span class="line">$ hexo clean# 清除之前生成的东西</span><br><span class="line"></span><br><span class="line">$ hexo d# 部署文章</span><br><span class="line"></span><br><span class="line">$ hexo new 文件名# 创建新.md文件</span><br></pre></td></tr></table></figure></li><li><p>文章的标准格式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章标题</span><br><span class="line">date: 文章创建日期</span><br><span class="line">categories: 文章分类</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">  - </span>文章标签1</span><br><span class="line"><span class="bullet">  - </span>文章标签2</span><br><span class="line"><span class="bullet">  - </span>...</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">在<span class="code">`&lt;!-- more --&gt;`</span>之前编写文章的摘要内容！！！</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- more --&gt;</span></span></span><br><span class="line"></span><br><span class="line">在<span class="code">`&lt;!-- more --&gt;`</span>之后编写文章的正式内容！！！</span><br></pre></td></tr></table></figure></li></ul><h3 id="域名绑定与解析"><a href="#域名绑定与解析" class="headerlink" title="域名绑定与解析"></a>域名绑定与解析</h3><ul><li>请见另一篇博文。</li></ul><h3 id="截断文章，显示摘要"><a href="#截断文章，显示摘要" class="headerlink" title="截断文章，显示摘要"></a>截断文章，显示摘要</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在文章中合适 位置添加&lt;!--more--&gt;</span><br><span class="line"></span><br><span class="line">注意&lt;!--more--&gt;前的内容为摘要，不会显示在正文中</span><br></pre></td></tr></table></figure><h3 id="文章模版"><a href="#文章模版" class="headerlink" title="文章模版"></a>文章模版</h3><ul><li>可以修改在博客根目录下的scafflods的post.md文件。</li></ul><h3 id="文件中添加图片"><a href="#文件中添加图片" class="headerlink" title="文件中添加图片"></a>文件中添加图片</h3><ul><li>请见另一篇博文。</li></ul><h3 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h3><ul><li><p>npm install 时，长时间停留在fetchMetadata</p><ul><li><p>原因：网络不好</p></li><li><p>解决方法：更换源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org&#x2F;</span><br></pre></td></tr></table></figure></li><li><p>验证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config get registry</span><br></pre></td></tr></table></figure></li></ul></li><li><p>yml文件中</p><ul><li>每行的初始不能有空格</li><li>冒号之后必须有空格</li></ul></li></ul><h3 id="在不同的电脑上管理博客"><a href="#在不同的电脑上管理博客" class="headerlink" title="在不同的电脑上管理博客"></a>在不同的电脑上管理博客</h3><ul><li>这里提供一个思路，在github上令创建一个仓库，用于存放源文件，或者在码云上存放</li></ul><p> 本博客使用的是<a href="https://github.com/dongyuanxin/theme-ad" target="_blank" rel="noopener">ad</a>主题，欢迎来信交流。</p><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 博客相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu下搭建spark单机环境</title>
      <link href="/passages/ubuntu-xia-da-jian-spark-dan-ji-huan-jing/"/>
      <url>/passages/ubuntu-xia-da-jian-spark-dan-ji-huan-jing/</url>
      
        <content type="html"><![CDATA[<ul><li>Java SE</li><li>Scala</li><li>spark</li><li>sbt</li></ul><a id="more"></a><h3 id="安装配置Java-SE"><a href="#安装配置Java-SE" class="headerlink" title="安装配置Java SE"></a>安装配置Java SE</h3><ul><li><p>下载Java SE Linux版本，<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">这里</a>。</p></li><li><p>注意要选择Linux版本，并且根据实际情况选择64 or 32位。</p></li><li><p>下载jdk-XXXX-linux-XXX.tar.gz，解压到自己制定目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tar -zxvf jdk-XXXX-linux-XXX.tar.gz -C /usr/lib/java</span></span><br></pre></td></tr></table></figure></li><li><p>配置java环境变量</p><ul><li><p>打开.bashrc并在其尾部添加如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ nano ~&#x2F;.bashrc</span><br><span class="line"></span><br><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;lib&#x2F;java&#x2F;jdk1.8.0_131 </span><br><span class="line">export JRE_HOME&#x3D;$&#123;JAVA_HOME&#125;&#x2F;jre </span><br><span class="line">export CLASSPATH&#x3D;.:$&#123;JAVA_HOME&#125;&#x2F;lib:$&#123;JRE_HOME&#125;&#x2F;lib </span><br><span class="line">export PATH&#x3D;$&#123;JAVA_HOME&#125;&#x2F;bin:$&#123;JRE_HOME&#125;&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure></li><li><p>执行下列命令使环境变量生效，并测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> ~/.bashrc</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> java -version</span></span><br><span class="line">java version "XXXX"</span><br></pre></td></tr></table></figure><h3 id="安装配置Scala"><a href="#安装配置Scala" class="headerlink" title="安装配置Scala"></a>安装配置Scala</h3></li></ul></li><li><p>下载Scala的压缩文件，<a href="http://www.scala-lang.org/download/" target="_blank" rel="noopener">这里</a>。</p></li><li><p>下载scala-2.12.2.tgz后,解压到制定目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tar -zxvf scala-2.12.2.tgz -C /opt/scala/</span></span><br></pre></td></tr></table></figure></li><li><p>配置scala环境变量</p><ul><li><p>打开.bashrc，并在其尾部添加如下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nano ~/.bashrc</span></span><br><span class="line"></span><br><span class="line">export SCALA_HOME=/opt/scala/scala-2.12.2 </span><br><span class="line">export PATH=$&#123;SCALA_HOME&#125;/bin:$PATH</span><br></pre></td></tr></table></figure></li><li><p>执行下列命令使环境变量生效，并测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> ~/.bashrc</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> scala -version</span></span><br><span class="line">Scala code runner version 2.12.2</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="安装配置spark"><a href="#安装配置spark" class="headerlink" title="安装配置spark"></a>安装配置spark</h3><ul><li><p>下载spark压缩文件，<a href="http://spark.apache.org/downloads.html" target="_blank" rel="noopener">这里</a>。</p></li><li><p>下载spark-2.1.1-bin-hadoop2.7.tgz后，解压到指定的目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tar -zxvf spark-2.1.1-bin-hadoop2.7.tgz -C /opt/spark/</span></span><br></pre></td></tr></table></figure></li><li><p>配置spark环境变量</p><ul><li><p>打开.bashrc，并在其尾部添加如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nano ~/.bashrc</span></span><br><span class="line"></span><br><span class="line">export SPARK_HOME=/opt/spark/spark-2.1.1-bin-hadoop2.7</span><br><span class="line">export PATH=$&#123;SPARK_HOME&#125;/bin:$PATH</span><br></pre></td></tr></table></figure></li><li><p>执行下列命令时环境变量生效并测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> ~/.bashrc</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> spark-shell</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="安装配置sbt"><a href="#安装配置sbt" class="headerlink" title="安装配置sbt"></a>安装配置sbt</h3><ul><li><p>下载sbt的压缩文件，<a href="http://www.scala-sbt.org/download.html" target="_blank" rel="noopener">这里</a>。</p></li><li><p>下载sbt-0.13.15.tgz后，解压到指定的目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tar -zxvf sbt-0.13.15.tgz -C /opt/scala/sbt/</span></span><br></pre></td></tr></table></figure></li><li><p>配置sbt环境变量</p><ul><li><p>打开.bashrc文件，并在其尾部添加：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nano ~/.bashrc</span></span><br><span class="line"></span><br><span class="line">export SBT_HOME=/opt/scala/sbt</span><br><span class="line">export PATH=$&#123;SBT_HOME&#125;/bin:$PATH</span><br></pre></td></tr></table></figure></li><li><p>执行下列命令使环境变量生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> ~/.bashrc</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>创建启动sbt的脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir /opt/scala/sbt/ </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /opt/scala/sbt/ </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> touch sbt  </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 脚本内容如下，注意sbt-launch.jar的位置</span></span><br><span class="line">SBT_OPTS="-Xms512M -Xmx1536M -Xss1M -XX:+CMSClassUnloadingEnabled -XX:MaxPermSize=256M" </span><br><span class="line">java $SBT_OPTS -jar /opt/scala/sbt/bin/sbt-launch.jar "$@"</span><br></pre></td></tr></table></figure></li><li><p>检测sbt是否正确安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod u+x sbt </span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> sbt sbt-version</span></span><br><span class="line">[info] 0.13.15</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 若报错，使用如下命令查看</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sbt sbtVersion</span></span><br></pre></td></tr></table></figure></li></ul><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 工具配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>静态连接数据数据库实例</title>
      <link href="/passages/jing-tai-lian-jie-shu-ju-shu-ju-ku-shi-li/"/>
      <url>/passages/jing-tai-lian-jie-shu-ju-shu-ju-ku-shi-li/</url>
      
        <content type="html"><![CDATA[<p>数据库静态连接</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String url = <span class="string">"jdbc:mysql://127.0.0.1:3306/jdbc_db"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"root"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PASS = <span class="string">"123456"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//加载驱动程序</span></span><br><span class="line">       Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//获得数据库连接</span></span><br><span class="line">       Connection conn = DriverManager.getConnection(url, NAME, PASS);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//通过数据库的连接操作数据库</span></span><br><span class="line">       Statement stat = conn.createStatement();</span><br><span class="line"></span><br><span class="line">       ResultSet rs = stat.executeQuery(<span class="string">"select user_name from jdbc_db_goddess"</span>);</span><br><span class="line">       <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line"></span><br><span class="line">           System.out.println(rs.getString(<span class="string">"user_name"</span>));</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言文件操作</title>
      <link href="/passages/c-yu-yan-zhi-wen-jian-cao-zuo/"/>
      <url>/passages/c-yu-yan-zhi-wen-jian-cao-zuo/</url>
      
        <content type="html"><![CDATA[<ul><li>文件分类</li><li>文件缓冲区</li><li>文件指针</li><li>文件的打开与关闭</li><li>文件的读写</li><li>注意事项</li></ul><a id="more"></a><h3 id="文件分类"><a href="#文件分类" class="headerlink" title="文件分类"></a>文件分类</h3><ul><li>ASCII文件：文本文件，每一个字节存放一个字符的ASCII代码</li><li>二进制文件：映像文件，相当于存放在内存中数据的映像（内存中数据是以二进制形式存放的）</li></ul><h3 id="文件缓冲区"><a href="#文件缓冲区" class="headerlink" title="文件缓冲区"></a>文件缓冲区</h3><ul><li>从内存中输出数据必须先送到内存中的换中去，装满缓冲区之后才一起送到磁盘中去</li></ul><h3 id="文件指针"><a href="#文件指针" class="headerlink" title="文件指针"></a>文件指针</h3><ul><li>由系统声明，取名FILE  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FILE f1;&#96;&#96;&#96;  &#x2F;&#x2F;定义结构体变量f1，用于存放一个问价的有关信息 </span><br><span class="line">FILE *f1;&#96;&#96;&#96; &#x2F;&#x2F;指向文件类型数据的指针变量，通过文件指针变量能够找到与它关联的文件</span><br></pre></td></tr></table></figure></li></ul><h3 id="文件的打开与关闭"><a href="#文件的打开与关闭" class="headerlink" title="文件的打开与关闭"></a>文件的打开与关闭</h3><ul><li>在读写之前必须先打开文件，使用结束后必须手动关闭文件</li><li>打开文件使用fopen函数，fopen(文件名, 使用方式);</li><li><blockquote><p>“r”; //读，打开一个已存在的文本文件<br>  “w”; //写，打开一个文本文件<br>  “a”; //向文本文件尾部追加数据<br>  “rb”; //读，打开一个二进制文件<br>  “wb”; //写，打开一个二进制文件<br>  “ab”; //向二进制文件尾部追加数据<br>  “r+”; //读写，打开文本文件<br>  “w+”; //读写，新建文本文件<br>  “a+”; //读写，打开文本文件<br>  “rb+”; //读写，打开二进制文件<br>  “wb+”; //读写，新建二进制文件<br>  “ab+”; //读写，打开二进制文件</p></blockquote></li></ul><ul><li><pre><code class="c"><span class="comment">// 常规文件打开方式</span><span class="keyword">if</span>(fp=fopen(filename,<span class="string">"w"</span>) == <span class="literal">NULL</span>) {        <span class="built_in">printf</span>(<span class="string">"cannot ipen this file"</span>);        <span class="built_in">exit</span>(<span class="number">0</span>); }&lt;!--￼<span class="number">1</span>--&gt;      fclose(文件指针);  &lt;!--￼<span class="number">2</span>--&gt;  fgetc(文件指针);  fputc(字符, 文件指针);  &lt;!--￼<span class="number">3</span>--&gt;  fgets(字符数组, 长度, 文件指针);   <span class="built_in">fputs</span>(字符数组, 文件指针);  &lt;!--￼<span class="number">4</span>--&gt;  <span class="built_in">fprintf</span>(文件指针，格式字符串，输出列表);  <span class="built_in">fscanf</span>(文件指针，格式字符串，输入列表);  &lt;!--￼<span class="number">5</span>--&gt;  fread(<span class="built_in">buffer</span>, <span class="built_in">size</span>, count, fp);  fwrite(<span class="built_in">buffer</span>, <span class="built_in">size</span>, count, fp);  &lt;!--￼<span class="number">6</span>--&gt;</code></pre></li></ul><h3 id="随机读写数据文件"><a href="#随机读写数据文件" class="headerlink" title="随机读写数据文件"></a>随机读写数据文件</h3><ul><li><p>文件位置标记：指示接下来要读写的下一个字符的位置</p></li><li><p>文件位置标记的定位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rewind()# 使文件位置标记重新返回文件头部</span><br><span class="line"></span><br><span class="line">fseek(fp, 位移量, 起始点)# 改变文件位置标记</span><br><span class="line"></span><br><span class="line"># 起始点</span><br><span class="line">SEEK_SET# 文件开始位置</span><br><span class="line">SEEK_CUR# 文件当前位置</span><br><span class="line">SEEK_END# 文件末尾位置</span><br></pre></td></tr></table></figure></li><li><p>文件读写的出错检测</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ferror(fp);# 检测调用输入输出函数是是否出现错误</span><br><span class="line"></span><br><span class="line">clearerr();#使文件出错标志和文件结束标志置为<span class="number">0</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>null在c语言中没有预定义，必须使用大写NULL</li><li>双引号中的内容是const char，单引号中的内容是char</li><li>从控制台读字符串使用%s占位，读字符使用%c占位，读整形数字使用%d占位，读浮点数使用%f占位</li><li>使用vs2010编译c语言文件：创建项目，不勾选预编译，源文件文件夹上右键新建项，c++文件；先编译（ctrl+f7），再执行</li><li>打开文件后一定要手动关闭</li></ul><p>欢迎转载交流，拒绝一切形式的复制抄袭。</p><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 研究生复试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 研究生复试 </tag>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>苏州大学2007年复试编程题</title>
      <link href="/passages/su-zhou-da-xue-2007-nian-fu-shi-bian-cheng-ti/"/>
      <url>/passages/su-zhou-da-xue-2007-nian-fu-shi-bian-cheng-ti/</url>
      
        <content type="html"><![CDATA[<ul><li>找出指定范围内符合描述条件的数字并写入文件<a id="more"></a></li></ul><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><ul><li>找出10~1000之间：<ul><li>本身是素数</li><li>其反数也是素数，例如123的反数是321</li></ul></li><li>将结果写入result文件中</li></ul><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><ul><li>判断数字是否为素数</li><li>求其反数并判断是否为素数</li><li>符合条件的数字写入文件中</li></ul><h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. bool is_prime(int num)：</span><br><span class="line">判断传入的数字是否为素数</span><br><span class="line">2. int reverse(int num)：</span><br><span class="line">求传入数字的反转</span><br><span class="line">3. int mian()：</span><br><span class="line">创建文件指针</span><br><span class="line">循环判断数字是否符合条件</span><br><span class="line">格式化输出到文件中</span><br><span class="line">关闭文件</span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_prime</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        判断传入的数字是否为素数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>; i*i &lt; num; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        将传入的数字反转</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rev = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        rev = rev * <span class="number">10</span> + num % <span class="number">10</span>;</span><br><span class="line">        num /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FILE *fp = fopen(<span class="string">"result_2007.txt"</span>, <span class="string">"w"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">10</span>; i &lt;= <span class="number">1000</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(is_prime(i) &amp;&amp; is_prime(reverse(i)))&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(fp, <span class="string">"%d\n"</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 研究生复试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 研究生复试 </tag>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>苏州大学2008年复试编程题</title>
      <link href="/passages/su-zhou-da-xue-2008-nian-fu-shi-bian-cheng-ti/"/>
      <url>/passages/su-zhou-da-xue-2008-nian-fu-shi-bian-cheng-ti/</url>
      
        <content type="html"><![CDATA[<ul><li><p>排除指定单词，转换单词格式，输入到文件中</p><a id="more"></a><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3></li><li><p>用IE从FTP上下载org.dat，并保存到D盘根目录</p></li><li><p>顺序读取文件内的文章内容，读取过程中排除“the”及其变形</p></li><li><p>将读取的所有单词首字母转大写后，输出到D盘根目录下new.txt，每个单词一行</p></li></ul><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><ul><li>从ftp上下载文件</li><li>读取文件内容</li><li>过滤掉“the”及其变形，相同单词读写一次</li><li>将每个单词首字母大写，格式化输出到文件中</li></ul><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><h4 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. bool is_the(char word[15])：</span><br><span class="line">判断传入的单词是否为the，或其变形</span><br><span class="line"></span><br><span class="line">2. int main()：</span><br><span class="line">创建文件指针</span><br><span class="line">读取文件org.dat，输出并过滤the及其变形并写入<span class="keyword">new</span>.txt中</span><br><span class="line">输出<span class="keyword">new</span>.txt中的内容</span><br></pre></td></tr></table></figure><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_the</span><span class="params">(<span class="keyword">char</span> <span class="keyword">word</span>[<span class="number">15</span>])</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        判断传入的长度不超过15的单词是否为the及其变形</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> the[] = <span class="string">"the"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(<span class="keyword">word</span>) != <span class="built_in">strlen</span>(the))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(<span class="keyword">word</span>); i++)</span><br><span class="line">        <span class="keyword">word</span>[i] |= <span class="number">0x20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按字典顺序比较两个字符串的大小</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(<span class="keyword">word</span>, the) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FILE *fporg = fopen(<span class="string">"org.dat"</span>, <span class="string">"r"</span>);</span><br><span class="line">    FILE *fpnew = fopen(<span class="string">"new.txt"</span>, <span class="string">"w"</span>);</span><br><span class="line">    <span class="keyword">char</span> <span class="keyword">word</span>[<span class="number">15</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证两个文件均正常打开</span></span><br><span class="line">    <span class="keyword">if</span>(!fporg || !fpnew)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"File opening failed"</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"org.dat:\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按单词读取org.dat的内容并输出，同时过滤the并写入new.txt中</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">fscanf</span>(fporg, <span class="string">"%s"</span>, <span class="keyword">word</span>) != EOF)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s "</span>, <span class="keyword">word</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 'a'-'A' = 32 = 0x20</span></span><br><span class="line">        <span class="keyword">if</span>(!is_the(<span class="keyword">word</span>))&#123;</span><br><span class="line">            <span class="comment">// 首字母大写</span></span><br><span class="line">            <span class="keyword">word</span>[<span class="number">0</span>] = (<span class="keyword">word</span>[<span class="number">0</span>] | <span class="number">0x20</span>) - <span class="number">0x20</span>;</span><br><span class="line">            <span class="built_in">fprintf</span>(fpnew, <span class="string">"%s\n"</span>, <span class="keyword">word</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    fclose(fporg);</span><br><span class="line">    fclose(fpnew);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出new.txt的内容</span></span><br><span class="line">    fpnew = fopen(<span class="string">"new.txt"</span>, <span class="string">"r"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"new.txt:\n"</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">fscanf</span>(fporg, <span class="string">"%s"</span>, <span class="keyword">word</span>) != EOF)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s "</span>, <span class="keyword">word</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    fclose(fpnew);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><h4 id="代码结构-1"><a href="#代码结构-1" class="headerlink" title="代码结构"></a>代码结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. void divide(char *a, char words[][15], int *p)```：</span><br><span class="line">将读取的整个文件（含空格，含‘\<span class="number">0</span>’），划分为单词，这里可以改进为用格式化按单词读取文件。</span><br><span class="line">2. void printResult(char words[][15], int n)：</span><br><span class="line">重复单词只往文件中读写一次</span><br><span class="line">过滤THE及其变形</span><br><span class="line">首字母大写并写入文件中</span><br><span class="line">3. int isThe(char *p)：</span><br><span class="line">判断传入的单词是否是THE及其变形</span><br><span class="line">将传入长度为<span class="number">3</span>的单词转换成全部大写，再与THE比较</span><br><span class="line"><span class="number">4.</span> <span class="keyword">int</span> main：</span><br><span class="line">读取文件</span><br><span class="line">输出划分好的文章</span><br></pre></td></tr></table></figure><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">char</span> *a, <span class="keyword">char</span> words[][<span class="number">15</span>], <span class="keyword">int</span> *p)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        将直接读取整个文件（包含空格）划分成单词</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(a[i] != <span class="string">'\0'</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">isalpha</span>(a[i]))&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] == <span class="string">'\0'</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[i] == <span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isalpha</span>(a[i]))</span><br><span class="line">            words[j][k++] = a[i++];</span><br><span class="line"></span><br><span class="line">        words[j][k] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单词个数</span></span><br><span class="line">    *p = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printResult</span><span class="params">(<span class="keyword">char</span> words[][<span class="number">15</span>], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        过滤the及其变形，重复单词只写一遍，写入文件中</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">int</span> i, j, signal;</span><br><span class="line">    <span class="keyword">char</span> temp[<span class="number">15</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确认文件正常打开</span></span><br><span class="line">    <span class="keyword">if</span>((fp = fopen(<span class="string">"new.txt"</span>,<span class="string">"w"</span>)) == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"cannot opening file"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相同单词只读写一次</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        signal = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j == i)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 比较两个单词是否相同</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">strcmp</span>(words[i], words[j]) == <span class="number">0</span>)&#123;</span><br><span class="line">                    signal = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 非the及其变形的单词首字母大写并写入文件中</span></span><br><span class="line">        <span class="keyword">if</span>((signal == <span class="number">0</span>) &amp;&amp; !isThe(words[i]))&#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(temp, words[i]);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">islower</span>(temp[<span class="number">0</span>]))&#123;</span><br><span class="line">                temp[<span class="number">0</span>] -= <span class="number">32</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">fprintf</span>(fp, <span class="string">"%s "</span>, temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isThe</span><span class="params">(<span class="keyword">char</span> *p)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        判断传入的单词是否为THE及其变形</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> i, k;</span><br><span class="line">    <span class="comment">// 长度不为3</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(p) != <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 转化成全部大写，再与THE比较</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">islower</span>(p[i]))&#123;</span><br><span class="line">                p[i] -= <span class="number">32</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(p, <span class="string">"THE"</span>) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">500</span>];</span><br><span class="line">    <span class="keyword">char</span> words[<span class="number">100</span>][<span class="number">15</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((fp = fopen(<span class="string">"org.dat"</span>, <span class="string">"r"</span>)) == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"cannot open the file"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取文件</span></span><br><span class="line">    <span class="keyword">while</span>(!feof(fp))&#123;</span><br><span class="line">        a[i++] = fgetc(fp);</span><br><span class="line">    &#125;</span><br><span class="line">    a[i<span class="number">-1</span>] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    divide(a, words, &amp;j);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出划分好的文章</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; j; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s "</span>, words[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printResult(words, j);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 研究生复试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 研究生复试 </tag>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>苏州大学2005年复试编程题</title>
      <link href="/passages/su-zhou-da-xue-2005-nian-fu-shi-bian-cheng-ti/"/>
      <url>/passages/su-zhou-da-xue-2005-nian-fu-shi-bian-cheng-ti/</url>
      
        <content type="html"><![CDATA[<p>将给定数字拆分成若干素数的和</p><a id="more"></a><h2 id="2005-1"><a href="#2005-1" class="headerlink" title="2005-1"></a>2005-1</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><ul><li>将给定数字拆分成若干素数的和</li></ul><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><ul><li>素数：本身大于1，且除了1和其本身之外没有其他的素数因子。</li><li>C99之前的c语言没有bool类型，之后的标准中使用bool类型需要添加头文件stdbool.h。</li></ul><h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. int is_prime(int num)：</span><br><span class="line">判断输入的数字是否小于二</span><br><span class="line">循环判断<span class="number">2</span>~$\<span class="built_in">sqrt</span>&#123;n&#125;$是否有输入数字的因子</span><br><span class="line"></span><br><span class="line">2. void splite(int num)：</span><br><span class="line">判断数字是否小于<span class="number">2</span></span><br><span class="line">判断数字本身是否为素数：输出本身</span><br><span class="line">递归循环判断从n~<span class="number">1</span>开始依次递减判断是否为素数：输出并递归，减去输出的数字</span><br><span class="line"></span><br><span class="line">3. int main() ：</span><br><span class="line">输入并调用切分函数</span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_prime</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        判断输入的数字是否为素数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 小于2的不是素数</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否有除1和其本身之外的因子</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>; i*i &lt; num; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num % i == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// 小于2的不是素数</span></span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 本身是否为素数</span></span><br><span class="line">    <span class="keyword">if</span>(is_prime(num))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, num);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归判断</span></span><br><span class="line">    <span class="keyword">for</span>(i = num; i &gt; <span class="number">1</span>; --i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(is_prime(i) &amp;&amp; num-i &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, i);</span><br><span class="line">            splite(num - i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;i))&#123;</span><br><span class="line">        split(i);</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="number">10</span>);    <span class="comment">//输出换行符</span></span><br><span class="line">    &#125;</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2005-2"><a href="#2005-2" class="headerlink" title="2005-2"></a>2005-2</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><ul><li>从指定文件中读取文件内容</li><li>统计文件中各个字母的出现次数</li><li>字母顺序按照出现次数升序排列</li></ul><h3 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h3><ul><li>从文件中读取内容</li><li>定义结构体Letter，包含两部分：字母，次数</li><li>定义长度为26的Letter数组</li><li>判断字母大小写，同一个字母的大小写按同一个计数</li><li>使用选择排序对按出现次数对Letter数组排序</li></ul><h3 id="代码结构-1"><a href="#代码结构-1" class="headerlink" title="代码结构"></a>代码结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> Letter结构体：</span><br><span class="line"><span class="keyword">char</span>；</span><br><span class="line">n；</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> swap(Letter *a, Letter *b)：</span><br><span class="line">交换传入的两个数据</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> compare(Letter *a, Letter *b)：</span><br><span class="line">比较传入的两个数据</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> selection_sort(Letter *ptr, <span class="keyword">int</span> count)：</span><br><span class="line">选择排序（升序）</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> is_upper(<span class="keyword">char</span> c)：</span><br><span class="line">判断字母是否为大写</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span> is_lower(<span class="keyword">char</span> c)：</span><br><span class="line">判断字母是否为小写</span><br><span class="line"></span><br><span class="line">7. int main()：</span><br><span class="line">读入文件</span><br><span class="line">初始化Letter数组</span><br><span class="line">统计各个字母次数</span><br><span class="line">选择排序</span><br><span class="line">输出</span><br></pre></td></tr></table></figure><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;     <span class="comment">//字母</span></span><br><span class="line">    <span class="keyword">int</span> n;    <span class="comment">//出现次数</span></span><br><span class="line">&#125;Letter;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Letter *a, Letter *b)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        交换传入的两个数据</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Letter temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(Letter *a, Letter *b)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        比较两个传入字母出现次数的大小</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(a-&gt;n &lt; b-&gt;n)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a-&gt;n &gt; b-&gt;n)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(Letter *ptr, <span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        使用选择排序对传入的数组按升序排序</span></span><br><span class="line"><span class="comment">        选择排序：第i趟选择第i小的与第i个位置的元素交换位置</span></span><br><span class="line"><span class="comment">        第一层循环控制趟数，第二层循环控制比较</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; count; i++)&#123;</span><br><span class="line">        <span class="comment">// 从第i+1个位置与第i个位置的元素比较</span></span><br><span class="line">        <span class="keyword">for</span>(j = i+<span class="number">1</span>; j &lt; count; j++)</span><br><span class="line">            <span class="comment">// 若前者大于后者</span></span><br><span class="line">            <span class="keyword">if</span>(compare(&amp;ptr[i], &amp;ptr[j]) &gt; <span class="number">0</span>)</span><br><span class="line">                swap(&amp;ptr[i], &amp;ptr[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断是否为大写字母</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_upper</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;<span class="keyword">return</span> c&gt;=<span class="string">'A'</span> &amp;&amp; c&lt;=<span class="string">'Z'</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否为小写字母</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_lower</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;<span class="keyword">return</span> c&gt;=<span class="string">'a'</span> &amp;&amp; c&lt;=<span class="string">'z'</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FILE *fp = fopen(<span class="string">"2005_2.txt"</span>, <span class="string">"r"</span>);</span><br><span class="line"></span><br><span class="line">    Letter letter[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件打开失败</span></span><br><span class="line">    <span class="keyword">if</span>(!fp)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"file opening failed"</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初试化letter数组</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)&#123;</span><br><span class="line">        letter[i].c = i+<span class="string">'a'</span>;</span><br><span class="line">        letter[i].n = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计字母个数</span></span><br><span class="line">    <span class="keyword">while</span>((c = fgetc(fp)) != EOF)&#123;</span><br><span class="line">        <span class="keyword">if</span>(is_upper(c))</span><br><span class="line">            letter[c - <span class="string">'A'</span>].n ++;</span><br><span class="line">        <span class="keyword">if</span>(is_lower(c))</span><br><span class="line">            letter[c - <span class="string">'a'</span>].n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 选择排序</span></span><br><span class="line">    selection_sort(letter, <span class="number">26</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出letter数组</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c: %d\n"</span>, letter[i].c, letter[i].n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 研究生复试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 研究生复试 </tag>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>苏州大学2006年复试编程题</title>
      <link href="/passages/su-zhou-da-xue-2006-nian-fu-shi-bian-cheng-ti/"/>
      <url>/passages/su-zhou-da-xue-2006-nian-fu-shi-bian-cheng-ti/</url>
      
        <content type="html"><![CDATA[<p>找出100~1000中不含9的素数，将结果输入到result文件中</p><a id="more"></a><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><ul><li>找出100~1000中不含9的素数，将结果输入到result文件中</li></ul><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><ul><li>判断数字是否为素数</li><li>在是素数的基础上判断是否含9</li><li>写入文件</li></ul><h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. bool is_prime(int num)：</span><br><span class="line">判断传入的数字是否为素数</span><br><span class="line">2. bool is_has9(int num)：</span><br><span class="line">判断传入的数字是否含<span class="number">9</span></span><br><span class="line">3. int mian()：</span><br><span class="line">创建文件指针</span><br><span class="line">循环判断<span class="number">100</span>~<span class="number">1000</span>之间的数字是否为素数</span><br><span class="line">是素数的数字是否含<span class="number">9</span></span><br><span class="line">符合条件的数字写入文件</span><br><span class="line">关闭文件</span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_prime</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        判断传入的数字是否为素数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>; i*i &lt; num; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_has9</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        判断传入的数字是否含9</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="number">9</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(num &gt;= <span class="number">9</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num % <span class="number">10</span> == <span class="number">9</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FILE *fp = fopen(<span class="string">"result.txt"</span>, <span class="string">"w"</span>);;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环判断</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">100</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(is_prime(i) &amp;&amp; !is_has9(i))</span><br><span class="line">            <span class="built_in">fprintf</span>(fp, <span class="string">"%d\n"</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>欢迎来信交流||指教。</p>]]></content>
      
      
      <categories>
          
          <category> 研究生复试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 研究生复试 </tag>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
