{"meta":{"title":"Ziv（瓶子）","subtitle":null,"description":null,"author":"Wang Jinfeng","url":"http://zivblog.top","root":"/"},"pages":[{"title":"所有分类","date":"2019-03-02T12:18:35.000Z","updated":"2020-07-06T04:12:46.688Z","comments":true,"path":"categories/index.html","permalink":"http://zivblog.top/categories/index.html","excerpt":"","text":""},{"title":"友链","date":"2020-07-07T01:33:01.603Z","updated":"2020-07-07T01:33:01.603Z","comments":true,"path":"friends/index.html","permalink":"http://zivblog.top/friends/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-03-02T12:20:11.000Z","updated":"2020-07-06T04:10:57.853Z","comments":true,"path":"about/index.html","permalink":"http://zivblog.top/about/index.html","excerpt":"","text":"个人简介 计算机研一在读 方向：自然语言处理 喜欢Python 对机器学习、自然语言处理感兴趣 联系方式 邮箱 : jfwang9@stu.suda.edu.cn QQ : 850300210 欢迎交流，无事勿扰 如发现文章内排版或理论问题，欢迎来信指正 请指明文章名及位置 请配截图 谢谢"},{"title":"所有标签","date":"2020-07-06T06:13:01.499Z","updated":"2020-07-06T06:13:01.499Z","comments":true,"path":"tags/index.html","permalink":"http://zivblog.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Leetcode之数组与字符串","slug":"Leetcode之数组与字符串","date":"2020-08-04T00:58:45.000Z","updated":"2020-08-09T06:42:10.892Z","comments":true,"path":"passages/leetcode-zhi-shu-zu-yu-zi-fu-chuan/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-shu-zu-yu-zi-fu-chuan/","excerpt":"数组与字符串（2020.8.4~2020.8.）","text":"数组与字符串（2020.8.4~2020.8.） 2020.8.4 更新 数组简介集合、列表和数组 集合：由一个或多个确定的元素所构成的整体 集合里的元素类型不一定相同 集合里的元素没有顺序 列表（线性列表）：按照一定的线性顺序，排列而成的数据项的集合 包括数组和链表 Python中的List不是数组，包含的元素的数据类型不一定相同 寻找数组的中心索引 对应Leetcode第724题 给定一个整数类型的数组，返回中心索引 中心索引：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和 123456789101112131415161718192021def pivotIndex(self, nums: List[int]) -&gt; int: ''' 先计算出数组所有元素之和 遍历数组，计算当前位置左边的元素之和 当左边元素之和*2+当前元素=数组之和时，返回当前位置 特殊处理： 数组长度为0时，返回-1 数组长度为1时，返回nums[0] ''' if len(nums) == 0: return -1 if len(nums) == 1: return nums[0] sum_ = sum(nums) left_sum = 0 for idx, num in enumerate(nums): if left_sum*2+num == sum_: return idx left_sum += num return -1 搜索插入位置 对应leetcode第35题 给定一个排序数组（无重复元素）和一个目标值 在数组中找到目标值，并返回其索引 如果目标值不存在于数组中，返回它将被插入的位置 12345678910111213def searchInsert(self, nums: List, target: int) -&gt; int: ''' 遍历有序数组，若当前位置的元素大于或等于目标值，则返回当前位置的下标 特殊处理： 当数组为空时，返回0 当数组中无插入位置，返回len(nums)，即数组最后一个位置的下一个位置 ''' if len(nums) == 0: return 0 for idx, num in enumerate(nums): if num &gt;= target: return idx return len(nums) 合并区间 对应leetcode第56题 解析见合并区间 二维数组简介 二维数组是一种结构比较特殊的数组，将数组中的每个元素变成了一维数组 旋转矩阵 对应leetcode第48题 给定一幅由N*N矩阵表示的图像，其中的像素大小为4字节 将图像旋转90度 能够不使用额外的内存空间（原地）解决吗？ 解析见旋转图像 1234567891011121314151617181920212223class Solution: def rotate(self, matrix: List[List[int]]) -&gt; None: \"\"\" 通过数据观察可以发现，旋转90度相当于将第i行转化为第len(matrix)-i-1列 这里我们通过两次反转实现 根据左上到右下的对角线反转 再根据水平对称轴反转 原理在于 进行对角线反转时，相当于一次270度的旋转 进行水平对称轴反转，相当与进行一次-189度的旋转 最终两次效果叠加，相当于一次90度的旋转 \"\"\" # 方阵 n = len(matrix) # 沿左上到右下反转 for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] print() # 竖直对称轴反转 for i in range(n): matrix[i].reverse() 12345678910111213141516class Solution: def rotate(self, matrix: List[List[int]]) -&gt; None: # 方阵 n = len(matrix) ''' 或者沿右上到左下的对角线反转 再沿竖直对称线反转 ''' # # 沿右上到左下反转 # for i in range(n): # for j in range(n-i): # matrix[i][j], matrix[n-j-1][n-i-1] = matrix[n-j-1][n-i-1], matrix[i][j] # # 水平对称线反转 # for i in range(n//2): # matrix[i], matrix[n-i-1] = matrix[n-i-1], matrix[i] 零矩阵 对应leetcode第91题 编写算法，若M*N的矩阵中某个元素为0，则将其所在的行与列清零 解析见矩阵置零 1234567891011121314151617181920212223class Solution: def setZeroes(self, matrix: List[List[int]]) -&gt; None: \"\"\" 使用一个字典记录 \"\"\" r_c = &#123;'row':[], 'col':[]&#125; for i in range(len(matrix)): for j in range(len(matrix[0])): if matrix[i][j] == 0: r_c['row'].append(i) r_c['col'].append(j) row, col = set(r_c['row']), set(r_c['col']) for i in range(len(matrix)): if i in row: for j in range(len(matrix[0])): matrix[i][j] = 0 else: for j in range(len(matrix[0])): if j in col: matrix[i][j] = 0 12345678910111213141516171819202122232425262728293031323334353637class Solution: def setZeroes(self, matrix: List[List[int]]) -&gt; None: \"\"\" 不使用额外的空间，使用第一行第一列记录的元素记录该行或该列是否需要置零 注意点： matrix[0][0]只能表示列或行中的一种情况，所以需要一个额外的标识来记录其中一个 以代码为例，用一个标识记录第一列是否需要置零，这时对第一列的置零要在第一行之后（对第一列置零后会影响行的置零） \"\"\" # 第一列是否需要置零 is_col = False for i in range(len(matrix)): # 只要第一列有0 if matrix[i][0] == 0: is_col = True for j in range(1, len(matrix[0])): if matrix[i][j] == 0: # 记录该行 matrix[i][0] = 0 # 记录该列 matrix[0][j] = 0 # 除去第一列和第一行 for i in range(1, len(matrix)): for j in range(1, len(matrix[0])): if not matrix[i][0] or not matrix[0][j]: matrix[i][j] = 0 # 注意顺序 # 第一行 if matrix[0][0] == 0: for i in range(len(matrix[0])): matrix[0][i] = 0 # 处理第一列 if is_col: for i in range(len(matrix)): matrix[i][0] = 0 2020.8.6 更新 对角线遍历 对应leetcode第498题 给定一个包含M*N个元素的矩阵（M行，N列），请以对角线遍历的顺序返回这个矩阵中的所有元素，对角线遍历如下图所示 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution: def findDiagonalOrder(self, matrix: List[List[int]]) -&gt; List[int]: ''' 对于这种比较奇怪的遍历，找规律 按遍历的顺序，每层存在一个规律 当前层的元素的横纵坐标之和为一个定值 刚好为当前所在的层的索引[0, m+n-1], 共m+n+1层 另外，遍历的顺序有两种 当层数的索引为偶数时，遍历从左下向右上进行（横坐标减小，纵坐标增大） 当层数的索引为奇数时，遍历从右上向左下进行（横坐标增大，从坐标减小） ''' if len(matrix) == 0: return [] n, m = len(matrix), len(matrix[0]) f_num = n + m - 1 res = [] # 按层遍历 for f in range(f_num): # 左下到右上 if f % 2 == 0: # 横坐标减小 for i in range(f, -1, -1): # 横纵坐标之和为一定值，即f j = f - i if i &lt; n and j &lt; m: res.append(matrix[i][j]) elif j &gt;= m: break else: continue # 右上到左下 else: # 纵坐标减小 for j in range(f, -1, -1): i = f - j if i &lt; n and j &lt; m: res.append(matrix[i][j]) elif i &gt;= n: break else: continue return res 字符串简介 字符串由一个或多个字符组成的有限序列 字符串的基本操作对象通常是字符串整体或字符串的子串 最长公共前缀 对应leetcode的第14题 编写函数查找字符串数组中的最长公共前缀 123456789101112131415161718192021222324252627282930class Solution: def longestCommonPrefix(self, strs: List[str]) -&gt; str: ''' 依次遍历每个字符串的每个字符 若相等，则添加到结果中 若不相等，则退出 剪枝： 按照最短的字符串的长度进行遍历 特殊情况： 当数组为空时，返回空串 ''' if len(strs) == 0: return \"\" str_len = [len(str) for str in strs] max_pre = \"\" i = 0 while i &lt; min(str_len): is_equal = True s = strs[0][i] # 遍历所有字符串的第i个字符 for str_ in strs[1:]: if s != str_[i]: is_equal = False break if is_equal: max_pre += strs[0][i] else: break i += 1 return max_pre 1234567891011121314151617class Solution: def longestCommonPrefix(self, strs: List[str]) -&gt; str: ''' 利用字符串排序的原理 按字符的ASCII码进行排序 只需对排序后字符串数组的第一个字符串和最后一个字符串求公共前缀即可 ''' if len(strs) == 0: return \"\" strs.sort() min_, max_ = strs[0], strs[len(strs)-1] for i in range(len(min_)): if min_[i] != max_[i]: return min_[:i] return min_ 最长回文子串 对应leetcode中第5题 给定一个字符串s，找到s中最长的回文子串 12345678910111213141516171819202122232425262728293031323334353637383940class Solution: def longestPalindrome(self, s: str) -&gt; str: ''' 动态规划 N*N的数组，记录第i个元素到第j个元素组成的子串是否为回文串 单个元素必为回文串 当i和j对应的元素相等时 若两者之差小于等于2，必为回文串 当两个之差大于2时，与第i+1到j-1个元素组成的子串有关 记录i的位置和回文串的长度 特殊情况 当字符串长度小于等于2的时候，必为回文串 注意 子串和子序列的区别 ''' if len(s) &lt; 2: return s len_ = len(s) dp = [[False]*len_ for _ in range(len_)] # 初始化 for i in range(len_): dp[i][i] = True max_len, start = 1, 0 for j in range(1, len_): for i in range(j): if s[i] == s[j]: if j - i &lt;= 2: dp[i][j] = True else: dp[i][j] = dp[i+1][j-1] else: dp[i][j] = False if dp[i][j]: cur_len = j - i + 1 if cur_len &gt; max_len: max_len = cur_len start = i return s[start: start+max_len] 2020.8.8更新 翻转字符串里的单词 对应leetcode中第151题 给定一个字符串，逐个翻转字符串中的每个单词 无空格字符构成一个单词 输入字符串可以在前面或后面包含多余的空格，但是反转后的字符串不能包括 如果两个单词之间有多个空格，将反转后单词间的空格减少到只含一个 123456789101112131415161718192021222324252627class Solution: def reverseWords(self, s: str) -&gt; str: ''' 遍历，使用列表存储当前字符串，添加到结果中 在字符串后添加一个空格分割 缺点： 使用几乎等长的额外空间 ''' res = list() sub_s = '' is_end = False for i in range(len(s)): if s[i] != ' ': sub_s += s[i] else: if is_end == False: is_end = True # 连续空格跳过 else: continue if is_end or i == len(s)-1: if sub_s != \"\": res.append(sub_s) sub_s = '' is_end = False # 反向添加到结果中 return \" \".join(reversed(res)) 123456789class Solution: def reverseWords(self, s: str) -&gt; str: ''' Python的内置函数 使用split按空格分割，因为可能是多个空格分割，不能指定为单空格分割 使用reversed反转列表 使用join中间添加空格拼接 ''' return \" \".join(reversed(s.split())) 实现strStr 对应leetcode第28题 KMP算法 使用next数组保存模式串和主串之间元素不匹配时，下一步应该重新开始的位置 next数组中，p[i]对应模式串p[0,i+1]中最长公共前后缀（前缀和后缀中的公共部分，前后缀不能有重叠）的长度 net[0]=1表示不懂 next数组只与模式串本身的性质有关 参考代码 12345678910111213141516171819202122232425262728293031# next数组的构造def build_next(P): n = len(P) Next = [0]*n Next[0]= -1 j, t = 0, -1 while j &lt; n-1: if t &lt; 0 or P[j]==P[t]: j += 1 t += 1 Next[j] = t else: t = Next[t] return Nextdef match(P, S): ''' P: 模式串 S: 主串 ''' next = build_next(P) m, n = len(S), len(P) i, j = 0, 0 while j &lt; n and i &lt; m: if j &lt; 0 or S[i]==P[j]: i += 1 j == 1 else: # 有限回溯 j = next[j] return i - j 给定一个字符串和一个模式串，找到在主串中模式串第一次出现的位置 如果不存在，则返回-1 12345678910111213141516class Solution: def strStr(self, haystack: str, needle: str) -&gt; int: ''' 暴力匹配 ''' if len(needle) == 0: return 0 for i in range(len(haystack)-len(needle)+1): j = 0 while j &lt; len(needle): if haystack[i+j] != needle[j]: break j += 1 if j == len(needle): return i return -1 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution: def strStr(self, haystack: str, needle: str) -&gt; int: ''' KMP 构建next数组 匹配 ''' def build_next(P): n = len(P) Next = [0]*n Next[0] = -1 j, t = 0, -1 while j &lt; n-1: if t &lt; 0 or P[j]==P[t]: j += 1 t += 1 Next[j] = t else: t = Next[t] return Next def match(P, S): Next = build_next(P) m, n = len(S), len(P) i, j = 0, 0 while j &lt; n and i &lt; m: if j &lt; 0 or S[i]==P[j]: i += 1 j += 1 else: # 有限回溯 j = Next[j] print(i, j) return i, j if len(needle) == 0: return 0 i, j = match(needle, haystack) # 匹配成功 if j == len(needle): return i-j else: return -1 2020.8.9 更新 双指针技巧 双指针的经典场景 从两段向中间迭代数组，指针的运动方向相反 两个不同步的指针，即快慢指针，指针的运动方向相同 反转字符串 对应leetcode第344题 将输入的字符串反转过来，字符串以字符数组的形式给出 需要原地修改数组 详细解释见反转字符串 123456789101112131415class Solution: def reverseString(self, s: List[str]) -&gt; None: \"\"\" 双指针分别指向数组的头部和尾部 交换指针指向的元素 两指针分别向中间移动 直到两指针相遇 \"\"\" left, right = 0, len(s)-1 while left &lt; right: s[left], s[right] = s[right], s[left] left += 1 right -= 1 return s 数组拆分 对应leetcode第561题 给定长度为2n的数组, 你的任务是将这些数分成n对, 例如(a1, b1), (a2, b2), ..., (an, bn)，使得从1到n的min(ai, bi)总和最大 1234567891011121314class Solution: def arrayPairSum(self, nums: List[int]) -&gt; int: ''' 可以发现，如果想要使n对数中较小值的和最大 可以将数组进行排序，每相邻两个组成一对，这样每对中的较小值之和即为最大 所以，可以先对数组进行排序，从第一个开始，隔一个取一个即可 ''' nums.sort() sum_, i = 0, 0 while i &lt;= len(nums)-2: sum_ += nums[i] i += 2 return sum_ 好像和双指针没什么联系啊，难道是排序算法？ 两数之和 Ⅱ 对应leetcode第167题 给定一个按照升序排列的有序数组，找到两个数使他们相加之和等于目标数 返回两个下标值index1和index2，要求index1必须小于index2 下标值是从1开始的，并且不能使用两个相同的数 详细分析请看两数之和Ⅱ 12345678910111213141516171819class Solution: def twoSum(self, numbers: List[int], target: int) -&gt; List[int]: ''' 双指针分别指向数组的头和尾部 计算指针指向的两个元素的值 若两者之和大于目标值，则尾指针向前移动 若两者之和小于目标值，则头指针向后移动 由于排过序，相同的数字都在一起 两指针不能指向同一个元素 ''' head, tail = 0, len(numbers)-1 while head &lt; tail: sum_ = numbers[head]+numbers[tail] if sum_ == target: return [head+1, tail+1] elif sum_ &gt; target: tail -= 1 else: head += 1 移除元素 对应leetcode第27题 给定一个数组nums和一个val，你需要原地移出所有数值等于val的元素，并返回一处后数组的新长度 不要使用额外的数组空间，请原地修改数组 123456789101112131415class Solution: def removeElement(self, nums: List[int], val: int) -&gt; int: ''' 由于对元素的顺序没有要求，且返回的是长度 可以将与val相同的元素依次用后面的元素替换 最后返回新的长度即可 ''' p, end = 0, len(nums)-1 while p &lt;= end: if nums[p] == val: nums[p] = nums[end] end -= 1 else: p += 1 return p 123456789101112131415class Solution: def removeElement(self, nums: List[int], val: int) -&gt; int: &#39;&#39;&#39; 快慢指针 快指针每次移动一步 慢指针仅在元素不为val的时候移动 当慢指针指向val时，与快指针交换 &#39;&#39;&#39; slow, fast &#x3D; 0, 0 while fast &lt; len(nums): if nums[fast] !&#x3D; val: nums[slow] &#x3D; nums[fast] slow +&#x3D; 1 fast +&#x3D; 1 return slow 最大连续1的个数 给定一个二进制数组，计算其中最大连续1的个数 1234567891011121314151617181920212223class Solution: def findMaxConsecutiveOnes(self, nums: List[int]) -&gt; int: ''' 快慢指针 快指针每次都移动 慢指针在指向0的时候移动，或在快指针指向0的时候计算完连续1的长度后移动 特殊情况 当快指针指向最后一个元素且为1时，长度+1 ''' if len(nums) == 1: return 1 if nums[0]==1 else 0 res = 0 slow = 0 for fast in range(len(nums)): if nums[slow] == 0: slow += 1 continue if nums[fast] != 1: res = max(res, fast-slow) slow = fast if fast == len(nums)-1: res = max(res, fast-slow+1) return res 长度最小的子数组 对应leetcode第209题 给定一个含有n个正整数的数组和一个正整数s，找出该数组中满足和&gt;=s的长度最小的连续子数组，返回长度；如果不存在，则返回0 详细分析见长度最小的子数组 12345678910111213141516171819class Solution: def minSubArrayLen(self, s: int, nums: List[int]) -&gt; int: ''' 双指针 快指针一直移动，不断累加，直到大于给定值时 和不断减去慢指针指向的位置的元素，慢指针移动 直到快指针遍历结束 ''' res = float('inf') slow = 0 sum_ = 0 for fast in range(len(nums)): sum_ += nums[fast] while sum_ &gt;= s: res = min(res, fast-slow+1) sum_ -= nums[slow] slow += 1 return 0 if res == float('inf') else res 2020.8.10 更新","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"多标签任务中的Macro-F1和Micro-F1","slug":"多标签任务中的Macro-F1和Micro-F1","date":"2020-08-03T02:42:31.000Z","updated":"2020-08-03T04:00:30.993Z","comments":true,"path":"passages/duo-biao-qian-ren-wu-zhong-de-macro-f1-he-micro-f1/","link":"","permalink":"http://zivblog.top/passages/duo-biao-qian-ren-wu-zhong-de-macro-f1-he-micro-f1/","excerpt":"多标签任务中的宏平均和微平均","text":"多标签任务中的宏平均和微平均 多标签任务中的Macro-F1和Micro-F1本文分为三部分 混淆矩阵中TP、FP、TN、FN四个值 Precision、Recall和F1-Score的计算 Macro-F1和Micro-F1的区别 混淆矩阵 实际标签 实际标签 P N 预测输出 P’ TP，实际为正预测为正（真阳性） FP，实际为负，预测为正（假阳性） 预测输出 N’ FN，实际为正，预测为负（假阴性） TN，实际为负，预测为负（真阴性） 精确度和召回值 精确率，表示的是正确预测为正的样本占全部预测为正的样本的比例$$Precision=\\frac{TP}{TP+FP}$$ 召回率，表示的是正确预测为正的样本占全部实际为正的样本的比例$$Recall=\\frac{TP}{TP+FN}$$ F1值，表示的是精确率和召回率的加权$$F1-Score=\\frac{2*Precision*Recall}{Precision+Recall}$$ Macro-F1和Micro-F1 举例说明 预测值 实际值 A A A A B A C A B B B B C B B C C C 类别A的混淆矩阵为 A Other Pre_A 2 0 Pre_Other 2 ~ $$Precison_A = \\frac{TP}{TP+FP}=\\frac{2}{2+0}=100%$$ $$Recall_A = \\frac{TP}{TP+FN} = \\frac{2}{2+2} = 50%$$ $$F1-Score_A = \\frac{2PrecisionRecall}{Precision+Recall} = \\frac{210.5}{1+0.5}=67%$$ 类别B的混淆矩阵为 B Other Pre_B 2 2 Pre_Other 1 ~ $$Precison_B = \\frac{TP}{TP+FP}=\\frac{2}{2+2}=50%$$ $$Recall_B = \\frac{TP}{TP+FN} = \\frac{2}{2+1} = 67%$$ $$F1-Score_B = \\frac{2PrecisionRecall}{Precision+Recall} = \\frac{20.50.67}{0.5+0.67}=57%$$ 类别C的混淆据真伪 C Other Pre_C 1 2 Pre_Other 1 ~ $$Precison_C = \\frac{TP}{TP+FP}=\\frac{1}{1+2}=33%$$ $$Recall_C = \\frac{TP}{TP+FN} = \\frac{1}{1+1} = 50%$$ $$F1-Score_C = \\frac{2PrecisionRecall}{Precision+Recall} = \\frac{20.330.5}{0.33+0.5}=40%$$ Micro-F1不需要去分类别，直接统计总样本的准确率和召回率进行计算整个样本上的F1-Score 5（TP，预测正确） 4（FP，预测错误） 4（TN，预测错误） ~ $$Precision=\\frac{TP}{TP+FN} = \\frac{5}{5+4} = 56%$$ $$Recall = \\frac{TP}{TP+FN} = \\frac{5}{5+4}=56%$$ $$Micro-F1 =\\frac{2PrecisionRecall}{Precision+Recall} = \\frac{20.560.56}{0.56+0.56}=56%$$ Macro-F需要先计算出每个类别的准确率和召回率，通过求平均值计算整个样本上的F1-Score$$Macro-F1 = \\frac{F1_A+F1_B+F1_C}{3} = \\frac{0.67+0.57+0.40}{3}=0.546$$ 从上面的例子中可以发现 Micro-Score考虑到了每个类别中样本的数量，适用于数据分布不均衡的情况；但是在数据分布极度不平衡的情况下，数量多的类别会对最终的成绩影响较大 Macro-Score没有考虑不同类别中的样本数量，平等地看待每一个类别，会有较高的Precision和Recall的影响","categories":[{"name":"自然语言处理","slug":"自然语言处理","permalink":"http://zivblog.top/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"}],"tags":[{"name":"NLP","slug":"NLP","permalink":"http://zivblog.top/tags/NLP/"}]},{"title":"Leetcode之删除二叉搜索树中的节点","slug":"Leetcode之删除二叉搜索树中的节点","date":"2020-07-30T02:18:57.000Z","updated":"2020-07-30T02:50:21.365Z","comments":true,"path":"passages/leetcode-zhi-shan-chu-er-cha-sou-suo-shu-zhong-de-jie-dian/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-shan-chu-er-cha-sou-suo-shu-zhong-de-jie-dian/","excerpt":"Delete Node in BST","text":"Delete Node in BST Delete Node in BST code with Python title number：450 读题 给定一个二叉搜索树的根节点root和一个值key，删除二叉搜索树中的key对应的节点，保证二叉搜索树的性质不变 返回根节点 一般来说，删除节点可分为两个步骤： 找到需要删除的节点 找到之后，删除 调整树结构使之符合二叉搜索树的性质 示例 1234567891011121314151617181920212223242526root &#x3D; [5,3,6,2,4,null,7]key &#x3D; 3 5 &#x2F; \\ 3 6 &#x2F; \\ \\2 4 7给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。 5 &#x2F; \\ 4 6 &#x2F; \\2 7另一个正确答案是 [5,2,6,null,4,null,7]。 5 &#x2F; \\ 2 6 \\ \\ 4 7 思路一 首先，待删除的节点有三种情况 如果该节点是叶子节点，则直接删除 如果该节点的左右孩子只存在一个，则将其孩子节点与该节点交换位置，并删除叶子节点即可 如果该节点的左右孩子都存在，则选择左子树中的最小值或右子树中的最大值与其交换，删除叶子节点即可 整体思路是将待删除节点交换到叶子节点处执行删除操作 123456789101112131415161718def deleteNode(self, root: TreeNode, key: int) -&gt; TreeNode: def delete(root, key, l): # 树为空 if not root: return l # 删除根节点 if root.val == key: return delete(root.right, key, root.left) # 节点在右子树中 elif root.val &lt; key: root.right = delete(root.right, key, l) return root # 节点在左子树中 else: root.left = delete(root.left, key, l) return root return delete(root, key, None) 另一种写法 12345678910111213141516171819202122232425262728293031def deleteNode(self, root: TreeNode, key: int) -&gt; TreeNode: if not root: return Nonde # 去左子树中找 if root.val &gt; key: root.left = self.deleteNode(root.left, key) return root # 去右子树中找 elif root.val &lt; key: root.right = self.deleteNode(root.right, key) return root # 找到待删除节点 else: left = root.left right = root.right # 左子树为空，直接返回右子树 if not left: return root.right # 右子树为空，直接返回左子树 elif not right: return root.left # 左右子树都不为空，与右子树的最左节点（第一个比跟大的节点） # 删除，并将根节点的左子树代替其位置 # 返回该节点右子树的根节点 else: r = right while right.left: right = right.left right.left = left return r","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之找到字符串中所有字母异位词","slug":"Leetcode之找到字符串中所有字母异位词","date":"2020-07-29T01:16:07.000Z","updated":"2020-07-29T01:32:19.748Z","comments":true,"path":"passages/leetcode-zhi-zhao-dao-zi-fu-chuan-zhong-suo-you-zi-mu-yi-wei-ci/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zhao-dao-zi-fu-chuan-zhong-suo-you-zi-mu-yi-wei-ci/","excerpt":"Find All Anagrams in a String","text":"Find All Anagrams in a String Find All Anagrams in a String code with Python title number：438 读题 给定一个字符串s和一个非空字符串p，找到s中所有是p的字母异位词的子串，返回这些子串的起始索引 字符串只包含小写英文字母，并且字符串s和p的长度都不超过20100 示例 12345输入：s: \"cbaebabacd\" p: \"abc\"输出：[0, 6]解释：起始索引等于 0 的子串是 \"cba\", 它是 \"abc\" 的字母异位词起始索引等于 6 的子串是 \"bac\", 它是 \"abc\" 的字母异位词 思路一 所谓字母异位词，实际与567中的字符串的排列是相同的概念 子串中的字母没有顺序，因此我们可以使用字典来保存每个字母出现的次数 使用滑动窗口读取s中与p等长的子串，如果子串对应的字母出现的次数和p相同，那么子串就是p的字母异位词 注意，通过这种方式判断s的子串为p的异位词时，指针q所在的位置时子串的结束索引，可以通过q-l1+1计算得到子串的起始位置，也可以直接读取p所在的位置 123456789101112131415161718def findAnagrams(selfm s: str, p: str) -&gt; List[int]: res = [] l1, l2 = len(p), len(q) c1, c2 = collections.Counter(p), collections.Counter() p, q = 0, 0 while q &lt; l2: c2[s[q]] += 1 if c2 == c1: res.append(p) q += 1 if q - p + 1 &gt; l1: c2[s[p]] -= 1 if c2[s[q]] == 0: del c2[s[p]] p += 1 return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之字符串的排列","slug":"Leetcode之字符串的排列","date":"2020-07-28T00:55:35.000Z","updated":"2020-07-28T01:33:32.472Z","comments":true,"path":"passages/leetcode-zhi-zi-fu-chuan-de-pai-lie/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zi-fu-chuan-de-pai-lie/","excerpt":"Permutation in String","text":"Permutation in String Permutation in String code with Python title number：567 读题 给定两个字符串s1和s2，判断s2是否包含s1的排列 即：s1的排列之一是否是第二个字符串的子串 思路一 滑动窗口+哈希表 由于判断的是s1的排列是否为s2的子串，可以等价于s1中的元素是无序的，我们可以只统计字母出现的频次 使用滑动窗口遍历s2，并统计其中字母出现的频次 当子串长度不够时，向右移动滑动窗口的右边界，将最右边的字母的频次+1 当子串长度超过s1时，向右移动滑动窗口的左边界，并将左边的字母的频次-1 当子串与s1的哈希表相同时，则说明s2包含s1的排列 1234567891011121314151617181920def checkInclusion(self, s1: str, s2: str) -&gt; bool: l1, l2 = len(s1), len(s2) c1, c2 = collections.Counter(s1), collections.Counter() p, q = 0, 0 while q &lt; l2: c2[s2[q]] += 1 if c2 == c1: return True q += 1 # 当子串长度超过s1的长度 if q - p + 1 &gt; l1: c2[s2[p]] -= 1 if c2[s2[p]] == 0: del c2[s2[p]] p += 1 return False 思路二 字符哈希 + 滑动窗口 整体思路同思路一，优化哈希表结构 由于字母的数量是有限的，使用数组来存储字母出现的频次 使用s[i]-&#39;a&#39;的值作为数组下标 1234567891011121314151617181920def checkInclusion(self, s1: str, s2: str) -&gt; bool: l1, l2 = len(s1), len(s2) c1, c2 = [0]*26, [0]*26 p, q = 0, 0 # 统计s1 for i in s1: c1[ord(i)-ord('a')] += 1 while q &lt; l2: c2[ord(s2[q])-ord('a')] += 1 if c2 == c1: return True q += 1 if q - p + 1 &gt; l1: c2[ord(s2[p])-ord('a')] -= 1 p += 1 return False 思路三 其实在做比较时，我们无需每次都比较两个哈希表 维护一个变量，用来统计滑动窗口中频次与s1中相同的字母的个数 当滑动窗口中符合条件的字母的个数与s1中字母的个数相同，则返回True 123456789101112131415161718192021222324252627def countInclusion(self, s1: str, s2: str) -&gt; bool: l1, l2 = len(s1), len(s2) c1, c2 = collections.Counter(s1), collections.Counter() # 统计变量，全26个字母，频率相同的个数 cnt = 0 # 滑动窗口的左右边界 p, q = 0, 0 while q &lt; l2: c2[s2[q]] += 1 if c2[s2[q]] == c1[s2[q]]: cnt += 1 if cnt == len(c1): return True q += 1 if q - p + 1 &gt; l1: if c1[s2[p]] == c2[s2[p]]: cnt -= 1 c2[s2[p]] -= 1 if c2[s2[p]] == 0: del c2[s2[p]] p += 1 return False","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之斐波那契数","slug":"Leetcode之斐波那契数","date":"2020-07-27T00:38:17.000Z","updated":"2020-07-27T06:55:55.337Z","comments":true,"path":"passages/leetcode-zhi-fei-bo-na-qi-shu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-fei-bo-na-qi-shu/","excerpt":"Fibonacci Number","text":"Fibonacci Number Fibonacci Number code with Python title number：509 读题 斐波那契数，通常使用F(n)表示，形成的序列成为斐波那契数。 该数列有0和1开始，后面的每一项数字都是前面两项数字的和 即 12F(0) &#x3D; 0, F(1) &#x3D; 1F(N) &#x3D; F(N-1) + F(N-2), N &gt; 1 思路 递归 当N=0或N=1时，返回设定值 其他情况下的N返回F(N-1)和F(N-2)的和 1234567def fib(self, N: int) -&gt; int: if N == 0: return 0 if N == 1: return 1 return fib(N-1) + fib(N-2) 思路二 递归的时间复杂度太高了 采取记忆化的方式，存储前面已经计算过的值，减少递归带来的重复计算 首先是自底向上的方法 当N &lt;= 1时，返回N 否则迭代计算N，并存储在数组中 直接从记忆数组中读取N对应的值 1234567891011def fib(self, N: int) -&gt; int: if N &lt;= 1: return N return self.memorize(N)def memorize(self, N): cache = &#123;0:0, 1:1&#125; for i in range(2, N+1): cache[i] = cache[i-1] + cache[i-2] return cache[N] 思路三 仍然是记忆化的思路，这次是自顶向下的方法 如果N &lt;= 1，返回N 调用和返回memorize(N) 如果N对应的值存在，则直接返回 否则通过公式memorize(N-1) + memorize(N-2)，计算N对应的值 1234567891011def fib(self, N: int) -&gt; int: if N &lt;= 1: return N self.cache = &#123;0:0, 1:1&#125; return self.memorize(N)def memorize(self, N): if N in self.cache: return self.cache[N] self.cache[N] = self.memorize(N-1) + self.memorize(N-2) return self.memorize(N)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode周赛（199）","slug":"Leetcode周赛（199）","date":"2020-07-26T06:36:42.000Z","updated":"2020-07-27T00:29:25.352Z","comments":true,"path":"passages/leetcode-zhou-sai-199/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhou-sai-199/","excerpt":"Leetcode第199场周赛","text":"Leetcode第199场周赛 重新排列字符串 给定一个字符串s和一个长度相同的整数数组indices 重新排列字符串s，其中第i个字符需要移动到indices[i]指示的位置 返回重新排列后的字符串 思路一 翻译题目要求即可 创建一个空字符 使用index()定位i在indices中的位置 按顺序添加到字符串中即可 123456def restoreString(self, s: str, indeices: List[int]) -&gt; str: res = '' for i in range(len(s)): res += s[indices.index(i)] return res 顺便说一句，第一题太简单了不是什么好兆头，后面会让你怀疑人生 灯泡开关 房间中有n个灯泡，编号从0到n-1，自左向右排成一行。最开始的时候，所有的灯泡都是关着的 请你设法使得灯泡的开关状态和target描述的状态一致，其中target[i]等于1第i个灯泡是开着的，等于0意味着第i个灯是关着的 有一个开关可以用于翻转灯泡的状态，翻转操作定义如下： 选择当前配置下的任意一个灯泡（下标为 i ） 翻转下标从i到n-1的每个灯泡 翻转时，如果灯泡的状态为0就变为1，为1就变为0 返回达成target描述的状态所需的 最少 翻转次数 思路一 由于一次操作会反转后面的所有开关，即后一状态与前一状态相关，我们使用动态规划 使用dp数组存储中间信息 每个位置有两个状态：与目标相同，与目标相反；以第i个位置的 dp[i][0]表示从第i个灯泡到末尾转化为和目标状态相同需要的次数，且第i个灯泡当前状态为0 当target[i]==&#39;0&#39;时，无需改变，dp[i][0] = dp[i+1][0] 当target[i]==&#39;1&#39;，对第i个位置进行反转操作，dp[i][0] = dp[i+1][0] + 1 dp[i][1]表示从第i个灯泡到末尾转化为和目标状态相反需要的次数，且第i个灯泡当前状态为1 当target[i]==&#39;0&#39;时，对第i个位置进行反转操作，dp[i][1] = dp[i+1][0] + 1 当target[i]==&#39;1&#39;，无需改变，dp[i][0] = dp[i+1][1] 初始状态：dp[n][0] = dp[n][1] = 0 注意：因为开关影响的是后面的灯泡，所以需要从后往前遍历 123456789101112def minFlips(self, target: str) -&gt; int: dp = [[0]*2 for _ in range(len(target)+1)] # 从后向前 for i in range(len(target)-1, -1, -1): if target[i] == '0': dp[i][0] = dp[i+1][0] dp[i][1] = dp[i+1][0] + 1 if target[i] == '1': dp[i][0] = dp[i+1][1] + 1 dp[i][1] = dp[i+1][1] return dp[0][0] 好叶子节点对的数量 给定一棵二叉树和一个整数distance 如果二叉树中两个叶子节点之间的最短路径长度小于或等于distance，则这两个叶子节点就可以组成一组好叶子节点 路径长度指的是两个叶子节点相互到达需要经过的边的数量 返回好叶子节点对的数量 思路一 left保存左子树根节点到叶子节点的距离列表 right保存右子树根节点到叶子节点的距离列表 ans保存当前节点到叶子节点的距离列表，当left、right都为空时，说明该节点是叶子节点 当left和right都不为空时，寻找和小于等于distance的叶子对 由于left、right是左右子树的举例列表，因此需要+2 123456789101112131415161718192021222324252627282930313233def countPairs(self, root: TreeNode, distance: int) -&gt; int: self.cnt = 0 def dfs(node) -&gt; List[int]: if not node: return [] left = dfs(node.left) right = dfs(node.right) ans = [] if not left and not right: ans.append(0) elif left and not right: for num in left: ans.append(num+1) elif right and not left: for num in right: ans.append(num+1) else: for num in left: ans.append(num+1) for num in right: ans.append(num+1) for i in left: for j in right: if i+j+2 &lt;= distance: self.cnt += 1 retrun ans dfs(root) return self.cnt 压缩字符串Ⅱ 形成长度编码是一种常用的字符串压缩方法，它将连续的相同字符（重复2次或更多次）替换为字符和表示字符计数的数字（行程长度） 例如：用此方法压缩字符串aabccc，将aa替换为a2，ccc替换为c3，因此压缩之后的字符串变为a2bc3 注意，在单个字符之后不附加计数1 给定一个字符串s和一个整数k，你需要从字符串s中删除最多k个字符，以使s的形成长度编码长度最小 返回删除最多k个字符后，s行程长度编码的最小长度 示例： 123输入：s &#x3D; &quot;aaabccd&quot;, k &#x3D; 2输出：4解释：在不删除任何内容的情况下，压缩后的字符串是 &quot;a3bc3d&quot; ，长度为 6 。最优的方案是删除 &#39;b&#39; 和 &#39;d&#39;，这样一来，压缩后的字符串为 &quot;a3c3&quot; ，长度是 4 。 思路一 从示例中可以发现，优先删除重复次数少的字符可使总编码长度最小 因此，在可删除的字符个数k范围内，删除k个必定会导致最终编码长度最小 当我们删除了重复次数少的字符造成了编码长度的减小后，即使剩余的删除并不会完全删掉较多重复的字符，也不会影响最终编码长度最小 故，问题可转化为从字符串中选取n-k个字符，使编码长度最小 动态规划 定义dp[p][cnt] p表示从字符串的第p位开始 cnt表示当前已经选取了cnt个字符 状态转移 从当前的位置p开始向后遍历，只要发现后面又自负和s[p]相同，则选取 例如：当s = aabaaca, p=0，则我们可以从0位置开始选择5个a，再从之后的字符串中选取字符 状态转移方程为：dp[p][cnt] = min(calc(same) = dp[j+1][cnt+same]) same表示s[p:j]中和s[p]相同的字符的数量 calc(same)表示长度为same的连续字符的编码长度 转化一下，比较可操作的状态转移方程为 dp[p][cnt] = min(dp[p][cnt], dp[p+1][cnt]) 初始条件下，dp[p][T]=0 引用自题解，转移方程还不是很理解，代码后面补充","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之反转字符串","slug":"Leetcode之反转字符串","date":"2020-07-25T01:45:09.000Z","updated":"2020-07-25T01:57:26.653Z","comments":true,"path":"passages/leetcode-zhi-fan-zhuan-zi-fu-chuan/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-fan-zhuan-zi-fu-chuan/","excerpt":"Reverse String","text":"Reverse String Reverse String code with Python title number：344 读题 编写函数，将给定的字符串反转 不能额外为数组分配空间，必须原地修改数组，可使用O(1)的额外空间 思路一 递归 如果left &lt; right，则交换两指针指向的元素 再次调用函数本身，传入的left和right要分别右移和左移 递归的好处在于代码比较简单，但是由于函数需要不断调用自身，所需要的堆栈空间比较多（O(n)），并且花费的时间比较多 12345678def reverseString(self, s: List[int]) -&gt; None: def helper(left, right): if left &lt; right: s[left], s[right] = s[right], s[left] helper(left+1, right-1) helper(0, len(s)-1) 思路二 双指针 设置两个指针分别指向字符串的首部的尾部 在两指针相遇之前，交换两指针指向的元素，同时指针想内侧移动 使用双指针替代递归，空间复杂度达到了O(1) 1234567def reverseString(self, s: List[int]) -&gt; None: left, right = 0, len(s)-1 while left &lt; right: s[left], s[right] = s[right], s[left] left += 1 right -= 1","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Lintcode之背包问题（ⅠandⅡ）","slug":"Lintcode之背包问题（ⅠandⅡ）","date":"2020-07-24T02:34:59.000Z","updated":"2020-07-24T04:03:43.128Z","comments":true,"path":"passages/lintcode-zhi-bei-bao-wen-ti-iandii/","link":"","permalink":"http://zivblog.top/passages/lintcode-zhi-bei-bao-wen-ti-iandii/","excerpt":"背包问题，标准的01背包和完全背包问题，动态规划中有详细思路，此处仅做记录","text":"背包问题，标准的01背包和完全背包问题，动态规划中有详细思路，此处仅做记录 Backpack code with Python title number：92 题目 在n个物品中挑选若干物品装入背包，最多能装多满？ 假设背包大小为m，每个物品的大小为A[i] 思路 使用dp数组记录中间值 问题转化为前i个物品总体积不超过j的选法的集合，选对应的最大的价值 将每次第i个物品能不能选则作为集合划分标准 若选择第i个物品，则当前体积上限变为j-V_i，问题转化为前i-1个物品总体积不超过j-V_i的选法的集合 若不选择第i个物品，则当前体积上限仍为j，问题转化为前i-1个物品总体积不超过j的选法的集合 状态转移方程为dp[i][j] = dp[i-1][j-1]+A[i] or dp[i-1][j] 数组的每个位置使用布尔值来进行表示 1234567891011121314151617181920def backPcak(self, m, A): if len(A) == 0: return 0 dp = [[False]*(m+1) for _ in range(len(A)+1)] for i in range(len(A)+1): dp[i][0] = True for i in range(1, len(A)+1): for j in range(m+1): dp[i][j] = dp[i-1][j] if j &gt;= A[i-1]: dp[i][j] = dp[i-1][j-A[i-1]] or dp[i][j] res = 0 for z in range(m+1): if dp[len(A)][z] == True: res = z return res Backpack Ⅱ题目 有n个物品和一个大小为m的背包，给定数组A表示每个物品的大小和数组V表示每个物品的价值 问最多能装入背包的总价值有多大 思路 仍然是01背包问题（即一个物品只能选择拿或不拿） 使用dp数组表是前i个物品中可以放到容量为j的背包中的最大价值和 以第i个物品是否选择作为划分标准 如果选择第i个物品，则dp[i][j]=dp[i-1][j-A[i-1]]+V[i-1] 如果不选择第i个物品，则dp[i][j]=dp[i-1][j] 状态转移方程 dp[i][j] = max(dp[i][j], dp[i-1][j-A[i-1]]+V[i-1]) 1234567891011121314def backPackII(self, m, A, V): if len(A) == 0: return 0 dp = [[0]*(m+1) for _ in range(len(A)+1)] for i in range(1, len(A)+1): for j in range(1, m+1): dp[i][j] = dp[i-1][j] if j &gt;= A[i-1]: dp[i][j] = max(dp[i][j], dp[i-1][j-A[i-1]]+V[i-1]) return dp[-1][-1]","categories":[{"name":"Lintcode","slug":"Lintcode","permalink":"http://zivblog.top/categories/Lintcode/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"},{"name":"lintcode","slug":"lintcode","permalink":"http://zivblog.top/tags/lintcode/"}]},{"title":"Leetcode之编辑距离","slug":"Leetcode之编辑距离","date":"2020-07-23T01:08:57.000Z","updated":"2020-07-23T02:12:35.315Z","comments":true,"path":"passages/leetcode-zhi-bian-ji-ju-chi/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-bian-ji-ju-chi/","excerpt":"Edit Distance","text":"Edit Distance Edit Distance code with Python title number：72 读题 给定两个单词word1和word2，请你计算出将word1转化成word2所使用的最少操作数 你可以对一个单词进行如下三种操作 插入一个字符 删除一个字符 替换一个字符 示例 123456输入：word1 &#x3D; &quot;horse&quot;, word2 &#x3D; &quot;ros&quot;输出：3解释：horse -&gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)rorse -&gt; rose (删除 &#39;r&#39;)rose -&gt; ros (删除 &#39;e&#39;) 思路一 动态规划 对于双序列的动态规划我们都使用一个二维的矩阵来做状态表示 使用dp[i][j]表示word1前i个字符转化为word2前j个字符需要的最少步数 特殊的，我们要考虑word1和word2为空的情况，即另一个字符串全增加或全删除 定义dp[0][j]和dp[i][0]分别表示word1和word2为空的情况 对三种转移状态进行表示 插入字符，dp[i][j] = dp[i][j-1] + 1，表示把word1的前i-1个字符转化为word2的前j-1个字符，再将word2的第j个字符插入到尾部 删除字符，dp[i][j] = dp[i-1][j] + 1，表示删除掉word1的第i个字符，再将前i-1个字符转化为word2的前j个字符 替换字符，dp[i][j] = dp[i-1][j-1] + 1，表示把word1的前i-1个字符转化为word2的前j-1个字符，再将word1的第i个字符替换为word2的第j个字符 双循环进行遍历，每进行一次遍历，比较三种操作所需要的操作次数，取最小值，再+1 当word1[i] != word2[j]，dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1 当word1[i-1] == word2[j-1]是，可直接参考dp[i-1][j-1]，无需进行比较 12345678910111213141516171819def minDistance(self, word1: str, word2: str) -&gt; int: n1, n2 = len(word1), len(word2) dp = [[0]*(n2+1) for i in range(n1+1)] # 第一列 for j in range(1, n2+1): dp[0][j] = dp[0][j-1] + 1 # 第一行 for i in range(1, n1+1): dp[i][0] = dp[i-1][0] + 1 for i in range(1, n1+1): for j in range(1, n2+1): if word1[i-1] == word2[j-1]: dp[i][j] = dp[i-1][j-1] else: dp[i][j] = min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1]) + 1 return dp[-1][-1]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之分割回文串Ⅱ","slug":"Leetcode之分割回文串Ⅱ","date":"2020-07-22T01:08:20.000Z","updated":"2020-07-22T01:33:34.146Z","comments":true,"path":"passages/leetcode-zhi-fen-ge-hui-wen-chuan-ii/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-fen-ge-hui-wen-chuan-ii/","excerpt":"palindrome partitioning Ⅱ","text":"palindrome partitioning Ⅱ palindrome partitioning Ⅱ code with Python title number：132 读题 给定一个字符串S，将S分割成一些子串，使每个子串都是回文串 返回符合要求的最少分割次数 思路一 动态规划 使用min_cnt数组维护长度不同的字符串的最小分割次数 min_cnt[i]表示s[0:i]分割回文串的最小分割次数 min_cnt[i]默认为i，例如：s[0:0]只有一个字符，最少分割次数为0 使用dp数组维护任意子串是否为回文串 dp[i][j]表示s[i][j]是否为回文串 dp数组中值默认为False 穷举所有子串的边界情况，更新dp数组 当end - start &lt; 2时，必为回文数组 当s[start] == s[end]时，若dp[start+1][end-1]==True，则dp[start][end]=True（左右两段字符相同并且内部为回文串） 在子串为回文串的情况下 若start == 0，则说明当前回文串从下标0开始，无需切割，即min_cnt[end]=0 若start != 0，说明开始位置不是0，需要更新，取min_cnt[j]和上一回文串分割次数+1的较小值，即min_cnt[j] = min(min_cnt[j], min_cnt[i-1]+1) 12345678910111213141516171819def minCut(self, s: str) -&gt; int: min_cnt = list(range(len(s))) dp = [[False]*len(s) for _ in range(len(s))] for end in range(len(s)): for start in range(end + 1): # 当前情况为回文串 if s[start] == s[end] and (end - start &lt; 2 or dp[start+1][end-1]==True): dp[start][end] = True # 更新min_cnt if start == 0: min_cnt[end] = 0 else: min_cnt[end] = min(min_cnt[end], min_cnt[start-1]+1) return min_cnt[-1]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之最长上升子序列","slug":"Leetcode之最长上升子序列","date":"2020-07-21T01:30:47.000Z","updated":"2020-07-21T01:50:29.942Z","comments":true,"path":"passages/leetcode-zhi-zui-chang-shang-sheng-zi-xu-lie/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zui-chang-shang-sheng-zi-xu-lie/","excerpt":"Longest Increasing Subsequence","text":"Longest Increasing Subsequence Longest Increasing Subsequence code with Python title number：300 读题 给定一个无需的整数数组，找到其中最长上升子序列的长度 思路一 注意子序列与子串之间的区别 子序列中的元素在原字符串中不必相邻 子串是原字符串中的连续元素的组合 动态规划： 使用dp数组保存当前位置及之前的字符串中的最长上升子序列的长度 对于每一个位置，遍历其前方的所有dp元素 如果nums[j]&lt;nums[i]，则取dp[i]和dp[j]+1的较大值（前面的最长子序列的长度+当前元素） 最后取dp数组的最大值返回 1234567891011def lengthOfLIS(self, nums: List[int]) -&gt; int: if len(nums) == 0: return 0 dp = [1 for _ in range(len(nums))] for i in range(len(nums)): for j in range(i): if nums[j] &lt; nums[i]: dp[i] = max(dp[j]+1, dp[i]) return max(dp)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之爬楼梯","slug":"Leetcode之爬楼梯","date":"2020-07-20T01:44:26.000Z","updated":"2020-07-21T01:51:03.654Z","comments":true,"path":"passages/leetcode-zhi-pa-lou-ti/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-pa-lou-ti/","excerpt":"Climbing Stairs","text":"Climbing Stairs Climbing Stairs code with Python title number：70 读题 假设你需要爬n阶楼梯才能到达楼顶 每次你可以爬1或2个台阶，试计算可以有多少中方式爬到楼顶 n总不为0，是一个正整数 思路一 动态规划 使用dp数组记录到达当前位置的方法数 通过题目描述可以发现，到达任意位置的方法数仅与其前面的两个台阶有关（每次只能选择爬一个或两个台阶） 需要特殊处理前两个台阶（如果存在两个）：dp[0], dp[1] = 1, 2 返回数组中最后一个台阶对应的值即可 12345678910def climbStairs(self, n: int) -&gt; int: if n == 1: return 1 dp = [0] * n dp[0], dp[1] = 1, 2 for i in range(2, n): dp[i] = dp[i-1] + dp[i-2] return dp[-1] 因为当前位置的值至于前面两个位置的值有关，所以可以减少对空间的使用——仅使用两个变量存储前两个位置的值即可 整体思路同上，仅做代码复杂度优化 12345678910111213def climbStairs(self, n: int) -&gt; int: ''' r表示当前位置的值 p是前两位的值 q是前一位的值 ''' p, q, r = 0, 0, 1 for i in range(1, n+1): p = q q = r r = p + q return r 思路二 这是一道动态规划的简单题，尝试使用数学的方法解答 该问题的递推方程为$f(n) = f(n-1) + f(n-2)$ 写出其特征方程：$x^2 = x + 1$ 求得：$x_1 = \\frac{1+\\sqrt{5}}{2}, x_2 = \\frac{1 - \\sqrt{5}}{2}$ 设通解为：$f(n) = c_1x_1 + c_2x_2$ 将初始值f(1) = 1, f(2)=2带入通解中，解得：$c_1 = \\frac{1}{\\sqrt{5}}, c_2 = -\\frac{1}{\\sqrt{5}}$ 最终的通解为：$$f(n) = \\frac{1}{\\sqrt{5}}[(\\frac{1+\\sqrt{5}}{2})^2 - (\\frac{1-\\sqrt{5}}{2})^2]$$ 12345def climbStairs(self, n: int) -&gt; int: sqrt_5 = sqrt(5) fib_n = ((1+sqrt_5)/2)** (n+1) - ((1-sqrt_5)/2)**(n+1) return int(fib_n / sqrt_5)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode周赛（198）","slug":"Leetcode周赛（198）","date":"2020-07-19T05:15:48.000Z","updated":"2020-07-19T07:41:52.852Z","comments":true,"path":"passages/leetcode-zhou-sai-198/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhou-sai-198/","excerpt":"Leetcode第198场周赛","text":"Leetcode第198场周赛 换酒问题 小区便利店正在促销，用numExchange个空酒瓶可以兑换一瓶新酒 你购入了numBottles瓶酒 请问你最多可以喝到多少瓶酒 思路一 递归 每次传入现有的空瓶数量，交换规则，以及当前一共喝过多少瓶酒 递归求解，最终返回喝过的酒的总数 1234567891011121314151617181920class Solution: def change(self, k, exchange, sum_): ''' k：当前的空瓶数 exchange：交换规则 sum_：喝过的酒的瓶数 ''' if k &lt; exchange: return sum_ else: num = k // exchange remain = k % exchange sum_ += num return self.exchange(num+remain, exchange, sum_) def numWaterBottles(self, numBottles: int, numExchange: int) -&gt; int: return self.exchange(numBottles, numExchange, numBottles) 注意else分支中要有返回值，否则最后可能为None 思路二 数学解法 将每瓶内酒的价值视为2，将空瓶的价值视为1（整体价值为3） 注意至少最后有一个空瓶在手里什么也换不了 当倒数第二次换完一瓶后没有空瓶，则最后剩一个空瓶 当倒数第二次换完剩下一个空瓶，则最后剩两个空瓶 123def numWaterBottles(self, numBottles: int, numExchange: int) -&gt; int: return (numBottles * numExchange - 1) // (numExchange-1) 子树中标签相同的节点数 给定一棵树，树由编号0 ~ n-1的n个节点组成，且有n-1条边 树的根节点为节点0，树上的每个节点都有一个标签，也就是字符串labels中的一个小写字符（编号为i的节点对的标签就是labels[i]） 边数组edges以edges[i] = [ai, bi]的形式给出，该格式表示节点ai和bi之间存在一条边 返回一个大小为n的数组，其中ans[i]表示第一i个节点的子树中与节点i标签相同的节点数 示例 12输入：n &#x3D; 7, edges &#x3D; [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], labels &#x3D; &quot;abaedcd&quot;输出：[2,1,1,1,1,1,1] 思路一 因为子树是嵌套的，所以采取自底至顶的方式进行比较合适 edges的顺序是随机的，唯一能确定的就是edges[0]是包含0 首先遍历edges，记录下每个节点的父节点 按从底至顶的方式遍历节点 将每个节点的子树中的labels数组及其数量传递给父节点 123456789101112131415161718192021222324252627282930313233def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -&gt; List[int]: # father[i]为节点i的父节点 father = [-1 for i in eange(n)] # 顺序，在列表中越靠前的在树中越靠上 order = [0] # 若order中有i则saved[i]=True saved = [False] * n saved[0] = True # 遍历整个树，得到每个节点的父节点 for [head, tail] in edges: if saved[head]: father[tail] = head order.append(tail) saved[tail] = True else: father[head] = tail order.append(head) saved[i] = True # 为每个标签创建一个字典 counters = [Counter(labels[i]) for i in range(n)] order.reverse() for i in order: if i == 0: break for key in counters[i].keys(): # 将子节点的统计传给其父节点 counters[father[i]][key] += counters[i][key] # 依次得到每个编号对应的节点中对应标签的次数 return [counters[i][labels[i]] for i in range(n)] if saved[head]比if head in order快，不过需要占额外空间 思路二 树形DP 深度优先遍历，同时记录以当前节点为根的子树中每种字符的累计数值 根据节点编号读取以当前节点为根节点的子树中根节点label出现的次数 1234567891011121314151617181920212223242526272829def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -&gt; List[int]: link = &#123;&#125; # 遍历所有的边，建立映射字典 for a, b in edges: if a not in link: link[a] = [] if b not in link: link[b] = [] link[a].append(b) link[b].append(a) # key是节点的坐标值，value是以该节点为根的子树上所有节点的字符个数累计 char_cnt = &#123;&#125; def dfs(root, prev): root_counter = Counter() root_counter[labels[root]] = 1 # 当前节点信息的存储结构 char_cnt[root] = root_counter for child in link[root]: if child != prev: dfs(child, root) c = char_cnt[child] for ch in 'abcdefghijklmnopqrstuvwxyz': root_counter[ch] += c[ch] dfs(0, None) return [char_cnt[node][label[node]] for node in range(n)] 由于dp的时候需要记录当前节点子树中所有可能的字母的出现次数（26个字母），使用的额外空间比较多 补充 collections.Counter函数可用作计数 是实现dict的一个子类，得到的结果是一个字典 例如，统计一个字符串中每个单词出现的次数 123c = Counter('abcasdf')输出为：Counter(&#123;'a': 2, 'b': 1, 'c': 1, 's': 1, 'd': 1, 'f': 1&#125;) 最多的不重叠子字符串 给定一个只包含小写字母的子字符串s，要求找到s中最多数目的非空子字符串，满足以下条件： 子字符串之间互不重叠 如果一个子字符串包含字符c，则s中所有的字符c都要包含在该子字符串中 示例 1234567891011121314输入：s &#x3D; &quot;adefaddaccc&quot;输出：[&quot;e&quot;,&quot;f&quot;,&quot;ccc&quot;]解释：下面为所有满足第二个条件的子字符串：[ &quot;adefaddaccc&quot; &quot;adefadda&quot;, &quot;ef&quot;, &quot;e&quot;, &quot;f&quot;, &quot;ccc&quot;,]如果我们选择第一个字符串，那么我们无法再选择其他任何字符串，所以答案为 1 。如果我们选择 &quot;adefadda&quot; ，剩下子字符串中我们只可以选择 &quot;ccc&quot; ，它是唯一不重叠的子字符串，所以答案为 2 。同时我们可以发现，选择 &quot;ef&quot; 不是最优的，因为它可以被拆分成 2 个子字符串。所以最优解是选择 [&quot;e&quot;,&quot;f&quot;,&quot;ccc&quot;] ，答案为 3 。不存在别的相同数目子字符串解。 思路一 对字符串进行一次遍历，记录每个字符最早和最晚出现的位置 组合两个数组，最终得到一个长度之多为26的数组，例：[(s, e)]记录的是a出现的区间 进行去重操作 使用动态规划进行求解 问题为区间的不相交问题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253def maxNumOfSubstrings(self, s: str) -&gt; List[str]: start = [-1] * 26 end = [-1] * 26 for i in range(len(s)): c = s[i] tmp = ord(c) - ord('a') # 当前字母第一次出现的位置 if start[tmp] == -1: start[tmp] = i # 当前字母最后又一次出现的位置 end[tmp] = i pos = [(-1, -1)] * 26 for i in range(26): l, r = start[i], end[i] if r == -1: continue cur = set(s[start[i]: r+1]) seen = set() while cur: seen |= cur for nxt in cur: r = max(r, end[ord(nxt)-ord('a')]) l = min(l, start[ord(nxt)-ord('a')]) cur = set(s[l: r+1]) - seen pos[i] = (l, r) pos = set(pos) pos = sorted(list(pos)) n = len(pos) def dp(i, e): if i &gt;= n: return [] res = dp(i+1,e) if pos[i][0] &gt; e: tmp = [i] + dp(i+1,pos[i][1]) else: return res if not res: return tmp if len(tmp) &gt; len(res): return tmp elif len(tmp) == len(res): if sum([pos[j][1]-pos[j][0] for j in tmp]) &lt; sum([pos[j][1]-pos[j][0] for j in res]): return tmp return res return [s[pos[i][0]:pos[i][1]+1] for i in dp(0,-1)] 还有几个点不是很通透，后面补充 找到最接近目标值的函数值 Winston构造了一个如下所示的函数 12345678def func(arr, l, r): if r &lt; l: return -1000000000 ans = arr[l] for i in range(l, r+1): ans = ans &amp; arr[i] return ans 现有一个整数数组arr，和一个整数target 找到让|func(arr, l, r) - target|最小的l和r 返回|func(arr, l, r) - target|的最小值 思路一 最暴力的思路是： 穷举所有的区间情况，计算该区间内元素对应的func值 与target作差取绝对值 比较得到最小值 这种情况是肯定会超时的（要对得起hard的难度），我们要对其进行优化 将数组中相邻且相同的元素进行合并（对&amp;操作的结果没有影响） 当函数求&amp;的值小于target时，则无需继续进行操作（&amp;之后得到的值只会更小） 函数得到的值越小，与target作差再取绝对值的结果只会更大 即要求满足条件的最小值，只能从func计算得到的比target更大的值中选择 123456789101112131415161718192021def closestToTarget(self, arr: List[int], target: int) -&gt; int: # 相邻且相同的值去重 new_arr = [] for i in range(len(arr)): if not new_arr or new_arr[-1] != arr[i]: new_arr.append(arr[i]) arr = new_arr ans = abs(-10**9 - target) for l in range(len(arr)): cur = ~0 for r in range(l, len(arr)): cur &amp;= arr[r] ans = min(ans, abs(cur - target)) # 如果ans小于target，跳出 if cur &lt;= target: break if ans == 0: break return ans 思路二 数位DP 对当前二进制从高位到低位枚举，目前为止选择区间[l, r]的与结果f(index, l, r)，target只取从高位32到index的值g(index) 如果f(index, l, r) &gt; g(index)，取所有[l, r]的数字，因为从index到0的bit位能取到的最小值就是[l, r]中所有的数字与的结果 如果f(index, l, r) &lt; g(index)，当前位如果能取1到1，否则才取0 如果f(index, l, r) = g(index)，当前位取0或1都可以 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364def closestToTarget(self, A: list[int], target: int) -&gt; int: def bitset(val, index): return val &amp; (1 &lt;&lt; index) &gt; 0 def setbit(val, index): return val | (1 &lt;&lt; index) def getones(index, start, end): l, r = start, start ones = [] while r &lt;= end: if not bitset(A[i], index): if r &gt; l: ones.append((l, r - 1)) l = r + 1 r += 1 if r &gt; 1: ones.append((l, r - 1)) return ones INF = 10**9 + 7 def dfs(index, state, start, end, op): if start &gt; end: return INF if index &lt; 0: return abs(state - target) if start == end: return abs(A[start] - target) if op &gt; 0: rest = (1 &lt;&lt; (index + 1)) - 1 for i in range(start, end+1): rest &amp;= A[i] state |= rest return abs(state - target) ans = INF cv = bitset(target, index) ones = getones(index, start, end) nstate = setbit(state, index) if op == 0: # set current bit to one ans = min(ans, min([dfs(index - 1, nstate, l, r, 0 if cv else 1) for l, r in ones] or [INF])) # if current bit of some value is 0 if any([not bitset(A[i], index) for i in range(start, end + 1)]): # bitwise and of all value in A == 0 ans = min(ans, dfs(index - 1, state, start, end, -1 if cv else 0)) elif op &lt; 0: # always choose 1 for current bit ans = min(ans, min([dfs(index - 1, nstate, l, r, -1) for l, r in ones] or [INF])) if not ones: ans = min(ans, dfs(index - 1, state, start, end, -1)) return ans ans = dfs(31, 0, 0, len(A) - 1, 0) return ans","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之不同路径Ⅱ","slug":"Leetcode之不同路径Ⅱ","date":"2020-07-18T05:07:32.000Z","updated":"2020-07-18T05:49:34.583Z","comments":true,"path":"passages/leetcode-zhi-bu-tong-lu-jing-ii/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-bu-tong-lu-jing-ii/","excerpt":"Unique Paths Ⅱ","text":"Unique Paths Ⅱ Unique Paths Ⅱ code with Python title number：63 读题 一个机器人位于一个m * n的网格的左上角，试图到达网格的右下角 机器人每次只能向下或向左移动一步 网格之中存在障碍物，计算从左上角到右下角将会有多少条不同的路径 思路一 使用dp数组记录从左上角到达该位置的路径数 dp[i][j] = dp[i-1][j] + dp[i][j-1] 有两个特殊的位置，即第一行和第一列（它们只有来自一个方向的路径） 第一行：dp[i][0] = dp[i-1][0] 第一列：dp[0][i] = dp[0][i-1] 若当前位置是障碍物，则能到达当前位置的路径数为0 12345678910111213141516171819202122232425def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -&gt; int: height, width = len(obstacleGrid), len(obstacleFrid[0]) if obstacleFrid[0][0] == 1: return 0 dp = [[0 for _ in range(width)] for _ in range(height)] dp[0][0] = 1 # 第一列 for i in range(1, height): if obstacleGrid[i][0] == 0: dp[i][0] = dp[i-1][0] # 第一行 for i in range(1, width): if obstacleGrid[0][i] == 0: dp[0][i] = dp[0][i-1] for i in range(1, height): for j in range(1, width): if obstacleGrid[i][j] == 1: dp[i][j] = 0 else: dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[-1][-1]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之最小路径和","slug":"Leetcode之最小路径和","date":"2020-07-17T01:45:38.000Z","updated":"2020-07-18T05:17:12.499Z","comments":true,"path":"passages/leetcode-zhi-zui-xiao-lu-jing-he/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zui-xiao-lu-jing-he/","excerpt":"Minimum Path Sum","text":"Minimum Path Sum Minimum Path Sum code with Python title number：64 读题 给定一个包含非负整数的m * n的网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小 每次只能向下或向右移动一步 思路一 使用dp数组保存由左上角到当前位置的最小值 由于当前位置只能由左侧和上方的位置到达，只需要比较两者所保存的dp值的大小，加上grid当前位置的大小 dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] 最终结果保存在dp[m-1][n-1]中 由于需要通过访问每个位置的前一行和前一列的元素，有两个位置需要单独处理 第一行中的元素只能由左侧位置到达，dp[i][j] = dp[i][j-1] + grid[i][j] 第一列中的元素只能由上方位置到达，dp[i][j] = dp[i-1][j] + grid[i][j] 123456789101112131415161718192021def minPathSum(self, grid: List[List[int]]) -&gt; int: m, n = len(grid), len(grid[0]) dp[[0 for _ in range(n)] for _ in range(m)] dp[0][0] = grid[0][0] for i in range(m): # 第一行 if i == 0: for j in range(1, n): dp[i][j] = dp[i][j-1] + grid[i][j] else: for j in range(n): # 第一列 if j == 0: dp[i][j] = dp[i-1][j] + grid[i][j] else: dp[i][j] = min(dp[i][j-1], dp[i-1][j]) + grid[i][j] return dp[m-1][n-1] 优化一下代码结构 与思路一的主体思路相同，改变一下数据结构 直接在grid上进行修改，不使用额外的数据结构保存中间结果 通过grid[-1][-1]访问最终结果 12345678910111213def minPathSum(self, grid: List[List[int]]) -&gt; int: for i in range(grid): for j in range(len(grid[0])): if i == j == 0: continue elif i == 0: grid[i][j] = grid[i][j-1] + grid[i][j] elif j == 0: grid[i][j] = grid[i-1][j] + grid[i][j] else: grid[i][j] = min(grid[i-1][j], grid[i][j-1]) + grid[i][j] return grid[-1][-1]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之三角形最小路径和","slug":"Leetcode之三角形最小路径和","date":"2020-07-16T01:59:50.000Z","updated":"2020-07-16T02:53:11.680Z","comments":true,"path":"passages/leetcode-zhi-san-jiao-xing-zui-xiao-lu-jing-he/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-san-jiao-xing-zui-xiao-lu-jing-he/","excerpt":"Triangle","text":"Triangle Triangle code with Python title number：120 读题 给定一个三角形，找出自顶向下的最小路径和 规定每一步只能移动到下一行中相邻的结点上 相邻结点指：下标与上层节点的下标相同或上层节点下标+1的两个节点 示例： 1234567[ [2], [3,4], [6,5,7], [4,1,8,3]]自顶向下的最小路径和为11，即 2-&gt;3-&gt;5-&gt;1 其实，将给定的示例转化一下更容易理解 123456[ [2], [3,4], [6,5,7], [4,1,8,3]] 思路一 使用dp数组保存每次移动的最小值，自顶向下 按照上面的示例，在dp数组中保存的结果2 -&gt; 5 -&gt; 10 -&gt; 11 对于在三角形的任意一层中的某个位置，只有两个位置可以移动 反过来说，三角形中的每个位置，有至多两个位置可以到达该位置 我们只需比较这两个位置的dp值大小，即可选择经过当前位置的最小路径 dp[i][j] = min(dp[i-1][j-1], dp[i-1][j]) + triangle[i][j] 此外，三角形中的两个特殊路径需要单独处理 第一列列，即每行只有一个元素，这种需要单独计算 在使用dp[i-1][j-1]取斜上方的dp值时会越界 dp[i][0] = dp[i-1][0] + triangle[i][0] 斜边，也只有一条路径，下一层的横坐标在上一层的基础上右移一格i+1, j+1 在使用dp[i-1][j]取上方的dp值时会越界 dp[i][j] = dp[i-1][j-1] + triangle[i][j] 最终获取dp数组最后一行的最小值即可 1234567891011121314151617181920def minimumTotal(self, triangle : List[List[int]]) -&gt; int: if not triangle: return 0 dp = [[0 for _ in range(len(triangle[-1]))] for _ in range(len(triangle))] dp[0][0] = triangle[0][0] # 第一列单独处理 for i in xrange(1, n): dp[i][0] = dp[i-1][0] + triagnle[i][0] # 自顶向下 for i in xrange(1, n): j = 1 while j &lt; len(triangle[i])-1: dp[i][j] = min(dp[i-1][j-1], dp[i-1][j]) + triagle[i][j] j += 1 # 斜边单独计算 dp[i][j] = dp[i-1][j-1] + triangle[i][j] # 返回最后一行的最小值 return min(dp[-1]) 思路二 使用dp数组保存每次移动的最小值，自底向上 按照上面的示例，在dp数组中显式的路径为1 -&gt; 6 -&gt; 9 -&gt; 11 同自顶向下的想法 每个位置都有两个下层的位置可以到达，需要比较两个的大小，取其中一个 dp[i][j] = min(dp[i+1][j+1], dp[i+1][j]) + triangle[i][j] 不同之处在于 自底向上的方式将结果保存在了dp[0][0]中，不需要遍历最后一行取最小值 为了处理边界（最底层一行），需要在dp数组中添加一行 无需处理第一列和斜边这两种特殊情况 1234567891011def minimumTotal(self, triangle: List[List[int]]) -&gt; int: if not triangle: return 0 dp = [[0 for _ in range(len(triangle[-1])+1)] for _ in range(len(triangle)+1)] # 自底向上 for i in range(len(triangle)-1, -1, -1): for j in range(len(triangle[i])-1, -1, -1): dp[i][j] = min(dp[i+1][j+1], dp[i+1][j]) + triangle[i][j] return dp[0][0]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"快速排序","slug":"快速排序","date":"2020-07-15T12:13:26.000Z","updated":"2020-07-15T12:24:38.211Z","comments":true,"path":"passages/kuai-su-pai-xu/","link":"","permalink":"http://zivblog.top/passages/kuai-su-pai-xu/","excerpt":"快速排序","text":"快速排序 快速排序 从数列中挑出一个元素作为”基准“（通常会选择数列的第一个元素） 重新排序数列，将比基准小的放到基准的前面，比基准大的元素放到基准的后面，此时”基准“位于数组的中间（即完成了对基准的排序） 递归进行，将基准左侧和右侧的子数列按上述方式操作 知道子数列的长度为0或1的时候，跳出递归，此时数组已排列完毕 12345678910def quick_sort(self, nums: List[int]) -&gt; List[int]: if len(nums) &lt; 2: return nums else: # 选择基准 pivot = nums[0] less = [i for i in nums[1:] if i &lt;= pivot] greater = [i for i in nums[1:] if i &gt; pivot] return quick_sort(less) + [pivot] + quick_sort(greater)","categories":[{"name":"算法","slug":"算法","permalink":"http://zivblog.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"基数排序","slug":"基数排序","date":"2020-07-15T12:02:33.000Z","updated":"2020-07-19T05:17:26.429Z","comments":true,"path":"passages/ji-shu-pai-xu/","link":"","permalink":"http://zivblog.top/passages/ji-shu-pai-xu/","excerpt":"基数排序","text":"基数排序 基数排序 基数排序是一种非比较排序算法 将所有待排序元素（必须是非负整数）统一为位数相同的整数，位数较少的前面补零 从最低位开始，依次进行依次稳定排序；后面更高位的排序是在前面排序结果的基础上进行的 直到最高位排序完成之后，整个序列就变成了一个有序序列 时间复杂度：O(n) 空间复杂度：O(n+k) 1234567891011def RadixSort(self, nums: List[int], d: int) -&gt; List[int]: # 数字的位数，即排序轮数 for k in range(d): # 0~9，共10个桶 s = [[] for _ in range(10)] # 将第K位放到桶中 for i in nums: s[i // (10**k) % 10].append(i) # 按当前桶的顺序重新排列数组 nums = [j for i in s for j in i] return nums 与桶排序相比： 桶排序是在max-min之间划分出多个区间，将元素先划分到不同的区间中，对区间中的元素进行排序，再将其结合 基数排序可以看作是多轮桶排序，每个位数上都进行一轮桶排序","categories":[{"name":"算法","slug":"算法","permalink":"http://zivblog.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"归并排序","slug":"归并排序","date":"2020-07-15T08:40:44.000Z","updated":"2020-07-15T08:50:27.003Z","comments":true,"path":"passages/gui-bing-pai-xu/","link":"","permalink":"http://zivblog.top/passages/gui-bing-pai-xu/","excerpt":"归并排序","text":"归并排序 归并排序 采用分治的思想，将原问题划分为多个规模较小而结构相似的子问题，最终合并结果，得到原问题的解 使用递归将原数组转化为多个子列 申请空间将两个子列排序合并 将所有子列一步步合并，最终完成排序 常见的即二路归并（每次排序合并相邻的两个子序列） 时间复杂度： 最好时间复杂度：O(nlog2n) 最坏时间复杂度：O(nlog2n) 平均时间复杂度：O(nlog2n) 空间复杂度，O(1) 123456789101112131415161718192021222324def merge_sort(self, nums: List[int]) -&gt; List[int]: if len(nums) == 1: return nums mid = len(nums) // 2 left = nums[:mid] right = nums[mid:] # 递归分割 &amp; 合并 return merge(merge_sort(left), merge_sort(right)) def merge(left, right): '''合并传入的两个子数组并排序''' result = [] while len(left) &gt; 0 and len(right) &gt; 0: if left[0] &lt;= right[0]: result.append(left.pop(0)) else: result.append(right.pop(0)) # 某个子数组中可能还有元素 result += left resule += right return result","categories":[{"name":"算法","slug":"算法","permalink":"http://zivblog.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"冒泡排序","slug":"冒泡排序","date":"2020-07-15T08:26:32.000Z","updated":"2020-07-15T08:40:17.522Z","comments":true,"path":"passages/mou-pao-pai-xu/","link":"","permalink":"http://zivblog.top/passages/mou-pao-pai-xu/","excerpt":"冒泡排序","text":"冒泡排序 冒泡排序 从第一个开始和第二个比较，如果第一个比第二个大（小），则将其交换位置 然后比较第二个和第三个，…… 经过一轮后可以将最大（小）的元素排到最后 重复上述过程，可在第i趟的时候将第i大（小）的元素排在倒数第i个位置上，从而使整个数组有序 时间复杂度 最好时间复杂度，O(n) 最坏时间复杂度，O(n^2) 平均时间复杂度，O(n^2) 空间复杂度，O(1) 12345678def bubble_sort(self, nums: List[int]) -&gt; List[int]: # 控制循环的次数 for i in range(len(nums)-1): # 控制相邻元素的比较和交换 for j in range(len(nums) - 1 - i): if nums[j] &gt; nums[j + 1]: nums[j], nums[j+1] = nums[j+1], nums[j] return nums","categories":[{"name":"算法","slug":"算法","permalink":"http://zivblog.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"希尔排序","slug":"希尔排序","date":"2020-07-15T08:10:03.000Z","updated":"2020-07-15T08:24:58.059Z","comments":true,"path":"passages/xi-er-pai-xu/","link":"","permalink":"http://zivblog.top/passages/xi-er-pai-xu/","excerpt":"希尔排序","text":"希尔排序 希尔排序 希尔排序的思想是将固定间隔的几个元素之间排序，不断缩小这个间隔，最后数列就成为了有序数列 计算一个增量值（间隔） 按照增量对元素进行分组并组内排序 当前增量下的所有分组内元素排序完毕后，对增量进行调整（一般为缩小到原来的一半） 进行完增量为1的分组排序后，结果即为最终结果 时间复杂度 时间复杂度与步长的选择有关 通常认为希尔排序的时间复杂度为O(n^1.5) 空间复杂度 O(1) 不稳定的排序算法 两个相同的数可能因为分组的不同而发生相对位置的改变 1234567891011121314151617181920def shell_sort(self, nums: list[int]) -&gt; List[int]: # 计算增量 gap = len(nums) // 2 while gap &gt; 0: # 按增量值开始遍历比较 # 分组内元素的排序使用直接插入排序 for i in range(gap, len(nums)): j = i current = nums[i] while j - gap &gt;= 0 and current &lt; nums[j - gap]: # 将不合适的向后移 nums[j] = nums[j - gap] # 往前比较下一个元素 j -= gap # 插入合适的位置 nums[j] = current # 缩小增量值 gap //= 2 return nums","categories":[{"name":"算法","slug":"算法","permalink":"http://zivblog.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"直接插入排序","slug":"直接插入排序","date":"2020-07-15T07:57:05.000Z","updated":"2020-07-15T08:09:52.114Z","comments":true,"path":"passages/zhi-jie-cha-ru-pai-xu/","link":"","permalink":"http://zivblog.top/passages/zhi-jie-cha-ru-pai-xu/","excerpt":"直接插入排序","text":"直接插入排序 直接插入排序 初始状态，将第一个元素是做已经被排序的元素 取出下一个元素，在已经排序的元素序列中从前向后扫描 如果该元素大于新元素，则将该元素移到下一位置 知道找到已排序的元素小于或等于新元素的位置，将新元素插入到该位置的后面 时间复杂度 最好时间复杂度：O(n) 最差时间复杂度：O(n^2) 平均时间复杂度：O(n^2) 空间复杂度 O(1) 稳定的排序算法 1234567891011121314def insertion_sort(self, nums: List[int]) -&gt; List[int]: # 控制循环插入的次数 for i in range(1, len(nums)): # 需要插入的元素 current = nums[i] # 有序区的最后一个元素 pre_index = i - 1 # 逆向遍历比较 while pre_index &gt;= 0 and nums[pre_index] &gt; current: nums[pre_index + 1] = nums[pre_index] pre_index -= 1 # 插入元素到合适的位置 nums[pre_index + 1] = current return nums","categories":[{"name":"算法","slug":"算法","permalink":"http://zivblog.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"堆排序","slug":"堆排序","date":"2020-07-14T04:06:32.000Z","updated":"2020-07-15T08:05:09.605Z","comments":true,"path":"passages/dui-pai-xu/","link":"","permalink":"http://zivblog.top/passages/dui-pai-xu/","excerpt":"堆排序","text":"堆排序 堆排序 对排序是指利用堆这种数据结构进行排序算法 堆类似于一个完全二叉树的结构，并且满足子节点的值总小于或大于它的父节点的值 这样，堆顶的值一定是当前堆中最大的或最小的，我们也正是将此性质用作排序 堆排序算法如下（结果为升序排列）： 初始无序区为R1……Rn，初始有序区为空 将无序区调整为大顶堆，将堆顶元素与最后一个元素交换 这样有序区为R_max，无序区还剩n-1个元素 再次将无序区调整为大顶堆，将堆顶元素与倒数第二个元素交换 …… 直到无序区为空，排序完成 注意： 要得到升序序列，使用大顶堆 要得到降序序列，使用小顶堆 堆排序的时间复杂度为O(nlogn) 每次进行堆调整需要的时间为O(logn) 空间复杂度为O(1) 交换时需要一个暂存空间 不稳定的排序算法 12345678910111213141516171819202122232425262728293031323334353637def HeapSort(self, nums: List[int]) -&gt; List[int]: def heapAdjust(arr, start, end): temp = arr[start] son = 2 * start + 1 while son &lt; end: # 找到左右孩子中较大的节点 if son &lt; end and arr[son] &lt; arr[son + 1]: son += 1 # 判断是否符合大顶堆 if temp &gt;= arr[son]: break # 子节点上移 arr[start] = arr[son] # 继续向下比较 start = son son = 2 * son + 1 # 将原堆顶插入正确位置 arr[start] = temp n = len(nums) if n &lt;= 1: return nums # 完全二叉树中的最后一个非叶子节点 root = n // 2 -1 while root &gt;= 0: heapAdjust(nums, root, n-1) root -= 1 i = n -1 while i &gt;= 0: # 交换堆顶与第i个元素 nums[0], nums[i] = nums[i], nums[0] heapAdjust(nums, 0, i-1) i -= 1 return nums","categories":[{"name":"算法","slug":"算法","permalink":"http://zivblog.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"简单选择排序","slug":"简单选择排序","date":"2020-07-14T03:19:19.000Z","updated":"2020-07-15T08:04:39.990Z","comments":true,"path":"passages/jian-dan-xuan-ze-pai-xu/","link":"","permalink":"http://zivblog.top/passages/jian-dan-xuan-ze-pai-xu/","excerpt":"简单选择排序","text":"简单选择排序 简单选择排序 第i次遍历 从待排序的数据元素中选择最小（最大）的元素 将其与数组中第i个位置进行交换 直到待排序部分为空 时间复杂度： 最好的情况下O(n)（数组有序） 最坏的情况为O(n^2)（数组降序，要求升序排列） 平均的情况为O(n^2) 空间复杂度为O(1)，即进行数据交换时的过渡空间 不稳定的排序算法 12345678910111213def SelectSort(self, nums: List[int]) -&gt; List[int]: n = len(nums) if n &lt;= 1: return nums for i in range(n - 1): minIndex = i for j in range(i+1, n): if nums[j] &lt; nums[minIndex]: minIndex = j if minIndex != i: nums[minIndex], nums[i] = nums[i], nums[minIndex] return nums 需要注意的是，与简单插入排序相比 简单插入排序初始将第一个元素视为有序部分，每一趟将一个元素插入有序部分（不是第i大） 简单选择排序是每次将第i大的元素与第i个位置进行交换","categories":[{"name":"算法","slug":"算法","permalink":"http://zivblog.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之搜索旋转排序数组Ⅱ","slug":"Leetcode之搜索旋转排序数组Ⅱ","date":"2020-07-13T11:37:50.000Z","updated":"2020-07-13T12:24:06.825Z","comments":true,"path":"passages/leetcode-zhi-sou-suo-xuan-zhuan-pai-xu-shu-zu-ii/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-sou-suo-xuan-zhuan-pai-xu-shu-zu-ii/","excerpt":"Search in Rotated Sorted Array Ⅱ","text":"Search in Rotated Sorted Array Ⅱ Search in Rotated Sorted Array Ⅱ code with Python title number：81 读题 假设按照升序排序的数组在预先位置的某个点上进行了旋转 编写函数来判断给定的目标值是否存在于数组中 若存在则返回True，若不存在则返回False 数组中可能存在重复数字 思路一 延续上一题的思路 使用二分搜索，减少对数组中元素的判断次数，从而降低时间复杂度 我们知道旋转后的排序数组是由两个升序子数组组成的，并且两个子数组的长度必定有一个小于len(nums) / 2 通过比较nums[mid]和nums[start]的大小可以确定nums[mid]所在的位置，从而选择mid左边或者右边舍弃 如果nums[mid]&gt;=nums[start]，则nums[mid]位于左边的有序子数组中 如果nums[mid]&lt;nums[start]，则nums[mid]位于右边的有序子数组中 target位置的确定只需比较target和有序部分边界的大小关系即可 若nums[mid] == nums[start] == nums[end]，将左右指针分别向内移动一个位置 若nums[mid] &gt; nums[start]，说明mid在做边的子序列中 若此时nums[start] &lt;= target &lt; nums[mid]，则说明target在[start, mid]中，令end = mid -1 否则，令start = mid + 1 若nums[mid] &lt; target &lt;= nums[end], 说明target在右子序列中 若此时nums[mid] &lt; target &lt; nums[end]，则说明target在[mid, end]之间，令start = mid + 1 否则，令end = mid - 1 12345678910111213141516171819202122def search(self, nums: List[int], target: int) -&gt; bool: l, r = 0, len(nums) - 1 while l &lt;= r: mid = (l + r) // 2 if nums[mid] == target: return True if nums[mid] == nums[l] == nums[r]: l += 1 r -= 1 elif nums[mid] &gt;= nums[l]: if nums[l] &lt;= target &lt; nums[mid]: r = mid - 1 else: l = mid + 1 else: if nums[mid] &lt; target &lt;= nums[r]: l = mid + 1 else: r = mid - 1 return False","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode周赛（197）","slug":"Leetcode周赛（197）","date":"2020-07-12T03:49:49.000Z","updated":"2020-07-14T03:18:41.105Z","comments":true,"path":"passages/leetcode-zhou-sai-197/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhou-sai-197/","excerpt":"第197周周赛","text":"第197周周赛 前言 第一次参加周赛，AC了两道（easy+medium）,另外一道medium超时了，hard直接没思路……，我太菜了 大神们都20min+全部AC，哭liao~ 向前排大佬学习一下，对比自己和他们思路上的差别（我还是太喜欢暴力了） 题目好数对的数目（Easy）题目 给你一个整数数组 nums 如果一组数字 (i,j) 满足 nums[i] == nums[j] 且 i &lt; j ，就可以认为这是一组 好数对 。 返回好数对的数目 思路 这道题的思路很简单，使用双指针进行数组的遍历即可 当两个指针指向的元素值相等时，则为一对好数对 注意两指针不能指向同一个元素 1234567891011class Solution: def numIdenticalPairs(self, nums: List[int]) -&gt; int: res = 0 for i in range(len(nums)): for j in range(i, len(nums)): if nums[i] == nums[j] and i != j: print(i, j) res += 1 return res 仅含1的子串数（Medium）题目 给定一个二进制字符串s（仅由0和1组成的字符串） 返回所有字符都为1的子字符串的个数 由于答案可能很大，请将其对10 ^ 9 + 7取模后返回 我的思路 连续的n个1可以组成的关于1的子字符串的个数为 123451个长为n的子字符串2个长为n-1的子字符串...n-1个长为2的子字符串n个长为1的子字符串 故，只需要统计有多少个连续为1的子字符串的长度即可 由连续1产生的子字符串是可以通过计算1~n的累加和得到 123456789101112131415161718192021222324252627class Solution: def numSub(self, s: str) -&gt; int: res = 0 one_array = [] cnt = 0 def count_(num): sum_ = 0 for i in range(1, num+1): sum_ += i return sum_ for i in range(len(s)): if s[i] == '1': cnt += 1 else: if cnt != 0: one_array.append(cnt) cnt = 0 if cnt != '0': one_array.append(cnt) sum_ = 0 for num in one_array: sum_ += count_(num) return sum_ % (10**9 + 7) 哦……，要记得做最后的取模运算 概率最大的路径（Medium）题目 给你一个由 n 个节点（下标从 0 开始）组成的无向加权图，该图由一个描述边的列表组成，其中 edges[i] = [a, b] 表示连接节点 a 和 b 的一条无向边，且该边遍历成功的概率为 succProb[i] 。 指定两个节点分别作为起点 start 和终点 end ，请你找出从起点到终点成功概率最大的路径，并返回其成功概率。 如果不存在从 start 到 end 的路径，请 返回 0 。只要答案与标准答案的误差不超过 1e-5 ，就会被视作正确答案。 我的思路（超时） 将用边表示的图转化为以节点表示的图（原谅我只会以节点表示的图的深度优先搜索……） 进行深度优先搜索，得到所有start和end之间的路径 遍历路径，拿到边对应的权值，计算路径的概率 比较得到最终概率最大的路径 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class Solution: def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -&gt; float: def build_graph(edges): graph = &#123;&#125; for edge in edges: left, right = edge[0], edge[1] if left not in graph: graph[left] = [right] else: graph[left].append(right) if right not in graph: graph[right] = [left] else: graph[right].append(left) return graph def find_all_path(graph, start, end, path = []): if start not in graph: return [] path = path + [start] if start == end: return [path] paths = [] for node in graph[start]: if node not in path: newpaths = find_all_path(graph, node, end, path) for newpath in newpaths: paths.append(newpath) return paths def cal_max_prob(paths, edges, succProb): max_prob = float(0) if paths == []: return max_prob for path in paths: prob = float(1) for i in range(len(path)-1): if [path[i], path[i+1]] in edges: index = edges.index([path[i], path[i+1]]) else: index = edges.index([path[i+1], path[i]]) prob *= succProb[index] if max_prob &lt; prob: max_prob = prob return max_prob # 构建图 graph = build_graph(edges) # 所有路径 paths = find_all_path(graph, start, end) max_prob = cal_max_prob(paths, edges, succProb) return max_prob 前排围观 BFS + 剪枝 使用广度优先搜索进行图的遍历 使用一个数组记录已经访问过的节点（提前剪枝） 使用字典记录每个节点被访问到的最大概率（防止再次访问到时概率小的进队） 1234567891011121314151617181920212223242526class Solution: def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -&gt; float: # adjlist存储从边的一端到另一端的概率（双向） # 队列用于实现bfs adjlist, queue, record, visited = defaultdict(list), deque([(start, 1), ]), defaultdict(int), set() # 从一个节点到其他节点的概率 for (x, y), p in zip(edges, succProb): adjlist[x].append((y, p)) adjlist[y].append((x, p)) ans = 0 # bfs while queue: node, prob = queue.popleft() if node == end: ans = max(ans, prob) continue for next_node, next_prob in adjlist[node]: val = next_prob * prob if val &gt; record[next_node]: record[next_node] = val queue.append((next_node, val)) return ans 题目要求求概率最大的路径，整体思路与Dijkstra相同 需要将其中边的权值相加替换为边的权值相乘 Dijkstra使用来计算单源最短路径的算法，是一种贪心算法 1234567891011121314151617181920212223242526272829303132class Solution: def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -&gt; float: # 构造图 mem = collections.defaultdict(list) for (u, v), p in zip(edges, succProb): mem[u].append((v, p)) mem[v].append((p, u)) dist = [0 for _ in range(n)] visited = [False for _ in range(n)] # 构造一个优先队列辅助实现 queue = [] heapq.heappush(queue, (-1, start)) dist[start] = 1 # 为了每次返回最大概率，对概率取反 while queue: maxprob, u = heapq.headppop(queue) # 已访问过的跳过 if visited[u]: continue visited[u] = True for v, p in mem[u]: new_prob = - (p * maxprob) if dist[v] &lt; new_prob: dist[v] = new_prob heapq.heappush(queue, (-dist[v], v)) return dist[end] 服务中心的最佳位置（Hard）题目 一家快递公司希望在新城市建立新的服务中心。公司统计了该城市所有客户在二维地图上的坐标，并希望能够以此为依据为新的服务中心选址：使服务中心 到所有客户的欧几里得距离的总和最小 。 给你一个数组 positions ，其中 positions[i] = [xi, yi] 表示第 i 个客户在二维地图上的位置，返回到所有客户的 欧几里得距离的最小总和 。 换句话说，请你为服务中心选址，该位置的坐标 [xcentre, ycentre] 需要使下面的公式取到最小值： $$\\sum_{i=0}^{n-1} \\sqrt{(x_{centre} - x_i)^2 + (y_{centre} - y_i)^2}$$ 前排围观 梯度下降算法 首先选择x0, y0，作为迭代的初始值 求当前节点的梯度，即dx, dy 学习率的调节：固定x0, y0不变的情况下，成倍数的缩减步长，直到找到距离小于当前点的转移点 进行下一步的迭代 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution: def dist(self, x, y, positions): \"\"\"计算欧式距离\"\"\" return sum([((x - xi) ** 2 + (y - yi) ** 2) ** 0.5 for xi, yi in positions]) def deri(self, x, y, positions): \"\"\"计算导数（偏微分）\"\"\" dx, dy = 0, 0 for xi, yi in positions: div = ((x - xi) ** 2 + (y - yi) ** 2) ** 0.5 if div == 0: continue dx += (x - xi) / div dy += (y - yi) / div return dx, dy def getMinDistSum(self, positions: List[List[int]]) -&gt; float: if len(set([tuple(v) for v in positions])) &lt;= 1: return 0 # 初始迭代位置 x0 = sum([p[0] for p in positions]) / len(positions) y0 = sum([p[1] for p in positions]) / len(positions) # 初始步长 step = 16 while True: dx, dy = self.deri(x0, y0, positions) # 导数都为0, 说明当前是极值点, 退出循环。凹函数的证明可以参考其他文章 if (dx, dy) == (0, 0): break while True: x1 = x0 - step * dx y1 = y0 - step * dy # 保持x0、y0不变，一直寻找下一个下降点，并在此期间改变步长 if self.dist(x1, y1, positions) &lt; self.dist(x0, y0, positions): break # 减少步长 step /= 4 if abs(self.dist(x1, y1, positions) - self.dist(x0, y0, positions)) &lt; 10 ** -6: break # 转移到下一个位置点 x0, y0 = x1, y1 return self.dist(x0, y0, positions) 任重道远呀，要开始记解题模板了🎈🎈🎈🎈","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之寻找旋转排序数组中的最小值Ⅱ","slug":"Leetcode之寻找旋转排序数组中的最小值Ⅱ","date":"2020-07-12T01:17:10.000Z","updated":"2020-07-12T01:49:46.396Z","comments":true,"path":"passages/leetcode-zhi-xun-zhao-xuan-zhuan-pai-xu-shu-zu-zhong-de-zui-xiao-zhi-ii/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-xun-zhao-xuan-zhuan-pai-xu-shu-zu-zhong-de-zui-xiao-zhi-ii/","excerpt":"Find Minimum in Rotated Sorted Array Ⅱ","text":"Find Minimum in Rotated Sorted Array Ⅱ Find Minimum in Rotated Sorted Array Ⅱ code with Python title number：154 读题 假设按照升序排序的数组在预先未知的点上进行了旋转 请找出其中最小的元素 数组中可能存在重复元素 思路一 延续上一题的思路： 旋转排序数组nums可以被拆分为两个单独的升序数组nums1, nums2，并且前者中任意元素均大于等于后者中的元素 使用二分法查找两个子排序数组的分界点（nums2的首个元素），即为当前数组中的最小值 同样的，mid位置元素的值要与end位置的值进行比较 不同之处在于，本题给出的数组中可能存在重复的元素： 设置left, right分别位于数组的两端 当nums[mid] &gt; nums[right]时，mid一定在nums1中，接下来需要去mid右边查找，即left = mid=1 当nums[mid] &lt; nums[right]时，mid一定在nums2中，且分割点一定在mid的左侧，即right = mid 当nums[mid] == nums[right]时，由于重复元素的存在，并不能准确判断出mid所在的位置： 我们采用right = right - 1的方式解决此问题 当nums[right]是最小值且是唯一最小值时，nums[mid]==nums[right]不可能成立（``mid必小于right`） 当nums[right]是最小值且不唯一时，由于mid &lt; right，则有其他最小值存在于[left, right-1]之间 12345678910111213def findMin(self, nums: List[int]) -&gt; int: left, right = 0, len(nums) - 1 while left &lt; right: mid = left + int((right - left) / 2) if nums[mid] &gt; nums[right]: left = mid + 1 elif nums[mid] &lt; nums[right]: right = mid else: right = right - 1 return nums[left]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之寻找旋转排序数组中的最小值","slug":"Leetcode之寻找旋转排序数组中的最小值","date":"2020-07-11T05:21:18.000Z","updated":"2020-07-12T02:02:46.951Z","comments":true,"path":"passages/leetcode-zhi-xun-zhao-xuan-zhuan-pai-xu-shu-zu-zhong-de-zui-xiao-zhi/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-xun-zhao-xuan-zhuan-pai-xu-shu-zu-zhong-de-zui-xiao-zhi/","excerpt":"Find Minimum in Rotated Sorted Array","text":"Find Minimum in Rotated Sorted Array Find Minimum in Rotated Sorted Array code with Python title number：153 读题 假设按照升序排序的数组，在预先未知的某个点上进行了旋转 例如，数组[0, 1, 2, 3, 4, 5, 6, 7]可能变为[4, 5, 6, 7, 0, 1, 2, 3] 找出其中的最小元素 假设数组中不存在重复元素 思路一 首先想到的思路是，对于进行过旋转的数组上，出最小值之外，数组中任意相邻两个元素，后者减去前者一定是正数，只要便利找到第一个为负数的组合即可 但是这样的问题在于，如果未进行过旋转（最坏情况），那么时间复杂度为O(n) 使用二分查找能明显减少查找的次数，从而降低时间复杂度 根据旋转后数组的特征：最右边的值是旋转部分中的最大值 当mid位置的值大于right时，最小值在右半部分（旋转的部分在mid右边） 当mid位置的值小于right时，最小值在左半部分（即mid在旋转的部分中） 123456789101112def findMin(self, nums: List[int]) -&gt; int: l, r = 0, len(nums) - 1 while l &lt; r: mid = int(l + (r - l) / 2) if nums[mid] &lt; nums[len(nums)-1]: r = mid else: l = mid + 1 return nums[r] 深入讨论 使用二分法查找的主要思路是什么？ 使用二分法的目的是通过不断收缩走右边界，将目标值始终包含在[left, right]区间内 当左右边界重合之后，就完成了目标的查找 旋转后的数组有什么特性？ 特性很明显，旋转之后，左半部分的数组始终大于右半部分数组中的值 为什么通过比较nums[mid]与nums[right]之间的大小关系而不是比较nums[mid]与nums[left]之间的关系来确定区间的收缩方式呢？ 我们可以穷举所有可能的情况 在前面三种情况中，情况1、2同属一类，第三种属于第二类 如果中值 &lt; 右值，则最小值在左半边，可以收缩右边界。 如果中值 &gt; 右值，则最小值在右半边，可以收缩左边界。 通过比较中值与右值，可以确定最小值的位置范围，从而决定边界收缩的方向 而如果进行中值与左值的比较： 在第三种情况中，均为左值小于中值，但是最小值的范围却不相同 即不能确定区间边界的收缩 ​","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之第一个错误的版本","slug":"Leetcode之第一个错误的版本","date":"2020-07-10T03:48:35.000Z","updated":"2020-07-10T04:54:46.620Z","comments":true,"path":"passages/leetcode-zhi-di-yi-ge-cuo-wu-de-ban-ben/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-di-yi-ge-cuo-wu-de-ban-ben/","excerpt":"First Bad Version","text":"First Bad Version First Bad Version code with Python title number：278 读题 给定一个长为n的序列，对应一个产品编号为1~n的n个版本 其中有一个版本出错，会导致后续版本都有错误 请找出第一个出现错误的版本，并尽量减少判断的次数 思路一 请原谅我第一反应竟然是顺序遍历，并依次判断当前版本是否为错误版本（很明显会超时） 通过二分搜索来减少一半的搜索空间，以此来减少时间复杂度 对于情况一： 1234561 2 3 4 5 6 7 8 9G G G G G G B B B| | |l mid r对mid位置的判断为true，因此我们知道mid左边的一定全是未出现错误的版本，只需去右半部分进行搜索即可。即l = mid + 1 对于情况二： 123451 2 3 4 5 6 7 8 9G G B B B B B B B| | |l mid r对mid位置的判断为false，因此我们知道右边的一定全是出现错误的版本，只需去左半部分进行搜索即可。即r = mid 需要注意的是，在初始时需要将l=0, r=n，当两个相等时，所指方向即为第一个错误的版本号 12345678910def firstBadVersion(self, n: int) -&gt; int: left, right = 0, n while left != right: mid = int(left + (right - left) / 2) if isBadVersion(mid): right = mid else: left = mid + 1 return left","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之搜索二维矩阵","slug":"Leetcode之搜索二维矩阵","date":"2020-07-09T02:43:33.000Z","updated":"2020-07-09T02:55:44.811Z","comments":true,"path":"passages/leetcode-zhi-sou-suo-er-wei-ju-zhen/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-sou-suo-er-wei-ju-zhen/","excerpt":"Search a 2D Matrix","text":"Search a 2D Matrix Search a 2D Matrix code with Python title number：74 读题 编写算法，在二维矩阵中，判断是否存在目标值，矩阵特点如下： 每行中的整数从左到右按升序排列 每行的第一个整数大于前一行的最后一个整数 思路一 根据矩阵的特点，可以将矩阵转化为一维的升序列表 查找 &amp; 有序列表 ——&gt; 使用二分查找进行目标值的查找 12345678910111213141516171819202122232425def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool: # 矩阵中不包含元素 if len(matrix) == 0 or len(matrix[0]) == 0: return False # 矩阵转化为列表 L = [] for m in matrix: L.extend(m) # 进行二分查找 l, r = 0, len(L) - 1 while l + 1 &lt; r: mid = int(l + (r - l) / 2) if L[mid] == target: return True if L[mid] &lt; target: l = mid if L[mid] &gt; target: r = mid # 当矩阵中只包含一个元素时 if L[l] == target or L[r] == target: return True return False","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Lintcode之搜索区间","slug":"Lintcode之搜索区间","date":"2020-07-08T00:54:23.000Z","updated":"2020-07-10T04:55:04.973Z","comments":true,"path":"passages/lintcode-zhi-sou-suo-qu-jian/","link":"","permalink":"http://zivblog.top/passages/lintcode-zhi-sou-suo-qu-jian/","excerpt":"Search For Range","text":"Search For Range Search For Range code with Python titile number： 60 读题 给定一个包含n个整数的排序数组，找出给定目标值target的起始和结束位置 如果目标值不再数组中，则返回[-1, -1] 示例： 123输入：[5, 7, 7, 8, 8, 10], 8输出：[3, 4]解释：返回的是数组中目标值出现的起始位置的下标 思路一 有序数组中的查找，最先想到的是二分查找 通过两次二分查找分别得到target的两个边界 值得注意的是，两个边界要么都存在，要么都不存在 12345678910111213141516171819202122232425262728293031323334353637383940414243444546def searchRange(self, A: List[int], target: int) -&gt; List[int]: if len(A) == 0: return [-1, -1] result = [] start, end = 0, len(A) - 1 while start + 1 &lt; end: mid = int(start + (end - start) / 2) if A[mid] &gt; target: end = mid elif A[mid] &lt; target: start = mid else: end = mid # 查找左边界 if A[start] == target: result.append(start) elif A[end] == target: result.append(end) else: result.append(-1) result.append(-1) return result start, end = 0, len(A) - 1 while start + 1 &lt; end: mid = int(start + (end - start) / 2) if A[mid] &gt; target: end = mid elif A[mid] &lt; target: start = mid else: start = mid # 查找右边界 if A[end] == target: result.append(end) elif A[start] == target: result.append(start) else: result.append(-1) result.append(-1) return result return result","categories":[{"name":"Lintcode","slug":"Lintcode","permalink":"http://zivblog.top/categories/Lintcode/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"},{"name":"lintcode","slug":"lintcode","permalink":"http://zivblog.top/tags/lintcode/"}]},{"title":"Leetcode之比特位计数","slug":"Leetcode之比特位计数","date":"2020-07-07T00:37:25.000Z","updated":"2020-07-07T01:43:20.319Z","comments":true,"path":"passages/leetcode-zhi-bi-te-wei-ji-shu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-bi-te-wei-ji-shu/","excerpt":"Counting Bits","text":"Counting Bits Counting Bits code with Python title number：338 读题 给定一个非负整数num，对于0 &lt;= n &lt;= num范围中的每个数字i，计算器二进制数中的1的数目并将他们作为数组返回 示例： 123输入：2输出：[0, 1, 1]解释：0: 00, 1: 01, 2: 10, 包含的1的个数分别为0, 1, 1 思路一 遍历整个范围，对范围中的每个数统计其包含的1的个数，将统计结果添加到结果集中 将数字和1进行与操作，判断当前最低位是否为1 将数字进行左移操作，删除掉低位被统计过的1 12345678910def countBits(self, num: int) -&gt; List[int]: res = [] for i in range(num + 1): count = 0 while i: count += i &amp; 1 res.append(count) return res 时间复杂度为O(n*sizeof(integer)) 思路二 题目要求使用线性时间复杂度的算法，并且算法的空间复杂度为O(n) 要想实现时间复杂度是O(n)的算法，必然不能一边遍历一遍统计；需要在遍历的同时，利用之前的结果计算当前数字中1的个数 如果当前数字是偶数，则f(i)=f(i//2) 如果当前数字是奇数，则f(i)=f(i-1)+1 具体解释一下 如果当前数字是偶数，说明数字的最低位一定是0，所以将数字左移一位（除2），数字中所包含的1的个数是不变的 如果当前数字是奇数，则其前一位必定是偶数，当前奇数只是在前一个数字的最低位加了一个1，所以其1的个数是前一个数字的1的个数+1 其实这就是动态规划 12345678910def countBits(self, num: int) -&gt; List[int]: res = [0] for i in range(1, num+1): if i % 2 == 0: res.append(res[i // 2]) else: res.append(res[i - 1] + 1) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之只出现一次的数字Ⅲ","slug":"Leetcode之只出现一次的数字Ⅲ","date":"2020-07-06T02:01:26.000Z","updated":"2020-07-06T05:04:53.844Z","comments":true,"path":"passages/leetcode-zhi-zhi-chu-xian-yi-ci-de-shu-zi-iii/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zhi-chu-xian-yi-ci-de-shu-zi-iii/","excerpt":"Single Number Ⅲ","text":"Single Number Ⅲ Single Number Ⅲ code with Python title number：260 读题 给定一个整数数组，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素 思路一 沿用之前的思路，数学方法、字典、位运算 由于这里是要求两个元素，故前面用过的数学方法不适用 这里先用字典解决： 遍历数组，统计每个元素出现的次数 返回出现次数为1的元素 123456789101112131415def SingleNumber(self, nums: List[int]) -&gt; List[int]: map_ = dict() for num in nums: if num in map_: map_[num] += 1 else: map_[num] = 1 res = [] for key in map_keys(): if map_[key] == 1: res.append(key) return res 思路二 位运算背景知识： 0和所有数异或得到数字本身 相同的数字进行异或得到的结果为0 补码等于原码的反码加1，负数用补码表示 一个数和它的相反数异或得到该数二进制表示最左边的1 例如 1234原码：0000 0101反码：1111 1010补码：1111 11115 &amp; (-5) &#x3D; 1 思路： 所有数进行异或操作，得到只出现一次的两个数的异或 将这个异或与自己的相反数进行与操作，得到两个数最左边出现的1，记为2 分别用a与每个数进行与操作，将数组分为两部分 每部分分别进行异或操作，即可得到这两个只出现一次的数 12345678910111213141516def singleNumber(self, nums； List[int]) -&gt; List[int]: a = 0 # 遍历，进行异或操作 for num in nums: a ^= num x, y = 0, 0 # 得到两个数的异或的最左边的1 a &amp;= -a for num in nums: if a &amp; num: x ^= num else: y ^= num return [x, y]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之只出现一次的数字Ⅱ","slug":"Leetcode之只出现一次的数字Ⅱ","date":"2020-07-05T09:39:46.000Z","updated":"2020-07-06T05:31:44.321Z","comments":true,"path":"passages/leetcode-zhi-zhi-chu-xian-yi-ci-de-shu-zi-ii/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zhi-chu-xian-yi-ci-de-shu-zi-ii/","excerpt":"Single Number Ⅱ","text":"Single Number Ⅱ Single Number Ⅱ code with Python title number：137 读题 给定一个非空整数数组，除了某个元素只出现一次之外，其余的元素均出现了三次，找出那个只出现了一次的元素 说明 算法应具有线性时间复杂度，尽量不要使用额外空间 思路一 数学方法 利用集合的特性，求整个数组的不重复元素，乘3求和 对所有数组元素求和 两者相减除以2即为只出现了一次的元素 例如: 123输入：[2, 2, 3, 2]输出：3解释：[2*3 * 3*3 - (2+2+3+2)] &#x2F; 2 &#x3D; 3 123456789def singleNumber(self, nums: List[int]) -&gt; int: single = set(nums) sum_3 = 0 for i in single: sum_3 += 3*i for num in nums: sum_3 -= num return sum_3 / 2 思路二 利用字典 遍历整个数组，统计每个元素出现的次数 返回出现次数为1的元素 1234567891011def singleNumber(self, nums: List[int]) -&gt; int: map_ = dict() for num in nums: if num in map_: map_[num] += 1 else: map_[num] = 1 for key in map_.keys(): if map_[key] == 1: return key 思路三 先进行排序（将相同的数字放到一起） 遍历，如果nums[i]==nums[i+2]，则说明该数字出现了三次 否则返回当前数字 如果遍历完也没有找到，则最后一个数字为出现一次的 123456789def singleNumber(self, List[int]) -&gt; int: nums.sort() i = 0 while i + 2 &lt; len(nums): if nums[i] == nums[i+2]: i += 3 else: return nums[i] return nums[-1] 思路三 上述方法都使用了额外的空间 使用位运算进行，先介绍三种位运算： and，且运算，使用&amp;表示 not，非运算，使用~表示 xor，异或运算，使用^表示 使用异或运算可以检测出现奇数次的数字 0异或所有数字都为该数字本身 两个相同的数进行异或操作，结果为0 对于出现两次的相同数，我们可以通过异或置0 对于出现三次的相同数，我们要构造一种方法，将同一个位置上的三个1清零，这样就可以发现出现三次的数字了 在异或运算中，1^1=0, 1^0=0, 0^1=1，可以将其理解为不进位的二进制加法，而不进位可以理解为进位为对2取模 这样，我们可以定义二进制加法，且进位为对3取模的做法为三个相同位的清零运算，即可实现a?a?a=0 所谓清零 12321: 1010121: 10101异或: 00000 1234567891011def singleNumber(self, nums: List[int]) -&gt; int: res = 0 for i in range(64): # 初始化每一位1的个数为0 sum = 0 for j in range(len(nums)): # 通过右移的方式，统计每一位1的个数 sum += nums[j] &gt;&gt; i &amp; 1 # 最终将抵消后剩余的1放到对应的位数上 res ^= (sum % 3) &lt;&lt; i return res 推而广之，如果是定义一个a?a?a?a?a=0的运算，只需要进行二进制加法，进位对5取模","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之01矩阵","slug":"Leetcode之01矩阵","date":"2020-07-04T05:08:08.000Z","updated":"2020-07-06T05:08:18.261Z","comments":true,"path":"passages/leetcode-zhi-01-ju-zhen/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-01-ju-zhen/","excerpt":"01 Matrix","text":"01 Matrix 01 Matrix code with Python title number：542 读题 给定一个由0, 1组成的矩阵，找出每个元素到最近的0的距离 两个相邻元素间的距离为1 例如： 矩阵元素只能在四个方向上相邻：上、下、左、右 思路一 由题意可知，所求距离为曼哈顿距离，即方向上只能沿这横、竖到达下一个位置 在一个图中，从一个点出发求最短距离，首先想到的是广度优先遍历 广度优先遍历会优先将最近的一圈搜索完之后，再去搜索下一圈 所以在本题中，第i圈对应的就是距离为i 题目给出了多个1，要求找到每个1到0的最近曼哈顿距离。而0到1的距离和1到0的距离是相同的 故我们可以将问题转化为:每个0到1距离 问题抽象为:多个起始点的广度优先搜索 接下来是广度优先搜索： 将每个还未搜索到的点依次放入队列，再弹出队列的头部元素作为当前的遍历点 要确定遍历到哪一层，需要加一个level记录遍历的层数 访问完每层的元素之后，level+1 具体算法细节，请结合代码和注释理解 12345678910111213141516171819202122232425262728293031323334353637383940def updateMatrix(self, matrix: List[List[int]]) -&gt; List[List[int]]: M, N = len(matrix), len(matrix[0]) queue = collections.deque() # 记录已访问过的位置 visited = [[0] * N for _ in range(M)] # 结果 res = [[0] * N for _ in range(M)] # 将所有的0添加到队列中 for i in range(M): for j in range(N): if matrix[i][j] == 0: queue.append((i, j)) visited[i][j] = 1 # 四个方向 dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)] # 距离 = 层数 step = 0 # 出队所有元素 while queue: size = len(queue) # 当前元素所有邻居 for i in range(size): x, y = queue.popleft() if matrix[x][y] == 1: res[x][y] = step # 广度优先遍历，四个方向 for dx, dy in dirs: newx, newy = x + dx, y + dy if newx &lt; 0 or newx &gt;= M or newy &lt; 0 or newy &gt;= N or visited[newx][newy] == 1: continue # 新节点入队 queue.append((newx, newy)) visited[newx][newy] = 1 # 下一层 step += 1 return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之柱状图中最大的矩形","slug":"Leetcode之柱状图中最大的矩形","date":"2020-07-03T01:02:29.000Z","updated":"2020-07-06T05:32:02.951Z","comments":true,"path":"passages/leetcode-zhi-zhu-zhuang-tu-zhong-zui-da-de-ju-xing/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zhu-zhuang-tu-zhong-zui-da-de-ju-xing/","excerpt":"Largest Rectangle in Histogram","text":"Largest Rectangle in Histogram Largest Rectangle in Histogram code with Python title number：84 读题 给定n个非负数，用来表示柱状图中每个柱子的高度。 每个柱子彼此相邻，且宽度为1 求在该柱状图中，能够勾勒出来的矩形的最大面积 先验知识 单调栈适合处理两端元素的大小决定中间元素大小的问题 单调栈有一下性质： 如果是单调递增栈，则从栈顶到栈底的元素是严格递增的；如果是单调递减栈，则从栈顶到栈底的元素是严格递减的 只能在栈顶操作 进栈过程（以单调递增栈为例）： 如过当前进栈元素为e，从栈顶开始遍历元素，把小于e或等于e的元素弹出 直到遇到一个大于e的元素或栈空为止，然后再把e压入栈中 思路一 当前位置的高度能决定的最大阴影面积由其左右第一个小于该元素的元素决定 以第i根柱子为最矮柱子所能延伸的最大面积：当前高度 * 左右第一个小于该元素之间的距离 使用单调栈用以找到当前元素左右第一个小于它的元素 上述思路体现在单调栈上的操作，即： 从左到右遍历每一根柱子，我们要找到第一个小于当前高度的柱子 如果柱子高度大于栈顶的柱子高度（不是我们要找的），则入栈 如果柱子高度小于栈顶的柱子高度（所求）， 对于栈顶元素，其右边的第一个小于它的就是当前遍历到的柱子，左边第一个小于它的柱子就是栈中下一个要被弹出的元素 因此，当前栈顶元素决定的最大阴影面积为：当前栈顶的柱子高度 * (当前遍历到的柱子索引 - 栈中下一个要被弹出的元素的索引 + 1) 为了方便操作，在heights的左右两边各添加一个哨兵元素，保证所有的柱子都会出栈 1234567891011def largestRectangleArea(self, heights: List[int]) -&gt; int: n, heights, stack, ans = len(heights), [0]+heights+[0], [], 0 for i in range(n + 2): # 当前元素是栈顶元素右边第一小于它的元素 # 栈顶第二元素是栈顶元素左边第一个小于它的元素 while st and heights[stack[-1]] &gt; heights[i]: ans = max(ans, heights[stack.pop(-1)] * (i - stack[-1] - 1)) stack.append(i) return ans 不愧是hard的题目啊，🤦‍♂️🤦‍♂️🤦‍♂️","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之克隆图","slug":"Leetcode之克隆图","date":"2020-07-02T01:09:58.000Z","updated":"2020-07-06T05:20:05.243Z","comments":true,"path":"passages/leetcode-zhi-ke-long-tu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-ke-long-tu/","excerpt":"Clone Graph","text":"Clone Graph Clone Graph code with Python title number：133 读题 给定一个无向连通图中一个节点的引用，请返回该图的深拷贝（克隆） 图中每个节点包含它的值和它的邻居列表 思路一 由于图是连通图，可以通过一次遍历访问到所有节点（深度优先搜索 or 广度优先搜索） 深拷贝，即所有节点的空间要重新申请，而不是只创建索引 图中可能存在环，因此需要存储已经访问过的节点，防止陷入死循环 这里我们使用深度优先搜索遍历图 用于存储已访问过（且拷贝过）节点的数据结构为字典{原节点:复制节点} 12345678910111213141516171819202122232425class Solution: def __init__(self): self.visited = &#123;&#125; def cloneGraph(self, node: 'Node') -&gt; 'Node': # 深度优先遍历并克隆 def dfs(node): if not node: return None # 已访问过，直接返回已创建的克隆对象 if node in self.visited: return self.visited[node] # 未访问过，创建克隆对象 ans = Node(node.val) self.visited[node] = ans # 深度优先搜索其邻居节点 for neighbor in node,neighbors: ans.neighbors.append(dfs(neighbor)) return ans return dfs(node)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之字符串解码","slug":"Leetcode之字符串解码","date":"2020-07-01T01:22:07.000Z","updated":"2020-07-06T05:32:44.602Z","comments":true,"path":"passages/leetcode-zhi-zi-fu-chuan-jie-ma/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zi-fu-chuan-jie-ma/","excerpt":"Decode String","text":"Decode String Decode String code with Python title number：394 读题 给定一个经过编码的字符串，返回它解码后的字符串。 编码规则为: k[encoded_string]，表示其中方括号内部的encoded_string正好重复k次。注意k保证为正整数。 输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像3a或 2[4]的输入。 思路一 本题的难点在于解码过程存在嵌套现象，即需要先对内部进行解码拼接，再依次对外部进行解码 这与栈的先入后出十分吻合，这里我们使用辅助栈进行解码操作： 遇到数字（’[‘之前的元素，转化为数字）压入栈中 遇到’[‘之后，将左右括号之间的元素压入栈中 遇到’]’之后，取出栈中元素进行拼接，将结果放入栈中 栈中唯一元素即为拼接后的结果 12345678910111213141516def decodeString(self, s: str) -&gt; str: stack, res, multi = [], '', 0 for c in s: if c == '[': stack.append([multi, res]) res, multi = '', 0 elif c == ']': cur_multi, last_res = stack.pop() res = last_res + cur_multi * res elif '0' &lt;= c &lt;= '9': multi = multi * 10 + int(c) else: res += c return res 思路二 这种嵌套结构也会令人自然想到递归 左右括号间的内容是需要递归的主体： 遇到’[‘，开启一层新的递归 遇到’]’，返回当前括号内的字符串和索引i 遍历完返回结果 1234567891011121314151617def decodeString(self, s: str) -&gt; str: def dfs(s, i): res, multi = \"\", 0 while i &lt; len(s): if '0' &lt;= s[i] &lt;= '9': multi = multi *10 + int(s[i]) elif s[i] == '[': i, temp = dfs(s, i + 1) res += multi * temp multi = 0 elif s[i] == ']': return i, res else: res += s[i] i += 1 return res return dfs(s, 0)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之复制带随机指针的链表","slug":"Leetcode之复制带随机指针的链表","date":"2020-06-30T01:05:43.000Z","updated":"2020-07-06T05:16:16.485Z","comments":true,"path":"passages/leetcode-zhi-fu-zhi-dai-sui-ji-zhi-zhen-de-lian-biao/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-fu-zhi-dai-sui-ji-zhi-zhen-de-lian-biao/","excerpt":"Copy List with Random Pointer","text":"Copy List with Random Pointer Copy List with Random Pointer code with Python title number：138 读题 给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点 要求返回该链表的深拷贝 用一个有n个节点组成的链表来表示输入/输出的链表。每个节点用一个[val, random_index]表示： val：节点值 random_index：随机指针 示例 12输入：head &#x3D; [[7,null],[13,0],[11,4],[10,2],[1,0]]输出：[[7,null],[13,0],[11,4],[10,2],[1,0]] 思路一 深拷贝与浅拷贝的区别： 深拷贝在于创建新的指针和空间，即深拷贝得到的对象与原对象之间相互独立，互不影响 浅拷贝只创建新的指针指向原对象的空间，原对象上的修改都会浅拷贝对象的改变 本题的关键在于存在随机指针，所以链表中可能存在环，如果直接遍历复制可能导致死循环，故有以下考虑： 使用hash表存储已访问过的节点 对next和random两个指针同时进行递归复制 123456789101112131415161718192021class Solution: def __init__(self): self.visited = &#123;&#125; def copyRandomList(self, head: 'Node') -&gt; 'Node': if head == None: return None if head in self.visited: return self.visited[head] node = Node(head.val, None, None) self.visited[head] = node # 递归 node.next = self.copyRandomList(head.next) node.random = self.copyRandomList(node.random) return node 思路二 本题的难点在于随机指针的复制，我们通过一下三步实现： 根据遍历到的原节点创建对应的新节点，每个新创建的节点添加到原节点的后面（为了方便的复制随机指针） 对所有新创建节点组成的链表添加随机指针（若node1.random=node3，则node1_new.random=node3_new） 将两个链表分离 另外，我们是沿着next链进行的遍历，无需使用额外的空间来记录访问过的节点 12345678910111213141516171819202122232425262728293031class Solution: def __init__(self, head): if not head: return Node p = head # 第一步：在每个节点后创建新节点 while p: new_node = Node(p.val, None, None) new_node.next = p.next p.next = new_node p = new_node.next p = head # 第二步：复制随机指针 while p: if p.random: p.next.random = p.random.next p = p.next.next p = head dummy = Node(-1, None, None) cur = dummy # 将两个链表分离 while p: cur.next = p.next cur = cur.next p.next = cur.next p = p.next return dummy.next","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之回文链表","slug":"Leetcode之回文链表","date":"2020-06-29T02:32:37.000Z","updated":"2020-07-06T05:17:13.216Z","comments":true,"path":"passages/leetcode-zhi-hui-wen-lian-biao/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-hui-wen-lian-biao/","excerpt":"Palindrome Linked List","text":"Palindrome Linked List Palindrome Linked List code with Python title number：234 读题 给定一个单链表，判断其是否为回文链表 思路一 快慢指针找到中间节点 反转后半部分链表 两子链表从头比较是否完全相同 具体细节参看代码注释 123456789101112131415161718192021222324252627282930313233343536def isPalindrome(self, head: ListNode) -&gt; bool: # 链表为空或链表长度为1，为回文链 if head is None or head.next is None: return True # 反转链表 def reverse(head): pre, cur = None, head while cur: temp = cur.next cur.next = pre pre = cur cur = temp return pre fast, slow = head.next, head # 查找中间节点 while fast and fast.next: fast, slow = fast.next.next, slow.next if fast == slow: break # 指向两子链表头节点 p, q = head, slow.next # 断开链表 slow.next = None # 反转后半部分链表 q = reverse(q) while p and q: # 中间存在不相等节点 if p.val != q.val: return Fasle p, q = p.next, q.next return True","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之环形链表Ⅱ","slug":"Leetcode之环形链表Ⅱ","date":"2020-06-29T01:21:25.000Z","updated":"2020-07-06T05:16:47.809Z","comments":true,"path":"passages/leetcode-zhi-huan-xing-lian-biao-ii/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-huan-xing-lian-biao-ii/","excerpt":"Linked List Cycle Ⅱ","text":"Linked List Cycle Ⅱ Linked List Cycle Ⅱ code with Python title number：142 读题 给定一个链表，返回链表开始入环的第一个节点。 如果链表中不存在环， 返回None 链表不允许修改 思路一 首先要判断链表中是否存在环，使用快慢指针即可 其次查找链表中入环的第一个节点（有点绕，自己画个示意图） 假设，头结点到链表入环的第一个节点的长度为a（a的值即为所求） 假设，环的长度为b 分析 两节点相遇时，慢指针走过的长度必小于a+b（假设为a+x） 快指针必定已经走完至少一圈环（假设为m圈） 此时有：快指针走过的长度为a + mb + x，慢指针走过的长度为a + x 快指针走过的长度是慢指针的两倍，故a + mb + x = 2*(a + x)，可得a = mb - x 方法 在两指针相遇时，在头结点出设置一指针，令其与快指针同步移动（每次一个位置） 两指针相遇的位置即为环的入口 证明如下： 新指针到达入口需要走的长度为a 快指针再走a总长度为a + mb + x + mb - x = a + 2*mb，即刚好走完两个环，到达环的入口位置 123456789101112131415161718def detectCycle(self, head: ListNode) -&gt; ListNode: fast, slow = head, head while fast and fast.next: fast = fast.next.next slow = slow.next # 有环 if fast == slow: meetNode = slow start = head while meetNode != start: meetNode, start = meetNode.next, start.next return meetNode return None","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之环形链表","slug":"Leetcode之环形链表","date":"2020-06-29T01:13:19.000Z","updated":"2020-07-06T05:16:38.708Z","comments":true,"path":"passages/leetcode-zhi-huan-xing-lian-biao/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-huan-xing-lian-biao/","excerpt":"Linked List Cycle","text":"Linked List Cycle Linked List Cycle code with Python title number：141 读题 给定一个链表，判断链表中是否存在环 思路一 快慢指针 如果链表中存在环，则两指针必会相遇 12345678910111213141516def hasCycle(self, head: ListNode) -&gt; bool: if head == None: return False fast, slow = head.next, head while fast and fast.next: fast = fast.next.nxt slow = slow.next # 如果有环，则跳不出循环 if fast == slow: return True # 跳出循环则无环 return False","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之重排列表","slug":"Leetcode之重排列表","date":"2020-06-28T02:07:35.000Z","updated":"2020-07-06T05:31:55.952Z","comments":true,"path":"passages/leetcode-zhi-chong-pai-lie-biao/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-chong-pai-lie-biao/","excerpt":"Reorder List","text":"Reorder List Reorder List code with Python title number：143 读题 给定一个链表，形如： L : L0 -&gt; L1 -&gt; L2 -&gt; … -&gt; Ln-1 -&gt; Ln 将其重新排序为： L : L0 -&gt; Ln -&gt; L1 -&gt; Ln-1 -&gt; … 不能仅交换节点内部的值，需要进行实际的节点交换 思路一 实名反对所有使用栈和列表等外部结构的解法 算法分为三部分： 查找前后两部分的分割点 —— 快慢指针查找中点 反转后半部分的链表 将两部分链表进行拼接 —— 两个指针遍历两个链表 1234567891011121314151617181920212223242526272829303132333435def reorderList(self, head: ListNode) -&gt; None: # 反转链表 def reverse(head): pre, cur = None, head while cur: temp = cur.next cur.next = pre pre = cur cur = temp return cur # 快慢指针查找中间节点 fast, slow = head.next, head while fast and fast.next: fast = fast.next.next slow = slow.next # 获取后半部分的头节点，截断两部分链表 last_part, slow.next = slow.next, None last_part = reverse(last_part) # 两个指针用于遍历两个子链表 p, q = head, last_part while p and q: p_temp, q_temp = p.next, q.next # 链接 p.next = q q.next = p_temp # 指针后移 p, q = p_temp, q_temp","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之排序链表","slug":"Leetcode之排序链表","date":"2020-06-27T03:27:41.000Z","updated":"2020-07-06T05:23:40.671Z","comments":true,"path":"passages/leetcode-zhi-pai-xu-lian-biao/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-pai-xu-lian-biao/","excerpt":"Sort List","text":"Sort List Sort List code with Python title number：148 读题 在O(nlogn)的时间复杂度和常数级空间复杂度下，对链表进行排序 思路一 常见的排序算法都可以在链表上应用，只不过为了追求操作上的简便，一些方法我们一般不用，例如： 快速排序：需要使用首尾指针，对于单链表来说不容易实现 通常我们只考虑只需要比较相邻元素的排序算法 链表结构不同与顺序结构： 不支持随机访问，只能单向遍历 节点交换涉及至少三个节点（单链表），操作繁琐 这里要求常数级空间复杂度和O(nlogn)的时间复杂度，所以我们选择归并排序 归并排序采用分治法的思想，将已有序的子序列合并，得到完全有序的子序列 可以很方便的使用递归的方式实现 递归实现链表的归并排序有两个环节： 分割环节 找到链表的中点（使用快慢指针，快指针每次移动两个位置，慢指针每次移动一个位置），将链表切断 递归分割链表 合并环节 双指针法进行合并 使用辅助节点作为头部，比较两个待合并的链表中元素的大小，将合适的加到辅助节点的后面 盗张图，演示一下😜😜😜 1234567891011121314151617181920212223242526def sortList(self, head: ListNode) -&gt; ListNode: # 链表为空 or 只包含一个节点 if not head or not head.next: return head # 快慢指针查找中间位置 slow, fast = head, head.next while fast and fast.next: fast, slow = fast.next.next, slow.next mid, slow.next = slow.next, None # 递归分割 left, right = self.sortList(head), self.sortList(mid) # 双指针进行合并 h = res = ListNode(0) while left and right: # 左子链中当前节点更小 if left.val &lt; right.val: h.next, left = left, left.next else: h.next, right = right, right.next h = h.next h.next = left if left else right return res.next 思路二 这是一种比较讨巧的方法 通过一次遍历，将链表中的元素全部读取到数组中 对数组中的元素进行排序（选择符合复杂度要求的排序算法） 最后将有序数组依次写入链表节点中 123456789101112131415def sortList(self, head: ListNode) -&gt; ListNode: p = head arr = [] while p: arr.append(p.val) p = p.next arr.sort() p, i = head, 0 while p: p.val = arr[i] i += 1 p = p.next return head","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之删除排序链表中的重复元素Ⅱ","slug":"Leetcode之删除排序链表中的重复元素Ⅱ","date":"2020-06-26T06:19:07.000Z","updated":"2020-07-06T05:25:46.022Z","comments":true,"path":"passages/leetcode-zhi-shan-chu-pai-xu-lian-biao-zhong-de-chong-fu-yuan-su-ii/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-shan-chu-pai-xu-lian-biao-zhong-de-chong-fu-yuan-su-ii/","excerpt":"Remove Duplicates from Sorted List Ⅱ","text":"Remove Duplicates from Sorted List Ⅱ Remove Duplicates from Sorted List Ⅱ code with Python title number：82 读题 给定一个排序链表，删除所有含有重复数字的节点 最终链表中只保留原始链表中没有重复出现的数字 思路一 本题的特殊之处在于：删除所有重复的节点，即头结点也有可能被删除 故这里需要使用dummpy头结点 具体思路结合代码注释理解 12345678910111213141516171819def deleteDuplicates(self, head: ListNode) -&gt; ListNode: # 创建虚拟节点 dummp_node = TreeNode(0) # 添加到头结点之前 dummp_node.next = head # 将头指针指向虚拟节点 head = dummpy_node while head.next and head.next.next: # 出现连续相同的元素 if head.next.val == head.next.next.val: # 依次删除 val = head.next.val while head.next and head.next.val == val: head.next = head.next.next # 头指针向后移 else: head = head.next return dummp_node.next","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之删除排序链表中的重复元素","slug":"Leetcode之删除排序链表中的重复元素","date":"2020-06-26T06:04:00.000Z","updated":"2020-07-06T05:25:37.983Z","comments":true,"path":"passages/leetcode-zhi-shan-chu-pai-xu-lian-biao-zhong-de-chong-fu-yuan-su/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-shan-chu-pai-xu-lian-biao-zhong-de-chong-fu-yuan-su/","excerpt":"Remove Duplicates from Sorted List","text":"Remove Duplicates from Sorted List Remove Duplicates from Sorted List code with Python title number：83 读题 给定一个排序数组，删除所有重复的元素，使得每个元素只出现一次 思路一 由于是排序数组，所以相同的元素是连续的 单指针 遇到重复项就使用指针指向其下一项，以此来完成删除操作 12345678def deleteDuplicate(self, head: ListNode) -&gt; ListNode: temp = head while temp: while temp.next and temp.val == temp.next.val: temp.next = temp.next.next temp = temp.next return head","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之二叉搜索树中的插入操作","slug":"Leetcode之二叉搜索树中的插入操作","date":"2020-06-25T03:01:23.000Z","updated":"2020-07-06T05:12:57.875Z","comments":true,"path":"passages/leetcode-zhi-er-cha-sou-suo-shu-zhong-de-cha-ru-cao-zuo/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-er-cha-sou-suo-shu-zhong-de-cha-ru-cao-zuo/","excerpt":"Insert into a Binary Search Tree","text":"Insert into a Binary Search Tree Insert into a Binary Search Tree code with Python title number：701 读题 给定一棵二叉搜索树的根节点以及要插入树总的值，将值插入二叉搜索树 返回插入后二叉搜索树的根节点 思路一 二叉搜索树的新插入节点比定位叶子节点 二叉搜索树是一种递归结构，即左孩子小于根节点的值，右孩子大于根节点的值 使用递归的方式查找待插入的位置，在合适的位置穿件新节点并连接到树中即可 返回根节点 12345678910111213def insertIntoBST(self, root: TreeNode, val: int) -&gt; TreeNode: # 插入位置 if root is None: root = TreeNode(val) return root # 递归在右子树中查找插入位置 if root.val &lt; val: root.right = self.insertIntoBST(root.right, val) # 递归在左子树中查找插入位置 if root.val &gt; val: root.left = self.insertIntoBST(root.left, val) return root 思路二 还是上面的思路，使用迭代的方式进行 沿着树结构不断查找合适的插入位置，到达根节点后穿件新节点插入 单独处理树为空的情况 123456789101112131415161718def insertIntoBST(self, root: TreeNode, val: int) -&gt; TreeNode: node = root # 迭代查找插入位置，并插入 while node: if val &gt; node.val: if not node.right: node.right = TreeNode(val) return root else: node = node.right if val &lt; node.val: if not node.left: node.left = TreeNode(val) return root else: node = node.left # 处理根节点为空的情况 return TreeNode(val)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之二叉树的层序遍历Ⅱ","slug":"Leetcode之二叉树的层序遍历Ⅱ","date":"2020-06-24T08:00:48.000Z","updated":"2020-07-06T05:11:38.530Z","comments":true,"path":"passages/leetcode-zhi-er-cha-shu-de-ceng-xu-bian-li-ii/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-er-cha-shu-de-ceng-xu-bian-li-ii/","excerpt":"Binary Tree Level Order Traversal Ⅱ","text":"Binary Tree Level Order Traversal Ⅱ Binary Tree Level Order Traversal Ⅱ code with Python title number：107 读题 给定一棵二叉树，返回其节点值自底向上的层次遍历。 按叶子节点所在的层到根节点所在的层，逐层从左向右遍历 思路一 按照正常的自顶向下的方式进行层序遍历 对遍历结果的顺序进行翻转 1234567891011121314151617181920212223def levelOrderBottom(self, root: TreeNode) -&gt; List[List[int]]: if root is None: return [] queue = [root] res = [] while queue: len_ len(queue) res.append([]) for i in range(len_): node = queue.pop(0) res[-1].append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) res = res[::-1] return res 思路二 沿用上面的思路，调整添加当前层结果到结果集中的位置，省去最后翻转的过程 自顶向下进行层序遍历 每次都将当前层的遍历结果添加到结果集的头部 123456789101112131415161718192021def levelOrderBottom(self, root: TreeNode) -&gt; List[List[int]]: if root is None: return [] queue = [root] res = [] while queue: len_ len(queue) res.insert(0, []) for i in range(len_): node = queue.pop(0) res[0].append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之平衡二叉树","slug":"Leetcode之平衡二叉树","date":"2020-06-23T07:54:20.000Z","updated":"2020-07-06T05:24:07.549Z","comments":true,"path":"passages/leetcode-zhi-ping-heng-er-cha-shu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-ping-heng-er-cha-shu/","excerpt":"Balanced Binary Tree","text":"Balanced Binary Tree Balanced Binary Tree code with Python title number：110 读题 给定一棵二叉树，判断它是否为平衡二叉树 平衡二叉树的定义为： 二叉树中，每个节点的左右两棵子树的高度差的绝对值不超过1 思路一 题目的关键在于：得到每个节点的高度 关于树形结构，最省心的方法就是递归 递归判断每个节点是否为平衡点 若是，返回True和当前节点高度 若否，返回False和当前节点高度（统一格式） 123456789101112131415161718192021def isBalanced(self, root: TreeNode) -&gt; bool: def is_Bala(root): if root is None: return True, 0 bool_left, left_height = is_Bala(root.left) bool_right, right_height = is_Bala(root.right) if bool_left and bool_right: if abs(left_height - right_height) &lt;= 1: return True, max(left_height, right_height) + 1 else: return False, max(left_height, right_height) + 1 else: return False, max(left_height, right_height) + 1 bool_, height = is_Bala(root) return bool_","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Sword-offer-03-数组中的重复元素","slug":"Sword-offer-03-数组中的重复元素","date":"2020-06-22T10:35:40.000Z","updated":"2020-07-06T05:40:48.905Z","comments":true,"path":"passages/sword-offer-03-shu-zu-zhong-de-chong-fu-yuan-su/","link":"","permalink":"http://zivblog.top/passages/sword-offer-03-shu-zu-zhong-de-chong-fu-yuan-su/","excerpt":"Sword Offer","text":"Sword Offer 数组中重复的数字 code with Python title number：03 读题 在一个长度为n的数组nums里的所有数字都在[0, n-1]的范围内 数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次 请找出数组中任意一个重复的数字 思路一（常规） 使用字典保存每个元素出现的次数 如果不在字典内，则添加 如果在字典内，直接返回该元素 12345678def findRepeatNumber(self, nums: List[int]) -&gt; int: count = dict() for num in nums: if num not in count: count[num] = 1 else: return num 思路二（时间优先） 使用字典保存每个元素出现的次数 使用排序，将相同元素聚集到一起，加快遇到重复元素的速度 123456789def findRepeatNumber(self, nums: List[int]) -&gt; int: count = dict() nums.sort() for num in nums: if num not in count: count[num] = 1 else: return num 思路三（空间优先） 原地哈希 不使用额外的空间来保存字典 由于数组中元素的值域为[0, len(nums)]，所以可以利用第i个位置存储元素i，如此“ 当前元素为i，需要与第``i`个位置的元素交换 如果第i个位置的元素不为i，则执行交换 如果第i个位置的元素为i，则说明该元素重复了，直接返回 12345678910def findRepeatNumber(self, nums: List[int]) -&gt; int: n = len(nums) for i in range(n): while i != nums[i]: if nums[i] == nums[nums[i]]: return nums[i] else: temp = nums[i] nums[i], nums[temp] = nums[temp], nums[i]","categories":[{"name":"Sword Offer","slug":"Sword-Offer","permalink":"http://zivblog.top/categories/Sword-Offer/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"http://zivblog.top/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Python环境配置","slug":"Python环境配置","date":"2020-06-16T02:19:58.000Z","updated":"2020-07-11T05:36:38.272Z","comments":true,"path":"passages/python-huan-jing-pei-zhi/","link":"","permalink":"http://zivblog.top/passages/python-huan-jing-pei-zhi/","excerpt":"Python环境配置","text":"Python环境配置 Motivation 现在百度来的环境配置教程太繁琐~，且不友好，遂整理出这篇博文，希望对看到的你有所帮助 中间遇到问题或错误，欢迎交流指正 内容仅针对Window10，MaxOS可自行百度 你需要下载这些东西 Python3.x，在这里下载你顺眼的版本， 不要用最新的，推荐3.6或者3.7 下载带executable installer且x86-64字样的，省心 Pycharm 在这里下载，有两种可选 专业版，功能齐全，需要PJ 社区版，功能经过阉割，无需PJ，免费使用 社区版足够使用，如需进行网页开发，Python开发及远程连接功能，请下载专业版 PJ教程参考一份香甜的免费午餐 只需以下几步 对于下载好的Python3.x，双击 需要注意的来了（两点） 直接点击Install Now会安装到寸土寸金的C盘，所以我们选择下面的Customize installation 之后一路Next，直到： 勾选红色箭头所指的选项，其他的凭个人喜好 下面的Customize install location选择一个位置（尽量不要是C盘，最好是盘符下的根目录，该文件夹需自行创建），例如D:\\Python3.8 等待安装完成，打开cmd——组合键win+R，输入cmd 在命令行界面输入python，出现版本等信息证明安装成功，输入exit()即可退出Python环境 Pycharm 正常安装即可，没有需要注意的地方 安装之后打开（截图来自专业版，实际都大同小异） location处，取一个你喜欢的响当当的名字~，例如：’python_learn’。这个是工程的名字，即一个文件夹，下面可以有很多python文件 Project Interpreter处选择Existing interpreter，找到之前安装的python 不推荐使用虚拟环境，也就是上面的New environment，这个会创建一个基于本工程的Python环境。如果使用的话注意这个会下载python文件用于编译该工程的文件，需等待片刻才能使用 进入工程后，创建文件 输入内容并编译执行，即可得到代码执行后的内容 后续如果想要使用更多的Python包，可使用Anaconda——一款Python的集成环境，预装了很多常用工具包，使用清华源下载更快 ———— 2020.7.11 更新 推荐练习或者简单的小项目使用jupyter notebook 安装方法： 在cmd命令行中使用pip install jupyter等待安装完成即可 安装完成之后执行jupyter notebook命令即可启动该工具 如果安装的是Anaconda，会自带jupyter包，直接在命令行中执行jupyter notebook即可 在jupyter中创建文件的方式如下: 执行cell中代码的快捷键是Shift+Enter 完结，撒花🎈🎈🎈","categories":[{"name":"工具配置","slug":"工具配置","permalink":"http://zivblog.top/categories/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://zivblog.top/tags/Tools/"}]},{"title":"Leetcode之每个元音包含偶数次的最长子字符串","slug":"Leetcode之每个元音包含偶数次的最长子字符串","date":"2020-06-08T02:32:22.000Z","updated":"2020-07-06T05:23:08.001Z","comments":true,"path":"passages/leetcode-zhi-mei-ge-yuan-yin-bao-han-ou-shu-ci-de-zui-chang-zi-zi-fu-chuan/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-mei-ge-yuan-yin-bao-han-ou-shu-ci-de-zui-chang-zi-zi-fu-chuan/","excerpt":"Find the Longest Substring Containing Vowels in Even Counts","text":"Find the Longest Substring Containing Vowels in Even Counts Find the Longest Substring Containing Vowels in Even Counts code with Python title numbers：1371 读题 给定一个字符串s，返回满足下列条件的最长字符串的长度 每个出现在子串中的元音字母（a, e, i, o, u）都恰好出现了偶数次 示例： 123输入：s &#x3D; &quot;eleetminicoworoep&quot;输出：13解释：最长子字符串是 &quot;leetminicowor&quot; ，它包含 e，i，o 各 2 个，以及 0 个 a，u 思路一 暴力+剪枝 双层循环找到所有的子串，对每个子串统计元音字母的个数，如果满足条件，则更新最长字符串的长度 可以反向枚举，即从最长的子串开始枚举，这样就可以更快的接近答案 1234567891011def findTheLongestSubstring(self, s: str) -&gt; int: for i in range(len(s), 0, -1): for j in range(len(s) - i + 1): sub = s[j:j + i] has_odd_vowel = False for vowel in ['a', 'e', 'i', 'o', 'u']: if sub.count(vowel) % 2 != 0: has_odd_vowel = True break if not has_odd_vowel: return i return 0 思路二 我们知道枚举所有子串是会有很多重复统计的 简化这部分操作会使时间复杂度显著降低 对每个字母维护一个前缀和，p[i][k]表示字符串前i个字符中，第k个原因字母出现的次数 此时如果要判断子串[l:r]是否满足条件，就可以使用p[r][k]-p[l-1][k]来直接得到该子串中第k个元音字母是否满足条件 123456789101112131415161718192021222324252627282930i_mapper = &#123; \"a\": 0, \"e\": 1, \"i\": 2, \"o\": 3, \"u\": 4&#125;def check(self, s, pre, l, r): for i in range(5): if s[l] in self.i_mapper and i == self.i_mapper[s[l]]: cnt = 1 else: cnt = 0 if (pre[r][i] - pre[l][i] + cnt) % 2 != 0: return False return Truedef findTheLongestSubstring(self, s: str) -&gt; int: n = len(s) pre = [[0] * 5 for _ in range(n)] # pre for i in range(n): for j in range(5): if s[i] in self.i_mapper and self.i_mapper[s[i]] == j: pre[i][j] = pre[i - 1][j] + 1 else: pre[i][j] = pre[i - 1][j] for i in range(n - 1, -1, -1): for j in range(n - i): if self.check(s, pre, j, i + j): return i + 1 return 0","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之阈值距离内邻居最少的城市","slug":"Leetcode之阈值距离内邻居最少的城市","date":"2020-06-07T02:30:47.000Z","updated":"2020-07-06T05:30:43.247Z","comments":true,"path":"passages/leetcode-zhi-yu-zhi-ju-chi-nei-lin-ju-zui-shao-de-cheng-shi/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-yu-zhi-ju-chi-nei-lin-ju-zui-shao-de-cheng-shi/","excerpt":"Find the City With the Smallest Number of Neighbors at a Threshold Distance","text":"Find the City With the Smallest Number of Neighbors at a Threshold Distance Find the City With the Smallest Number of Neighbors at a Threshold Distance code with Python title number：1334 读题 有n个城市，按0到n-1编号 给你一个边数组edges，其中edges[i]=[from_i, to_i, weight_i]，代表的是从from_i到to_i两个城市之间的双向加权边 距离阈值是一个整数distanceThreshold 返回能通过某些路径到达其他城市数目最多，且路径距离最大为distanceThreshold的城市 如果有多个这样的城市，则返回编号最大的 示例： 在上图中，设距离阈值为4 每个城市阈值距离范围内的邻居城市如下 城市0：城市1，城市2 城市1：城市0，城市2，城市3 城市2：城市0，城市1，城市3 城市3：城市1，城市2 返回3（编号最大，邻居最少） 思路一 问题的本质是查找两个城市之间的最短路径 对于多源最短路径，我们使用Floyd-Warshall算法 得到各个城市之间的最短路径 对每个城市筛选距离不大于阈值的邻居城市 最后统计每个城市满足条件的城市 返回邻居城市最少且编号最大的城市 123456789101112131415161718192021222324252627def findTheCity(self, n: int, edges: List[List[int]], distanceThreshold: int) -&gt; int: # distance矩阵，二维矩阵 dist = [[float('inf')] * n for _ in range(n)] # 初始化 for i, j, w in edges: dist[i][j] = w dist[j][i] = w for i in range(n): dist[i][i] = 0 # 求最短 for k in range(n): for i in range(n): for j in range(n): dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j]) # 过滤 res = 0 minCnt = float('inf') for i in range(n): cnt = 0 for d in dist[i]: if d &lt;= distanceThreshold: cnt += 1 if cnt &lt;= minCnt: minCnt = cnt res = i return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之子数组异或查询","slug":"Leetcode之子数组异或查询","date":"2020-06-06T11:09:13.000Z","updated":"2020-07-06T05:32:34.641Z","comments":true,"path":"passages/leetcode-zhi-zi-shu-zu-yi-huo-cha-xun/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zi-shu-zu-yi-huo-cha-xun/","excerpt":"XOR Queries of a Subarray","text":"XOR Queries of a Subarray XOR Queries of a Subarray code with Python title number：1310 读题 有一个正整数数组arr，现给定一个对应的查询数组queries，其中queries[i]= $[L_i, R_i]$ 对于每个查询i，请计算从Li到Ri的XOR值（即arr[i] xor arr[Li+1] xor .. xor arr[Ri]​）作为本次查询的结果 并返回一个包含给定查询queries所有结果的数组 示例： 12345678910111213输入：arr &#x3D; [1,3,4,8], queries &#x3D; [[0,1],[1,2],[0,3],[3,3]]输出：[2,7,14,8] 解释：数组中元素的二进制表示形式是：1 &#x3D; 0001 3 &#x3D; 0011 4 &#x3D; 0100 8 &#x3D; 1000 查询的 XOR 值为：[0,1] &#x3D; 1 xor 3 &#x3D; 2 [1,2] &#x3D; 3 xor 4 &#x3D; 7 [0,3] &#x3D; 1 xor 3 xor 4 xor 8 &#x3D; 14 [3,3] &#x3D; 8 思路一 直接线上暴力解法 双层循环 12345678910def xorQueries(self, arr: List[int], queriesL List[List[int]]) -&gt; List[int]: res = [] for (L, R) in queries: i = L xor = 0 while i &lt; R: xor ^= arr[i] i += 1 res.append(xor) return res 毫无悬念的超时了 思路二 前缀表达式 我们使用一个数组pre来表示数组arr的前缀异或和 12pre[0] &#x3D; 0pre[i] &#x3D; arr[0] ^ arr[1] ... ^ arr[i-1] 这样以来，我们要计算arr[Li]到arr[Ri]的异或值时，我们可以通过 12345pre[Li] ^ pre[Ri+1] &#x3D; (arr[0] ^ ... ^ arr[Li-1])^(arr[0] ^ ... ^ arr[Ri])&#x3D; (arr[0] ^ ... ^ arr[Li - 1]) ^ (arr[0] ^ ... ^ arr[Li - 1]) ^ (arr[Li] ^ ... ^ arr[Ri]) （异或运算的结合律）&#x3D; 0 ^ (arr[Li] ^ ... ^ arr[Ri]) （异或运算的逆运算，即 a ^ a &#x3D; 0）&#x3D; arr[Li] ^ ... ^ arr[Ri] 总的来说，需要知道异或运算的一个规律，即x ^ y ^ x = y 123456789def xorQueries(self, arr: List[int], queriesL List[List[int]]) -&gt; List[int]: pre = [0] res = [] for i in range(len(arr)): pre.append(pre[i] ^ arr[i]) for (L, R) in queries: res.append(pre[L] ^ pre[R + 1]) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之子串出现的最大次数","slug":"Leetcode之子串出现的最大次数","date":"2020-06-05T01:44:16.000Z","updated":"2020-07-06T05:32:15.313Z","comments":true,"path":"passages/leetcode-zhi-zi-chuan-chu-xian-de-zui-da-ci-shu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zi-chuan-chu-xian-de-zui-da-ci-shu/","excerpt":"Maximum Number of Occurrences of a Substring","text":"Maximum Number of Occurrences of a Substring Maximum Number of Occurrences of a Substring code with Python title number：1297 读题 给定一个字符串S，返回满足下列条件且出现次数最大的任意子串的出现次数： 子串中不同字母的数目必须小于等于maxLetters 子串的长度必须大于等于minSize且小于等于maxSize 示例： 1234输入：s &#x3D; &quot;aababcaab&quot;, maxLetters &#x3D; 2, minSize &#x3D; 3, maxSize &#x3D; 4输出：2解释：子串 &quot;aab&quot; 在原字符串中出现了 2 次。它满足所有的要求：2 个不同的字母，长度为 3 （在 minSize 和 maxSize 范围内）。 思路一 尝试暴力解法： 找出所有满足长度要求（[minSize, maxSize]）的子串 对于maxLetter满足题意的子串，统计其出现次数 返回最大的出现次数 1234567891011121314151617181920def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -&gt; int: n = len(s) letters = set() cnts = dict() res = 0 for i in range(n - minSize + 1): length = minSize while i + length &lt;= n and length &lt;= maxSize: t = s[i:i+length] for c in t: if len(letters) &gt; maxLetters: break letters.add(c) if len(letters) &lt;= maxLetters: cnts[t] = cnts.get(t, 0) + 1 res = max(res, cnts[t]) letters.clear() length += 1 return res 代码超时 思路二 我们尝试在上述思路的基础上进行优化 从题目要求中可以分析出——maxSize属于无用信息，不需要考虑，而是只需要统计长度等于minSize的子串即可 原因是，如果一个长度大于minSize的子串满足条件，那么该子串其中必定至少一个长度为minSize的子串满足条件 所以如果一个长度大于minSize的子串出现了n次，必定有一个长度为minSize的子串出现了n次 于是题目转化为了一个滑动窗口的问题，我们只需要通过滑动窗口来判断所有长度为minSize的子串中有多少满足条件即可 123456789def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -&gt; int: counter, res = &#123;&#125;, 0 for i in range(0, len(s) - minSize + 1): sub = s[i: i + minSize] if len(set(sub)) &lt;= maxLetters: counter[sub] = counter.get(sub, 0) + 1 res = max(res, counter[sub]) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之可被三整除的最大和","slug":"Leetcode之可被三整除的最大和","date":"2020-06-04T08:39:33.000Z","updated":"2020-07-06T05:19:58.318Z","comments":true,"path":"passages/leetcode-zhi-ke-bei-san-zheng-chu-de-zui-da-he/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-ke-bei-san-zheng-chu-de-zui-da-he/","excerpt":"Greatest Sum Divisible by Three","text":"Greatest Sum Divisible by Three Greatest Sum Divisible by Three code with Python title number：1262 读题 给定一个数组，找出并返回可被三整除的元素最大和 示例： 123输入：nums &#x3D; [3,6,5,1,8]输出：18解释：选出数字 3, 6, 1 和 8，它们的和是 18（可被 3 整除的最大和） 思路一 比较暴力的想法是穷举所有可能的组合，然后判断是否可被三整除 由于nums的长度为[1, 4*10^4]，这种方法必定会超时 思路二 排序+减法 我们首先计算出所有元素的总和并判断是否能被三整除 如果能整除，即余数为0，则直接返回结果 如果不能整除，可能的情况有两种：余数为1或余数为2 针对这两种情况，我们分别建立数组one和two，数组内元素被排序 两个数组分别存储余数为1和余数为2的元素 如果余数为1，我们减去one数组中最小的元素，或者减去two数组中最小的两个元素。取决于两者谁更小 如果余数为1，我们减去two数组中最小的元素，或者减去one数组中最小的两个元素。取决于两者谁更小 1234567891011121314151617181920212223def maxSumDivThree(self, nums: List[int]) -&gt; int: one, two = [], [] total = 0 for num in nums: total += num if num % 3 == 1: one.append(num) if num % 3 == 2: two.append(num) one.sort(), two.sort() if total % 3 == 0: return total elif total %3 == 1 and one: if len(two) &gt;= 2 and one[0] &gt; two[0]+two[1]: return total - two[0] - two[1] return total - one[0] elif total % 3 == 2 and two: if len(one) &gt;= 2 and two[0] &gt; one[0]+one[1]: return total - one[0] - one[1] return total - two[0] return 0 思路二 我们发现上述的算法中，我们只用到了one数组和two数组中最小的两个数 所以我们只需要使用4个存储空间来存储两个数组即可 1234567891011121314151617181920212223242526272829303132def maxSumDivThree(self, nums: List[int]) -&gt; int: one, two = [float('inf')]*2, [float('inf')]*2 total = 0 for num in nums: total += num if num % 3 == 1: if num &lt; one[0]: t = one[0] one[0] = num one[1] = t elif num &lt; one[1]: one[1] = num if num % 3 == 2: if num &lt; two[0]: t = two[0] two[0] = num two[1] = t elif num &lt; two[1]: two[1] = num if total % 3 == 0: return total elif total %3 == 1 and one: if len(two) &gt;= 2 and one[0] &gt; two[0]+two[1]: return total - two[0] - two[1] return total - one[0] elif total % 3 == 2 and two: if len(one) &gt;= 2 and two[0] &gt; one[0]+one[1]: return total - one[0] - one[1] return total - two[0] return 0","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之在受污染的二叉树中查找元素","slug":"Leetcode之在受污染的二叉树中查找元素","date":"2020-06-03T01:05:49.000Z","updated":"2020-07-06T05:30:58.527Z","comments":true,"path":"passages/leetcode-zhi-zai-shou-wu-ran-de-er-cha-shu-zhong-cha-zhao-yuan-su/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zai-shou-wu-ran-de-er-cha-shu-zhong-cha-zhao-yuan-su/","excerpt":"Find Elements in a Contaminated Binary Tree","text":"Find Elements in a Contaminated Binary Tree Find Elements in a Contaminated Binary Tree code with Python title number：1261 读题 给定一个满足下述规则的二叉树 root.val == 0 如果treeNode.val == x且treeNode.left != null，那么treeNode.left.val == 2*x + 1 如果treeNode.val == x且treeNode.right != null，那么treeNode.right.val == 2*x +2 现在，二叉树受到了污染，所有的treeNode.val都变成了-1 需要先还原二叉树，然后实现FindElements类 FindElements(TreeNode* root)用受污染的二叉树初始化对象，需要先将其还原 bool find(int target)判断目标值target是否存在于还原后的二叉树中并返回结果 思路一 根据题目描述，我们可以递归的由根结点得到所有结点的值，这样，就可以通过一次遍历，还原所有的结点的值 所以，比较朴素的想法就是全上递归 递归建树 递归查找 123456789101112131415161718192021222324class FindElements: def __init__(self, root: TreeNode): node = None def recover(node): if not node: return node if node.left: node.left.val = 2 * node.val + 1 if node.right: node.right.val = 2 * node.val + 2 recover(node.left) recoder(node.right) return node root.val = 0 self.node = recover(root) def find(self, target: int) -&gt; bool: def findTree(node, target): if not node: return False if node.val == target: return True return findTree(node.left, target) or findTree(node.right, target) return findTree(self.node, target) 不出意外的超时了😂😂😂 思路二 延续上一题的思路，使用空间换时间 123456789101112131415161718192021class FindElements: def __init__(self, root: TreeNode): self.seen = set() def recover(node): if not node: return node if node.left: node.left.val = 2 * node.val + 1 self.seen.add(node.left.val) if node.right: node.right.val = 2 * node.val + 2 self.seen.add(node.right.val) recover(node.left) recover(node.right) return node root.val = 0 self.seen.add(0) self.node = recover(root) def find(self, target: int) -&gt; bool: return target in self.seen","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之飞机座位分配概率","slug":"Leetcode之飞机座位分配概率","date":"2020-06-02T02:24:38.000Z","updated":"2020-07-06T05:15:31.998Z","comments":true,"path":"passages/leetcode-zhi-fei-ji-zuo-wei-fen-pei-gai-lu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-fei-ji-zuo-wei-fen-pei-gai-lu/","excerpt":"Airplane Seat Assignment Probability","text":"Airplane Seat Assignment Probability Airplane Seat Assignment Probability code with Python title number：1227 读题 有n位乘客即将登机，飞机正好有n个作为，第一位乘客的票丢了，它随便选了一个作为坐下 剩下的乘客将会 如果他们的座位还空着，就做到自己的座位上 如果它们的座位被占用时，随机选择其他座位 第n位乘客坐在自己作为上的概率是多少 思路一 按照题意，暴力递归 原问题定义为f(n)，对于第一个人来说，有n种选择，选择每个位置的概率都是$\\frac{1}{n}$ 如果第一个人选择了自己的位置，则剩下的人只需按自己票上的座位坐好即可，即最后一个人必会坐到自己的座位上 如果第一个人选择了最后一个人的位置，则最后一个人必不能坐到自己的位置上 如果第一个人选择了第i个位置（ 1 &lt; i &lt; n），那么第i个人就成为了新的“丢票的人”，问题转化为f(n-i+1) 123456789def nthPersonGetNthSeat(self, n: int) -&gt; float: if n == 1: return 1 if n == 2: return 0.5 res = 1 / n for i in range(2, n): res += self.nthPersonGetNthSeat(n-i+1) * 1 / n return res 栈溢出 思路二 数学思想 首先，将上述的递归表达式写出来 1234f(n) &#x3D; 1&#x2F;n + 0 + 1&#x2F;n*(f(n-1)+f(n-2)...f(2))&#x3D; 1&#x2F;n * (f(n-1)+f(n-2)...f(2)+1)&#x3D; 1&#x2F;n * (f(n-1)+f(n-2)...f(2)+f(1)) 下面对其进行化简 首先，写出f(n-1) 1f(n-1) &#x3D; 1&#x2F;(n-1) * (f(n-2)+f(n-3)...f(1)) 将上述两式两遍分别乘以n和n-1，即消除右侧分母 12n * f(n) &#x3D; f(n-1) + f(n-2) + ... + f(1)(n-1) * f(n-1) &#x3D; f(n-2) + f(n-3) + ... + f(1) 将两者相减 1n*f(n) - (n-1)*f(n-1) &#x3D; f(n-1) 将(n-1)*f(n-1)移到右边 1n * f(n) &#x3D; n * f(n-1) 即f(n) == f(n-1)（n &gt; 2） 这是一个重要的结论，以此，我们可以得到 12345f(1) &#x3D; 1f(2) &#x3D; 0.5f(3) &#x3D; f(2) &#x3D; 0.5...f(n) &#x3D; f(n-1) &#x3D; 0.5 12def nthPersonGetNthSeat(self, n: int) -&gt; float: return 1 if n == 1 else 0.5","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之最长定差子序列","slug":"Leetcode之最长定差子序列","date":"2020-06-01T05:41:55.000Z","updated":"2020-07-06T05:34:41.794Z","comments":true,"path":"passages/leetcode-zhi-zui-chang-ding-chai-zi-xu-lie/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zui-chang-ding-chai-zi-xu-lie/","excerpt":"Longest Arithmetic SubSequence of Fiven Difference","text":"Longest Arithmetic SubSequence of Fiven Difference Longest Arithmetic SubSequence of Fiven Difference code with Python title number：1218 读题 给定一个整数数组arr和一个整数difference，请你找出arr中所有相邻元素之间等于给定difference的等差子序列，并返回其中最长的等差子序列的长度 示例 123输入：arr &#x3D; [1, 2, 3, 4], difference &#x3D; 1输出：4解释：最长的等差子序列是 [1, 2, 3, 4] 思路一 最直观的思路就是使用双循环，我们暴力枚举出以每一个元素为开始元素，以最后元素结尾的所有情况 1234567891011def longestSubsequence(self, arr: List[int], difference: int) -&gt; int: n = len(arr) res = 1 for in range(n): count = 1 for j in range(i+1, n): if arr[i] + difference * count == arr[j]: count += 1 if count &gt; res: res = count return res 超时，时间复杂度为$O(n^2)$ 思路二 动态规划 将每一个元素结尾的最长等差子序列的长度保存起来，这样在遍历新的元素的时候，只需从之前的存储中找是否有符合的，如果有，则更新当前的值，否则就不进行操作 具体而言 使用dp[num]中每个位置记录以当前元素为结尾的最长等差子序列的长度 当遍历到一个新的元素的时候，就去之前的存储中找dp[num-difference] 如果找到了，则更新当前值为dp[num] = dp[num-difference]+1； 否则，更新当前值为dp[num] = 1 12345678910def longestSubsequence(self, arr: List[int], difference: int) -&gt; int: n = len(arr) res = 1 dp = &#123;&#125; for num in arr: dp[num] = 1 if num - difference in dp: dp[num] = dp[num - difference] + 1 return max(dp.values())","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之删除一次得到子数组最大和","slug":"Leetcode之删除一次得到子数组最大和","date":"2020-05-31T02:37:33.000Z","updated":"2020-07-06T05:26:09.662Z","comments":true,"path":"passages/leetcode-zhi-shan-chu-yi-ci-de-dao-zi-shu-zu-zui-da-he/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-shan-chu-yi-ci-de-dao-zi-shu-zu-zui-da-he/","excerpt":"Maximum Subarray Sum with One Deletion","text":"Maximum Subarray Sum with One Deletion Maximum Subarray Sum with One Deletion code with Python title number：1186 读题 给定一个整数数组，返回其某个非空子数组（连续元素）在执行一次可选的删除操作后，所能得到的最大元素总和 换句话说，你可以从原数组中选出一个子数组，并可以决定要不要从中删除一个元素，（删除后）子数组中至少应当有一个元素，然后该子数组（剩下）的元素总和是所有子数组中最大的 示例 1234567输入：arr &#x3D; [1, -2, 0, 3]输出：4解释：我们可以选择[1, -2, 0, 3]，然后删掉-2，这样得到的[1, 0, 3]和最大输入：arr &#x3D; [-1, -1, -1, -1]输出：-1解释：最后得到的子数组不能为空，所以可以选择[-1, -1]删掉其中一个；或者选择[-1],不删除任何元素 思路一 暴力的做法是 计算所有可能的情况，取出最大的即可 使用双层循环，外循环用于确定我们丢弃的元素，内循环用于计算 12345678910111213141516def maximumSum(self, arr: List[int]) -&gt; int: res = arr[0] def maxSubSum(arr, skip): res = maxSub = float(\"-inf\") for i in range(len(arr)): if i == skip: continue maxSub = max(arr[i], maxSub+arr[i]) res = max(res, maxSub) return res for i in range(len(arr)+1): res = max(res, maxSubSum(arr, i)) return res 超时 思路一 基于上述方法会超时，我们考虑能否用空间换时间 从头尾分别遍历，建立两个子数组集合L, R 第一次从左向右遍历，建立数组L，L[i]表示从左向右以arr[i]结尾的子数组的最大值 第二次从右向左遍历，建立数组R，R[i]表示从右向左以arr[i]结尾的子数组的最大值 第三次遍历，计算L[i-1]+R[i+1]的最大值 这样，我们就可以在空间扩大一倍的情况下，将时间由O(n^2)降低到了O(n) 1234567891011121314151617181920def maximumSum(self, arr: List[int]) -&gt; int: n = len(arr) L = [arr[0]] * n R = [arr[n - 1]] * n if n == 1: return arr[0] res = arr[0] for i in range(1, n): L[i] = max(L[i-1] + arr[i], arr[i]) res = max(res, L[i]) for i in range(n-2, -1, -1): R[i] = max(R[i+1]+arr[i], arr[i]) res = max(res, R[i]) for i in range(1, n-1): res = max(res, L[i-1]+R[i+1]) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之绝对值表达式的最大值","slug":"Leetcode之绝对值表达式的最大值","date":"2020-05-30T02:39:50.000Z","updated":"2020-07-06T05:19:19.850Z","comments":true,"path":"passages/leetcode-zhi-jue-dui-zhi-biao-da-shi-de-zui-da-zhi/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-jue-dui-zhi-biao-da-shi-de-zui-da-zhi/","excerpt":"Maximum of Absolute Value Expression","text":"Maximum of Absolute Value Expression Maximum of Absolute Value Expression code with Python title number：1131 读题 给定两个长度相等的整数数组，返回下面表达式的最大值： |arr1[i] - arr1[j]| + |arr2[i] - arr2[j]| + |i - j| 其中i, j，满足0 &lt;= i, j &lt; arr1.length 示例： 1234输入：arr1 &#x3D; [1, 2, 3, 4], arr2 &#x3D; [-1, 3, 5, 6]输出：13解释：|1 - 4| + |-1 - 6| + |1 - 4| &#x3D; 13 思路一 数学分析，即去绝对值运算 表达式分为三部分，每一个部分绝对值内的计算结果会有两种情况（大于等于0 or小于0），故共有2 * 2 * 2 = 8种情况 我们尝试去掉绝对值，可以得到八个可能的表达式 arr1[i]-arr1[j]+arr2[i]-arr2[j]+i-j arr1[i]-arr1[j]-(arr2[i]-arr2[j])+i-j -(arr1[i]-arr1[j])+arr2[i]-arr2[j]+i-j -(arr1[i]-arr1[j])-(arr2[i]-arr2[j])+i-j arr1[i]-arr1[j]+arr2[i]-arr2[j]-(i-j) arr1[i]-arr1[j]-(arr2[i]-arr2[j])-(i-j) -(arr1[i]-arr1[j])+arr2[i]-arr2[j]-(i-j) -(arr1[i]-arr1[j])-(arr2[i]-arr2[j])-(i-j) 由于i, j之间没有大小关系，所以上述表达式可以缩减为4个 arr1[i]-arr1[j]+arr2[i]-arr2[j]+i-j arr1[i]-arr1[j]-(arr2[i]-arr2[j])+i-j -(arr1[i]-arr1[j])+arr2[i]-arr2[j]+i-j -(arr1[i]-arr1[j])-(arr2[i]-arr2[j])+i-j 我们只需计算上述四个表达式的最大值即可 再次进行变换，我们分别将与i, j相关的聚合到一起 arr1[i] + arr2[i] + i - (arr1[j] + arr2[j] + j) arr1[i] - arr2[i] + i - (arr1[j] - arr2[j] + j) arr2[i] - arr1[i] + i - (arr2[j] - arr1[j] + j) -arr2[i] - arr1[i] + i - (-arr1[j] - arr2[j] + j) 观察上式，可以发现，表达式的最大值即左半部分的最大值和右半部分的最小值之差 并且，由于i, j之间可以互换，前半部分和后半部分是等价的 故 遍历一遍数组，计算四个表达式的最大值和最小值 ``arr1[i] + arr2[i] + i` arr1[i] - arr2[i] + i arr2[i] - arr1[i] + i -arr2[i] - arr1[i] + i 分别取出四个表达式的最大值和最小值的差值 比较得到四个表达式中最大的差值即可 1234567891011121314def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -&gt; int: A, B, C, D = [], [], [], [] for i in range(len(arr1)): a = arr1[i] + arr2[i] + i b = arr1[i] - arr2[i] + i c = arr2[i] - arr1[i] + i d = -1 * arr2[i] - arr1[i] + i A.append(a) B.append(b) C.append(c) D.append(d) return max(max(A)-min(A), max(B)-min(B), max(C)-min(C), max(D)-min(D))","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之二叉树寻路","slug":"Leetcode之二叉树寻路","date":"2020-05-29T04:53:16.000Z","updated":"2020-07-06T05:12:46.206Z","comments":true,"path":"passages/leetcode-zhi-er-cha-shu-xun-lu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-er-cha-shu-xun-lu/","excerpt":"Path In Zigzag Labelled Binary Tree","text":"Path In Zigzag Labelled Binary Tree Path In Zigzag Labelled Binary Tree code with Python title number：1104 读题 在一棵无限的二叉树上，每个结点都有两个子节点，树中的结点逐行“之”字型进行标记 在奇数行从左向右标记 在偶数行按从右到左标记 给出树上的某个结点的标号label，返回从根节点到该标号为label的路径。路径由途径的结点标号组成 示例： 12输入：label &#x3D; 14输出：[1, 3, 4, 14] 思路一 随便说句：如果这道题是按层次遍历（一个方向）来标记，那么可以直接由子节点推算出父节点的标记 通过观察我们发现一个规律： 以上图最后一层为例： 12按“之”字形排列：15, 14, 13, 12, 11, 10, 9, 8按常规层次遍历： 8, 9, 10, 11, 12, 13,14,15 可以观察到，”之“字型排列和常规排列之和为一常数，并且等于该行的最大最小值之和 因此，问题转化为求每行行对应的常数，然后用其减去当前值就能得到标记的值 当前值可以通过二叉树子节点和父节点的关系得到 更进一步，由于满二叉树的性质：每一行的最小值为2^(level-1)，最大值为2^level - 1 那么，问题更简化为求每一行的level（直接用一个变量记录即可） 1234567891011121314def pathInZigZagTree(self, label: int) -&gt; List[int]: level = 0 res = [] while 2** level - 1 &lt; label: level += 1 while level &gt; 0: res.insert(0, label) label = 2 ** (level-1) + 2 ** level -1 - label label //= 2 level -= 1 return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之两个非重叠子数组的最大和","slug":"Leetcode之两个非重叠子数组的最大和","date":"2020-05-28T02:07:44.000Z","updated":"2020-07-06T05:20:20.194Z","comments":true,"path":"passages/leetcode-zhi-liang-ge-fei-chong-die-zi-shu-zu-de-zui-da-he/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-liang-ge-fei-chong-die-zi-shu-zu-de-zui-da-he/","excerpt":"Maximum Sum of Two Non-Overlapping Subarrays","text":"Maximum Sum of Two Non-Overlapping Subarrays Maximum Sum of Two Non-Overlapping Subarrays code with Python title number：1031 读题 给出非负整数数组A，返回两个非重叠（连续）子数组中元素的最大和，子数组的长度分别为L和M 长为L的子数组可以出现在长为M的子数组之前或之后 从形式上看，返回最大的V，V = (A[i] + A[i+1] + ... + A[i+L-1]) + (A[j] + A[j+1] + ... + A[j+M-1]) 示例： 123输入: [0, 6, 5, 2, 2, 5, 1, 9, 4], L &#x3D; 1, M &#x3D; 2输出: 20解释: 长度为1的子数组为[9]，长度为2的子数组为[6, 5] 思路一 一个简单的想法是穷举所有符合长度为L的子数组，再对剩余的数组元素列举所有长度为M的子数组，返回最大值即可 时间复杂度太高，必会超时 这里尝试用动态规划进行求解 根据题意，数组必定会被分为两部分（左边包含长为L的子数组，右边包含长为M的子数组，或者反过来） 这样就有四种状态，我们分别使用一次动态规划来得到相应的结果 dp[i][0]：从A[0]~A[i]中长为L的最大连续子数组 dp[i][1]：从A[0]~A[i]中长为M的最大连续子数组 dp[i][2]：从A[i+1]~A[len(A)-1]中长为L的最大连续子数组 dp[i][3]：从A[i+1]~A[len(A)-1]中长为M的最大连续子数组 这里使用滑动窗口分别对每个动态规划任务进行计算 最终，取其中的最大组合即可（dp[i][0]+dp[i][2]或dp[i][1]+dp[i][3]） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -&gt; int: dp = [[0, 0, 0, 0] for _ in range(len(A))] # L在左边 presum = 0 for i in range(L): presum += A[i] maxsum = presum dp[L-1][0] = maxsum # 华东窗口 for i in range(L, len(A)): presum -= A[i-L] presum += A[i] maxsum = max(maxsum, presum) dp[i][0] = maxsum # M在左边 presum = 0 for i in range(M): presum += A[i] maxsum = presum dp[M-1][1] = maxsum for i in range(M, len(A)): presum -= A[i-M] presum += A[i] maxsum = max(maxsum, presum) dp[i][1] = maxsum # L在右边 presum = 0 for i in range(len(A)-1, len(A)-L-1, -1): presum += A[i] maxsum = presum dp[len(A)-L][2] = maxsum for i in range(len(A)-L-1, -1, -1): presum -= A[i+L] presum += A[i] maxsum = max(maxsum, presum) dp[i][2] = maxsum # M在右边 presum = 0 for i in range(len(A)-1, len(A)-M-1, -1): presum += A[i] maxsum = presum dp[len(A)-M][3] = maxsum for i in range(len(A)-M-1, -1, -1): presum -= A[i+M] presum += A[i] maxsum = max(maxsum, presum) dp[i][3] = maxsum res = 0 # 取最大组合 for i in range(L, len(A)-M+1): res = max(res, dp[i-1][0] + dp[i][3]) for i in range(M, len(A)-L+1): res = max(res, dp[i-1][1] + dp[i][2]) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之驼峰式匹配","slug":"Leetcode之驼峰式匹配","date":"2020-05-27T01:37:01.000Z","updated":"2020-07-06T05:28:29.630Z","comments":true,"path":"passages/leetcode-zhi-tuo-feng-shi-pi-pei/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-tuo-feng-shi-pi-pei/","excerpt":"Camelcase Matching","text":"Camelcase Matching Camelcase Matching code with Python title number：1023 读题 如果可以将小写字母插入模式串pattern中得到带查询项query，则称待查询项与给定模式串匹配 给定待查询列表queries和模式串pattern，返回由布尔值组成的答案列表。 answer[i]=True表示匹配成功，否则为匹配失败 示例： 123456输入：queries &#x3D; [&quot;FooBar&quot;,&quot;FooBarTest&quot;,&quot;FootBall&quot;,&quot;FrameBuffer&quot;,&quot;ForceFeedBack&quot;], pattern &#x3D; &quot;FB&quot;输出：[true,false,true,true,false]解释：&quot;FooBar&quot; 可以这样生成：&quot;F&quot; + &quot;oo&quot; + &quot;B&quot; + &quot;ar&quot;。&quot;FootBall&quot; 可以这样生成：&quot;F&quot; + &quot;oot&quot; + &quot;B&quot; + &quot;all&quot;.&quot;FrameBuffer&quot; 可以这样生成：&quot;F&quot; + &quot;rame&quot; + &quot;B&quot; + &quot;uffer&quot;. 需要注意的是最后一个，由于只能插入小写字母，所以无法通过在FB上插入字母得到ForceFeedBack 思路一 双指针 我们将两个指针i, j分别指向模式串和待查询串的第一个字母 当指针指向的两个字母相同时，同时将两个指针向后移动一个位置 当指针指向的两个字母不相同时，移动指向查询串的j 直到j超出了查询串的范围，此时判断模式串是否遍历完毕（True） 当模式串提前遍历完时可提前退出 123456789101112131415161718192021def camelMatch(self, queries: List[str], pattern: str) -&gt; List[bool]: def isValid(pattern, query): i, j = 0, 0 while j &lt; len(query): if i &lt; len(pattern) and pattern[i] == query[j]: i += 1 j += 1 else: if query[j] &gt;='a' and query[j] &lt;= 'z': j += 1 else: return False return i == len(pattern) ans = [] for query in queries: ans.append(isValid(pattern, query)) return ans","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之飞地的数量","slug":"Leetcode之飞地的数量","date":"2020-05-26T02:24:16.000Z","updated":"2020-07-06T05:14:07.209Z","comments":true,"path":"passages/leetcode-zhi-fei-di-de-shu-liang/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-fei-di-de-shu-liang/","excerpt":"Number of Enclaves","text":"Number of Enclaves Number of Enclaves code with Python title number：1020 读题 给定一个二维数组，每个单元格为0（海）或1（陆地） 移动是指在陆地上从一个地方走到另一个地方（四个方向）或者离开网格的边界 返回网格中无法在任意次数的移动中离开网络边界的陆地单元格的数量 示例： 1234567[[0, 0, 0, 0], [1, 0, 1, 0], [0, 1, 1, 0], [0, 0, 0, 0]]输出：3解释： 有三个1被0包围，另外在边界上的1并没有被包围 思路一 典型的连通区域问题，可以使用DFS进行解决 具体而言： 遍历整个矩阵 如果遍历到0，不予理会 如果遍历到1，将其加到temp 不断拓展边界（上下左右四个方向） 在深度优先搜索的过程中碰到了边界，则证明可以逃脱，将累计的temp清空 如果深度优先搜索后无法到达边界，则证明无法逃脱，将temp加到cnt中 最终返回cnt即可 123456789101112131415161718192021222324252627282930313233343536class Solution: def __init__(self): self.temp = 0 self.meetEdge = False def numEnclaves(self, A: List[List[int]]) -&gt; int: cnt = 0 m, n = len(A), len(A[0]) visited =set() def dfs(i, j): # 到达边界或已访问过 if i &lt; 0 or i &gt;= m or j &lt; 0 or j &gt;= n or (i, j) in visited: return visited.add((i, j)) if A[i][j] == 1: self.temp += 1 else: return if i == 0 or i == m-1 or j == 0 or j == n-1: self.meetEdge = True dfs(i + 1, j) dfs(i - 1, j) dfs(i, j - 1) dfs(i, j + 1) for i in range(m): for j in range(n): dfs(i, j) if not self.meetEdge: cnt += self.temp # 重置 self.meetEdge = False self.temp = 0 return cnt 思路二 消除法，对上面方法的优化 具体而言 从矩阵边界开始进行深度优先搜索（搜索到的只能是非飞地） 如果碰到1就将其变为0 如果遇到0则跳过 最后遍历整个矩阵，统计剩下的1的个数即可 1234567891011121314151617181920212223242526272829def numEnclaves(self, A: List[List[int]]) -&gt; int: cnt = 0 m, n = len(A), len(A[0]) def dfs(i, j): if i &lt; 0 or i &gt;= m or j &lt; 0 or j &gt;= n or A[i][j] == 0: return A[i][j] = 0 dfs(i + 1, j) dfs(i - 1, j) dfs(i, j + 1) dfs(i, j - 1) # 从边界开始进行dfs for i in range(m): dfs(i, 0) dfs(i, n - 1) for j in range(n): dfs(0, j) dfs(m - 1, j) # 统计最终数组中1的个数 for i in range(m): for j in range(n): if A[i][j] == 1: cnt += 1 return cnt","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之链表中的下一个更大节点","slug":"Leetcode之链表中的下一个更大节点","date":"2020-05-25T00:43:36.000Z","updated":"2020-07-06T05:20:12.635Z","comments":true,"path":"passages/leetcode-zhi-lian-biao-zhong-de-xia-yi-ge-geng-da-jie-dian/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-lian-biao-zhong-de-xia-yi-ge-geng-da-jie-dian/","excerpt":"Next Greater Node In Linked List","text":"Next Greater Node In Linked List Next Greater Node In Linked List code with Python title number：1019 读题 给出一个以头结点head为第一个节点的链表。链表中的节点编号依次为node_1, node_2, node_3, ... 每个节点都可能有下一个更大值： 对于node_i，如果其next_latger(node_i)是node_j.val，则j &gt; i且node_j.val &gt; node_i.val，而且j是可能的选项中最小的那个。 若j不存在，则next_larger(node_i)返回0 返回整个数组的每个元素对应的下一个最大值 示例： 123456输入：[2, 1, 5]输出：[5, 5, 0]解释： 2的next_larger是5 1的next_larger是5 5的next_larger不存在，返回0 思路一 最开始的想法是，对于结点i将其后面的结点排序，取第一个大于结点i的值的结点值，这样的时间复杂度为O(n^2)，并且因为是链表，不容易进行排序操作 这里介绍一种数据结构，单调栈 栈中的元素满足单调性 在插入新元素时，出栈最少的元素以保持栈中元素的单调性 例如： 栈中元素自栈顶到栈底依次为[1, 2, 4, 5]，现插入元素3 为了保持栈中元素的单调性需出栈1, 2，最后将3插入栈中，得到[3, 4, 5]的单调栈 在这里如何使用呢 遍历链表，维护一个单调栈，单调栈的每个元素为(结点下标, 对应链表节点值) 按单调递减栈的入栈顺序，如果出现当前遍历到的结点值比栈顶值大，则将栈中元素出栈，并更新res值 12345678910111213def nextLargerNodes(self, head): res, st = [], [] # 遍历链表 while head: # 插入当前头指针指向的结点的值，并通过出栈操作维护单调性 while len(st) &gt; 0 and head.val &gt; st[-1][1]: res[st.pop()[0]] = head.val st.append((len(res), head.val)) # 没有符合条件的元素 res.append(0) head = head.next return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之可被K整除的最小整数","slug":"Leetcode之可被K整除的最小整数","date":"2020-05-24T04:17:05.000Z","updated":"2020-07-06T05:19:28.500Z","comments":true,"path":"passages/leetcode-zhi-ke-bei-k-zheng-chu-de-zui-xiao-zheng-shu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-ke-bei-k-zheng-chu-de-zui-xiao-zheng-shu/","excerpt":"Smallest Integer Divisible by K","text":"Smallest Integer Divisible by K Smallest Integer Divisible by K code with Python title number：1015 读题 给定正整数K，你需要找出可被K整除的、仅包含数字1的最小正整数N 返回N的长度，如果不存在这样的N，就返回-1 示例： 1234567891011输入：1输出：1解释：最小的答案是 N &#x3D; 1，其长度为1输入：2输出：-1解释：不存可被2乘除的正整数N输入：3输出：3解释：最小的答案是111，长度为3 思路一 最直接的想法就是从小到达遍历，判断是否能整除 根据题目给出的信息，可以从1, 11, 111, 1111...中不断尝试。但是该何时跳出循环呢 举几个例子： 123输入2， 1 % 2 &#x3D; 1， 11 % 2 &#x3D; 1， 好像没有什么特点输入6， 1 % 6 &#x3D; 1， 11 % 6 &#x3D; 5， 111 % 6 &#x3D; 3， 1111 % 6 &#x3D; 1， 11111 % 6 &#x3D; 5，陷入了循环153 总得来说 我们从1, 11, 111, ...中依次尝试 当余数出现之前出现过的数，则陷入了循环，则跳出循环返回-1 1234567891011121314def smallestRepunitDivByK(self, K: int) -&gt; int: if L % 10 in [2, 4, 5, 6]: return -1 seen = set() mode = 0 for i in range(1, K+1): mod = (mod*10 + 1) % K if mod in seen: return -1 if mod == 0: return i seed.add(mod)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之最佳观光组合","slug":"Leetcode之最佳观光组合","date":"2020-05-23T04:19:52.000Z","updated":"2020-07-06T05:33:34.786Z","comments":true,"path":"passages/leetcode-zhi-zui-jia-guan-guang-zu-he/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zui-jia-guan-guang-zu-he/","excerpt":"Best Sightseeing Pair","text":"Best Sightseeing Pair Best Sightseeing Pair code with Python title number：1014 读题 给定正整数数组A，A[i]表示第i个观光景点的评分，并且两个景点i和j之间的距离为j-i 一对景点组成的观光组合的得分为(A[i] + A[j] + i + j)：景点的评分之和减去两者之间的距离 返回一对观光经典能取得的最高分 示例： 123输入：[8,1,5,2,6]输出：11解释：i &#x3D; 0, j &#x3D; 2, A[i] + A[j] + i - j &#x3D; 8 + 5 + 0 - 2 &#x3D; 11 思路一 最直接的思路就是穷举所有的组合，计算其相应得分，最后返回最高得分 必然超时 1234567def maxScoreSightseeingPair(self, A: List[int]) -&gt; int: n = len(A) res = 0 for i in range(n - 1): for j in range(i+1, n): res = max(res, A[i] + A[j] + i - j) return res 思路二 对于得分的计算，我们可以分为两组，即A[i]+i和A[j]-j 对于每个A[j]-j，我们都去选取前面最大的A[i]+i即可实现结果最大 对于第二个子任务（选取数组A前i项的最大值）可以使用动态规划实现 状态表示：dp[] 集合：前i项所有的A[i]+i的值 属性：最大值 状态计算 比较前i-1个中的最大值与当前A[i]+i的大小，取较大值即可 常规的，我们使用长为i+1的数组简化操作 同时我们发现，dp[i]只与dp[i-1]有关，所以可以仅使用一个变量来存储dp[i-1]即可 1234567891011def maxScoreSightseeingPair(self, A: List[int]) -&gt; int: n = len(A) pre = A[0] + 0 res = 0 for i in range(1, n): res = max(res, pre + A[i] - i) pre = max(pre, A[i] + i) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之在D天内送达包裹的能力","slug":"Leetcode之在D天内送达包裹的能力","date":"2020-05-22T05:56:23.000Z","updated":"2020-07-06T05:30:50.349Z","comments":true,"path":"passages/leetcode-zhi-zai-d-tian-nei-song-da-bao-guo-de-neng-li/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zai-d-tian-nei-song-da-bao-guo-de-neng-li/","excerpt":"Capacity To Ship Packages Within D Days","text":"Capacity To Ship Packages Within D Days Capacity To Ship Packages Within D Days code with Python title number：1011 读题 传送带上的包裹必须在D天内从一个港口运送到另一个港口 传送带上的第i个包裹的重量为weights[i]。 每天，我们都会按给出的重量往传送带上装载包裹。装载的重量不会超过船的最大运载重量 返回能在D天内将传送带上的所有包裹送达的船的最低运载能力 思路一 货物必须按照给定的顺序装运 看一个示例： 123456789输入：weights &#x3D; [1,2,3,4,5,6,7,8,9,10], D &#x3D; 5输出：15解释：船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：第 1 天：1, 2, 3, 4, 5第 2 天：6, 7第 3 天：8第 4 天：9第 5 天：10 给定的列表并没有很特殊的地方，我们可以进行一下列表的转化 将列表中的元素进行合并，直至列表中元素与给定天数相同 这时，新构建的列表中元素的最大值即为所求最小运载能力 上面的例子，初始列表中最大值为10，这样我们可以选择将前面的4个元素进行合并，这样可以得到一个7个元素的列表（因为只能按顺序装货，此时仅能将前4个合并以得到更少的元素） 既然如此，就要提高每天搬运的上限。 我们意识到每天的搬运上限是有取值范围的，即[一天搬一袋时的上限, 一天全部搬完的上限]，对应到上述例子中就是[10, 50] 这样就转化为在指定范围内查找合适的数值的问题，面对查找问题，就可以用二分查找来解决了 只需要通过二分查找不断缩小查找的范围，然后找到恰好能D天搬运完的每日半圆上限（即为我们的最小每日搬运上限）即可 123456789101112131415161718192021222324252627282930313233def shipWithinDays(self, weights: List[int], D: int) -&gt; int: def get_days(weights, limit): # 根据上限判断能搬完的天数 r = 0 record = [] for w in weights: # 合并元素 if r+w &lt;= limit: r += w else: record.append(r) r = w record.append(r) return len(record) # 左右边界 left = max(weights) right = sum(weights) if left == right: return left while left &lt; right: mid = (left+right)//2 result = get_days(weights, mid) if result &gt; D: left = mid + 1 else: right = mid return left","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之骑士拨号器","slug":"Leetcode之骑士拨号器","date":"2020-05-21T04:40:23.000Z","updated":"2020-07-06T05:24:22.300Z","comments":true,"path":"passages/leetcode-zhi-qi-shi-bo-hao-qi/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-qi-shi-bo-hao-qi/","excerpt":"Knight Dialer","text":"Knight Dialer Knight Dialer code with Python title number：935 读题 国际象棋中的骑士可以按下图的方式移动 这一次，我们将其实放在电话拨号盘上，接下来骑士将会跳N-1步，每一步必须从一个数字跳到另一个数字 骑士每次落到一个键上都会拨出对应的数字，总共按下N位数字。 求一共可以拨出多少种不同的号码（因为答案很大，所以输出需要模10^9+7） 思路一 深度优先遍历 对于每一个号码，可以转移的状态是确定的，做以下处理 使用数组jump记录每个数字的转移状态，jump[i]即数字i可以转移的状态 这样问题就编程，从0开始的所有路径···从9开始的所有路径 但是这种暴力遍历必然存在很多重复的计算，超时 动态规划 状态表示：f(start, n) 集合：从start开始跳n-1步可以得到的数字的个数 属性：个数之和 状态计算 f(start, n)只与上一个可直接跳到start的数字有关 $$f(start, n) = \\sum f(x, n-1), x是可直接跳到start的数字$$ 所以要先进行处理，使用数组move保存转移关系 例如，当start=0时，可以由6或8直接跳到，所以move[0]=[6, 8] 所求即为f(0, n) + ... f(9, n) 12345678910111213141516def knightDialer(self, N): MOD = 10**9 + 7 moves = [[4, 6], [6, 8], [7, 9], [4, 8], [3, 9, 0], [], [1, 7, 0], [2, 6], [1, 3], [2, 4]] dp = [1] * 10 for hops in xrange(N-1): dp2 = [0]*10 for node, count in enumerate(dp): for nei in moves[node]: dp2[nei] += count dp2[nei] %= MOD dp = dp2 return sum(dp) % MOD","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之排序数组","slug":"Leetcode之排序数组","date":"2020-05-20T07:36:09.000Z","updated":"2020-07-06T05:23:49.810Z","comments":true,"path":"passages/leetcode-zhi-pai-xu-shu-zu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-pai-xu-shu-zu/","excerpt":"Sort an Array","text":"Sort an Array Sort an Array code with Python title number：912 读题 给定一个整数数组nums，将该数组升序排序 思路一 考察最基本的排序算法 排序算法可以分为多类，有不同的划分标准：稳定性、内外排序、时空复杂度等 下面依次实现常见的多种排序算法 选择排序 1234567def sortArray(self, nums: List[int]) -&gt; List[int]: n = len(nums) for i in range(n): for j in range(i, n): if nums[i] &gt; nums[j]: nums[i], nums[j] = nums[j], nums[i] return nums 冒泡排序 12345678def sortArray(self, nums: List[int]) -&gt; List[int]: n = len(nums) for c in range(n): for i in range(1, n-c): if nums[i-1] &gt; nums[i]: nums[i-1], nums[i] = nums[i], nums[i-1] return nums 插入排序 12345678def sortArray(self, nums: List[int]) -&gt; List[int]: n = len(nums) for i in range(1, n): while i &gt; 0 and nums[i-1] &gt; nums[i]: nums[i-1], nums[i] = nums[i], nums[i-1] i -= 1 return nums 希尔排序 1234567891011def sortArray(self, nums: List[int]) -&gt; List[int]: n = len(nums) gap = n // 2 while gap: for i in range(gap, n): while i - gap &gt;= 0 and nums[i-gap] &gt; nums[i]: nums[i - gap], nums[i] = nums[i], nums[i - gap] i -= gap gap //= 2 return nums 归并排序 123456789101112131415161718192021222324def merge(left, right): res = [] i = 0 j = 0 while i &lt; len(left) and j &lt; len(right): if left[i] &lt;= right[j]: res.append(left[i]) i += 1 else: res.append(right[j]) j += 1 res += left[i:] res += right[j:] return resdef sortArray(self, nums: List[int]) -&gt; List[int]: if len(nums) &lt;= 1: return nums mid = len(nums) // 2 # 分 left = merge_sort(nums[:mid]) right = merge_sort(nums[mid:]) # 合并 return merge(left, right) 快速排序 123456789101112131415161718192021def sortArray(self, nums: List[int]) -&gt; List[int]: n = len(nums) def quick(left, right): if left &gt;= right: return nums pivot = left i = left j = right while i &lt; j: while i &lt; j and nums[j] &gt; nums[pivot]: j -= 1 while i &lt; j and nums[i] &lt;= nums[pivot]: i += 1 nums[i], nums[j] = nums[j], nums[i] nums[pivot], nums[j] = nums[j], nums[pivot] quick(left, j - 1) quick(j + 1, right) return nums return quick(0, n - 1) 堆排序 123456789101112131415161718192021222324252627def sortArray(self, nums: List[int]) -&gt; List[int]: # 调整堆 # 迭代写法 def adjust_heap(nums, startpos, endpos): newitem = nums[startpos] pos = startpos childpos = pos * 2 + 1 while childpos &lt; endpos: rightpos = childpos + 1 if rightpos &lt; endpos and nums[rightpos] &gt;= nums[childpos]: childpos = rightpos if newitem &lt; nums[childpos]: nums[pos] = nums[childpos] pos = childpos childpos = pos * 2 + 1 else: break nums[pos] = newitem n = len(nums) # 建堆 for i in reversed(range(n // 2)): adjust_heap(nums, i, n) # 调整堆 for i in range(n - 1, -1, -1): nums[0], nums[i] = nums[i], nums[0] adjust_heap(nums, 0, i) return nums 基数排序 1234567891011121314151617181920def sortArray(self, nums: List[int]) -&gt; List[int]: if not nums: return [] _max = max(nums) # 最大位数 maxDigit = len(str(_max)) bucketList = [[] for _ in range(10)] # 从低位开始排序 div, mod = 1, 10 for i in range(maxDigit): for num in nums: bucketList[num % mod // div].append(num) div *= 10 mod *= 10 idx = 0 for j in range(10): for item in bucketList[j]: nums[idx] = item idx += 1 bucketList[j] = [] return nums 桶排序 1234567891011121314151617181920212223def sortArray(self, nums: List[int]) -&gt; List[int]: if len(nums) &lt; 2: return nums _min = min(nums) _max = max(nums) # 需要桶个数 bucketNum = (_max - _min) // bucketSize + 1 buckets = [[] for _ in range(bucketNum)] for num in nums: # 放入相应的桶中 buckets[(num - _min) // bucketSize].append(num) res = [] for bucket in buckets: if not bucket: continue if bucketSize == 1: res.extend(bucket) else: # 当都装在一个桶里,说明桶容量大了 if bucketNum == 1: bucketSize -= 1 res.extend(bucket_sort(bucket, bucketSize)) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之RLE迭代器","slug":"Leetcode之RLE迭代器","date":"2020-05-19T06:55:29.000Z","updated":"2020-07-06T05:08:36.474Z","comments":true,"path":"passages/leetcode-zhi-rle-die-dai-qi/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-rle-die-dai-qi/","excerpt":"RLE Iterator","text":"RLE Iterator RLE Iterator code with Python title number：900 读题 编写一个遍历游程编码序列的迭代器 迭代器由RLEIterator(int[] A)初始化，其中A是某个序列的游程编码 对于所有偶数i，A[i]告诉我们在序列中重复非负整数值A[i+1]的次数 迭代其支持一个函数next(int n)，它耗尽接下来的n个元素(n&gt;=1)，并返回以这种方式耗去的最后一个元素。如果没有剩余的元素可供耗尽，则next返回-1 例如，我们以 A = [3,8,0,9,2,5] 开始，这是序列 [8,8,8,5,5] 的游程编码。这是因为该序列可以读作 “三个八，零个九，两个五”。 示例： 1234567891011输入：[&quot;RLEIterator&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;], [[[3,8,0,9,2,5]],[2],[1],[1],[2]]输出：[null,8,8,5,-1]解释：RLEIterator 由 RLEIterator([3,8,0,9,2,5]) 初始化。这映射到序列 [8,8,8,5,5]。然后调用 RLEIterator.next 4次。.next(2) 耗去序列的 2 个项，返回 8。现在剩下的序列是 [8, 5, 5]。.next(1) 耗去序列的 1 个项，返回 8。现在剩下的序列是 [5, 5]。.next(1) 耗去序列的 1 个项，返回 5。现在剩下的序列是 [5]。.next(2) 耗去序列的 2 个项，返回 -1。 这是由于第一个被耗去的项是 5，但第二个项并不存在。由于最后一个要耗去的项不存在，我们返回 -1。 思路一 编码中两个数表示一种状态，例如3, 8 -&gt; 三个八，第一个是元素个数，第二个是元素值 在调用next()时，不改变数组的值，而是维护两个变量i, q，i表示迭代器当前指向的元素是A[i+1]，q表示它已经被删除的次数，q的值不会大于A[i] 调用next(n)时，即删除n个元素，相对与当前的元素A[i+1]，我们还可以删除的次数为D=A[i]-q 如果n &gt; D，那么我们会删除所有的A[i+1]，并迭代下一个元素，即n-=D, i+=2, q=0 如果n &lt;= D，那么我们删除的最后一个元素为A[i+1]，即q+=D, return A[i+1] 1234567891011121314151617class RLEIterator: def __init__(self, A: List[int]): self.A = A self.i = 0 self.q = 0 def next(self, n: int) -&gt; int: while self.i &lt; len(self.A): if self.q + n &gt; self.A[self.i]: n -= self.A[self.i] - self.q self.q = 0 self.i += 2 else: self.q += n return self.A[self.i+1] return -1","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之鸡蛋掉落","slug":"Leetcode之鸡蛋掉落","date":"2020-05-18T06:23:57.000Z","updated":"2020-07-06T05:18:24.149Z","comments":true,"path":"passages/leetcode-zhi-ji-dan-diao-luo/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-ji-dan-diao-luo/","excerpt":"Super Egg Drop","text":"Super Egg Drop Super Egg Drop code with Python title number：887 读题 你有K个鸡蛋，可以使用移动从1到N的N层楼的建筑 每个鸡蛋功能相同，且摔碎之后不能再用 存在楼层F，满足0 &lt;= F &lt;= N任何从高于F的楼层落下的鸡蛋会碎，低于F的楼层落下的鸡蛋不会碎 每次移动，可以取一个鸡蛋从任一楼层扔下，来测试确切的F的值 无论F的值如何，请计算确定F的值的最小移动次数为多少 示例： 123456输入：K &#x3D; 1, N &#x3D; 2输出：2解释：鸡蛋从1楼掉落，如果碎了，则F &#x3D; 0否则，鸡蛋从二楼掉落，如果碎了，则F &#x3D; 1；如果没碎，则F &#x3D; 2因此最坏的情况下需要移动两次才能确定 思路一 动态规划 最直接的想法 状态表示 集合：有i个鸡蛋，j层楼，测试出F的需要的次数的集合 属性：最小值 状态计算 状态转移方程为：dp[i][j] = min(dp[i-1][j-1], dp[i][N-j]+1) 前者表示在第j层楼扔下去，碎了，下次只有i-1个鸡蛋，测试j层之下的j-1层楼即可 后者表示在第j层楼扔下去，没碎，下次只有i-1个鸡蛋，测试j层之上的N-j层楼即可 这种方式的时间复杂度太高，相当于穷举 1def superEggDrop(self, K: int, N: int) -&gt; int: 思路二 还是动态规划，转化一下想法 状态表示 有i个鸡蛋，扔j次 集合：测试出F需要的次数的集合 属性：最小值 状态计算 dp[i][j] = dp[i-1][j-1] + dp[i][j-1]+1 前者表示扔了一次之后，碎了，还剩j-1次机会 后者表示扔了一次之后，没碎，还剩j-1次机会 因为dp[i][j]只与dp[][j-1]有关，所以可以简化为一维数组，遍历时倒序遍历即可 dp[i] = dp[i-1] + dp[i]+1 12345678910def superEggDrop(self, k: int, N: int) -&gt; int: dp = [0]*(K+1) cnt = 0 while dp[-1] &lt; N: for i in range(K, 0, -1): dp[i] = dp[i] + dp[i-1]+1 cnt += 1 return cnt","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之石子游戏","slug":"Leetcode之石子游戏","date":"2020-05-17T06:52:28.000Z","updated":"2020-07-06T05:26:34.703Z","comments":true,"path":"passages/leetcode-zhi-shi-zi-you-xi/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-shi-zi-you-xi/","excerpt":"Stone Game","text":"Stone Game Stone Game code with Python title number：877 读题 A和B用几堆石子做游戏。石子的堆数是偶数，石子堆排成一行，每堆有正整数颗石子piles[i] 以谁手中的石子最多来决定胜负。石子总数为奇数，没有平局 两人轮流进行，每回合玩家从行的开始或结束处取走整堆石头，直到取完 假设两个都采取最佳方案，当A获胜时返回True，当B获胜时返回False 示例： 12345678输入：[5,3,4,5]输出：true解释： 亚历克斯先开始，只能拿前 5 颗或后 5 颗石子 。 假设他取了前 5 颗，这一行就变成了 [3,4,5] 。 如果李拿走前 3 颗，那么剩下的是 [4,5]，亚历克斯拿走后 5 颗赢得 10 分。 如果李拿走后 5 颗，那么剩下的是 [3,4]，亚历克斯拿走后 4 颗赢得 9 分。 这表明，取前 5 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 true 。 思路一 博弈问题，因为这道题的限制比较多，可以通过分析得出结论 因为石子堆是偶数堆，而A是先手，所以他可以做到取所有序号为偶数的堆（第一次取最后一堆），也可以做到取所有序号为奇数的堆（第一次取第一堆） 既然如此，B是没有选择权的，只能被动的选择 只需要计算所有奇数堆和所有偶数堆哪个大选择哪个即可 所以，在本题的情境中，A立于不败之地 123def stoneGame(self, piles: List[int]) -&gt; bool: return True 思路二 博弈问题，两者都会选择最有利于自己的方案，不过这道题的限制太多（先手必胜），我们将其推广到更通用的情况来分析 A和B面前有一排石头堆，用一个数组piles表示，piles[i]表示第i堆石子有多少个。 轮流拿石头，一次拿一堆，但是只能拿走最左边或者最右边的石头堆。所有石头被拿完后，谁拥有的石头多，谁获胜 状态表示：dp[i][j] 想要使用动态规划，首先要抽象出总问题与子问题之间的关系 [i, ..., j]之间先手和后手能获得的最高分数 每个状态要存储两个值，我们使用对象来存储 集合：第i到第j个石堆先手和后手的可能的得分的集合 属性：先手和后手得分的最大值 状态计算 对于每一个状态，只有两个选择：选择最左边的石堆，选择最右边的石堆。我们可以穷举出所有状态 故：以先手选择取左边还是右边的石堆作为集合划分标准 如果先手选择左边的石堆，则： dp[i][j].first = piles[i] + dp[i+1][j].second 在[i, ... j]是先手，则在下一步[i+1, ..., j]就变成了后手 dp[i][j].second = dp[i+1][j].first 在[i, ... j]是后手，则在[i+1, ..., j]就变成了先手 如果先手选择右边的石堆，则： dp[i][j].first = piles[j] + dp[i][j-1].second 在[i, ... j]是先手，则在下一步[i, ..., j-1]就变成了后手 dp[i][j].first = dp[i][j-1].first 在[i, ... j]是后手，则在[i, ..., j]就变成了先手 初始化 如果只有一堆石头，即i==j时，先手得到该堆石头，后手什么都没有 dp[i][j].first = piles[i] dp[i][j].second = 0 所求 dp[0][n-1]中first与second的大小关系 12345678910111213141516171819202122232425262728293031class Pair: def __init __(self, first, second): self.first = first self.second = second def stoneGame(self, piles: List[int]) -&gt; bool: len_ = len(piles) dp = [[0 for _ in range(len_)] for _ in range(len_)] for i in range(len_): dp[i][i].first = piles[i] dp[i][i].second = 0 # 斜着遍历数组 for i in range(len_-2, -1, -1): # (len-2, 0) for j in range(i+1, len_): # (i+1, len-1) left = piles[i] + dp[i+1][j].second right = piles[j] + dp[i][j-1].second if left &gt; right: dp[i][j].first = left dp[i][j].second = dp[i+1][j].first else: dp[i][j].first = right dp[i][j].second = dp[i][j-1].first res = dp[0][n-1] if res.first &gt; res.second: return True else: return False","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之爱吃香蕉的珂珂","slug":"Leetcode之爱吃香蕉的珂珂","date":"2020-05-16T13:24:21.000Z","updated":"2020-07-06T05:08:43.716Z","comments":true,"path":"passages/leetcode-zhi-ai-chi-xiang-jiao-de-ke-ke/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-ai-chi-xiang-jiao-de-ke-ke/","excerpt":"Koko Eating Bananas","text":"Koko Eating Bananas Koko Eating Bananas code with Python title number：875 读题 珂珂喜欢吃香蕉，这里有N堆香蕉，第i堆中有piles[i]根香蕉。警卫已经离开，将在H小时候返回 珂珂可以决定自己的吃香蕉速度K（每小时K根） 每小时选择一堆香蕉，吃掉其中的K根香蕉。如果该堆少于K根则吃掉整堆的香蕉，并且在该小时内不能吃其他堆的香蕉 返回珂珂可以在H小时内吃掉所有香蕉的最小速度K 示例： 12输入：piles &#x3D; [3, 6, 7, 11], H &#x3D; 8输出：4 思路一 直觉上，不断进行尝试，从令K = 最大堆的香蕉数开始尝试，如果可行，则减小1，如果不行则返回上一次的结果。一次类推，计算出刚好不行的临界值即可 或者假设珂珂吃的特别慢，从K = 1开始，不断提高速度，直到刚刚可以在规定时间内吃完 但是使用二分查找能有效减小时间复杂度（题目的相关标签中也有提示使用二分查找） 由于只能每个小时选择其中一堆吃，所以速度的最大值就是最大堆的香蕉数，最小值为1 每堆香蕉吃完的耗时 = 这对香蕉的数量 / 速度（不能整除时取上界） 123456789101112131415161718def minEatingSpeed(self, piles: List[int], H: int) -&gt; int: def cal_sum(self, piles, speed): res = 0 for pile in piles: res += (pile + speed - 1) // speed return res left = 1 right = max(piles) while left &lt; right: mid = (left + right) &gt;&gt; 1 if cal_sum(piles, mid) &gt; H: left = mid + 1 else: right = mid return left 绝大多数在递增递减区间中搜索目标值的问题都可以转化为二分查找问题","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之单词的压缩编码","slug":"Leetcode之单词的压缩编码","date":"2020-05-15T02:32:26.000Z","updated":"2020-07-06T05:10:38.578Z","comments":true,"path":"passages/leetcode-zhi-dan-ci-de-ya-suo-bian-ma/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-dan-ci-de-ya-suo-bian-ma/","excerpt":"Short Encoding of Words","text":"Short Encoding of Words Short Encoding of Words code with Python title number：820 读题 给定一个单词列表，讲这个列表编码称一个索引字符串S与索引列表A 通过每个索引，我们可以通过从字符串S中索引的位置开始读取字符串，直到#结束，以此来恢复我们的单词列表 返回给单词列表进行编码的最小字符串长度 示例： 123输入：words &#x3D; [&#39;time&#39;, &#39;me&#39;, &#39;bell&#39;]输出：10说明：S &#x3D; &#39;time#bell#&#39;, indexes &#x3D; [0, 2, 5] 思路一 解读一下上面给出的例子，对于time和me拥有相同的后缀，所以可以不用重复存储，而只需要记录起始位置为[0, 2]就可以恢复原来的字符序列 由于这种共享后缀的特性我们联想到了后缀树，而之前我们做过关于前缀树（字典树）的题目实现Trie 而只需要将字符串逆序存储，原来的共同后缀就变为了共同前缀，也就可以使用前缀树解决了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Trie: def __init__(self): \"\"\" Initialize your data structure here. \"\"\" self.lookup = &#123;&#125; def insert(self, word: str) -&gt; None: \"\"\" Inserts a word into the trie. \"\"\" tree = self.lookup for a in word: if a not in tree: # 新节点 tree[a] = &#123;&#125; tree = tree[a] # 设置单词的结束标志 tree[\"#\"] = \"#\" def search(self, word: str) -&gt; bool: \"\"\" Returns if the word is in the trie. \"\"\" tree = self.lookup for a in word: if a not in tree: return False tree = tree[a] if \"#\" in tree: return True return False def startsWith(self, prefix: str) -&gt; bool: \"\"\" Returns if there is any word in the trie that starts with the given prefix. \"\"\" tree = self.lookup for a in prefix: if a not in tree: return False tree = tree[a] return Truedef minimumLengthEncoding(self, word: List[str]) -&gt; int: len_ = 0 trie = Trie() words = set(words) for word in words: # 插入的是字符串逆序 trie.insert(word[::-1]) for word in words: if trie.startsWith(word[::-1]): len_ += len(word) + 1 return cnt","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之在系统中查找重复文件","slug":"Leetcode之在系统中查找重复文件","date":"2020-05-14T02:08:29.000Z","updated":"2020-07-06T05:31:12.892Z","comments":true,"path":"passages/leetcode-zhi-zai-xi-tong-zhong-cha-zhao-chong-fu-wen-jian/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zai-xi-tong-zhong-cha-zhao-chong-fu-wen-jian/","excerpt":"Find Duplicate File in System","text":"Find Duplicate File in System Find Duplicate File in System code with Python title number：609 读题 给定一个目录信息列表，包括目录路径以及目录中的所有包含内容的文件 找到文件系统中的所有重复文件组的路径 一组重复的文件至少包含两个完全相同内容的文件 示例： 12345输入列表格式为：&quot;root&#x2F;d1&#x2F;d2&#x2F;...&#x2F;dm f1.txt(f1_content) f2.txt(f2_content) ... fn.txt(fn_content)&quot;表示有n个文件：f1.txt, f2.txt ... fn.txt 内容分别为：f1_content, f2_content ... fn_content输出为一个列表，包含文件路径及文件名 对输出顺序无要求 同意目录中没有没有同名文件或目录 思路一 使用字典存储 key为文件内容，value为文件路径列表，遍历一遍列表 输出时要输出value列表长度大于2的 1234567891011121314def findDuplicate(self, paths: List[str]) -&gt; List[List[str]]: dict_ = collections.defaultdict(list) for path in paths: splits = path.split(\" \") folder, files = splits[0], splits[1:] for file in files: # 以左括号划分 name, content = file.split('(') dict[content] += [folder+'/'+name] result = [] for value in dict_.values(): if len(value) &gt;= 2: result.append(value) return result","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之朋友圈","slug":"Leetcode之朋友圈","date":"2020-05-13T03:07:47.000Z","updated":"2020-07-06T05:23:58.411Z","comments":true,"path":"passages/leetcode-zhi-peng-you-quan/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-peng-you-quan/","excerpt":"Friend Circles","text":"Friend Circles Friend Circles code with Python title number：547 读题 班上有N名学生，其中有一些人是朋友，有一些不是 他们的友谊具有传递性，即A与B是朋友，B与C是朋友，则A与C也是朋友 给定一个N*N的矩阵，表示班级中学生之间的朋友关系。如果M[i][j]=1，则表示第i个学生与第j个学生互为朋友 输出所有一直的朋友圈总数 示例： 1234567输入：[[1, 1, 0], [1, 1, 0], [0, 0, 1]]输出：2解释：第1个和第2个学生互为朋友，是一个朋友圈第3个学生自己在一个朋友圈 思路一 可以当作连通区域问题解决，具体可参考岛屿数量和被围绕的区域 使用深度搜索查找矩阵中的连通区域 123456789101112131415def findCircleNum(self, M: List[List[int]]) -&gt; int: def dfs(M, visited, i): for j in range(len(M)): if M[i][j] == 1 and visited[j] == 0: visited[j] = 1 dfs(M, visited, j) visited = [0 for _ in range(len(M))] count = 0 for i in range(len(M)): if visited[i] == 0: dfs(M, visited, i) count += 1 return count 思路二 使用并查集统计连通块数量 使用一个大小为N的parent数组，遍历整个图，每个结点都遍历所有相邻点，并将相邻点指向该节点，设置成一个parent数组结点决定的单独组，即union过程 对于新节点，寻找其父亲，如果父亲结点一样，则在同一个组内 如果父亲节点不同，则仍需要合并，故将其父亲节点合并 123456789101112131415161718192021222324def findCircleNum(self, M: List[List[int]]) -&gt; int: def find(parent, i): if parent[i] == -1: return i return find(parent, parent[i]) def union(parent, x, y): x_set = find(parent, x) y_set = find(parent, y) if x_set != y_set: parent[x_set] = y_set parent = [-1 for i in range(len(M))] for i in range(len(M)): for j in range(len(M)): if M[i][j] == 1 and i != j: union(parent, i, j) count = 0 for i in range(len(parent)): if parent[i] == -1: count += 1 return count 实际尝试中，并查集的时间复杂度更高","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之零钱兑换Ⅱ","slug":"Leetcode之零钱兑换Ⅱ","date":"2020-05-12T08:22:06.000Z","updated":"2020-07-06T05:22:09.324Z","comments":true,"path":"passages/leetcode-zhi-ling-qian-dui-huan-ii/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-ling-qian-dui-huan-ii/","excerpt":"Coin Change Ⅱ","text":"Coin Change Ⅱ Coin Change Ⅱ code with Python title number：518 读题 给定不同面额的硬币和一个总金额，计算有多少中凑成总金额的硬币组合数 每种面额的硬币都有无限个 示例 1234567输入：amount &#x3D; 5，coins &#x3D; [1, 2, 5]输出：4解释：5 &#x3D; 55 &#x3D; 2 + 2 + 15 &#x3D; 2 + 1 + 1 + 15 &#x3D; 1 + 1 + 1 + 1 + 1 思路一 很明显的完全背包问题的变体，使用动态规划解决 状态表示：$f(i, j)$ 集合：使用前i种硬币凑出金额j的方法数 属性：总数（求和） 状态计算 以前i种硬币中第i个硬币是否使用作为集合分割标准 第i种硬币不用，$f(i, j) = f(i-1, j)$ 第i中硬币选用，k是满足j &gt;= k*coin[i]的最大值 $f(i, j) = f(i-1, j-1coin[i]) + f(i-1, j-2coin[i])+…f(i-1, j-k*coin[i])$ 综上：$$f(i, j) = f(i-1,j) + f(i-1, j-1coin[i]) + f(i-1, j-2coin[i])+…f(i-1, j-k*coin[i])$$ 令j = j-coin[i]，则 $$f(i, j-coin[i]) = f(i-1,j-coin[i]) + f(i-1, j-2coin[i])+…f(i-1, j-kcoin[i])$$ - 结合两式，可得到 $$ f(i, j) = f(i, j-coin[i]) + f(i-1, j) $$ 所求即为，$f(len(coins), amount)$ 123456789101112def change(self, amount: int, coins: List[int]) -&gt; int: n = len(coins) dp = [[0]*(amount+1) for _ in range(n+1)] for i in range(n+1): dp[i][0] = 1 for i in range(1, n+1): for j in range(1, amount+1): dp[i][j] = dp[i-1][j] if j &gt;= coins[i-1]: dp[i][j] = dp[i][j] + dp[i][j-coins[i-1]] return dp[-1][-1] 优化 使用dp[i]表示组成金额i的总组合数 对于小于最小硬币面值的金额，跳过 每个金额遍历一遍硬币，进行更新 12345678def change(self, amount: int, coins: List[int]) -&gt; int: n = len(coins) dp = [0]*(amount+1) dp[0] = 1 for coin in coins: for j in range(coin, amount): dp[j] = dp[j] + dp[j-coin] return dp[-1]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之最长回文子序列","slug":"Leetcode之最长回文子序列","date":"2020-05-11T01:50:43.000Z","updated":"2020-07-06T05:35:18.396Z","comments":true,"path":"passages/leetcode-zhi-zui-chang-hui-wen-zi-xu-lie/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zui-chang-hui-wen-zi-xu-lie/","excerpt":"Longest Palindromic Subsequence","text":"Longest Palindromic Subsequence Longest Palindromic Subsequence code with Python title number：516 读题 给定一个字符串s找到其中最长的回文子序列 假设s的最大长度为1000 示例： 123输入：&quot;bbbab&quot;输出：4解释：可能的最长子序列为&quot;bbbb&quot; 思路一 注意”子序列“与”子串“的区别，子序列并不要求序列中的元素在原字符串中相邻 对于找子序列问题，关键词在于”延伸“ 如果一个子序列是回文子序列，那么在其左右分别加上一个相同的字符，它还是一个回文子序列。此时回文子序列长度要+2 如果 一个子序列不是回文子序列，或者在其左右加上不同的字符，则得到的不是回文子序列，此时回文子序列长度不变，取[i][j-1]和[i+1][j]的较大值 根据上述分析，我们得到了整体问题与子问题之间的关系，可以用动态规划来解决了 按照惯例，下面进行动态规划式的分析 状态表示：$f(i, j)$表示子串s[i:j]之间所有回文子序列的集合 集合：在子串s[i:j]的所有回文子序列的集合 属性：最长的回文子序列 状态计算 以子串的第一个字符s[i]和最后一个字符s[j]是否相同作为分割标准 如果两者相同，则为子串s[i+1, j-1]中的最长回文子串长度加2，即$f(i, j) = f(i+1, j-1) + 2$ 如果两者不相同，则为子串s[i+1, j-1]分别加上其中一个字符所产生的最长子序列中的较大值，即$f(i, j) = max[f(i+1, j), f(i, j-1)]$ 综上，$$f(i, j) = \\begin{cases}f(i+1, j-1), s[i]==s[j]\\max[f(i+1, j), f(i, j-1)], s[i!=s[j]\\end{cases}$$ 所求即为，$f(0, len(str))$ 123456789101112131415def longestPalindromeSubseq(self, s: str) -&gt; int: n = len(s) dp = [[0]*(n) for _ in range(n)] if s == s[::-1]: return n for i in range(n): dp[i][i] = 1 for i in range(n, -1, -1): for j in range(i+1, n): if s[i] == s[j]: dp[i][j] = dp[i+1][j-1] + 2 else: dp[i][j] = max(dp[i+1][j], dp[i][j-1]) return dp[0][-1]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之一和零","slug":"Leetcode之一和零","date":"2020-05-10T01:13:53.000Z","updated":"2020-07-06T05:30:00.833Z","comments":true,"path":"passages/leetcode-zhi-yi-he-ling/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-yi-he-ling/","excerpt":"Ones and Zeroes","text":"Ones and Zeroes Ones and Zeroes code with Python title number：474 读题 假设你分别支配着m个0和n个1，另外还有一个仅包含0和1字符串的数组 现在的任务是，使用给定的m个0和n个1，找到能拼接出存在于数组中的字符串的最大数量 每个0和1至多被使用一次 示例： 1234567输入：Array &#x3D; &#123;&quot;10&quot;, &quot;0001&quot;, &quot;111001&quot;, &quot;1&quot;, &quot;0&quot;&#125;, m &#x3D; 5, n &#x3D; 3输出：4解释：总共有4个字符串可以通过5个0和3个1拼出输入：Array &#x3D; &#123;&quot;10&quot;, &quot;1&quot;, &quot;0&quot;&#125;, m &#x3D; 1, n &#x3D; 1输出：2解释：只能拼出“10”，之后0,1就被使用完了 思路一 本题可以转化为01背包问题，经典的01背包问题介绍见这里 转化后的问题 把0和1的个数视为背包的容量，将每个字符串视为装进背包的物品 不同之处，这里的背包分为两部分，分别用来装0或1 状态表示，$f(i, j , k)$ 集合：输入字符串在自区间[0, i]能够使用j个0和k个1表示字符串数 属性：可被表示的字符串的最大数量 状态计算 以第i个字符串是否使用01表示为分割标准 若第i个字符串被表示，$f(i-1, j-第i个字符串0的个数, k-当前字符串1的个数) + 1$ 若第i个自负串不被表示，$f(i-1, j, k)$ 综上$$f(i , j , k) = max[f(i-1, j, k), f(i-1, j-当前字符串使用0的个数, k-当前字符串使用1的个数)]$$ 最终所求即为：$f(len, m, n)$ 另外，我们一般多设置一行，即用来处理第0个字符串为空串的情况，初始化为0 1234567891011121314151617181920212223242526272829def findMaxForm(self, strs: List[str], m: int, n: int) -&gt; int: len_ = len(strs) # 注意三维数组的初始化 def make_dp(len_, m, n): dp = [0]*(len_+1) for i in range(len_+1): dp[i] = [0]*(m+1) for i in range(len+1): for j in range(m+1): dp[i][j] = [0]*(n+1) def countZeroAndOne(str_): ones, zeroes = 0, 0 for i in range(len(str_)): if str_[i] == \"0\": zeroes += 1 if str_[i] == \"1\": ones += 1 return ones, zeroes dp = make_dp(len_, m, n) for i in range(1, len_+ 1): ones, zeroes = countZeroAndOne(strs[i-1]) for j in range(m+1): for k in range(n+1): dp[i][j][k] = dp[i-1][j][k] if j &gt;= zeroes and k &gt;= ones: dp[i][j][k] = max(dp[i-1][j][k], dp[i-1][j-zeroes][k-ones] + 1) return dp[len_][m][n] 我们知道，动态规划实质上是一种填表的过程，所谓状态压缩，就是根据状态之间的相关性，通过遍历顺序上的调整，节省掉一种到多重状态的表示，体现在dp数组上就是数组的维度下降 以下分析来自题解区 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152以给定的示例为例：Array &#x3D; &#123;&quot;10&quot;, &quot;0001&quot;, &quot;111001&quot;, &quot;1&quot;, &quot;0&quot;&#125;, m &#x3D; 5, n &#x3D; 3初始化背包：dp 0列 1列 2列 3列 0行 0 0 0 01行 0 0 0 02行 0 0 0 03行 0 0 0 04行 0 0 0 0 5行 0 0 0 0（行表示背包0的可容纳大小，列表示背包1的可容纳大小）对于第一个串“10”：可容纳的背包 （√表示可容纳 x表示不可容纳）dp 0列 1列 2列 3列 0行 × × × ×1行 × √ √ √2行 × √ √ √3行 × √ √ √4行 × √ √ √ 5行 × √ √ √对于可容纳的背包要依次遍历，不放，则查看原旧背包容量 放，则 1（当前01串）+ 变小的 旧背包容量 -&gt; 取最大值dp 0列 1列 2列 3列 0行 0 0 0 01行 0 1 1 12行 0 1 1 13行 0 1 1 14行 0 1 1 1 5行 0 1 1 1对于第二个串“0001”可容纳的背包 （√表示可容纳 x表示不可容纳）dp 0列 1列 2列 3列 0行 × × × × 1行 × × × × 2行 × × × × 3行 × √ √ √4行 × √ √ √ 5行 × √ √ √对于可容纳的背包要依次遍历， 不放，则查看原旧背包容量 放，则 1（当前01串）+ 变小的 旧背包容量 -&gt; 取最大值dp 0列 1列 2列 3列 0行 0 0 0 01行 0 1 1 12行 0 1 1 13行 0 1 1 1 4行 0 1 2 2 5行 0 1 2 2 &lt;-- max（原本背包价值1【不放】， 1+旧背包dp[5-3][3-1]【放】） 分析上述过程，我们发现，当前行的值只与上一行的值有关，所以，我们可以使用滚动数组，也可以从后向前赋值，此时dp数组只需要有两维即可 12345678910111213141516171819def findMaxForm(self, strs: List[str], m: int, n: int) -&gt; int: dp = [[0]*(n+1) for _ in range(m+1)] def countZeroAndOne(str_): ones, zeroes = 0, 0 for i in range(len(str_)): if str_[i] == \"0\": zeroes += 1 if str_[i] == \"1\": ones += 1 return ones, zeroes for str_ in strs: ones, zeroes = countZeroAndOne(str_) for i in range(m, zeroes-1, -1): for j in range(n, ones-1, -1): dp[i][j] = max(dp[i][j], dp[i-zeroes][j-ones] + 1) return dp[m][n]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"周知识总结（5-4-5-10）","slug":"周知识总结（5-4-5-10）","date":"2020-05-09T10:15:12.000Z","updated":"2020-07-06T05:50:03.742Z","comments":true,"path":"passages/zhou-zhi-shi-zong-jie-5-4-5-10/","link":"","permalink":"http://zivblog.top/passages/zhou-zhi-shi-zong-jie-5-4-5-10/","excerpt":"周知识总结","text":"周知识总结 5月4日进行模型评估时，主要有哪些验证方法？试比较其优劣 在进行机器学习时，我们通常把样本分为训练集和测试集，训练集用于训练模型，测试集用于评估模型。在样本划分和模型验证的过程中，有不同的抽样方法和验证方法。 Holdout检验 将原始的样本集合随机划分成训练集和验证集两部分（两部分占用的比例由使用者指定） 缺点是在验证集上计算出来的最后评估指标与原始分组有很大关系，有很大的随机性 交叉检验 k-fold：将全部样本划分成k个大小相等的样本自己，依次遍历这k个子集，每次把当前子集作为验证集，其余所有子集作为训练集，进行模型的训练和估，最后将k次评估指标的平均值作为最终的评估指标。通常，k=10 留一验证：每次留下一个样本作为验证集，其余所有样本作为测试集。如果样本数为n的话，则需要依次对n个样本进行遍历。 留一验证的时间开销极大。 自助法 当样本集比较小的时候，将样本进行划分会导致用于训练的样本进一步减少。 自助法是基于自助采样的检验方法。对于总数为n个样本集合，进行n次又放回的随机抽样，得到大小为n个训练集。 采样过程中可能会有样本被重复选择，也会有样本没有被抽取过，这些没有被抽取过的样本作为验证集 5月5日在自助法的随机采样过程中，当n趋于无穷大时，最终有多少数据未被抽取过？ 一个样本在一次抽取中未被抽中的概率为$1-\\frac{1}{n}$，进行n次抽样均为抽中的概率为$(1-\\frac{1}{n})^n$，当n趋于无穷大的时候$lim_{n-&gt;∞}(1- \\frac{1}{n})^n$ 因为$$lim_{n-&gt;∞}(1+\\frac{1}{n})=e$$ 所以$$lim_{n-&gt;∞}(1- \\frac{1}{n})^n = lim_{n-&gt;∞}(\\frac{1}{(1+\\frac{1}{n-1})^n}) = \\frac{1}{e} = 0.36$$ 即，有大约36%的样本从未被选择过，可以作为验证集 5月6日超参数有哪些调优方法？ 网格搜索 通过查找搜索范围内所有的点来确定最优值。 如果采用较大的搜索范围以及较小的步长，网格搜索有很大概率查找到全局最优值 但是这种搜索方案十分消耗计算资源和时间，特别是当需要调优的超参数比较多的时候。 因此在实际使用中，一般会使用较广的搜索范围和较大的步长，来寻找全局最优值的可能位置；然后会逐渐缩小搜索范围和步长，来寻找更为精确的最优值 随机搜索 主体思想与网格搜索比较相似，只是不再测试上界和下界之间的所有值，而是在搜索范围内随机选取样本点。 如果选取的样本点足够多的时候，也能大概率找到全局最优值或其近似值 速度上比网格搜索更快，但是结果是无法保证的 贝叶斯优化 之前两种方法，在测试新点的时候会忽略之前一个点的信息，而贝叶斯优化算法则充分利用了之前的信息。 通过对目标函数形状进行学习，找到使目标函数向全局最优值提升的参数。 具体来说，它会首先根据先验分布，假设一个搜集函数；然后，每一次使用新的采样点来测试目标函数时，利用这个信息来更新目标函数的先验分布；最后，算法测试由后验分布给出的全局最优值最可能出现的位置的点。 5月7日逻辑回归和线性回归的区别？ 逻辑回归处理的是分类问题，线性回归处理的是回归问题 逻辑回归中，因变量取值是一个二元分布，模型学习得出的是$E[y|x;θ]$，给定自变量和超参数后，得到因变量的期望，并根据该期望来处理预测分类任务 线性回归中，求解的是$y’ = θ^Tx$，是对我们假设的真实关系的一个近似$y=θ^Tx + \\eta$，其中$\\eta$是误差 而两者也有一定的相同之处，我们可以认为二者都使用了极大似然估计来对训练样本进行建模。 线性回归使用的最小二乘法可以认为是在自变量x与超参数θ确定，y服从正态分布的假设下，使用极大似然估计的一个简化 逻辑回归中对似然函数$L(θ)=\\prod_{i=1}^n P(y_i|x;θ)=\\prod_{i=1}^n(\\pi(x_i))^{y_i}(1-\\pi(x_i))^{1-y_i}$的学习就使用了极大似然估计 另外，两者在求解超参数的过程中，都可以使用梯度下降的方法 5月8日使用逻辑回归处理多分类问题，有哪些常见做法？ 使用什么办法来处理多分类的问题取决于具体问题的定义 如果一个样本之对应一个标签，我们可以假设每个样本属于不同标签的概率服从与几何分布，使用多项逻辑回归来进行分类$$h_{θ} = \\lceil \\begin{align}p(y=1|x;θ)\\p(y=2|x;θ)\\……\\p(y=k|x;θ)\\end{align}\\rceil = \\frac{1}{\\sum^k_{j=1} e^{θ^T_jx}}[\\begin{array} pp(y=1|x;θ)\\p(y=2|x;θ)\\……\\p(y=k|x;θ)\\end{array}]$$ 如果一个样本对应多个标签，我们可以训练k个二分类器的逻辑回归分类器，第i分类器用以区分每个样本是否可以归为第i类。在训练第i个分类器时，可以把样本标签分为第i类标签和非第i类标签 5月9日决策树有哪些常用的启发函数？ 决策树的目标时从一组样本数据中，根据不同的特征和属性，建立一棵树形的分类结构。我们希望它能尽可能的拟合数据，同时限制其复杂度以保证可泛化。 常用的决策树有ID3、CD4.5、CART等，它们使用的启发式函数各不相同 ID3——最大信息增益 对于样本集合D，类别数为K，则数据集的经验熵为$$H(D)=-\\sum^K_{k=1}\\frac{|C_k|}{|D|}log_2\\frac{|C_k|}{|D|}$$ 某个特征A对于数据集D的经验条件熵H(D|A)为$$H(D|A) = \\sum_{i=1}^n\\frac{|D_i|}{|D|}H(D_i)$$ 而信息增益为二者之差 $$g(D, A) = H(D) - H(D|A)$$ 在决策树的每个将要被划分的结点上，我们选则信息增益最大的特征作为标准来划分当前结点中的样本 C4.5——最大信息增益比 特征A对于数据集D的信息增益比为$$g_R(D, A) = \\frac{g(D, A)}{H_A(D)}$$ 其中，$H_A(D)$称为数据集D关于A的取值熵$$H_A(D)=-\\sum_{i=1}^n\\frac{|D_i|}{D}log_2\\frac{D_i}{D}$$ 在该决策树算法中，每次划分结点中的样本时，选择使信息增益比最大的特征作为标准 CART——最大基尼质数 基尼指数表示的是数据的纯度，与信息熵含义类似$$Gini(D)=1-\\sum_{k=1}^n (\\frac{|C_k|}{|D|})^2$$ 特征A对应的基尼指数表示为$$Gini(D|A) = \\sum_{i=1}^n\\frac{|D_i|}{|D|}Gini(D_i)$$ CART在每一次迭代中选择基尼指数最小的特征及其对应的切分点对样本集进行划分 结合上述的描述，我么可以总结出 ID3会倾向于取值较多的特征，因为信息增益反映的是给定条件后不确定性减小的程度，特征取之越多就意味着确定性越高 C4.5实际上是对ID3的优化，引入信息增益比，一定程度上对取值比较多的特征进行惩罚 从样本类型来看，ID3只能处理离散型变量，而C4.5和CART可以处理连续型变量 从应用角度来说，ID3和C4.5只能用于分类任务，而CART (classification and Regression Tree)可以用于分类和回归任务 5月10日如何对决策树进行剪枝？ 如果任由决策树生长，虽然在训练集上会表现的很好，但是会十分缺乏泛化能力 剪枝算法分为两类：预剪枝和后剪枝 预剪枝 核心思想是在树中结点进行扩展之前，先计算当前的划分能否带来模型泛化能力的提升，如果不能，则不再继续生长子树。一般有一下策略： 当树达到一定深度时，停止生长 当到达当前结点的样本数量小于某个阈值时，停止生长 计算每次分裂对测试集的准确度的提升，当提升程度小于指定阈值时，停止生长 后剪枝 允许决策树完全生长，然后自底向上进行剪枝 剪枝过程自底向上，计算是否删除当前子树，使用一个叶节点代替 后剪枝也能通过在测试集上的准确率进行判断，如果准确率提升，则进行剪枝。 相比于预剪枝，后剪枝得到的决策树会有更强的泛化能力，相对应的，也会花费更多的时间","categories":[{"name":"周知识总结","slug":"周知识总结","permalink":"http://zivblog.top/categories/%E5%91%A8%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://zivblog.top/tags/Artificial-Intelligence/"}]},{"title":"Leetcode之四数相加Ⅱ","slug":"Leetcode之四数相加Ⅱ","date":"2020-05-09T06:44:11.000Z","updated":"2020-07-06T05:27:37.154Z","comments":true,"path":"passages/leetcode-zhi-si-shu-xiang-jia-ii/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-si-shu-xiang-jia-ii/","excerpt":"4 Sum Ⅱ","text":"4 Sum Ⅱ 4 Sum Ⅱ code with Python title number：454 读题 给定四个列表A, B, C, D，计算有多少个元组(i, j, k, l)，使得A[i]+B[j]+C[k]+D[l]=0 所有的列表长度相同，且长度不超过500 示例： 12345678910111213输入：A = [1, 2]B = [-2, -1]C = [-1, 2]D = [0, 2]输出：2解释：两个元组如下:1. (0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 02. (1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0 思路一 按照常规的思路，遍历每种可能需要四层遍历，时间复杂度极高 核心思想是用空间换时间 将四个数组分为两组（例如：(A, B), (C, D)），先对求第一组中元素所有可能的和，使用字典存储，方面统计其出现的次数 再对第二组中元素所有可能的和，并得到的和是否与第一组中的和可以相加为0，若有，则取其出现的次数作为结果 123456789101112def fourSumCount(self, A: List[int], B: List[int], C: List[int], D: List[int]) -&gt; int: mapper = &#123;&#125; res = 0 for i in A: for j in B: mapper[i+j] = mapper.get(i+j, 0) + 1 for i in C: for j in D: res += mapper.get(-1*(i+j), 0) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之两数相加Ⅱ","slug":"Leetcode之两数相加Ⅱ","date":"2020-05-08T03:42:23.000Z","updated":"2020-07-06T05:21:29.255Z","comments":true,"path":"passages/leetcode-zhi-liang-shu-xiang-jia-ii/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-liang-shu-xiang-jia-ii/","excerpt":"Add Two Numbers Ⅱ","text":"Add Two Numbers Ⅱ Add Two Numbers Ⅱ code with Python title number：455 读题 给订两个非空链表来表示两个数。数字的最高位位于链表开始位置，每个节点只存储一位数字，将两数相加，返回一个新的链表 除了数字0之外，两个数组均不会以0开头 思路一 因为第一个结点表示的是最高位，而加法运算需要从低位开始，所以很容易想到借助栈来进行计算 另外要注意加法的进位即可 123456789101112131415161718192021222324252627282930313233343536373839def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode: # 将链表转化为列表 def L2S(l: ListNode) -&gt; List: stack , c = [], l while c: stack.append(c.val) c = c.next return stack stack1, stack2 = L2S(l1), L2S(l2) # 将两个列表补齐到相同长度，方便处理 diff = abs(len(stack1) - len(stack2)) stack1 = ([0]*diff + stack1 if len(stack1) &lt; len(stack2) else stack1) stack2 = ([0]*diff + stack2 if len(stack2) &lt; len(stack1) else stack2) # 对应相加 stack3 = [x+y for x, y in zip(stack1, stack2)] # 计算进位 up = 0 for i, val in enumerate(stack3[::-1]): index = len(stack3) - i - 1 up, stack3[index] = divmod(val + carry, 10) if carry and index == 0: # 最高位进位 stack3 = [1] + stack3 elif carry: # 进位 stack3[index - 1] += 1 # 转化为链表存储 result = ListNode(0) c = result for i in stack3: c.next = ListNode(i) c = c.next return result.next","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之分割等和子集","slug":"Leetcode之分割等和子集","date":"2020-05-07T04:26:44.000Z","updated":"2020-07-06T05:15:51.152Z","comments":true,"path":"passages/leetcode-zhi-fen-ge-deng-he-zi-ji/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-fen-ge-deng-he-zi-ji/","excerpt":"Partition Equal Subset Sum","text":"Partition Equal Subset Sum Partition Equal Subset Sum code with Python title number：416 读题 给定一个只包含正整数的非空数组，判断是否能够将这个数组分割成两个子集，使得两个子集的元素和相等 每个数组中的元素不会超过100，数组的大小不会超过200 思路一 可以看出，这是一道01背包问题的变种，为什么说这是一道01背包问题呢？我们来分析一下 先看一下01背包问题的描述： 一个可装载重量为 W 的背包和 N 个物品，每个物品有重量和价值两个属性。其中第 i 个物品的重量为 wt[i]，价值为 val[i]，现在让你用这个背包装物品，最多能装的价值是多少 再来看一下这个问题，我们可以转化为： 先对数组所有元素求和，得到sum 给一个可装载重量为 sum / 2 的背包和 N 个物品，每个物品的重量为 nums[i]。现在让你装物品，是否存在一种装法，能够恰好将背包装满？ 这样，我们直接使用之前的动态规划的分析框架进行分析 状态表示：$f(i, j)$ 集合：前i个物品，当前容量为j的情况下的所有选法 属性：能够恰好将背包装满 状态计算 以第i个元素是否选取作为分割标准，分割集合 若选取第i个元素，$f(i , j) = f(i-1, j-nums[i])$ 若不选取第i个元素，$f(i, j) = f(i-1, j)$ 即，$f(i, j) = f(i-1, j) | f(i-1, j-nums[i])$ 所求即为$f(n, sum/2)$，即前n个元素能够凑成sum/2，剩余的自然也是sum/2 123456789101112131415161718192021def canPartition(self, nums: List[int]) -&gt; bool: sum_ = sum(nums) if sum_ % 2 != 0: return False sum_ = sum_ // 2 # 多加一行一列，便于处理 dp = [[False]*(sum_+1) for _ in range(len(nums))] dp[0][0] = True for i in range(1, sum_+1): if nums[0] == i: dp[0][i] = True break for i in range(1, len(nums)): for j in range(sum_+1): if j &gt;= nums[i]: dp[i][j] = dp[i-1][j] or dp[i-1][j-nums[i]] else: dp[i][j] = dp[i-1][j] return dp[-1][-1]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之常数时间内插入删除和获取随机元素","slug":"Leetcode之常数时间内插入删除和获取随机元素","date":"2020-05-06T12:30:30.000Z","updated":"2020-07-06T05:09:39.263Z","comments":true,"path":"passages/leetcode-zhi-chang-shu-shi-jian-nei-cha-ru-shan-chu-he-huo-qu-sui-ji-yuan-su/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-chang-shu-shi-jian-nei-cha-ru-shan-chu-he-huo-qu-sui-ji-yuan-su/","excerpt":"Insert Delete GetRandom O(1)","text":"Insert Delete GetRandom O(1) Insert Delete GetRandom O(1) code with Python titile number：380 读题 设计以个支持在平均时间复杂度O(1)下，执行以下操作的数据结构： insert(val)：当元素val不存在时，向集合中插入该项 remove(val)：元素val存在时，从集合中移除该项 getRandom()：随机返回现有集合中的一项，每个元素应该有相同道德概率被返回 思路一 题目要求即思路，说一下几个要点 存储结构：组合使用哈希表和数组 插入操作：用哈希表判断元素是否存在，数组记录值（插入的元素添加到数组末尾），哈希表记录索引 删除操作：用哈希表来定位，把数组最后一个元素取下来顶替被删除元素位置 取随机数：随机从数组中挑选一个元素 123456789101112131415161718192021222324252627282930313233343536class RandomizedSet: def __init__(self): \"\"\" Initialize your data struct here \"\"\" self.d = &#123;&#125; self.l = [] def insert(self, val: int) -&gt; bool: \"\"\" Inserts a value to the set. Returns true if the set did not already contain the specified element. \"\"\" if val in self.d: return False else: self.d[val] = len(self.l) self.l.append(val) return True def remove(self, val: int) -&gt; bool: \"\"\" Removes a value from the set. Returns true if the set contained the specified element. \"\"\" if val in self.d: self.d[self.l[-1]] = self.d[val] self.l[self.d.pop(val)] = self.l[-1] self.pop() return True else: return False def getRandom(self) -&gt; int: \"\"\" Get a random element from the set. \"\"\" return self.l[random.randint(0, len(self.l)-1)]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之有序矩阵中第k小的元素","slug":"Leetcode之有序矩阵中第k小的元素","date":"2020-05-05T12:50:50.000Z","updated":"2020-07-06T05:30:34.173Z","comments":true,"path":"passages/leetcode-zhi-you-xu-ju-zhen-zhong-di-k-xiao-de-yuan-su/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-you-xu-ju-zhen-zhong-di-k-xiao-de-yuan-su/","excerpt":"Kth Smallest Element in a Sorted Matrix","text":"Kth Smallest Element in a Sorted Matrix Kth Smallest Element in a Sorted Matrix code with Python title number：378 读题 给定一个N*N的矩阵，其中每行和每列元素均按升序排序，找到矩阵中第K小的元素 注意是排序后的第k小元素，而不是第k个不同的元素 示例： 123456matrix &#x3D; [[1, 3, 5], [10, 11, 13], [12, 13, 15]]k &#x3D; 8返回 13 思路一 直觉上可以遍历读取整个矩阵，再进行排序，最后读取第k个元素即可 123456789def kthSmallest(self, matrix: List[List[int]], k: int) -&gt; int: arr = [] for i in range(matrix): arr.extend(matrix[i]) arr.sort() return arr[k-1] 思路二 既然使用了排序算法，那么可以更进一步 利用排序算法，大顶堆 但是使用排序算法显然没有利用有序矩阵这一信息 下面介绍一下值域二分法 首先，根据矩阵的性质，我们的矩阵元素的值域为[l, r]，其中l = matrxi[0][0], r = matrix[-1][1] 于是，我们就可以对该区间进行二分，mid = (l+r) / 2 统计矩阵中小于mid的元素个数，记为less_mid 如果less_mid &lt; k，那么[l , mid]之间包含的元素小于k，即第k个元素一定不在其中，而一定在[mid, r]中，此时将l = mid 如果less_mid &gt;= k，那么[l, mid]中的元素个数大于等于k，即第k小的元素一定在[l, mid]中，此时r = mid 只与如何统计小于等于mid的元素个数，利用矩阵本身的性质，从左下角开始枚举 12345678910111213141516171819202122232425def getLowCnt(self, matrix, row, col, mid): i, j = row-1, 0 cnt = 0 while i &gt;= 0 and j &lt; col: # 若当前值小于mid，则该列中，当前值上方的元素均小于mid if matrix[i][j] &lt;= mid: cnt = cnt + i + 1 j += 1 else: i -= 1 return cntdef kthSmallest(self, matrix: List[List[int]], k: int) -&gt; int: # k恒为有效值，无需判断 row, col = len(matrix), len(matrix[0]) l, r = matrix[0][0], matrix[-1][-1] while l &lt; r: mid = (l + r) &gt;&gt; 1 if self.getLowCnt(matrix, row, col, mid) &lt; k: l = mid + 1 else: r = mid return l 思路二应重点掌握 但从提交结果来看，第一种的时空复杂度更低","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之水壶问题","slug":"Leetcode之水壶问题","date":"2020-05-04T01:05:20.000Z","updated":"2020-07-06T05:27:29.922Z","comments":true,"path":"passages/leetcode-zhi-shui-hu-wen-ti/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-shui-hu-wen-ti/","excerpt":"Water and Jug Problem","text":"Water and Jug Problem Water and Jug Problem code with Python title number：365 读题 BFS 有两个容量分别为x升和y升的水壶以及无线多的水 判断是否能通过使用这两个水壶，得到恰好为z升的水 允许的操作： 装满任意一个水壶 清空任意一个水壶 从一个水壶向另一个水壶倒水，知道装满或倒空 思路一 将两个水壶视作两个状态，对水壶的操作视作改变状态 初始状态为(0, 0)，目标状态为(z, any)或(any, z) 每一时刻的状态由x和y决定 把X壶的水灌进Y壶，直至灌满或倒空 把Y壶的水灌进X壶，直至灌满或倒空 把X壶灌满 把Y壶灌满 把X壶倒空 把Y壶倒空 通过其中一个示例来模拟该过程 输入：x = 3, y= 5, z = 4输出：True (0, 0) -&gt; (0, 5) -&gt; (3, 2) -&gt; (0, 2) -&gt; (2, 0) -&gt; (2, 5) -&gt; (3, 4) -&gt; True 1234567891011121314151617181920212223242526def canMeasureWater(self, x: int, y : int, z: int) -&gt; bool: if x + y &lt; z: return False queue = [(0, 0)] seen = set((0, 0)) while len(queue) &gt; 0: a, b = queue.pop(0) if a == z or b == z or a + b == z: return True states = set() # 当前所有可能得到的的状态 states.add((x, b)) states.add((a, y)) states.add((0, b)) states.add((a, 0)) states.add((min(x, b+a), 0 if b &lt; x - a else b- (x-a))) states.add((0 if a + b &lt; y else a - (y - b), min(b+a, y))) for state in states: if state in seen: continue queue.append(state) seen.add(state) return False 思路二 数学方法：求最大公约数 先介绍一个定理，裴蜀定理 对任意两个整数a、b，设d是它们的最大公约数，那么关于x和y的线性方程ax+by=m，有整数解(x, y)当且仅当m是d的整数倍 用示例一演示该定理的使用： x = 3, y = 5, z= 4 3*3 - 1*5 = 4 -&gt; 3*x - 1*y = z 具体过程为： 倒满a（1）将a倒到b再次倒满a（2）再次将a倒到b（a这个时候还剩下1升）倒空b（-1）将剩下的1升倒到b将a倒满（3）将a倒到bb此时正好是4升 我们只需计算出x和y的最大公约数，再判断z是否是该最大公约数的整数倍即可 123456789101112131415161718def canMeasureWater(self, x: int, y: int, z: int) -&gt; bool: if x + y &lt; z: return False if z == 0: return True if x == 0: return y == z if y == 0: return x == z def getGCD(x, y): min_ = min(a, b) while min_: if a % min_ == 0 and b % min_ == 0: return min_ min_ -= 1 return z % getGCD(x, y) == 0","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之递增的三元子序列","slug":"Leetcode之递增的三元子序列","date":"2020-05-03T02:26:32.000Z","updated":"2020-07-06T05:11:02.700Z","comments":true,"path":"passages/leetcode-zhi-di-zeng-de-san-yuan-zi-xu-lie/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-di-zeng-de-san-yuan-zi-xu-lie/","excerpt":"Increasing Triplet Subsequence","text":"Increasing Triplet Subsequence Increasing Triplet Subsequence code with Python title number：334 读题 给定一个未排序的子数组，判断数组中是否存在长度为3的递增子序列 所谓递增子数组，定义如下： 如果存在这样的 i, j, k, 且满足 0 ≤ i &lt; j &lt; k ≤ n-1，使得 arr[i] &lt; arr[j] &lt; arr[k] ，返回 true ; 否则返回 false 。 要求算法复杂度为O(n)，空间复杂度为O(1) 思路一 由于时空复杂度的限制，暴力算法就不用考虑了 再者，结合之前的经验，子序列 != 子串。所以，满足条件的三个元素不一定连续，也不适合使用滑动窗口的思想 我们的目的是依次找到三个变量，这三个变量的大小是递增的，即可 所以，我们的做法是，遍历，维护三个变量min_one, min_two, min_thr,分别对应最小值，第二小值，第三小值。 只要我们能够在遍历的过程中将这三个变量填满，即认为可以找到满足条件的子序列 1234567891011121314def increaseTriplet(self, nums: List[int]) -&gt; bool: if len(nums) &lt; 3: return False min_one, min_two, min_thr = float(\"inf\"), float(\"inf\"), float(\"inf\") for i in range(len(nums)): if nums[i] &lt;= min_one: min_one = nums[i] elif nums[i] &lt;= min_two: min_two = nums[i] else: min_thr = nums[i] return min_one != float(\"inf\") and min_two != float(\"inf\") and min_thr != float(\"inf\")","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"周知识总结（4.27-5.3）","slug":"周知识总结（4-27-5-3）","date":"2020-05-03T00:49:34.000Z","updated":"2020-07-06T05:49:57.848Z","comments":true,"path":"passages/zhou-zhi-shi-zong-jie-4-27-5-3/","link":"","permalink":"http://zivblog.top/passages/zhou-zhi-shi-zong-jie-4-27-5-3/","excerpt":"文章部分内容来自《百面机器学习》","text":"文章部分内容来自《百面机器学习》 4月27日为什么评估标准对于机器学习很重要？ 只有选择与问题相匹配的评估方法，才能快速地发现模型选择或训练过程中出现的问题，迭代地对模型进行优化。 模型评估主要分为离线评估和在线评估两个阶段。针对分类、排序、回归、序列预测等不同类型的机器学习问题，评估指标的选择也有所不同。 知道每种评估指标的精确定义、有针对性地选择合适的评估指标、根据评估指标的反馈进行模型调整。 4月28日简要分析准确率作为评估标准的优劣？ 准确率（Accuracy） 指正确分类的样本占总样本个数的比例 $$Accuracy = \\frac{n_{correct}}{n_{total}}$$ 准确率是分类问题中最简单、最直接的评价标准。但是存在明显的缺陷： 例如当负样本占99%时，分类器将所有的样本都预测成负样本也能获得99%的准确率。也即是当不同类别的样本不均衡时，占比大的样本会模型造成很大的影响。 相对应的，我们可以采取更为有效的平均准确率（即每个类别下的样本准确率的算数平均）作为模型评估的指标 4月29日试对比精确率与召回率？ 精确率是指分类正确的正样本个数占分类器判定为正样本的样本个数的比例 $$Precision = \\frac{n_{分类为正且正确}}{n_{判定为正}}$$ 召回率是指分类正确的正样本个数占真正的正样本个数的比例 $$Recall = \\frac{n_{分类为正且正确}}{n_{实际为正}}$$ 两种指标既矛盾又统一： 为了提高Precision，分类器需要尽量在“更有把握”的时候才会将样本预测为正样本；但此时会由于过于保守而漏掉许多“没有把握”的正样本，导致Recall值降低 可以认为召回率越低越保守，从而精确率会越高 有时可以通过结合两种指标来进行分析，例如：P-R曲线 即横轴是召回率，纵轴是精确率 对于该曲线来说，线上的每一个点都表示在某一阈值下，模型将大于该阈值的结果判定为正样本，小于该阈值的判定为负样本，以此计算得到的精确率和召回率 整条曲线是通过将阈值从高到低移动而形成的 可见，当召回率接近0时，模型A的精确率高达90%，模型B的精确率高达100%； 这表明，模型预测为正样本的样本确实是真正的正样本 还有一种指标叫做F1-score，同样是结合了定义为：$$F1score = \\frac{2*precision*recall}{precision+recall}$$ 4月30日试分析平方差误差带来的问题？ 平方差误差，定义为： $$RMSE = \\sqrt{\\frac{\\sum_{i=1}^n (y_i - y^*_i)^2}{n}}$$ 一般来说，RMSE用于反映回归模型预测值与真实值的偏离程度，如果存在个别偏离程度非常大的离群点，即使离群点的数量非常少，也会让该指标变得很差。 如何处理该问题呢？ 若认为利群点应该剔除，则在数据预处理的过程中将离群的“噪声”过滤掉 若认为离群点对于当前场景是合理的存在，则调整模型，将离群点建模进去 找到更合适的指标来评估模型，例如平均绝对百分比误差（Mean Absolute Percent Error, MAPE） $$MAPE = \\sum_{i=1}^n |\\frac{y_i - y^_i}{y_i}|\\frac{100}{n}$$ 相比于RMSE，MAPE将每个点的误差进行了归一化，降低了个别利群点带来的绝对误差的影响 5月1日什么是ROC曲线？ ROC曲线是Receiver Operating Characteristic Curve的简称 横坐标为假阳性率，FPR，$FPR = \\frac{FP}{N} = \\frac{N个负样本中被预测为正样本的隔宿}{真实的负样本的个数}$ 纵坐标为真阳性率，TPR，$TPR = \\frac{TP}{P}=\\frac{P个正样本中被预测为正样本的个数}{真实的正样本的数量}$ ROC曲线是通过不断移动分类器的“截断点（分类标准）”来生成曲线的关键点 当截断点选择为正无穷时，模型把全部样本预测为负例，此时FP和TP都为0，FPR和TPR也都为0，即曲线的第一个坐标。 依次调整截断点，即可得到整条曲线 什么事AUC？ AUC，Area Under ROC，故名思义，指的是ROC曲线下的面积。 该值能够量化的反映使用ROC衡量出的模型性能 AUC越大，说明分类器越可能把真正的正样本预测出来，即分类器 性能越好 5月2日ROC曲线与P-R曲线的对比？ 两种曲线都是用来评估分类和排序模型的指标。 相比于P-R曲线，ROC曲线能够在正负样本的分布发生变化时，保持形状不变。即ROC曲线能够尽量降低不同测试集带来的干扰，更加客观的衡量模型本身的性能 所以ROC曲线的使用场景更多 5月3日余弦相似度与欧式距离的比较？ 在机器学习问题中，通常将特征表示为向量的形式，所以在分析两个向量之间的相似性时常常使用余弦相似度来表示 $$cos(A, B) = \\frac{A \\cdot B}{||A||_2||B||_2}$$ 余弦相似度关注的是两个向量之间的角度关系，并不关注其绝对大小 如果两个文本的内容相近，但是长度相差很大，此时如果使用词频或者词向量作为特征，它们在特征空间中的欧式距离会很大。但是用余弦相似度，就能比较正确地反映真实的相似度关系 如果向量的模长是经过归一化的，此时欧氏距离与余弦相似度得到的结果是相同的 总得来说，欧式距离体现数值上的绝对差异，余弦相似度体现方向上的相对差异，两种方法并没有高下之分。具体应用要依照实际场景选择。","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之奇偶链表","slug":"Leetcode之奇偶链表","date":"2020-05-02T00:38:58.000Z","updated":"2020-07-06T05:24:14.733Z","comments":true,"path":"passages/leetcode-zhi-qi-ou-lian-biao/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-qi-ou-lian-biao/","excerpt":"Odd Even Linked List","text":"Odd Even Linked List Odd Even Linked List code with Python title number：328 读题 给定一个单链表，把所有的奇数结点和偶数结点分别排在一起 这里的奇数偶数结点指的是结点编号的奇偶性 请使用原地算法完成 思路一 首先想到的是，遍历一遍链表 将奇数结点放到一起 将偶数结点放到一起 最后将两个子链表拼接起来 但题目要求的是原地算法，所以要转化思路 思路二 遍历一次，同时修改两个结点，具体而言： 设置三个指针，odd、even、evenhead，分别用于知识奇数子链的结尾、偶数子链的结尾、偶数子链的开头 具体实现见代码 1234567891011121314151617class ListNode: def __init__(self, x): self.val = x self.next = Nonedef oddEvenList(self, head: ListNode) -&gt; ListNode: if head == None: return head odd, evenhead, even = head, head.next, head.next while even != None and even.next != None: odd.next = even.next odd = odd.next even.next = odd.next even = even.next odd.next = evenhead return head","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之零钱兑换","slug":"Leetcode之零钱兑换","date":"2020-05-01T02:28:43.000Z","updated":"2020-07-06T05:22:00.060Z","comments":true,"path":"passages/leetcode-zhi-ling-qian-dui-huan/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-ling-qian-dui-huan/","excerpt":"Coin Change","text":"Coin Change Coin Change code with Python title number：322 读题 给定不同面额的硬币coins和一个总金额amount 计算可以凑成总金额所需的最少的硬币个数，每种硬币可以无限量使用 若没有凑成总金额的方案，则返回-1 思路一 本题十分类似于之前的完全平方数 贪心策略在这里是行不通的 思路二 动态规划 状态表示：$f(i)$ 集合：组成i块钱可行的硬币组合的集合 属性：集合中使用硬币数最少的方案 状态计算 类似于完全背包问题，每种面额的硬币可以无限使用 完全背包问题是在有限空间下求最大价值 本题是在给定金额下求最小硬币数 以第最后一种硬币取不取为集合分割标准 最后一种硬币不取，则f(i) 最后一种硬币取，则f(i-coni[j]) + 1 即，$f(i) = min(f(i), f(i-coins[j])+1)$ 最终答案为：$f(amount)$ 1234567891011def coinChange(self, coins: List[int], amount: int) -&gt; int: # 多申请一个空间，方便处理 dp = [amount+1]*(amount+1) dp[0] = 0 for i in range(1, amount+1): for j in range(len(coins)): if i &gt; coins[j]: dp[i] = min(dp[i], dp[i-coins[j]]+1) return -1 if dp[-1]==amount+1 else dp[-1]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之最佳买卖股票时机含冷冻期","slug":"Leetcode之最佳买卖股票时机含冷冻期","date":"2020-04-30T02:40:31.000Z","updated":"2020-07-06T05:33:44.639Z","comments":true,"path":"passages/leetcode-zhi-zui-jia-mai-mai-gu-piao-shi-ji-han-leng-dong-qi/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zui-jia-mai-mai-gu-piao-shi-ji-han-leng-dong-qi/","excerpt":"Best Time to Buy and Sell Stock with Cooldown","text":"Best Time to Buy and Sell Stock with Cooldown Best Time to Buy and Sell Stock with Cooldown code with Python title number：309 读题 给定一个整数数组，其中第i个元素代表了第i天的股票价格 设计一个算法计算出最大利润。 在满足约束条件下，你可以尽可能地完成更多的交易 注意： 不能多次参与多笔交易 卖出股票后，无法在第二天买入股票（冷冻期为1天） 例如： 输入：[1, 2, 3, 0, 2] 输出：3 解释：对应的交易状态为[买入, 卖出, 冷冻期, 买入, 卖出] 思路一 股票问题即动态规划问题 相比与最简单的股票问题，当前问题存在卖出股票后有一天的时间不允许买入股 因此当前状态变为了三种，即[卖出、不操作、买入]。所以使用三维的数组，dp[i][k][0]或dp[i][k][1]，其中i为第i天，k = [0:不操作, 1:卖出, 2:买入]，最后一维[0:当前不持有物品, 1:当前持有物品] 状态表示：$f(i, k, 0/1)$ 集合：第i天所有买卖股票方案的利润的集合 属性：所有方案下取得的最大利润 状态计算 有六种状态（其中有两种情况不可能存在） 当前不操作且无物品，$f(i, 0 ,0)$ 前一天不操作且无物品，$f(i-1, 0, 0)$ 前一天卖出物品，$f(i-1, 1, 0)$ 所以，$f(i, 0, 0) = max[f(i-1, 0, 0), f(i-1, 1, 0)]$ 当前不操作且有物品 前一天不操作且有物品，$f(i-1, 0, 1)$ 前一天买入后持有物品，$f(i-1, 2, 1)$ 所以，$f(i, 0, 1) = max[f(i-1, 0, 1), f(i-1, 2, 1)]$ 当前卖出后无物品 前一天买入物品，$f(i-1, 2, 1)+prices[i]$ 前一天持有物品，$f(i-1, 0, 1)+pries[i]$ 所以，$f(i, 1, 0) = max[f(i-1,2,1)+prices[i], f(i-1, 0, 1)+prices[i]]$ 当前买入后有物品 前一天不进行操作且不持有物品，$f(i-1, 0, 0)-prices[i]$ 所以，$f(i, 2, 1) = f(i-1, 0, 0) - prices[i]$ 当前卖出后持有物品 该状态不存在 当前买入后不持有物品 该状态不存在 最后一天一定为不操作无物品和卖出物品后无物品的最大值，即： $$max[f(len(prices)-1, 0, 0), f(len(prices)-1, 1, 0)]$$ 1234567891011121314151617181920212223242526272829303132def maxProfit(self, prices: List[int]) -&gt; int: def make_dp(n): dp = [0]*(n+1) for i in range(n+1): dp[i] = [0]*3 for i in range(n+1): for j in range(3): dp[i][j] = [0]*2 return dp if len(prices) == 0: return 0 dp = make_dp(len(prices)) # 初始化 dp[0][0][0] = 0 dp[0][2][1] = -prices[0] dp[0][0][1] = -float('inf') dp[0][1][0] = -float('inf') dp[0][1][1] = -float('inf') dp[0][2][0] = -float('inf') for i in range(1, len(prices)): dp[i][0][0] = max(dp[i-1][0][0], dp[i-1][1][0]) dp[i][0][1] = max(dp[i-1][0][1], dp[i-1][2][1]) dp[i][1][0] = max(dp[i-1][2][1], dp[i-1][0][1]) + prices[i] dp[i][2][1] = dp[i-1][0][0]-prices[i] return max(dp[len(prices)-1][0][0], dp[len(prices)-1][1][0]) 使用Python解决该题的时候，注意在创建多维数组时的方式 如果使用list comprehension会产生浅拷贝的问题，即dp = [[[0]*(len(prices)+1)]*3]*2的方式建数组","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之完全平方数","slug":"Leetcode之完全平方数","date":"2020-04-29T06:23:54.000Z","updated":"2020-07-06T05:28:39.490Z","comments":true,"path":"passages/leetcode-zhi-wan-quan-ping-fang-shu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-wan-quan-ping-fang-shu/","excerpt":"Perfect Squares","text":"Perfect Squares Perfect Squares code with Python title number：279 读题 给定一个正整数n，找到若干平方数，使这些完全平方数的和等于n，输出使用的完全平方数的个数 使组成和的完全平方数的个数最少，完全平方数可重复使用 思路一 首先说一下，一开始的想法是 生成一个完全平方数的列表，然后从中挑选尽可能大的数来用 但是这种想法是有问题的，虽然直觉上觉得每次取尽可能大的数会减少使用的数字的数量，这种想法的缺陷是会在后期使用多次的较小的数字，从而直接将使用的数字个数变多 例如： 对于n = 12，使用这种算法得到的序列为[9, 1, 1, 1] 而实际上[4, 4, 4]的序列才是最合适的 贴一下代码吧，但是不要用 12345678910111213141516171819def numSquares(self, n: int) -&gt; int: def gen_square_list(n): # 生成合适的完全平方素列表，返回降序列表 square, i = [], 1 while i*i &lt;= n: square.append(i*i) i += 1 return square[::-1] result, i = [], 0 square = gen_square_list(n) while n &gt; 0: if n &gt;= square[i]: result.append(square[i]) n -= square[i] else: i += 1 return result 思路二 暴力解法 完全平方数列表 + n 求出所有的组合，取其中最短的组合 1234567891011121314151617181920212223def numSquares(self, n: int) -&gt; int: def gen_square_list(n): # 生成合适的完全平方素列表，返回降序列表 square, i = [], 1 while i*i &lt;= n: square.append(i*i) i += 1 return square[::-1] square = gen_square_list(n) def minNumSquares(n): if n in square: return 1 min_num = float('inf') for s in square: if n &lt; s: break new_num = minNumSquare(n - s) + 1 min_num = min(min_num, new_num) return min_num return minNumSquares(n) 在题目没有给出范围时，使用暴力解法通常是会超时的 毫无意外，超时了 思路三 使用暴力枚举之所以会超时是因为我们在其中进行了多次的重复计算，所以动态规划登场 在使用动态规划之前，我们需要预先计算小于给定数字的完全平方数列表 状态表示（$f(i)$） 集合：数字i的平方数组合方案使用平方数的个数集合 属性：集合中使用平方数最少的方案 状态计算 以是否使用小于等于i的最大平方数作为集合的划分标准 假设符合条件的最后一个数字为k 若使用最后一个数字，则表达式为f(i) 若不使用最后一个数字，则表达式为f(i-k) 综上，状态计算表达式为：$f(i) = min(f(i), f(i-k)+1)$ 结果即$f(n)$，即数字n的平方数组合中使用平方数最少的个数 12345678910111213def numSquares(self, n: int) -&gt; int: square_nums = [i**2 for i in range(0, int(math.sqrt(n))+1)] # 这里多申请一个位置，用于处理n-k==0的情况 dp = [float('inf')] * (len(n)+1) dp[0] = 0 for i in range(1, n+1): for s in square_nums: if i &lt; s: break dp[i] = min(dp[i], dp[i-s] + 1) return dp[-1] 思路四 贴一个比较有趣的解法，是一个基于数学定理的解法，来自本题的题解区","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之搜索二维矩阵Ⅱ","slug":"Leetcode之搜索二维矩阵Ⅱ","date":"2020-04-28T02:07:54.000Z","updated":"2020-07-06T05:27:47.322Z","comments":true,"path":"passages/leetcode-zhi-sou-suo-er-wei-ju-zhen-ii/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-sou-suo-er-wei-ju-zhen-ii/","excerpt":"Search a 2D Matrix Ⅱ","text":"Search a 2D Matrix Ⅱ Search a 2D Matrix Ⅱ code with Python title number：240 读题 编写一个高效的算法来搜索一个m*n的矩阵中的一个目标值 矩阵具有以下的特性： 每行的元素从左到右升序排列 每列的元素从上到下升序排列 思路一 不巧，该题目在准备研究生初试的时候遇到过 说一下思路： 第一行中的每个位置的元素都是对应列中最小的元素 最后一行的元素从右向左遍历，如果target大于当前值，则行号+1；如果target小于当前值，则列号-1 直到找到target，返回True，或遍历完没发现对应元素，返回False 123456789101112131415161718192021def searchMatrix(self, matrix, target): \"\"\" :type matrix: List[List[int]] :type target: int :rtype: bool \"\"\" if len(matrix) == 0: return False i, j = len(matrix)-1, 0 while i &gt;= 0 and j &lt; len(matrix[0]): if matrix[i][j] == target: return True # target大于当前元素，列号+1 if matrix[i][j] &lt; target: j += 1 # target小于当前元素，行号-1 if matrix[i][j] &gt; target: i -= 1","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之除自身以外数组的乘积","slug":"Leetcode之除自身以外数组的乘积","date":"2020-04-27T05:31:32.000Z","updated":"2020-07-06T05:10:15.101Z","comments":true,"path":"passages/leetcode-zhi-chu-zi-shen-yi-wai-shu-zu-de-cheng-ji/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-chu-zi-shen-yi-wai-shu-zu-de-cheng-ji/","excerpt":"Product of Array Except Self","text":"Product of Array Except Self Product of Array Except Self code with Python title number：238 读题 给定一个长度为n的整数数组nums，其中n &gt; 1，返回输出数组output，其中output[i]等于nums中除nums[i]之外其余个元素的乘积 不允许使用除法 请尝试在常数空间复杂度内完成这个题目 思路一 常规思路为双重遍历 第一轮遍历进行数组的遍历 第二轮遍历除当前元素以外的数组，并进行计算 12345678910def productExceptSelf(self, nums: List[int]) -&gt; List[int]: output = [] for i in range(len(nums)): temp = nums[:i]+nums[i+1:] temp_product = temp[0] for j in range(len(temp)): temp_product *= temp[j] output.append(temp_product) return output 意料之中，超时 思路二 由于输出数组中每个位置的值都要用到其他元素只对数组进行一次遍历完成该任务是不可能的，我们的工作是尽可能的减少遍历的次数 我们正向进行一次遍历，维护一个数组，第i项代表前i个元素的乘积 之后再反向遍历一次数组，同样维护一个数组，第i项代表前i个元素的乘积 之后再将两个数组相乘，即为结果 这种做法本质上就是分别计算了第i个元素前面和后面的乘积，最后再结合 事实上，并不需要使用第二个数组，在进行第二遍遍历的时候，只需要对第一个数组的对应位置进行修改即可 123456789101112131415def productExceptSelf(self, nums: List[int]) -&gt; List[int]: output = [0]*len(nums) temp = 1 # 正向遍历 for i in range(len(nums)): output[i] = temp temp *= nums[i] temp, n = 1, len(nums)-1 # 反向遍历 while n &gt;= 0: output[n] *= temp temp *= nums[n] n -= 1 return output","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之二叉树的最近公共祖先","slug":"Leetcode之二叉树的最近公共祖先","date":"2020-04-26T08:02:59.000Z","updated":"2020-07-06T05:12:33.721Z","comments":true,"path":"passages/leetcode-zhi-er-cha-shu-de-zui-jin-gong-gong-zu-xian/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-er-cha-shu-de-zui-jin-gong-gong-zu-xian/","excerpt":"Lowest Common Ancestor of a Binary Tree","text":"Lowest Common Ancestor of a Binary Tree Lowest Common Ancestor of a Binary Tree code with Python title number：236 读题 给定一棵二叉树，找到树中两个指定结点的最近公共祖先 结点p和q为不同结点，并且必定存在于给定的二叉树中 最近公共祖先 对于有根数T的两个结点p、q，最近公共祖先表示为一个结点x，满足x是p、q的祖先，并且x的深度尽可能大 一个节点可以是自己的祖先 思路一 二叉树树是一种递归的数据结构，所以解决二叉树问题递归应该是我们首先需要想到的解决方法 不错，这里介绍的是一种递归方法 在当前结点的左右子树中分别查找p和q，如果p没有在左子树中，那么它一定在右子树中，反之依然 分别查找左右子树，返回查找到的结点 这种方法的原理在于： 树是一种递归数据结构 p和q是不同的结点，并且必定存在于一个结点的左右子树中 12345678910111213141516def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -&gt; 'TreeNode': if not root or root == p or root == q: return root # 分别去左右子树中找 left = self.lowestCommonAncestor(root.left, p, q) right = self.lowestCommonAncestor(root.right, p, q) # 左子树中没找到，找右子树 if not left: return right # 右子树中没找到，找左子树 if not right: return left # 分别一个，返回当前子树的root else: return root 欢迎来信交流||指教。","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"周知识总结（4-20-2-26）","slug":"周知识总结（4-20-2-26）","date":"2020-04-25T03:09:17.000Z","updated":"2020-04-26T07:25:59.307Z","comments":true,"path":"passages/zhou-zhi-shi-zong-jie-4-20-2-26/","link":"","permalink":"http://zivblog.top/passages/zhou-zhi-shi-zong-jie-4-20-2-26/","excerpt":"主要内容来自《百面机器学习》","text":"主要内容来自《百面机器学习》 4月20日 对于一个机器学习问题，数据和特征往往决定了结果的上限，而模型、算法的选择及优化则在逐步接近这个上线 两种常用的数据类型 结构化数据 可以看作关系型数据库的一张表，每列都有定义，称之为特征；每行表示一个样本 非结构化数据 主要包括文本、图像、音频、视频数据，最大的特点是其包含的信息无法使用一个简单的数值表示，也没有清晰的类别定义且每条数据的大小各不相同 为什么要进行特征归一化？ 特征归一化主要是为了消除特征之间的纲量影响 直观来说，如果要分析一个人的身高和体重对健康的影响，身高的单位为米，体重的单位为千克。那么两个特征的数值范围就会有较大的差别，身高[1.6, 1.8]，体重[50, 100]。如果直接使用这种样本，那么结果一定会倾向与数值差别比较大的体重特征。 想要更为准确的结果，就需要进行特征归一化 另一角度来说，在学习速率相同的情况下，两个取值范围不同的特征的下降速度是不同的，这就会导致在进行梯度下降时花费更多的时间才能达到最优解 常用特征归一化的方法？ 数值类型的特征做归一化可以将所有的特征都统一到一个大致相同的数值区间内。 线性函数归一化（Min-Max Scaling） 对原始数据进行线性变换，使结果映射到[0, 1]的范围内 $$X_{norm} = \\frac{X - X_{min}}{X_{max} - X_{min}}$$ 零均值归一化（Z-Score Normalization） 将原始数据映射到均值为0，标准差为1的分布上 $$z = \\frac{x - \\mu}{\\delta}$$ 什么样的模型需要进行归一化呢？ 数据归一化并不是万能的，通过梯度下降法求解的模型通常是需要归一化的 包括：线性回归、逻辑回归、支持向量机、神经网络等 一个典型的无需进行数据归一化的模型是：决策树 4月21日类别特征一般有什么处理方式？ 类别型的特征，是指一般只在有限的选项内取值的特征 类别性特征原始输入通常是字符串的形式，对于大多数模型来说，无法直接处理。常见的处理方法如下 序号编码（Ordinal Encoding） 通常用于处理类别间具有大小关系的数据，例如成绩，可以分为高、中、低三档，分别以3、2、1表示 独热编码（One-hot Encoding） 通常用于处理类别间不具大小关系的特征，例如血型，表示成一个4维的稀疏向量 二进制编码（Binary Encoding） 分为两步，显示用序号编码给每个类别赋予一个类别ID，然后将类别ID对应的二进制用作特征表示 4月22日什么是组合特征？ 为了提高复杂关系的拟合能力，在特征工程中常常会把一阶离散特征两两组合，构成高阶组合特征。简言之，提高表达能力 但是随意的进行特征的组合也会带来许多问题，而且并不是所有的特征组合都是有意义的，我们需要找到一种有效的方法来帮助我们找到对应有效的特征组合。 基于决策树的特征组合寻找方法？ 根据原始输入和标签构建决策树 每一条从根节点到叶节点的路径都可以看作一种特征组合方式 若样本为[年龄:28, 性别:女, 用户类型:免费, 物品类型:护肤]，则得到的变为(1, 1, 0, 0)。即同时满足(1)、(2)，但不满足(3)、(4) 4月23日如何进行文本数据表示？ 文本数据是一种重要的非结构话数据，如何有效进行文本数据的表示意义深远。 文本数据的表示并不能单独的来看 词袋模型（Bag of Words） 最基础的文本表示模型就是词袋模型 将每篇文章看成一袋词，并忽略每个词出现的顺序 具体而言， 将整段文本以词为单位切分开，真个文章可以表示成一个长向量，向量中的每一维表示一个单词。 TF-IDF 用于计算每个词在文本中的重要程度$$TF-IDF = \\frac{单词t在文档d中出现的频率}{log \\frac{文章总数}{包含单词t的文章总数+1}}$$ 计算得到每个词的权值放入词袋模型中对应单词的位置 直观来说，如果一个单词在非常多的文章中出现，那么该单词就是一个比较通用的词汇，并不具有特殊性 N-gram 有时候将文章进行单词级别的划分并不是很合理（例如英文中的词组） 可以将连续出现的n个词组成的词组作为一个单独特征放到向量表示中去，即N-gram模型 主题模型（Topic Model） 用于从文本库中发现有代表性的主题 词嵌入模型（Word Embedding） 词嵌入模型能够将词向量化，核心思想是讲每个词都映射成低维空间上的一个稠密向量 由于词嵌入将每个词映射成为一个K维的向量，一个文章如果有N个词，就可以用一个N*K维的矩阵来表示这篇文档，但这样太过底层。 通常的做法是在此基础上加工出更高层的特征，而深度学习模型正好为我们提供了一种自动地进行特征工程的方式，网络中的每层都相当于对应不同层次的抽象特征 常见的模型有CBOW、Skip-gram。其中前者是根据上下问预测当前词的生成概率；后者是通过当前词来预测上下文中各词的生成概率 4月24日分析Word2Vec和LDA的区别和联系？ LDA是利用文档中单词的共现关系对单词按主题聚类，也可以理解为对“文档-单词”矩阵进行分解，得到“文档-主题”和“主题-单词”两个概率分布。 而Word2Vec其实是对“上下文-单词”矩阵进行学习，其中上下文由周围的几个单词组成，由此得到的词向量表示更多地融入了上下文共现的特征。换句话说，如果两个Word2Vec向量的相似度较高，那么它们可能经常在同样的上下文中出现 主题模型和词嵌入模型的区别？ 上述分析仅为LDA和Word2Vec两者之间的区别，并不能繁华为两类模型之间的区别 具体来说，两种模型的主要区别还是模型本身。 主题模型是一种基于概率图模型的生成式模型，其似然函数可以协程若干条概率连乘的形式，其中包括需要预测的隐含变量 词嵌入模型一般表达为神经网络的形式，似然函数定义在网络的输出之上，需要通过学习网络的权重以得到单词的稠密向量表示 4月25日当模型缺少训练数据时，该如何处理呢？ 一个模型所能提供的信息一般来源于两个方面 一是训练数据中蕴含的信息 二是在模型形成过程中，人们提供的先验信息 当训练数据不足时，先验信息缺乏，需要更多的先验信息。 先验信息可以作用在模型上：例如对模型采用特定的内在结构，条件假设或其他约束条件 先验信息可以作用在数据集上，即根绝特定的先验假设去调整、变换或扩展训练数据，让其展示出更多的信息 4月26日具体而言，当一个图片分类模型缺少数据时，如何处理？ 训练数据不足带来的问题主要表现在过拟合方面，即模型在训练样本上的效果可能不错，但在测试集上的泛化效果不佳。 一是基于模型的方法，主要是采用降低过拟合风险的措施，包括简化模型（如将非线性模型简化为线性模型）、添加约束项以缩小假设空间（如L1/L2正则项）、集成学习、Dropout超参数等； 二是基于数据的方法，主要通过数据扩充（Data Augmentation），即根据一些先验知识，在保持特定信息的前提下，对原始数据进行适当变换以达到扩充数据集的效 在保持图像类别不变的前提下，可以对训练集中的每幅图像进行以下变换。 一定程度内的随机旋转、平移、缩放、裁剪、填充、左右翻转等，这些变换对应着同一个目标在不同角度的观察结果。 对图像中的像素添加噪声扰动，比如椒盐噪声、高斯白噪声等。 颜色变换。 改变图像的亮度、清晰度、对比度、锐度等","categories":[{"name":"周知识总结","slug":"周知识总结","permalink":"http://zivblog.top/categories/%E5%91%A8%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://zivblog.top/tags/Artificial-Intelligence/"}]},{"title":"Leetcode之二叉搜索树中第K小元素","slug":"Leetcode之二叉搜索树中第K小元素","date":"2020-04-25T02:41:24.000Z","updated":"2020-07-06T05:13:15.570Z","comments":true,"path":"passages/leetcode-zhi-er-cha-sou-suo-shu-zhong-di-k-xiao-yuan-su/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-er-cha-sou-suo-shu-zhong-di-k-xiao-yuan-su/","excerpt":"Kth Smallest Element in a BST","text":"Kth Smallest Element in a BST Kth Smallest Element in a BST code with Python title number：230 题目 给定一棵二叉搜索树，查找其中第k个最小的元素 k总是有效的 思路一 回顾一下，二叉搜索树的特点如下： 左子树若不空，则左子树中所有节点的值都小于根节点的值 右子树若不空，则右子树中所有结点的值都大于根节点的值 左右子树也符合该特点 根据二叉搜索树的特点，如果对二叉搜索树进行一次中序遍历可以得到一个升序数组，然后取数组的第k个元素即可 12345678910111213def kthSmallest(self, root: TreeNode, k: int) -&gt; int: def inorder(root): if root is None: return inorder(root.left) res.append(root.val) inorder(root.right) res = [] inorder(root) return res[k-1]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之求众数Ⅱ","slug":"Leetcode之求众数Ⅱ","date":"2020-04-24T07:18:59.000Z","updated":"2020-07-06T05:24:40.447Z","comments":true,"path":"passages/leetcode-zhi-qiu-zhong-shu-ii/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-qiu-zhong-shu-ii/","excerpt":"Majority Element Ⅱ","text":"Majority Element Ⅱ Majority Element Ⅱ code with Python title number：229 读题 给定一个大小为n的数组，找出其中所有出现次数超过$\\frac{1}{3}$次的元素 要求算法的时间复杂度为$O(n)$，空间复杂度为$O(1)$ 思路一 首先从分析一下从题目中得到的信息： 存在数组中没有没有符合条件的数的情况，即返回空集 最多存在两个满足条件的数（显然） 投票算法（摩尔投票，即对候选者与其他人对抗的过程） 本题特别之处在于，需要设置两个候选值（至多两个满足条件的元素） 对于候选者cand1和cand2： 如果投cand1，cand1加一票 如果投cand2，cand2加一票 如果投其他元素，cand1和cand2各减一票 1234567891011121314151617181920212223242526272829303132333435363738394041def majorityElement(self, nums: List[int]) -&gt; List[int]: cand1, vote1 = None, 0 cand2, vote2 = None, 0 res = [] for i in range(len(nums)): if cand1 is None and cand2 != nums[i]: cand1 = nums[i] vote1 = 1 elif cand2 is None and cand1 != nums[i]: cand2 = nums[i] vote2 = 1 else: if cand1 == nums[i]: vote1 += 1 elif cand2 == nums[i]: vote2 += 1 else: vote1 -= 1 vote2 -= 1 if vote1 == 0: cand1 = None if vote2 == 0: cand2 = None # 重新遍历判断 vote1 ， vote2 = 0， 0 if cand1 is not None: for i in range(len(nums)): if cand1 == nums[i]: vote1 += 1 if cand2 is not None: for i in range(len(nums)): if cand2 == nums[i]: vote2 += 1 if vote1 &gt; len(nums)//3: res.append(cand1) if vote2 &gt; len(nums)//3: res.append(cand2) return res 以下解释帮助理解 根据上面的信息，我们可以找出数组中出现次数最多的两个数，然后判断这两个数是否符合条件即可 如此一来，我们每次从数组中拿走三个不同的数，最后剩下的一定是出现次数最多的两个数，再判断这两个数是否合法即可。 分为三种情况：(将数组分为三组，A、B、其他，A、B为出现次数最多的两个数） 三个数中包含A和B。则三部分分别减去1，不影响最终结果 三个数中只包含A和B其中一个，假设是A。则A和其他分别减1减2，注意，即使这里A减去了1，但仍是出现次数最多的前两名 三个数中不包含A和B，则其他减去2，仍不改变最终的结果","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之最大正方形","slug":"Leetcode之最大正方形","date":"2020-04-23T03:17:19.000Z","updated":"2020-07-06T05:33:16.659Z","comments":true,"path":"passages/leetcode-zhi-zui-da-zheng-fang-xing/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zui-da-zheng-fang-xing/","excerpt":"Maximal Square","text":"Maximal Square Maximal Square code with Python title number：221 读题 给定一个由0和1组成的二维矩阵 在矩阵内找到之包含1的最大正方形，返回其面积 思路一 一开始想到了连通区域问题，但仔细一想并不可行，连通区域问题只需要进行DFS即可，而当前问题对连通区域的形状有要求，并不适合 暴力解法： 遍历每一个点，求以当前点为右下角点的正方形的最大面积 由于是正方形，所以我们只需要记录以当前点为右下角点的正方形的最大边长即可 12345678910111213141516171819202122232425262728293031def maximalSquare(self, matrix: List[List[str]]) -&gt; int: if len(matrix) == 0: return 0 # 存储以当前位置结尾的连续数字一的个数 width = [[0]*len(matrix[0]) for _ in range(len(matrix))] # 记录最大边长 int max_side = 0 for row in range(len(matrix)): for col in range(len(matrix[0])): if matrix[row][col] == '1': if col == 0: # 第一列，只能为1 width[row][col] = 1 else: width[row][col] = width[row][col-1] + 1 else: width[row][col] = 0 cur_width = width[row][col] #向上扩展行 up_row = row while up_row &gt;= 0: height = row - up_row + 1 if width[up_row][col] &lt;= max_side || height &gt; cur_width: break # 最大边长受高和长的限制， max_side = max(height, max_side) up_row -= 1 return max_side * max_side 思路二 动态规划 在思路一中，我们求每个点的最大边长时并没哟欧考虑之前的解，而事实上是可以用到的，所以动态规划他来了 状态表示：$f(i, j)$ 集合：以点matrix[i][j]为右下角点的正方形的边长的集合 属性：集合中边长的最大值 状态计算： 当前的点有三个方向可以到达：上方、左边、左上角（当前点是右下角。所以右边和下边对当前点没有影响）。以此作为标准划分集合，在当前点为1的时候: 当左上角的最大边长不为0时，当前点的最大边长可以表示为$f(i, j) = f(i-1, j-1)+1$ 当左边的最大边长不为0时，当前点的最大边长可以表示为$f(i ,j) = f(i-1, j) + 1$ 当上面的最大边长不为0时，当前点的最大边长可以表示为$f(i, j) = f(i , j-1) + 1$ 而当前点最终的最大边长受这三者中最短的最大边长的限制，于是：$$f(i, j) = min[f(i-1, j-1), f(i-1, j), f(i ,j-1)]+1$$ 代码方面，我们可以多申请一行和一列，这样第一行和第一列就不需要特殊处理了 1234567891011121314151617def maximalSquare(self, matrix: List[List[str]]) -&gt; int: if len(matrix) == 0: return 0 dp = [[0]*len(matrix[0])+1 for _ in range(len(matrix)+1)] max_side = 0 for row in range(1, len(matrix)+1): for col in range(1, len(matrix[0])+1): if matrix[row-1][col-1] == '0': dp[row][col] = 0 else: dp[row][col] = min(dp[row][col-1], min(dp[row-1][col], dp[row-1][col-1]))+1 max_side = max(dp[row][col], max_side) print(dp) return max_side * max_side","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之数组中第K个最大元素","slug":"Leetcode之数组中第K个最大元素","date":"2020-04-22T08:25:46.000Z","updated":"2020-07-06T05:27:21.801Z","comments":true,"path":"passages/leetcode-zhi-shu-zu-zhong-di-k-ge-zui-da-yuan-su/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-shu-zu-zhong-di-k-ge-zui-da-yuan-su/","excerpt":"Kth Largest Element in an Array","text":"Kth Largest Element in an Array Kth Largest Element in an Array code with Python title number：215 读题 在未排序的数组中找到第K个最大的元素。 注意，你要找到的是数组排序后的第K个最大的元素，而不是第K个不同的元素（即降序排序后的第K个元素） 示例： 12345输入：[3, 2, 1, 5, 6, 4] 和 k &#x3D; 2输出：5输入：[3, 2, 3, 1, 2, 4, 5, 5, 6] 和 k &#x3D; 4输出：4 思路一 直接调用sort()进行原地排序，返回排序后的降序序列的第K个元素 1234def findKthLargest(self, nums: List[int], k: int) -&gt; int: nums.sort(reverse=True) return nums[k-1] 思路二 联想到排序算法中的堆排序，我们可以使用小顶堆来优化该算法的时间复杂度 利用对存储前K个最大的数，最后返回堆顶的元素即可 当i &lt; k时，压数据进堆 当i &gt;= k时，比较nums[i]和堆顶元素的大小，如果大于，则使用heapreplace()进行替换，否则跳过 123456789101112from heapq import heappush, heapreplacedef findKthLargest(self, nums: List[int], k: int) -&gt; int: heap = [] for i in range(len(nums)): if i &lt; k: heappush(heap.nums[i]) if i &gt;= k: if nums[i] &gt; heap[0]: heapreplace(heap, nums[i]) return heap[0]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之添加与搜索单词","slug":"Leetcode之添加与搜索单词","date":"2020-04-21T04:46:01.000Z","updated":"2020-07-06T05:28:02.653Z","comments":true,"path":"passages/leetcode-zhi-tian-jia-yu-sou-suo-dan-ci/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-tian-jia-yu-sou-suo-dan-ci/","excerpt":"Add and Search Word","text":"Add and Search Word Add and Search Word code with Python title number：211 读题 又是一道数据结构的设计题 设计一个支持一下两种操作的数据结构 添加单词 搜索单词 所有单词仅由小写字母组成 示例 1234567addWord(&quot;bad&quot;)addWord(&quot;dad&quot;)addWord(&quot;mad&quot;)search(&quot;pad&quot;) -&gt; falsesearch(&quot;bad&quot;) -&gt; truesearch(&quot;.ad&quot;) -&gt; truesearch(&quot;b..&quot;) -&gt; true 思路一 观察上面的示例，如果没有正则符号.（匹配除换行符之外的任意单字符），我们可以使用数组直接存储单词，在查找的时候线性查找即可 不过加入.之后也比较好处理，因为在判断时只需要将.对应的字符认为时匹配到了即可 之前做过一道前缀树的设计题，我们这里可以使用前缀树进行优化 123456789101112131415161718192021222324252627282930313233343536373839404142class WordDictionary: from collections import defaultdict def __init__(self): \"\"\" Initialize your data structure here. \"\"\" self.lookup = &#123;&#125; def addWord(self, word: str) -&gt; None: \"\"\" Adds a word into the data structure. \"\"\" tree = self.lookup for a in word: tree = tree.setdefault(a, &#123;&#125;) tree[\"#\"] = &#123;&#125; def search(self, word: str) -&gt; bool: \"\"\" Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. \"\"\" def helper(word, tree): if not word: if \"#\" in tree: return True return False if word[0] == \".\": for t in tree: if helper(word[1:], tree[t]): return True elif word[0] in tree: if helper(word[1:], tree[word[0]]): return True return False return helper(word, self.lookup)# Your WordDictionary object will be instantiated and called as such:# obj = WordDictionary()# obj.addWord(word)# param_2 = obj.search(word)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之最长公共子序列","slug":"Leetcode之最长公共子序列","date":"2020-04-20T11:02:30.000Z","updated":"2020-07-06T05:35:01.284Z","comments":true,"path":"passages/leetcode-zhi-zui-chang-gong-gong-zi-xu-lie/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zui-chang-gong-gong-zi-xu-lie/","excerpt":"Longest Common Subsequence","text":"Longest Common Subsequence Longest Common Subsequence code with Python title numbber：1143 读题 给定两个字符串text1和text2，返回这两个字符串的最长公共子序列 若两个自负串没有公共子序列，则返回0 值得注意的是： 子序列与子串的最大区别在于：子序列并不要求序列中的元素相邻 思路一 动态规划 对于两个字符串text1，text2 状态表示：$f(i, j)$ 集合：所有两个字符串A[0, i]和B[0, j]的公共子序列的集合 属性：集合中的最长子序列 状态计算 我们以字符串的最后一个字符是否包含在公共子序列中作为集合的划分标准 可以划分为4种情况： 两个字符串的最后一个字符均包含在公共字序列中（即两个字符串的最后一个字符相同），即除去最后一个字符的最长公共子序列的长度加一，可以表示为$f(i-1, j-1)+1$ 两个字符串的最后一个字符都不再公共子序列中，即除去最后一个字符的最长公共子序列的长度，$f(i-1, j-1)$ 字符串A[0, i]的最后一个字符包含在公共字序列中，字符串B[0, j]的最后一个字符不包含在公共字序列中 字符串B[0, j]的最后一个字符包含在公共字序列中，字符串A[0, i]的最后一个字符不包含在公共字序列中 事实上最后两种比较难以精确表示 前面我们也说过，虽然状态表示要求不重不漏，但是在求最值时可以适当重复 我们可以使用f(i, j-1)和f(i-1, j)来近似的表示上面的两种情况（准确的说时包含上面的两种情况），而且f(i-1, j-1)包含在这两种情况中 故f(i,j) = max[f(i, j-1), f(i-1, j)]，并且第一种情况仅在A[i]==B[i]的时候才会存在 题目所求即为$f[len(text1), len(text2)]$， 1234567891011def longestCommonSubsequence(self, text1: str, text3: str) -&gt; int: # 在前面添加了全为0的一行和一列 dp = [0]*(len(text2)+1) for _ in range(len(text1)+1) for i in range(len(text1)): for j in range(len(text2)): if text1[i] != text2[j]: dp[i][j] = max(dp[i+1][j], dp[i][j+1]) else: dp[i+1][j+1] = dp[i][j] + 1 return dp[-1][-1]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之长度最小的子数组","slug":"Leetcode之长度最小的子数组","date":"2020-04-20T05:39:27.000Z","updated":"2020-07-06T05:31:20.681Z","comments":true,"path":"passages/leetcode-zhi-chang-du-zui-xiao-de-zi-shu-zu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-chang-du-zui-xiao-de-zi-shu-zu/","excerpt":"Minimum Size Subarray Sum","text":"Minimum Size Subarray Sum Minimum Size Subarray Sum code with Python title number：209 读题 给定一个含有n个正整数的数组和一个正整数s，找出该数组中满足其和大于等于s的长度最小的连续子数组 返回满足条件的子数组的长度 若不存在符合条件的连续子数组，返回0 思路一 暴力解法 穷举所有可能的子数组，在子数组和满足条件的情况下更新min_size 返回最终的min_size 1234567891011def minSubArrayLen(self, s: int, nums: List[int]) -&gt; int: min_size = len(nums) for i in range(len(nums)): for j in range(i, len(nums)): sum_ = 0 for k in range(i, j+1): sum_ += nums[k] if sum_ &gt;= s: min_size = min(min_size, j-i+1) return min_size 遍历所有的子数组的时间复杂度为$O(n^2)$，计算子数组的时间复杂度为$O(n)$ 整个算法的时间复杂度为$O(n^3)$，提交超时 思路二 优化后的暴力解法 可优化的部分为对子数组的求和： 使用一个与数组等长的数组sums来存储前i个元素的和 这样，求num[i:j]的和就是sums[j] - sums[i] + nums[j] 123456789101112131415161718def minSubArrayLen(self, s: int, nums: List[int]) -&gt; int: if len(nums) == 0: return 0 min_size = float('inf') sums = [0]*len(nums) sums[0] = nums[0] for i in range(1, len(nums)): sums[i] = sums[i-1] + nums[i] for i in range(len(nums)): for j in range(i, len(nums)): sum_ = sums[j] - sums[i] + nums[i] if sum_ &gt;= s: min_size = min(min_size, j-i+1) return 0 if min_size==float('inf') else min_size 仍是超时。。。。。 思路三 滑动窗口，所有查找连续子数组的都可以考虑滑动窗口 左指针从左向右遍历，若当前连续子数组满足条件后，尝试向右移动指针使当前连续子数组尽可能短 之后再加移动右指针，加上下一个值 重复上述过程 1234567891011def minSubArry(self, s: int, nums: List[int]) -&gt; int: l = total = 0 ans = float('inf') for r in range(len(nums)): total += nums[r] while total &gt;= s: ans = min(ans, r-l+1) total -= nums[l] l += 1 return 0 if ans == float('inf') else ans","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之实现Trie","slug":"Leetcode之实现Trie","date":"2020-04-19T04:56:36.000Z","updated":"2020-07-06T05:26:50.365Z","comments":true,"path":"passages/leetcode-zhi-shi-xian-trie/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-shi-xian-trie/","excerpt":"Implement Trie(Prefix Tree)","text":"Implement Trie(Prefix Tree) Implement Trie (Prefix Tree) code with Python title number：208 读题 实现前缀树，包含insert，search，startWith这三个操作 示例： 12345678Trie trie &#x3D; new Trie();trie.insert(&quot;apple&quot;);trie.search(&quot;apple&quot;); &#x2F;&#x2F; 返回 truetrie.search(&quot;app&quot;); &#x2F;&#x2F; 返回 falsetrie.startsWith(&quot;app&quot;); &#x2F;&#x2F; 返回 truetrie.insert(&quot;app&quot;); trie.search(&quot;app&quot;); &#x2F;&#x2F; 返回 true 前缀树，又称字典树： 是一种树形结构，是哈希树的变种，典型的应用是统计、排序和保存带昂的数据。 优点是可以利用字符串的公共前缀来减少查询时间 前缀树有三个基本特性： 根节点不包含字符，除根节点之外每个节点只包含一个字符 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串 每个结点的所有子节点包含的字符都不相同 思路一 题目很直接，实现前缀树的几个功能 初始化 前缀树又称字典树，所以存储结构初始化为字典 插入 每个结点是一个字典，不断迭代存入字符串中的元素 搜索 若有字母不再树中，则查找失败 遍历完当前字符串遇到结束标志才表示当前字符串存在（未遇到结束符则是前缀） 同时结束标志也用来区分是字符串存在于树中，还是当前字符串仅为前缀 判断是否有以给定字符串为前缀的字符串 迭代查找当前字符串，并且不是一个完整单词 即搜索完该前缀并未到达结束符 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Trie: def __init__(self): \"\"\" Initialize your data structure here. \"\"\" self.lookup = &#123;&#125; def insert(self, word: str) -&gt; None: \"\"\" Inserts a word into the trie. \"\"\" tree = self.lookup for a in word: if a not in tree: # 新节点 tree[a] = &#123;&#125; tree = tree[a] # 设置单词的结束标志 tree[\"#\"] = \"#\" def search(self, word: str) -&gt; bool: \"\"\" Returns if the word is in the trie. \"\"\" tree = self.lookup for a in word: if a not in tree: return False tree = tree[a] if \"#\" in tree: return True return False def startsWith(self, prefix: str) -&gt; bool: \"\"\" Returns if there is any word in the trie that starts with the given prefix. \"\"\" tree = self.lookup for a in prefix: if a not in tree: return False tree = tree[a] return True","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"标准完全背包问题","slug":"标准完全背包问题","date":"2020-04-19T03:33:51.000Z","updated":"2020-07-06T05:43:20.338Z","comments":true,"path":"passages/biao-zhun-wan-quan-bei-bao-wen-ti/","link":"","permalink":"http://zivblog.top/passages/biao-zhun-wan-quan-bei-bao-wen-ti/","excerpt":"标准完全背包问题","text":"标准完全背包问题 题目描述 有N种物品和一个容量是V的背包，每种物品都有无限件可用 第i种物品的体积是$v_i$，价值是$w_i$ 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大 返回最大价值 解题思路 我们使用闫式DP分析法给出的框架进行分析 首先，应该明确所有的情况有$2^N$种（每件物品选或不选）,且该问题为最大值问题 状态表示：$f(i, j)$ 集合：所有只从前i个物品中选，总体积不大于j的方案的集合 属性：最大价值 状态计算 与零一背包不同，本题中每个物品是无限的，所以不能以第i件物品放不放为分类标准对集合进行二分类 事实上，应该是k分类，第i件物品放0件、1件、…k件（$k*v_i &lt;= V$） 于是针对每一中情况，取max，表达式如下： $$f(i, j) = max[f(i-1, j), f(i-1, j-v_i)+w_i, … f(i-1, j-kv_i)+kw_i]$$ 表达式看起来比较难实现，我们再来看： $$f(i, j-v_i) = max[f(i-1, j-v_i), … f(i-1, j-(k+1)v_i)+(k+1)w_i]$$ 两个表达式相比较，式一 = max(f(i-1, j), 式二+w_i) 故状态转移方程为： $$f(i ,j) = max[f(i-1, j), f(i-1, j-v_i)+w_i]$$ 最终结果即为：$f(N, V)$ 1234567891011121314def backpack(self, N: int, V: int, v: List[int], w: List[int]) -&gt; int: ''' N: 物品数 V: 背包体积 v: 物品体积列表 w: 物品价值列表 ''' dp = [[0]*(N+1) for _ in range(N+1)] for i in range(1, N+1): for j in range(1, V+1): dp[i][j] = dp[i-1][j] if j &gt;= v[i]: dp[i][j] = max(dp[i][j], dp[i][j-v[i]]+w[i]) return dp[N][V] 优化 上述写法由于是按背包体积从小到大的顺序进行的，所以要判断当前背包能否装下一个物品 优化：从可装下物品的背包体积开始循环 123456789101112131415def backpack(self, N: int, V: int, v: List[int], w: List[int]) -&gt; int: ''' N: 物品数 V: 背包体积 v: 物品体积列表 w: 物品价值列表 ''' dp = [0]*(N+1) for i in range(1, N+1): j = v[i] while j &lt;= V: dp[j] = max(dp[j], dp[j-v[i]]+w[i]) j += 1 return dp[V]","categories":[{"name":"算法","slug":"算法","permalink":"http://zivblog.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"记一次Leetcode春季编程大赛","slug":"记一次Leetcode春季编程大赛","date":"2020-04-18T09:19:09.000Z","updated":"2020-07-06T05:45:36.813Z","comments":true,"path":"passages/ji-yi-ci-leetcode-chun-ji-bian-cheng-da-sai/","link":"","permalink":"http://zivblog.top/passages/ji-yi-ci-leetcode-chun-ji-bian-cheng-da-sai/","excerpt":"记一次Leetcode春季编程大赛","text":"记一次Leetcode春季编程大赛 前言 leetcode上的题目近期刷了100道左右，心想参加一下比赛试试水，可惜可惜，只做出了两道简单题。 简单题十几分钟就做完了，后面几道题看着有思路却总是调试不成功。 革命尚未成功，同志仍需努力，加油！ 拿硬币 桌上有 n 堆力扣币，每堆的数量保存在数组 coins 中。我们每次可以选择任意一堆，拿走其中的一枚或者两枚，求拿完所有力扣币的最少次数。 示例一 输入：[4,2,1] 输出：4 解释：第一堆力扣币最少需要拿 2 次，第二堆最少需要拿 1 次，第三堆最少需要拿 1 次，总共 4 次即可拿完。 示例二 输入：[2,3,10] 输出：8 限制 1 &lt;= n &lt;= 41 &lt;= coins[i] &lt;= 10 123456789101112131415class Solution: def minCount(self, coins: List[int]) -&gt; int: count = 0 for coin in coins: if coin &lt;= 2: count += 1 else: while coin &gt; 0: if coin - 2 &gt;= 0: coin -= 2 count += 1 else: coin -= 1 count += 1 return count 实际上，代码还可以优化 12345678class Solution: def minCount(self, coins: List[int]) -&gt; int: res = 0 for coin in coins: res += (coin+1) // 2 return res 传递信息小朋友 A 在和 ta 的小伙伴们玩传信息游戏，游戏规则如下： 有 n 名玩家，所有玩家编号分别为 0 ～ n-1，其中小朋友 A 的编号为 0 每个玩家都有固定的若干个可传信息的其他玩家（也可能没有）。传信息的关系是单向的（比如 A 可以向 B 传信息，但 B 不能向 A 传信息）。 每轮信息必须需要传递给另一个人，且信息可重复经过同一个人 给定总玩家数 n，以及按 [玩家编号,对应可传递玩家编号] 关系组成的二维数组 relation。返回信息从小 A (编号 0 ) 经过 k 轮传递到编号为 n-1 的小伙伴处的方案数；若不能到达，返回 0。 示例 1： 输入：n = 5, relation = [[0,2],[2,1],[3,4],[2,3],[1,4],[2,0],[0,4]], k = 3 输出：3 解释：信息从小 A 编号 0 处开始，经 3 轮传递，到达编号 4。共有 3 种方案，分别是 0-&gt;2-&gt;0-&gt;4， 0-&gt;2-&gt;1-&gt;4， 0-&gt;2-&gt;3-&gt;4。 示例 2： 输入：n = 3, relation = [[0,2],[2,1]], k = 2 输出：0 解释：信息不能从小 A 处经过 2 轮传递到编号 2 限制： 2 &lt;= n &lt;= 10 1 &lt;= k &lt;= 5 1 &lt;= relation.length &lt;= 90, 且 relation[i].length == 2 0 &lt;= relation[i][0],relation[i][1] &lt; n 且 relation[i][0] != relation[i][1] 123456789101112class Solution: def numWays(self, n: int, r: List[List[int]], k: int) -&gt; int: now = [1]+[0]*(n-1) for i in range(k): snow = [0]*n for x in r: a, b = x[0], x[1] snow[b] += now[a] now = snow return now[n-1] 剧情触发时间在战略游戏中，玩家往往需要发展自己的势力来触发各种新的剧情。一个势力的主要属性有三种，分别是文明等级（C），资源储备（R）以及人口数量（H）。在游戏开始时（第 0 天），三种属性的值均为 0。 随着游戏进程的进行，每一天玩家的三种属性都会对应增加，我们用一个二维数组 increase 来表示每天的增加情况。这个二维数组的每个元素是一个长度为 3 的一维数组，例如 [[1,2,1],[3,4,2]] 表示第一天三种属性分别增加 1,2,1 而第二天分别增加 3,4,2。 所有剧情的触发条件也用一个二维数组 requirements 表示。这个二维数组的每个元素是一个长度为 3 的一维数组，对于某个剧情的触发条件 c[i], r[i], h[i]，如果当前 C &gt;= c[i] 且 R &gt;= r[i] 且 H &gt;= h[i] ，则剧情会被触发。 根据所给信息，请计算每个剧情的触发时间，并以一个数组返回。如果某个剧情不会被触发，则该剧情对应的触发时间为 -1 。 示例 1： 输入： increase = [[2,8,4],[2,5,0],[10,9,8]] requirements = [[2,11,3],[15,10,7],[9,17,12],[8,1,14]] 输出: [2,-1,3,-1] 解释： 初始时，C = 0，R = 0，H = 0 第 1 天，C = 2，R = 8，H = 4 第 2 天，C = 4，R = 13，H = 4，此时触发剧情 0 第 3 天，C = 14，R = 22，H = 12，此时触发剧情 2 剧情 1 和 3 无法触发。 示例 2： 输入： increase = [[0,4,5],[4,8,8],[8,6,1],[10,10,0]] requirements = [[12,11,16],[20,2,6],[9,2,6],[10,18,3],[8,14,9]] 输出: [-1,4,3,3,3] 示例 3： 输入： increase = [[1,1,1]] requirements = [[0,0,0]] 输出: [0] 限制： 1 &lt;= increase.length &lt;= 10000 1 &lt;= requirements.length &lt;= 100000 0 &lt;= increase[i] &lt;= 10 0 &lt;= requirements[i] &lt;= 100000 12 最小跳跃次数为了给刷题的同学一些奖励，力扣团队引入了一个弹簧游戏机。游戏机由 N 个特殊弹簧排成一排，编号为 0 到 N-1。初始有一个小球在编号 0 的弹簧处。若小球在编号为 i 的弹簧处，通过按动弹簧，可以选择把小球向右弹射 jump[i] 的距离，或者向左弹射到任意左侧弹簧的位置。也就是说，在编号为 i 弹簧处按动弹簧，小球可以弹向 0 到 i-1 中任意弹簧或者 i+jump[i] 的弹簧（若 i+jump[i]&gt;=N ，则表示小球弹出了机器）。小球位于编号 0 处的弹簧时不能再向左弹。 为了获得奖励，你需要将小球弹出机器。请求出最少需要按动多少次弹簧，可以将小球从编号 0 弹簧弹出整个机器，即向右越过编号 N-1 的弹簧。 示例 1： 输入：jump = [2, 5, 1, 1, 1, 1] 输出：3 解释：小 Z 最少需要按动 3 次弹簧，小球依次到达的顺序为 0 -&gt; 2 -&gt; 1 -&gt; 6，最终小球弹出了机器。 限制： 1 &lt;= jump.length &lt;= 10^6 1 &lt;= jump[i] &lt;= 10000 12345678910111213141516171819202122232425262728from collections import deque # append(left), pop(left), extendclass Solution: def minJump(self, s: List[int]) -&gt; int: mi = 1 n = len(s) dp = [0]*(n-1)+[1] st = deque([(1, n-1), (0, n)]) for i in range(n-2, -1, -1): if i + s[i] &gt;= n: dp[i] = 1 st = deque([(1, i), (0, n)]) else: x = i+s[i] l, r = 0, len(st)-1 while l+1&lt;r: mi = (l+r)//2 if st[mi][1] &gt; x: r = mi else: l = mi now = min(dp[x], st[l][0]+1) + 1 dp[i]=now while st[0][0]&gt;dp[i]: st.popleft() st.appendleft((dp[i], i)) print(dp) return dp[0] 二叉树任务调度任务调度优化是计算机性能优化的关键任务之一。在任务众多时，不同的调度策略可能会得到不同的总体执行时间，因此寻求一个最优的调度方案是非常有必要的。 通常任务之间是存在依赖关系的，即对于某个任务，你需要先完成他的前导任务（如果非空），才能开始执行该任务。我们保证任务的依赖关系是一棵二叉树，其中 root 为根任务，root.left 和 root.right 为他的两个前导任务（可能为空），root.val 为其自身的执行时间。 在一个 CPU 核执行某个任务时，我们可以在任何时刻暂停当前任务的执行，并保留当前执行进度。在下次继续执行该任务时，会从之前停留的进度开始继续执行。暂停的时间可以不是整数。 现在，系统有两个 CPU 核，即我们可以同时执行两个任务，但是同一个任务不能同时在两个核上执行。给定这颗任务树，请求出所有任务执行完毕的最小时间。 示例 1： 输入：root = [47, 74, 31] 输出：121 解释：根节点的左右节点可以并行执行31分钟，剩下的43+47分钟只能串行执行，因此总体执行时间是121分钟。 示例 2： 输入：root = [15, 21, null, 24, null, 27, 26] 输出：87 示例 3： 输入：root = [1,3,2,null,null,4,4] 输出：7.5 限制： 1 &lt;= 节点数量 &lt;= 1000 1 &lt;= 单节点执行时间 &lt;= 1000 12345678910111213141516171819202122232425262728293031323334353637383940# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def minimalExecTime(self, root: TreeNode) -&gt; float: # def visit(node=root) : # if node is None : # return 0 # node.sum = visit(node.left)+visit(node.right)+node.val # return node.sum # visit() def get_value(node=root): if node.left is None and node.right is None: return node.val, node.val if node.left is None : minv, maxv = get_value(node.right) return minv+node.val, maxv+node.val if node.right is None : minv, maxv = get_value(node.left) return minv+node.val, maxv+node.val minv_left, maxv_left = get_value(node.left) minv_right, maxv_right = get_value(node.right) maxv = maxv_left+maxv_right+node.val if minv_right &gt; maxv_left : minv = minv_right-maxv_left elif minv_left &gt; maxv_right : minv = minv_left - maxv_right else : minv = 0. return minv+node.val, maxv minv, maxv = get_value() return (maxv+minv)/2","categories":[{"name":"算法","slug":"算法","permalink":"http://zivblog.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之数字范围按位与","slug":"Leetcode之数字范围按位与","date":"2020-04-18T03:49:57.000Z","updated":"2020-07-06T05:27:14.595Z","comments":true,"path":"passages/leetcode-zhi-shu-zi-fan-wei-an-wei-yu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-shu-zi-fan-wei-an-wei-yu/","excerpt":"Bitwise AND of Numbers Range","text":"Bitwise AND of Numbers Range Bitwise AND of Numbers Range code with Python title number：201 读题 给定范围[m, n]，其中0 &lt;= m &lt;= n &lt;= 2147483647 返回此范围内所有的数字的按位与（包含两个端点m，n） 解释：范围内所有的数字依次进行按位与运算 例如：[5, 7]，即5 &amp; 6 &amp; 7=4，返回4 思路一 最直接的想法就是遍历区间范围内的所有数字，依次进行与运算 但是这种方式的时间复杂度太高，我们需要通过观察发现某种规律 先看上面的例子：[5, 7]，转化为二进制为： 101, 110, 111，结果是1 来看一个例子：[7, 8]，转化为二进制为： 111, 1000，结果为0 可以发现，当m的位数大于n的位数时，结果必定为0 接下来看一个区间内数字的二进制位数都相同的情况，[20, 23] 10100, 10101, 10110, 10111，结果为16 -&gt; 10000 对m和n做差，23-20=3 -&gt; 100，即从20到23的过程中要加三次1，所以倒数第一位或倒数第二位必定会有0，那么后两位相与必定为0。更进一步，倒数第三位只存在两种情况，原来为0变为1，或原来为1变为0，这样来说，相与也必定是0 所以，结果的后bin(n-m)位必定为0 仍是上面的例子，我们现在已经知道了结果的位数，和后bin(m-n)位的情况，现在只需要确定前几位的情况即可。 而在区间内所有数字位数确定的情况下，并不会有对最高位的进位 也就是前len(bin(n))-len(bin(n-m))位的结果等于m &amp; n的前len(bin(n))-len(bin(n-m))的结果 总结一下 如果bin(n) &gt; bin(m)，解果为0 计算bin(n-m)的位数len_sub 计算n &amp; m的结果 将n &amp; m后bin(n-m)位替换为0即可，或者说是将n &amp; m结果的前len(n)-len_sub位和len_sub个0相加即为结果 12345678def rangeBitwiseAnd(self, m: int, n: int) -&gt; int: if len(bin(n)) &gt; len(bin(m)): return 0 if m == n: return m sub = len(bin(n-m)[2:]) return int(bin(m&amp;n)[2: -sub] + '0'*sub, 2) 可能描述的并不是很容易理解，有疑问可以邮件问我或者看官网题解区的帖子 思路二 只需查找这个区间数字的第i位全为1，那么结构一定是前i位 12345678def rangeBitwiseAnd(self, m: int, n: int) -&gt; int: cnt = 0 while m != n: m &gt;&gt;= 1 n &gt;&gt;= 1 cnt += 1 return m &lt;&lt; cnt","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之岛屿数量","slug":"Leetcode之岛屿数量","date":"2020-04-17T10:26:39.000Z","updated":"2020-07-06T05:10:54.543Z","comments":true,"path":"passages/leetcode-zhi-dao-yu-shu-liang/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-dao-yu-shu-liang/","excerpt":"Number of Islands","text":"Number of Islands Number of Islands code with Python title number：200 读题 给定一个有1（陆地）和0（水）组成的二维网格，计算其中岛屿的数量 岛屿： 被水包围 通过水平或垂直方向上相邻的陆地连接而成 可以认为给定网格的四个边均被水包围 思路一 连通区域问题，可参考被围绕的区域 双循环查找起始位置，对于为1的位置使用DFS进行搜索 已访问位置需要标记，由于不同岛屿之间无关，可以直接将已经访问过的位置置为0 12345678910111213141516171819def numIslands(self, grid: List[List[str]]) -&gt; int: def dfs(grid, i, j): if grid[i][j] != '1' or i &lt; 0 or i &gt;= len(grid) or j &lt; 0 or j &gt;= len(grid[0]): return dfs(grid, i, j+1) dfs(grid, i. j-1) dfs(grid, i+1, j) dfs(grid, i-1, j) if not grid: return 0 count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == '1': dfs(grid, i, j) count += 1 return count","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"周知识总结（4.13~4.19）","slug":"周知识总结（4-13-4-19）","date":"2020-04-16T03:37:04.000Z","updated":"2020-07-06T05:49:45.239Z","comments":true,"path":"passages/zhou-zhi-shi-zong-jie-4-13-4-19/","link":"","permalink":"http://zivblog.top/passages/zhou-zhi-shi-zong-jie-4-13-4-19/","excerpt":"周知识总结","text":"周知识总结 4月13日试简述Adaboost算法？ Boosting类算法包含两个基本问题： 每一轮如何改变数据的权值或概率分布？ 如何将若分类器合成一个强分类器？ 针对两个问题，Adaboost有自己的解决方案： 每一轮如何改变数据权值或概率分布？ 一开始，每个样本的权值是一样的，在每一轮开始时，提高上一轮弱分类器错误分类样本的权值，同时降低那些被正确分类样本的权值 如何将弱分类器组合成一个强分类器？ Adaboost采用加权表决的方式。 加大分类错误率小的基学习器的权值，使其在表决中起到更大的作用，同时减小分类错误率大的基学习器的权值 总得来说，Adaboost的一大特点是： 不改变数据，通过不断改变数据权值的分布，使数据在基学习器的学习中骐达不同的作用 4月14日试简述梯度提升决策树GBDT？ GBDT是以决策树为基学习器，采用Boosting策略的一种集成学习模型 与提升树的区别： 残差的计算不同，提升树使用的是真正的残差，梯度提升树用当前模型的负梯度来模拟残差 提升树（Boosting Tree） 以决策树为基学习器，对分类问题使用二叉分类树，对回归问题使用二叉回归树 解决回归问题时，通过不断拟合残差得到新的树 提升树模型可表示为决策树的加法模型：$$f_M(x)=\\sum_{m=1}^MT(x;\\Theta_m)$$ 首先初始化提升树 f_0(x)=0，则第 m 步的模型为$$f_m(x)=f_{m-1}(x)+T(x;\\Theta_m)$$ 然后通过最小化损失函数决定下一个决策树的参数$$\\hat{\\Theta}m=\\arg \\underset{\\Theta_m}{min} \\sum{i=1}^NL(y_i, f_{m-1}(x_i) + T(x_i; \\Theta_m))$$ 梯度提升算法 当损失函数为平方损失或指数损失时，每一步的优化是很直观的；但对于一般的损失函数而言，不太容易——梯度提升正是针对这一问题提出的算法； 梯度提升是梯度下降的近似方法，其关键是利用损失函数的负梯度作为残差的近似值，来拟合下一个决策树。 4月15日梯度提升树（GBDT） GBDT的核心在于：每一棵树学的是之前所有树结论和的残差，这个残差就是一个加预测值后能得真实值的累加量 首先这是个迭代算法，每一轮迭代，把当前所有学习器的加权平均结果作为这一轮的函数值，然后求得针对某一个损失函数对于当前所有学习器的参数的一个梯度，然后利用某个弱学习器（LR，Logistic LR等）算法来拟合这个梯度，最后，利用查找的方式找到权重。其实，就是利用简单模型拟合不同迭代轮数的梯度。 梯度增强可跟梯度下降对比，梯度下降的最终预测式也可写成加和的形式，每一轮梯度的值和学习率共同叠加形成最终结果。这和构造弱学习器的加权平均联系起来看，每个梯度的值可以认为是个弱学习器，学习速率就是权重。 理解了梯度增强，梯度增强决策树就容易理解了，就是用决策树来当作弱学习器，去拟合梯度增强过程中的梯度。然后融合到整个梯度增强的过程中。 最终，梯度增强决策树就是每一轮迭代都拟合一个新的决策树，来表达当前的梯度，然后跟前面所有的决策树进行叠加。 4月16日试简述ReLU相比Sigmoid的优势？ 避免梯度消失 sigmoid函数在输入取绝对值非常大的正值或负值时会出现饱和现象——在图像上表现为变得很平，此时函数会对输入的微小变化不敏感——从而造成梯度消失； ReLU 的导数始终是一个常数——负半区为 0，正半区为 1——所以不会发生梯度消失现象 减缓过拟合 ReLU 在负半区的输出为 0。一旦神经元的激活值进入负半区，那么该激活值就不会产生梯度/不会被训练，造成了网络的稀疏性——稀疏激活 这有助于减少参数的相互依赖，缓解过拟合问题的发生 加速计算 ReLU 的求导不涉及浮点运算，所以速度更快 4月17日为什么 L1 和 L2 正则化可以防止过拟合？ L1 &amp; L2 正则化会使模型偏好于更小的权值。 更小的权值意味着更低的模型复杂度；添加 L1 &amp; L2 正则化相当于为模型添加了某种先验，限制了参数的分布，从而降低了模型的复杂度。 模型的复杂度降低，意味着模型对于噪声与异常点的抗干扰性的能力增强，从而提高模型的泛化能力。——直观来说，就是对训练数据的拟合刚刚好，不会过分拟合训练数据（比如异常点，噪声）——**奥卡姆剃刀原理 4月18日Dropout 与 Bagging 的不同 在神经网络上使用Dropout，相当于通过数据共享提供了一种连接的Bagging集成——在训练时随机使一些神经元失效，整个过程中相当于训练多个不同的模型；在测试时使用全部的神经元相当于一种变相的集成。 在 Bagging 的情况下，所有模型都是独立的；而在 Dropout 的情况下，所有模型共享参数，其中每个模型继承父神经网络参数的不同子集。 在 Bagging 的情况下，每一个模型都会在其相应训练集上训练到收敛。而在 Dropout 的情况下，通常大部分模型都没有显式地被训练；取而代之的是，在单个步骤中我们训练一小部分的子网络，参数共享会使得剩余的子网络也能有好的参数设定。 4月19日正则化过程中，为何只对权重做正则惩罚，而不对偏置做权重惩罚？ 在神经网络中，参数包括每一层仿射变换的权重和偏置，我们通常只对权重做惩罚而不对偏置做正则惩罚。 精确拟合偏置所需的数据通常比拟合权重少得多。每个权重会指定两个变量如何相互作用。我们需要在各种条件下观察这两个变量才能良好地拟合权重。 而每个偏置仅控制一个单变量。这意味着，我们不对其进行正则化也不会导致太大的方差。另外，正则化偏置参数可能会导致明显的欠拟合。","categories":[{"name":"周知识总结","slug":"周知识总结","permalink":"http://zivblog.top/categories/%E5%91%A8%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://zivblog.top/tags/Artificial-Intelligence/"}]},{"title":"周知识总结（4.6~4.12）","slug":"周知识总结（4-6-4-12）","date":"2020-04-16T03:30:03.000Z","updated":"2020-07-06T05:49:40.123Z","comments":true,"path":"passages/zhou-zhi-shi-zong-jie-4-6-4-12/","link":"","permalink":"http://zivblog.top/passages/zhou-zhi-shi-zong-jie-4-6-4-12/","excerpt":"周知识总结","text":"周知识总结 4月6日验证集的作用是什么？ 防止过拟合的方法，除了加入正则化项以外，还有一种方式叫做提前停止 在训练集和测试集之外，还会使用验证集来进行模型选择（验证集可以从训练数据中选择一部分） 每次迭代时，把新得到的模型在验证集上进行测试，并计算错误率。 如果在验证集上错误率不再下降，则停止迭代（即提前停止） 4月7日方差与偏差的作用是什么？ 偏差：指的是一个模型在不同训练集上的平均性能和最优性能的差异，可以用来衡量一个模型的拟合能力 偏差越大，模型的拟合能力越差 方差：方差指一个模型在不同训练集上的差异，可以用来衡量一个模型是否容易过拟合 方差越大，模型越不稳定，越容易过拟合 实际操作中，利用偏差和方差来分析模型比较难于实现 一般来说，当一个模型在训练集上错误率比较高时，认为模型拟合能力不够，偏差比较高 当一个模型在训练集上错误率比较低，在验证集上错误率比较高，则说明模型过拟合，方差比较高 4月8日简述特征学习的两种方式？ 特征学习具体来说可以分为两种：特征选择、特征抽取 特征选择：是选取原始特征集中的一个有效子集，使得使用该子集训练出来的模型准确率更高 一种比较直接的特征选择方法是子集搜索，即暴力尝试所有的子集在模型上的效果，选择最优的子集 特征抽取：构造一个新的特征空间，并将原始特征投影在新的空间中 特征抽取可以分为监督和无监督的方法 监督的特征学习的目标是抽取对特定任务有效的特征，例如线性判别分析 无监督的特征学习与特定任务无关，一般是为了减少冗余信息，例如主成分分析 总之，两者的共同目的都是使用数据中较少的特征来表示原始特征中的大部分相关信息，去掉噪声信息，并进而提高计算效率和减少维度灾难 多分类线性判别函数有哪些设计方法？ “一对其余”：把C分类转化为多个“一对其余”的二分类问题，需要C个判别函数 “一对一”：把C分类问题转化为C(C-1)/2个“一对一”的二分类问题，需要C(C-1)/2个二分类问题 “argmax”：预测结果是一个长度为C的向量，选择其中数值最大的一维作为预测类别 4月9日神经网络从哪两个方面模拟大脑？ 网络获取的知识是通过学习来获取的 内部神经元的链接强度（突触权重）用于存储获取的知识 激活函数需要具备那些性质？ 连续并可导的非线性函数。可导的激活函数可以直接利用数值优化的方法来学习网络参数 激活函数及其导函数的值域要在一个合适的区间内，不能太大也不能太小，否则会影响训练的效率和稳定性 激活函数及其导数要尽可能的简单，有利于提高网络计算效率 常用的神经网络结构有哪些？ 前馈网络 前馈网络中各个神经元按照接受信息的先后分为不同的组，每一个组可以看作一个神经层。 每层神经元只接受前一层神经元的输出，并输出到下一层神经元，整个网络中的信息是朝一个方向传播，没有反向的信息传播。 包括：全连接前馈网络和卷积神经网络等 反馈网络 反馈网络中神经元不但可以接受其他神经元的信号，还能接收自己的反馈信号 与前馈神经元相比，，反馈网络中的神经元具有记忆功能，可以单向传播也可以双向传播 包括：循环神经网络、Hopfield网络、玻尔兹曼机等 图网络 图网络是定义在图数据结构上的神经网络，图中每个节点都是一个或一组神经元构成，每个节点可以收到来自相邻节点或自身的信息 包括：图卷积神经网络、消息传递网络（MPNN） 4月10日什么是OOV问题？ OOV即Out Of Vocabulary，也就是序列中出现了词表之外的词，或称为未登陆词 或者说是测试集和验证集上出现了训练集中没有出现过的词 一般的解决方案： 设置一个词频阈值，只有高于该阈值的词才会加入词表 所有低于阈值的词替换为UNK（特殊符号） 在神经网络中，一般有以下几种处理UNK的思路 为其分配一个随机初始化的embedding，并参与训练 把UNK初始化为一个全为0的向量，不参与训练 每次都把UNK初始化为一个新的随即向量，不参与训练 4月11日集成学习有哪些基本策略？（接3-31） Boosting方法 基本思路： 先从初始训练集训练一个基学习器；初始训练集中各样本的权重是相同的； 根据上一个基学习器的表现，调整样本权重，使分类错误的样本得到更多的关注； 基于调整后的样本分布，训练下一个基学习器； 测试时，对各基学习器加权得到最终结果 特点： 每次学习都会使用全部训练样本 Stacking方法 基本思路**： 先从初始训练集训练 T 个不同的初级学习器; 利用每个初级学习器的输出构建一个次级数据集，该数据集依然使用初始数据集的标签； 根据新的数据集训练次级学习器； 多级学习器的构建过程类似。 周志华-《机器学习》中没有将 Stacking 方法当作一种集成策略，而是作为一种结合策略，比如加权平均和投票都属于结合策略。 为了降低过拟合的风险，一般会利用交叉验证的方法使不同的初级学习器在不完全相同的子集上训练 Bagging方法 基本思路： 利用自助采样法对训练集随机采样，重复进行 T 次; 基于每个采样集训练一个基学习器，并得到 T 个基学习器； 预测时，集体投票决策**。 自助采样法：对 m 个样本的训练集，有放回的采样 m 次；此时，样本在 m 次采样中始终没被采样的概率约为 0.368，即每次自助采样只能采样到全部样本的 63% 左右。 $$lim_{m-&gt;无穷}(1-\\frac{1}{m})^{m} -&gt; \\frac{1}{e} \\approx 0.368$$ 特点： 训练每个基学习器时只使用一部分样本； 偏好不稳定的学习器作为基学习器； 所谓不稳定的学习器，指的是对样本分布较为敏感的学习器 4月12日为什么选择决策树作为集成学习的基学习器？ 决策数的表达能力和泛化能力，可以通过剪枝来快速进行调整 决策树可以方便的将样本的权重整合到训练过程中 决策树是一种不稳定的学习器（易受样本扰动的影响） 另外，神经网络也属于不稳定的学习器，也可以作为基学习器 为什么不稳定的学习器更适合作为基学习器？ 不稳定的学习器易受样本分布的影响（方差大），很好的引入了随机性，这有助于在集成学习的时候提升模型的泛化能力 为了更好的引入随机性，有时会随机选择一个属性子集中的最优分裂属性，而不是全局最优（例如随机森林） Bagging或Boosting中能否使用线性分类器作为基学习器？ Bagging中不推荐使用线性分类器作为基学习器 线性分类器是稳定的学习器（方差小），对数据不敏感 可能因为bagging的采样，导致在训练中难以收敛，使分类器集成时偏差更大 Boosting中可以使用线性分类器作为基学习器 Boosting主要通过降低偏差来提升模型的性能，而线性分类器本身方差小，二者具有一定的相性（更合适） XGBoost中就支持用线性分类器作为基学习器","categories":[{"name":"周知识总结","slug":"周知识总结","permalink":"http://zivblog.top/categories/%E5%91%A8%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://zivblog.top/tags/Artificial-Intelligence/"}]},{"title":"周知识总结（3.30~4.5）","slug":"周知识总结（3-30-4-5）","date":"2020-04-16T03:18:39.000Z","updated":"2020-07-06T05:49:35.842Z","comments":true,"path":"passages/zhou-zhi-shi-zong-jie-3-30-4-5/","link":"","permalink":"http://zivblog.top/passages/zhou-zhi-shi-zong-jie-3-30-4-5/","excerpt":"周知识总结","text":"周知识总结 3月30日强化学习的主要特点？ 强化学习的学习器并不是学习怎样做，而是在尝试的过程中学习到在特定的情境下选择哪种行动可以得到最大的回报 主要包含四个元素：agent、环境状态、行动、奖励 强化学习的三个重要特点如下： 基本是以闭环的形式 不会直接指示选择哪种行动 一系列的action和reward会影响之后较长的时间 强化学习与监督学习的区别？ 监督学习实在标签的指导下，学习一个输入与输出之间的映射关系 强化学习在没有任何标签的情况下，先尝试做一些行为得到一个结果，通过这个结果是对的还是错的的反馈，调整之前的行为 强化学习与无监督学习的区别？ 无监督学习通过对没有标签的训练数据进行学习，发现训练数据中隐藏的结构性知识，即一种模式 强化学习并没有明确数据概念，它并不知道结果，只有目标，即学习到从状态到行动的映射 3月31日集成学习为什么会有效？ 不同的模型通常会在测试集上产生不同的误差；如果成员的误差是独立的，集成模型将显著地比其成员表现更好 集成学习有哪些基本策略？ Boosting方法 基于串行策略：基学习器之间存在依赖关系，新的学习器需要根据上一个学习器生成。 Stacking方法 基于并行策略：基学习器之间不存在依赖关系，可同时生成。 Bagging方法 基于串行策略：初级学习器与次级学习器之间存在依赖关系，初学习器的输出作为次级学习器的输入。 4月1日为什么需要迁移学习？ 大数据与少标注的矛盾：虽然有大量的数据，但往往都是没有标注的，无法训练机器学习模型。人工进行数据标定太耗时 大数据与弱计算的矛盾：普通人无法拥有庞大的数据量与计算资源。因此需要借助于模型的迁移 普适化模型与个性化需求的矛盾：即使是在同一个任务上，一个模型也往往难以满足每个人的个性化需求，比如特定的隐私设置。这就需要在不同人之间做模型的适配 特定应用（如冷启动）的需求 迁移学习与传统机器学习有什么区别？ 迁移学习 传统机器学习 数据分布 训练和测试数据不需要同分布 训练和测试数据同分布 数据标签 不需要足够的数据标注 足够的数据标注 建模 可以重用之前的模型 每个任务分别建模 迁移学习的基本思路有哪些？ 基于样本迁移 根据一定的权重生成规则，对数据样本进行重用，来进行迁移学习 基于特征迁移 将通过特征变换的方式互相迁移，来减少源域与目标域之间的差距；或者将源域和目标域的数据特征变换到同一特征空间中 基于模型迁移 从源域和目标域中找到他们之间共享的参数信息,以实现迁移的方法 基于关系迁移 比较关注源域和目标域的样本之间的关系 如下图 4月2日简要描述先验概率和后验概率 首先说明一下条件概率（似然概率） 一个事件发生后另一个事件发生的概率 一般形式为P(X|Y)，表示事件Y发生的条件下事件X发生的概率 先验概率 事件发生前的预判概率 可以是基于历史数据的统计，可以由背景常识得出，也可以是人的主观观点给出。 一般都是单独事件发生的概率，如 P(A)、P(B)。 后验概率 基于先验概率求得的反向条件概率，形式上与条件概率相同（若 P(X|Y) 为正向，则 P(Y|X) 为反向） 贝叶斯公式如下$$P(Y|X) = \\frac{P(X|Y)P(Y)}{P(X)}P(Y|X) = \\frac{P(X|Y)P(Y)}{P(X)}$$ 4月3日简要描述熵、联合熵、条件熵、相对熵、交叉熵的作用 熵：描述一个随机变量的不确定程度，不确定程度越大熵越大 联合熵：描述一对随机变量平均所需要的信息量 条件熵：已知随机变量X的条件下描述随机变量Y所需的信息量 相对熵：衡量两个随机分布的差距（当两个分布相同时，相对熵为0） 交叉熵：衡量估计模型与真实概率分布之间的差异（设计模型时我们希望交叉熵为0） 什么是互信息，互信息有什么作用？ 互信息I(X; Y)表示在知道Y的情况下X不确定性的减少量，即Y透露了多少关于X的信息量 互信息值越大，表示两个汉字之间的结合越紧密，越有可能成词 4月4日深度学习、神经网络、机器学习之间的关系 首先，深度学习问题是机器学习问题的一种，指从有限样例中，通过算法总结出一般性的规律，并可以应用到新的位置数据上 其次，和传统的机器学习不同，深度学习采用的模型一般比较复杂。 神经网络是深度学习中比较常用的模型，因为它比较好的解决了贡献度分配问题（即各个组件的贡献度问题） 深度学习和神经网络并不等价，深度学习可以使用神经网络，也可以使用其他模型（例如深度信念网络，是一种概率图模型） 4月5日模型中加入正则化项的目的是什么？ 一个好的模型应当有一个比较小的期望错误，但由于不知道真实的数据分布和映射函数，实际上无法计算期望风险。 所以我们只能通过在给定训练集上计算经验风险（即训练集上的平均损失），来得到一个比较好的模型。 由于训练数据少或噪声或模型能力强等原因，容易造成模型在其他数据集上的泛化能力不强，即过拟合。 引入正则化项的目的是限制模型的能力，使其不要过度地最小化经验风险，从而一定程度上避免过拟合。","categories":[{"name":"周知识总结","slug":"周知识总结","permalink":"http://zivblog.top/categories/%E5%91%A8%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://zivblog.top/tags/Artificial-Intelligence/"}]},{"title":"周知识总结（3.23~3.29）","slug":"周知识总结（3-23-3-29）","date":"2020-04-16T03:08:35.000Z","updated":"2020-07-06T05:49:31.229Z","comments":true,"path":"passages/zhou-zhi-shi-zong-jie-3-23-3-29/","link":"","permalink":"http://zivblog.top/passages/zhou-zhi-shi-zong-jie-3-23-3-29/","excerpt":"周知识总结","text":"周知识总结 3月23日激活函数有哪些性质？ 非线性：当激活函数是线性的，一个两层的神经网络就可以逼近所有的函数，层数的增加并不会带来什么收益。 可微性：当优化方法是基于梯度的时候，该性质必须得到满足。 单调性：当激活函数是单调的，单层网络就能够保证是凸函数。 f(x)≈x：当激活函数满足该性质是，如果参数的初始化是随机的较小值，那么神经网络的训练将会很高效，如果不满足这个性质，就需要详细地设置初始值 输出值的范围：当激活函数的输出值是有限的时候，基于梯度的优化方法会更加稳定，因为特征的表示受有限权值的影响更显著；当激活函数的输出是无限的时候，模型的训练会更加高效，不过在这种情况下，一般需要更小的学习率 如何选择激活函数？ 在不确定的情况下，可以将大多数的激活函数都试试，最后看一下哪一种的表现更好 不过存在一些可以参考的指标的选择： 如果输出是0, 1值，则输出层选择使用Sigmoid函数，然后其他单元都选择ReLU函数 如果在隐藏层不确定使用哪个激活函数，那么通常会使用ReLU激活函数；有时也会使用Tanh激活函数。ReLU有一个比较好的特点就是，当权值为负的时候，导数为0 Sigmoid激活函数，除了输出层是一个二分类问题，其他基本不使用 Tanh激活函数，几乎适用于所有场合 ReLU激活函数，最常用的默认激活函数 如果遇到一些死的神经元，我们可以使用Leaky ReLU激活函数 3月24日使用ReLU激活函数的优点？ 在区间变动很大的时候，ReLU激活函数的导数都会远大于0，在实践中，使用ReLU激活函数神经网络会学习的更快 sigmoid和tanh函数的导数在正负饱和区的梯度会接近于0，会造成梯度弥散，而ReLU的大于0部分都为常数，不会产生梯度弥散现象 但是ReLU在负半区的梯度为0，此时神经元不会训练，产生稀疏性，使用Leaky ReLU可以避免该问题 调节Batch_Size对训练效果有何影响？ Batch size太小，模型表现效果很差（error上升很快） 随着Batch Size的增大，处理相同数据量的速度越快 随着Batch Size，达到相同精读需要的epoch数量越来越多 由于上述两种因素的矛盾， Batch_Size增大到某个时候，达到时间上的最优。 由于最终收敛精度会陷入不同的局部极值，因此Batch_Size增大到某些时候，达到最终收敛精度上的最优 3月25日什么是归一化、标准化、正则化？ 归一化是讲数据映射到指定的范围，用于去除不同维度数据的量纲以及量纲单位。常见的映射范围有[0, 1]和[-1, 1] 标准化：将数据按比例缩放，使之落入一个小的特定空间。比如Z-Score，将数据的均值缩放到0，方差缩放到1 正则化：引入魔心复杂度的惩罚项，放置模型学习能力过强导致过拟合 为什么要进行归一化？ 为了后面数据处理的方便，归一化可以避免一些不必要的数值问题 为了程序运行时收敛加快 避免神经元饱和。即当神经圆的激活在接近1或0的时候会饱和，这些区域的梯度接近于0，反向传播的过程中，局部梯度会接近于0，导致无法更新参数 保证输出数据中数值小的不被吞食 3月26日深度网络存在那些问题？有无解决方法 网络越深，需要的训练样本越多 多层神经网络的参数优化是一个高阶非凸优化问题，经常得到收敛较差的局部解 梯度扩散问题，BP算法计算出的梯度随着深度向前而显著下降，导致前面网络参数更新很慢 逐层贪婪训练，即训练网络的第一个隐藏层，再训练第二个，最后用这些训练好的网络参数值作为整体网络参数的初始值。经过预训练最终能得到比较好的局部最优解 什么是模型微调？模型微调有哪几种状态？ 微调：即用别人的参数、修改后的网络和自己的数据进行训练，使得参数适应自己的数据，这样一个过程，通常称之为微调 微调有三种状态： 只预测，不训练。相对快、简单，针对那些应景训练好，现在要实际对未知数据进行标注的项目，非常高效 训练，但只训练最后的分类层。 完全训练，整个网络都参与训练。比较耗时，但预测精度也会提升不少。 权重初始化需要注意的事项？ 不能全部初始化为0。请参考这里 可以初始化为小的随机数，但不是随机数越小越好。 用1/sqrt(n)校准方差，n是输入值 稀疏初始化，即把所有权重矩阵都设为0，但是每个神经元都随机地连接到其下层的一个神经元 偏差（bias）是可以初始化为0的，通常建议的是使用ReLU单元以及下方公式$$w = np.random.randn(n) * \\sqrt{\\frac{2.0}{n}}$$ 3月27日学习率的作用？ 在机器学习中，监督式学习通过顶一个模型，并根据训练集上的数据估计最优参数。 梯度下降法是一个被广泛使用的最小化模型误差的参数优化算法。 而学习率在迭代过程中会控制模型的学习进度。 在梯度下降法中，学习率一般是统一的。 但是也存在一些方法：在迭代优化的前期学习率较大，到后面逐步减小学习率的值。常见的有：分段常数衰减、多项式衰减、指数衰减、噪声线性余弦衰减等 模型中加入正则化项的目的是什么？ 一个好的模型应当有一个比较小的期望错误，但由于不知道真实的数据分布和映射函数，实际上无法计算期望风险。 所以我们只能通过在给定训练集上计算经验风险（即训练集上的平均损失），来得到一个比较好的模型。 由于训练数据少或噪声或模型能力强等原因，容易造成模型在其他数据集上的泛化能力不强，即过拟合。 引入正则化项的目的是限制模型的能力，使其不要过度地最小化经验风险，从而一定程度上避免过拟合。 3月28日卷积层和池化层有什么区别？ 卷积层和池化层在结构上有一定的相似性，都是对感受域内的特征进行提取，但是其内在操作有一定的区别 卷积层 池化层 结构 零填充时输出维度不变，而通道数改变 通常特征维度会降低，通道数不变 稳定性 输入特征发生细微改变时，输出结果会改变 感受域内的细微变化不影响输出结果 作用 感受域内提取局部关联特征 感受域内提取泛化特征，降低维度 参数量 与卷积核尺寸、卷积核个数相关 不引入额外参数 CNN与RNN的区别？ 类别 特点描述 相同点 1、传统神经网络的扩展。2、前向计算产生结果，反向计算模型更新。3、每层神经网络横向可以多个神经元共存,纵向可以有多层神经网络连接。 不同点 1、CNN空间扩展，神经元与特征卷积；RNN时间扩展，神经元与多个时间输出计算2、RNN可以用于描述时间上连续状态的输出，有记忆功能，CNN用于静态输出 为什么RNN训练的时候Loss波动比较大？ 由于RNN特有的memory会影响后期其他的RNN的特点，梯度时大时小，learning rate没法个性化的调整，导致RNN在训练的过程中，Loss会震荡起伏 为了解决RNN的这个问题，在训练的时候，可以设置临界值，当梯度大于某个临界值，直接截断，用这个临界值作为梯度的大小，防止大幅震荡。 3月29日如何通俗的理解GAN？ GAN（Generative Adversarial network） GAN由生成器和判别器组成，生成器负责生成样本，判别器负责判断生成器生成的样本是否为真。 生成器要尽可能的迷惑判别器，而判别器要尽可能区分生成器生成的样本和真实样本 随着时间的进行，两者在相互博弈下都会越来越强 生成式模型和判别式模型的区别？ 对于机器学习模型，我们根据模型对数据的建模方式将模型分为两大类，生成式模型，判别式模型 具体而言： 生成式模型：由数据学习联合概率分布P(X, Y)，然后由P(Y|X) = P(X, Y)/P(X)求出概率分布P(Y|X)作为预测的模型。该方法表示了给定输入X与输出Y之间的生成关系 判别式模型：有数据直接学习决策函数或条件概率分布P(Y|X)作为预测模型。判别方法关心的是对于给定的输入X，应该预测什么样的输出Y 举一个生动点的例子，如果我们训练一个关于猫狗分类的模型 对于判别式模型，只需要学习二者的差异即可。例如猫的体型会小一些等 对于生成式模型，则需要学习猫的样子，狗的样子。然后根据长相去区分","categories":[{"name":"周知识总结","slug":"周知识总结","permalink":"http://zivblog.top/categories/%E5%91%A8%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://zivblog.top/tags/Artificial-Intelligence/"}]},{"title":"周知识总结（3.16~3.22）","slug":"周知识总结（3-16-3-22）","date":"2020-04-16T03:00:36.000Z","updated":"2020-07-06T05:49:25.244Z","comments":true,"path":"passages/zhou-zhi-shi-zong-jie-3-16-3-22/","link":"","permalink":"http://zivblog.top/passages/zhou-zhi-shi-zong-jie-3-16-3-22/","excerpt":"周知识总结","text":"周知识总结 3月16日简述决策树中剪枝处理的作用及策略 剪枝处理是决策树学习算法用来解决过拟合问题的一种办法 在决策树算法中，为了尽可能的正确分类训练样本，结点会不断的进行划分，有时候可能会导致决策树的分支过多，以至于训练样本本身的特点被当作泛化特点，最终导致过拟合。 因此，需要采用剪枝的方法来去掉一些分支来降低过拟合的风险。 剪枝的策略一般分为两种：预剪枝和后剪枝 预剪枝：在决策数生成的过程中，评估每个结点划分前和划分后的泛化性能，如果不能提升性能，则停止划分 后剪枝：决策树构建完毕后，再自上而下的对非叶结点进行考察，若将此节点标记为叶节点能带来泛化性能的提升，则修改当前节点为叶节点，舍弃它的子节点 简述决策树的基本原理 决策树是一种分而治之的决策过程 一个困难的预测问题，通过树的分支结点，被划分为两个或多个较为简单的子集（子问题）。 不断根据规则分割数据集，随着树的深度不断增加，分支结点的子集越来越小，要处理的问题也越来越简化。当分支结点的深度或者问题的简单程度满足设定条件时，一棵用于解决该问 3月17日试简述支持向量机中核函数的特点及作用 核函数的特点 核函数的引入可以避免“维度灾难”，大大减小了计算量。因此可以快速有效的处理高维输入 无需直到线性变换函数的形式和参数 核函数的形式和参数的变化，会隐式地改变输入空间到特征空间的映射，进而对特征空间的性质产生影响，最终改变各种和方法的性能 核函数可以和不同的算法灵活结合 核函数的作用 在支持向量机中，引入核函数可以把原来坐标系中线性不可分的数据用核函数投影到另一个空间，尽量是的数据在新的空间里线性可分 支持向量机为什么要引入对偶问题 对偶问题将原始问题中的不等式约束转化为了对偶问题中的等式约束，对偶问题一般来说更容易解决 由于拉格朗日表达式中有内积，可以很自然的使用核函数 试比较逻辑回归和支持向量机的异同 相同点 LR和SVM都是分类算法 LR和SVM都是监督学习算法 LR和SVM都是判别模型 不考虑核函数，LR和SVM都是线性分类算法 不同点 LR采用log损失，SVM采用合页(hinge)损失 LR对异常值敏感，SVM对异常值不敏感 计算复杂度不同。对于海量数据，SVM的效率较低，LR效率比较高 对非线性问题处理方式不同。LR必须要构造特征，SVM还可以通过核函数解决 SVM的损失函数自带正则，而LR需要加入正则项 SVM会用核函数而LR一般不用核函数（计算量太大） 3月18日试简述极大似然估计 极大似然估计的目的就是：利用已知的样本结果，反推最有可能（最大概率）导致这样结果的参数值 极大似然估计时建立在极大似然原理基础上的一个统计方法。极大似然估计提供了一种给定观察数据来评估模型参数的方法（“模型已定，参数未知”）。 所谓极大似然估计，是通过若干次实验，观察其结果，利用实验结果得到某个参数值能够使样本出现的概率为最大 试解释贝叶斯分类器的基本原理 贝叶斯分类器通过相关概率已知情况下的误判损失来选择最优的类别分类 假设有N种可能的分类标记，记为Y={c1, c2, c3, ...cn} 对于样本x，分别计算其属于第i类的概率P(ci|x) 通过比较所有的概率，得到样本所属的最佳类别，将样本和类别带入贝叶斯公式计算$$P(c_i|\\boldsymbol{x})=\\frac{P(\\boldsymbol{x}|c_i)P(c_i)}{P(\\boldsymbol{x})}.$$ 其中p(ci)是先验概率，p(x|ci)为条件概率。根据求条件概率的方式不同，可以得到多重贝叶斯分类器 例如朴素贝叶斯，所谓朴素，即假设所有属性相互独立 3月19日简述EM算法的基本思想 EM算法，即最大期望算法（Expectation-Maximization algorithm， EM），该算法通过迭代进行极大似然估计的优化算法，用于对包含隐含变量或缺失数据的概率模型进行参数估计 EM算法分为两个步骤，算法步骤是对两个步骤的交替计算 第一步是计算期望（E），利用隐藏变量的现有估计值，计算其最大似然估计值 第二步是最大化（M），最大化在E步上求得的最大似然值来计算参数的值 之后M步上得到的参数将用于下一个E步的计算，这个过程不断交替进行 比较聚类与分类的区别 聚类： 聚类是把相似的东西放到一起，并不需要这一类到底是什么 聚类算法属于无监督学习 分类： 分类之前，我们需要知道所有可能的类别，然后要根据数据的特征将数据分到最符合的类别中 分类算法一般都是监督学习算法 3月20日简述四种常见的聚类算法 k-means聚类、DBSCAN、层次聚类、SOM聚类 K-means聚类 以k为参数值，将数据集划分成k个簇，使簇内具有较高的相似度，二簇间的相似度较低 算法流程 任意选择k个对象作为初始的簇中心，将个数据集中对象都划分到一个簇中 根据簇中对象的平均值，替换簇中心 根据新的簇中心，同时将每个对象划分到一个新的簇中 重复上述二三步，直至簇中心不再变化（或变化幅度小于阈值） DBSCAN 基于密度的聚类算法 算法步骤： 确定半径和minPoint 从初始结点开始，检查半径之内的点的数量是否大于minPoint（即密度） 若满足条件则将该点作为核心点，并将每个对象唯一的分配给已经确定了的中心点 该算法比较大的优势是不需要指定类别数 层次聚类 根据层次分解的顺序可以分为自底向上的凝聚层次聚类和自顶向下的分裂层次聚类 算法流程（基于最小距离的凝聚层次聚类算法）： 将每个对象看作一类，计算两两之间的最小距离 将距离最小的两个类合并成一个新类 重新计算新类与所有类之间的距离 重复二三步直到所有类最后合并成一类 SOM聚类算法 SOM是一种神经网络，包含输入层和输出层。可以实现从输入空间到输出平面的降维映射 输入层对应一个高维的输入向量 输出层由一系列组织在二维网络网格上的有序结点构成 算法流程 网络初始化，对输出层每个节点权重赋初值 从输入样本中随机选取输入向量并且归一化，找到与输入向量距离最小的权重向量 定义获胜单元，在获胜单元的邻近区域调整权重使其向输入向量靠拢 提供新样本、进行训练 收缩邻域半径、减小学习率、重复，直到小于允许值，输出聚类结果 3月21日神经网络的为什么使用“深层”表示 深度神经网络是一种特征递进式的学习算法，浅层的神经元直接从输入数据中学习一些浅层的简单特征，而深层的特征是通过浅层的特征继续学习到的更高级的特征，从计算机的角度学习了更多的语义信息 深层的网络隐藏单元数量相对较少，隐藏层数目比较多，如果浅层的网络想要达到同样的计算结果则需要指数级增长的神经元数量才可以实现 为什么深层神经网络会难以训练 梯度消失 通过隐藏层反向传播的时候，梯度会变得越来越小，故前面的网络层的学习会显著慢于后面的网络层，学习会“卡住” 梯度爆炸 梯度在网络更新的过程中不断累积，变成非常大的梯度，导致网络权重值的答复更新，使网络不稳定，在极端情况下，权重值甚至会溢出，导致权重无法更新 权重矩阵的退化 权重矩阵的退化会导致模型的有效自由度减少。即网络的可用自由度对学习中梯度范数的贡献不均衡，随着相乘矩阵的数量的增加，矩阵的乘积变得越来越退化 3月22日前向传播与反向传播的区别 前向传播作用于每一层的输入，通过逐层计算得到输出结果 反向传播作用于网络的输出，通过计算梯度由深到浅更新网络参数 神经网络更”深“具有什么意义 前提是在一定范围内，不能无限制的加深神经网络 在神经元数量相同的情况下，深层网络结构具有更大容量，分层组合带来的是指数级的表达空间，能够组合成更多不同类型的子结构，这样可以更容易地学习和表示各种特征 隐藏层增加意味着由激活函数带来的非线性变换的嵌套层数曾多，就能构造更复杂的映射关系 为什么需要非线性激活函数 假若神经网络中全部都是线性部件，那么线性的组合还是线性，与单独一个线性分类器无益 使用非线性激活函数，以便使网络更加强大，增加它的能力，使它可以学习复杂的事物，复杂的表单数据，以及表示输入输出之间非线性的复杂的任意函数映射 使用非线性激活函数，能够在输入输出之间简历非线性映射","categories":[{"name":"周知识总结","slug":"周知识总结","permalink":"http://zivblog.top/categories/%E5%91%A8%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://zivblog.top/tags/Artificial-Intelligence/"}]},{"title":"Leetcode之二叉树的右视图","slug":"Leetcode之二叉树的右视图","date":"2020-04-16T02:11:34.000Z","updated":"2020-07-06T05:12:05.754Z","comments":true,"path":"passages/leetcode-zhi-er-cha-shu-de-you-shi-tu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-er-cha-shu-de-you-shi-tu/","excerpt":"Binary Tree RIght Side View","text":"Binary Tree RIght Side View Binary Tree RIght Side View code with Python title number：199 读题 给定一棵二叉树，想想自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值 示例 ​ 思路一 转化为层次遍历，即取层次遍历中每层的最后一个结点 具体而言 利用队列来存储结点 取每层的最后一个结点加入最终结果 1234567891011121314151617def rightSideView(self, root: TreeNode) -&gt; List[int]: res = [] if not root: return res deque = [root] while deque: len_ = len(deque) # 仅将当前层的最后一个结点加入结果集中 res.append(deque[-1]) for _ in range(len_): cur = deque.pop(0) if cur.left: deque.append(cur.left) if cur.right: deque.append(cur.right) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之乘积最大子数组","slug":"Leetcode之乘积最大子数组","date":"2020-04-15T06:34:22.000Z","updated":"2020-07-06T05:09:48.204Z","comments":true,"path":"passages/leetcode-zhi-cheng-ji-zui-da-zi-shu-zu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-cheng-ji-zui-da-zi-shu-zu/","excerpt":"Maximum Product Subarray","text":"Maximum Product Subarray Maximum Product Subarray code with Python title number：152 读题 给定一个整数数组，找出数组中乘积最大的连续子数组，返回其乘积 思路一 暴力破解， 穷举所有可能的连续子数组，使用一个变量来存储当前最大的连续子数组之积 1234567891011def maxProduct(self, nums: List[int]) -&gt; int: max_ = nums[0] temp = None for i in range(len(nums)): temp = nums[i] max_ = max(temp, max_) for j in range(i+1, len(nums)): temp *= nums[j] max_ = max(temp, max_) return max_ 意料之中，超时了 思路二 动态规划分析框架，请参考这篇文章 这个题比较特殊，需要分别记录乘积最大和乘积最小的子数组的值。这是因为乘法运算中，一个负数很可以使一个很大的数变为很小的数 状态表示 集合定义 $f(i)$ 以第i个元素为结尾的子数组的乘积的集合 属性 最大值 最小值 状态计算 以第i个数为正数还是负数为划分依据 当第i个数为正数时，第i个数乘以以i-1个数为结尾的最大值即为当前最大值，即$f(i){max} = f(i-1){max} * nums[i]$；同时也要更新当前的最小值，即$f(i){min} = f(i-1){min}*nums[i]$ 当第i个数为负数是，第i个数乘以以i-1个数为结尾的最小值即为当前最大值，即$f(i){max} = f(i-1){min}*nums[i]$；同时也要跟新当前的最小值，即$f(i){min} = f(i-1){max} * nums[i]$ 所求即为dp_max中的最大值 123456789101112def maxProduct(self, nums: List[int]) -&gt; int: n = len(nums) dp_max, dp_min = [1]*(n+1), [1]*(n+1) ans = float('-inf') for i in rnge(1, n+1): dp_max = max(dp_max[i-1]*nums[i-1], dp_min[i-1]*num[i-1], nums[i-1]) dp_min = min(dp_max[i-1]*nums[i-1], dp_min[i-1]*nums[i-1], nums[i-1]) ans = max(ans, dp_max[i]) return ans 我们发现，dp[i]只与dp[i-1]相关，因此我们并不需要两个动态规划数组，只需要两个额外的变量来记录即可 123456789101112def maxProduct(self, nums: List[int]) -&gt; int: n = len(nums) dp_max, dp_min = 1, 1 ans = float('-inf') for i in rnge(1, n+1): temp = dp_max dp_max = max(dp_max*nums[i-1], dp_min*nums[i-1], nums[i-1]) dp_min = min(temp*nums[i-1], dp_min*nums[i-1], nums[i-1]) ans = max(ans, dp_max) return ans 时间和空间上都有所优化","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"标准01背包问题","slug":"标准01背包问题","date":"2020-04-14T13:01:00.000Z","updated":"2020-07-24T03:54:51.808Z","comments":true,"path":"passages/biao-zhun-01-bei-bao-wen-ti/","link":"","permalink":"http://zivblog.top/passages/biao-zhun-01-bei-bao-wen-ti/","excerpt":"标准01背包问题","text":"标准01背包问题 题目描述 有N件物品和一个容量是V的背包。每件物品只能使用一次。 第i件物品的体积是$v_i$，价值是$w_i$ 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大，返回最大价值 解题思路 我们使用闫式DP分析法给出的框架进行分析 首先，应该明确所有的情况有$2^N$种（每件物品选或不选）,且该问题为最大值问题 状态表示：$f(i, j)$ 集合定义：所有只考虑前i个物品且总体积不超过j的选法的集合 属性：上述集合中选法对应价值的最大值 状态计算：根据最后一个不同点划分集合 由于每个物品有两种选择，即选或不选，我们以第i个物品选不选作为集合划分标准 选择第i个物品，则当前体积上限变为$j-V_i$，集合变为了所有只考虑前i-1个物品且总体积不超过$j-V_i$的选法的集合。根据集合定义，表达式为$f(i-1, j-v_i)+w_i$ 不选择第i个物品，则集合变为了所有只考虑前i-1个物品且总体积不超过j的选法的集合，根据集合定义，表达式为$f(i-1, j)$ 综上，$f(i, j) = max[f(i-1, j-v_i)+w_i, f(i-1, j)]$ 所求即为$f(N, V)$：只考虑前N个物品且总体积不超过V的集合中的最大价值 1234567891011121314151617def backpack(self, v: List[int], w: List[int], N: int, V: int) -&gt; int: ''' v: n件物品对应的体积 w: n件物品对应的价值 N: 物品数量 V: 背包容量 ''' f = [[0 for _ in range(V+1)] for _ in range(N+1)] # 遍历物品 for i in range(1, N+1): # 遍历所有可能容积 for j in range(V+1): f[i][j] = f[i-1][j] # 只有在当前的背包空间大于最第i个物品所占空间时 if j &gt;= v[i-1]: f[i][j] = max(f[i][j], f[i-1][j-v[i-1]]+w[i-1]) return f[N][V] 优化 所谓优化是针对代码进行的优化，并不是对算法本身的优化 由于我们的背包空间与第i个物品所占空间之间存在不确定关系，所以将物品所占空间从大到小遍历即可 另外，$f(i ,j)$只与$f(i-1, ~)$有关，所以可以省去一维，节省空间 123456789101112131415def backpack(self, v: List[int], w: List[int], N: int, V: int) -&gt; int: ''' v: n件物品对应的体积 w: n件物品对应的价值 N: 物品数量 V: 背包容量 ''' f = [0 for _ in range(V+1)] j = V for i in range(1, N+1): # 空间从大到小遍历 while j &gt;= v[i-1]: f[j] = max(f[j], f[j-v[i-1]]+w[i-1]) j -= 1 return f[V]","categories":[{"name":"算法","slug":"算法","permalink":"http://zivblog.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"前中后缀表达式的转换及计算","slug":"前中后缀表达式的转换及计算","date":"2020-04-14T03:44:56.000Z","updated":"2020-07-06T05:46:42.917Z","comments":true,"path":"passages/qian-zhong-hou-zhui-biao-da-shi-de-zhuan-huan-ji-ji-suan/","link":"","permalink":"http://zivblog.top/passages/qian-zhong-hou-zhui-biao-da-shi-de-zhuan-huan-ji-ji-suan/","excerpt":"前中后缀表达式的转换及计算","text":"前中后缀表达式的转换及计算 前言 对于人类来讲，中缀表达式是有利于直观理解的，为什么要将中缀表达式转化为前、后缀表达式呢？在我看来，可能有以下几点原因： 中缀表达式有运算符的优先级要求，而前、后缀表达式没有 中缀表达式通过括号提升某些运算的优先级，而前、后缀表达式通过调整运算符位置表示优先级 另外，前、后缀表达式只利用一个栈就能实现表达式的计算，相比于中缀表达式，更适合计算机运算 下面分别介绍中缀表达式如何转化为前、后缀表达式，以及如何使用栈计算前、后缀表达式 表达式的转换中缀转前缀 对于给定的中缀表达式，从右向左扫描 与操作数直接记录（从右向左记录） 与操作符： 栈空时，直接入栈 右括号，直接入栈 其他情况，判断栈顶元素： 栈顶元素为右括号，直接入栈 当前元素优先级小于栈顶元素优先级，栈顶元素出栈 当前元素优先级大于等于栈顶元素优先级，操作符入栈 若栈顶元素为左括号，则栈中左右括号及其之间的元素全部出栈 中缀转后缀 对于给定的中缀表达式，从左向右扫描 操作数直接记录（从左向右记录） 遇操作符： 栈空时，直接入栈 左括号，直接入栈 其他情况，判断栈顶元素： 栈顶为左括号，操作符入栈 当前运算符优先级小于等于栈顶运算符优先级，栈顶元素出栈 当前运算符优先级大于栈顶运算符优先级，操作符入栈 若栈顶为右括号，则栈中左右括号及其之间的元素全部出栈 至扫描完毕 表达式计算计算前缀表达式 对于给定前缀表达式 从右向左扫描 遇操作数入栈 遇操作符： 出栈两个操作数，先出的在左，后出的在右，执行计算 结果入栈 至扫描结束，栈顶元素即表达式结果 计算后缀表达式 对于给定后缀表达式 从左向右扫描 遇操作数入栈 遇操作符： 出栈两个操作数，先出的在右，后出的在左，执行计算 结果入栈 至扫描结束，栈顶元素即表达式结果","categories":[{"name":"算法","slug":"算法","permalink":"http://zivblog.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之逆波兰表达式求值","slug":"Leetcode之逆波兰表达式求值","date":"2020-04-14T03:36:50.000Z","updated":"2020-07-06T05:23:32.912Z","comments":true,"path":"passages/leetcode-zhi-ni-bo-lan-biao-da-shi-qiu-zhi/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-ni-bo-lan-biao-da-shi-qiu-zhi/","excerpt":"Evaluate Reverse Polish Notation","text":"Evaluate Reverse Polish Notation Evaluate Reverse Polish Notation code with Python title number：150 读题 根据逆波兰表达式，求表达式的值 有效的运算符包括+、-、*、/，每个运算对象可以是整数，也可以是另一个逆波兰表达式 说明： 整数除法只保留整数部分 给定的逆波兰表达式总是有效的，不存在除数为0或得不出有效数值的情况 所谓逆波兰表达式即：后缀表达式。 关于前中后缀表达式的转化及计算，请见这篇文章 思路一 根据上面链接中的介绍，后缀表达式的计算需呀借助一个栈来进行，具体细节不再描述 12345678910111213141516171819202122def evalRPN(self, tokens: List[str]) -&gt; int: stack = [] operator = ['+', '-', '*', '/'] for c in tokens: # 操作数，入栈 if c not in operator: stack.append(c) # 操作符，取栈中两个数并计算，注意顺序 else: right = int(stack.pop()) left = int(stack.pop()) if c == '+': stack.append(left+right) elif c == '-': stack.append(left-right) elif c == '*': stack.append(left*right) elif c == '/': stack.append(left/right) return int(stack.pop())","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之目标和","slug":"Leetcode之目标和","date":"2020-04-13T08:32:53.000Z","updated":"2020-07-06T05:23:24.005Z","comments":true,"path":"passages/leetcode-zhi-mu-biao-he/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-mu-biao-he/","excerpt":"Target Sum","text":"Target Sum Target Sum code with Python title number：494 读题 给定一个非负整数数组a1, a2, ... an，和一个目标数S 现有两个符号+和-，对数组中的任意一个整数，你都可以从+和-中选择一个符号添加到整数前面 返回可以使最终数组和为目标数的所有添加符号的方法数 示例： 12345678输入：nums&#x3D;[1, 1, 1, 1, 1], S&#x3D;3输出：5解释：-1+1+1+1+1 &#x3D; 3+1-1+1+1+1 &#x3D; 3+1+1-1+1+1 &#x3D; 3+1+1+1-1+1 &#x3D; 3+1+1+1+1-1 &#x3D; 3 注意： 数组非空 数组和不超过1000 方法一 动态规划，我们使用之前介绍的闫式DP分析法分析该问题 首先我们分析一下，在枚举的情况下，每一个数的后面我们都有两种选择，所以集合的规模是$2^{n}$ 使用之前介绍的框架 状态表示 集合是什么：$f(i, j)$，前i个元素经过计算为j的所有情况的集合 属性：满足条件的序列个数 状态计算 由于每个位置只有两种选择（即+和-），所以我们可以以此来划分集合 集合可以划分为一下两部分，并根据最初对集合的定义分别得到两部分的表达式： 最后一个元素前放置+ 对于这种情况，已经确定最后一项是做加法，那么对于前i-1项的情况则变为：前i-1个元素经过计算为j-num[i]的集合 根据定义，表示为$f(i-1, j-nums[i])$ 最后一个元素前放置- 对于这种情况，已经确定最后一项是做减法，那么对于前i-1项的情况则变为：前i-1个元素经过计算为j+nums[i]的集合 根据定义，表示为$f(i-1, j+nums[i])$ 综合起来，$f(i, j) = f(i-1, j+nums[i]) + f(i-1, j-nums[i])$ 根据定义，所求即为$f(len(nums), S)$，即包含所有元素和为S的情况的数目 朴素版本的代码 123456789101112131415161718192021def findTargetSumWays(self, nums: List[int], S: int) -&gt; int: if len(nums) == 0: return 0 # S的范围至多是[-s, s+1] s = sum(nums) # 使用dict存储，&#123;i : j&#125; dp = [dict() for _ in range(len(nums))] if nums[0] == 0: # 加和减都可以 dp[0][nums[0]] = 2 else: # 加或减 dp[0][nums[0]] = 1 dp[0][-nums[0]] = 1 for i in range(1, length): for j in range(-s, s+1): dp[i][j] = dp[i-1].get(j-nums[i], 0) + dp[i-1].get(j+nums[i], 0) return dp[len(nums)-1].get(S, 0) 优化后的代码 由于$f(i)$只与$f(i-1)$有关，所以我们可以优化代码结构————只需存储$f(i-1)$即可 待实现","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"动态规划","slug":"动态规划","date":"2020-04-13T07:39:51.000Z","updated":"2020-07-23T01:11:23.412Z","comments":true,"path":"passages/dong-tai-gui-hua/","link":"","permalink":"http://zivblog.top/passages/dong-tai-gui-hua/","excerpt":"动态规划","text":"动态规划 前言 先挂两个链接，都是质量非常高的资料，本文也参考了其中的内容 动态规划 闫式DP分析法 借用严总的话来说，动态规划是一种基于经验的算法，了解了基本的算法思想后，需要接触各种类型的题目之后才能对与动态规划做到得心应手 下面给出的分析框架是对闫式DP分析法的总结 后面还会对各种类型DP问题结合经典题目进行分析（待施工） 动态规划 本分析法主要是给出一套分析的框架，不同与常见算法书上的刻板描述，这里给出的分析方法结合集合的概念协助分析流程更为平滑 首先，我们要明确的是动态规划问题都是有限集合的最优化问题（求最值，求数量，判断是否存在）。不过较为特殊的是，集合虽然是有限的，但是集合规模一般很大，使用枚举的方式必定是行不通的 分析过程 两个阶段 状态表示（一般用f(i)或f(i, j)等形式表示）（化零为整） 集合定义 该定义极为关键，贯穿整个问题分析的流程 比如01背包问题中，集合定义为：所有只考虑前n个物品且总体积不超过体积V的选法的集合 属性 一般要求题目要求求什么，属性就是什么 比如01背包问题中，属性就是集合中符合条件的的最大值 状态计算（化整为零） 寻找最后一个不同点（划分依据，即根据最后一个不同点对集合进行分类） 再对不同的子集进行表示，组合成为最终的动态规划表达式（状态转移公式） 要求状态计算过程中做到不重复和不遗漏。实际操作中，对不遗漏要求较高，在必要情况下可以重复（比如在求最值的情况下） 单单框架看下来比较抽象，可结合下面各种类型的动态规划题目进行巩固 另外，对于动态规划的所有优化都是针对代码时间复杂度或空间复杂度的优化（即对代码的等价变换），对于算法本身并不存在优化之说 经典题目分析线性DP 爬楼梯 乘积最大子数组 最长公共子序列 最长上升子序列 最大正方形 完全平方数 鸡蛋掉落 不同路径Ⅱ 最小路径和 分割回文串Ⅱ 编辑距离 打家劫舍系列 打家劫舍 股票问题系列 买股票的最佳时机 买股票的最佳时机Ⅱ 最佳买卖股票时机含冷冻期 区间DP 最长回文子序列 背包DP 目标和，01背包问题 标准01问题 标准完全背包问题 零钱兑换 零钱兑换Ⅱ 分割等和子集，变种01背包问题 树形DP Leetcode周赛-第二题-思路二 状态压缩DP 骑士拨号器 数位DP Leetcode周赛-第四题-思路二 计数型DP 待施工 递推型DP 三角形最小路径和 概率DP 待施工 博弈性DP 待施工 记忆化搜索 待施工","categories":[{"name":"算法","slug":"算法","permalink":"http://zivblog.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之二叉树的前序遍历","slug":"Leetcode之二叉树的前序遍历","date":"2020-04-13T03:08:16.000Z","updated":"2020-07-06T05:11:56.485Z","comments":true,"path":"passages/leetcode-zhi-er-cha-shu-de-qian-xu-bian-li/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-er-cha-shu-de-qian-xu-bian-li/","excerpt":"Binary Tree Preorder Traversal","text":"Binary Tree Preorder Traversal Binary Tree Preorder Traversal code with Python title number：144 读题 给定一棵二叉树，返回其按前序遍历得到的节点值列表 思路一 前面的二叉树的中序遍历和二叉树的层序遍历中都使用到了一种名为颜色标记法的方法，这里先用该方法解题 使用颜色标记结点的状态：新节点：白色；已访问结点：灰色 遇到白色结点，将其标记为灰色并将其右结点，左结点，自身（与前序恰好逆序，出栈后即为前序）入栈 遇到灰色结点，则输出结点值 12345678910111213141516def preorderTraversal(self, root: TreeNode) -&gt; List[int]: w, g = 0, 1 stack = [(root, w)] res = [] while stack: node, color = stack.pop() if node is None: continue if color == w: stack.append((node.right, w)) stack.append((node.left, w)) stack.append((node, g)) if color == g: res.append(node.val) return res 思路二 递归遍历，根-&gt;左-&gt;右 12345678910111213def preorderTraversal(self, root: TreeNode) -&gt; List[int]: res = [] def preorder(root): if root is None: return res.append(root.val) preorder(root.left) preorder(root.right) preorder(root) return res 思路三 迭代，借助栈 12345678910111213141516def preorderTraversal(self, root: TreeNode) -&gt; List[int]: res = [] stack = [root] # 辅助栈 if root is None: return [] while stack: node = stack.pop() res.append(node.val) # 入栈先右后左，出栈才是先左后右 if node.right: stack.append(node.right) if node.left: stack.append(node.left) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之单词拆分","slug":"Leetcode之单词拆分","date":"2020-04-12T06:39:39.000Z","updated":"2020-07-06T05:10:29.997Z","comments":true,"path":"passages/leetcode-zhi-dan-ci-chai-fen/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-dan-ci-chai-fen/","excerpt":"Word Break","text":"Word Break Word Break code with Python title number：139 读题 给定一个非空字符串S和一个包含非空单词列表的字典wordDict 判定S是否可以被空格拆分为一个或多个在字典中出现的单词 注意： 拆分时可以重复使用字典中的单词 拆分时不能重复使用字符串中的字符，即单词之间无交集 可以认为字典中不存在重复单词 思路一 我们使用了回溯法来解决分割回文串中的问题，这道题目虽然也是分割问题，但是与分割回文串还是存在区别的 首先，可划分的子串是确定的（在wordDict中） 其次，只需要判断是否可行，而不用列举所有可能 回溯法会重复计算有些位的可拆分情况，要解决该问题，可以使用记忆化回溯或者动态规划 下面先介绍记忆化回溯 所谓记忆化回溯，就是在回溯法的基础上，保存出现过的情况，避免重复计算，具体而言： 定义回溯函数back_track(s) 若S长度为0，则返回true，表示已经使用wordDict中的单词分割完 初始化当前字符串是否可以被分割res=False 遍历索引i，遍历区间为[1, n+1) 如果s[0:i-1]在wordDict中：res=back_track(s[i, n-1])或res（保存遍历结束索引中，可以使用字符串切割完成的情况） 返回res 1234567891011121314151617def wordBreak(self, s: str, wordDict: List[str]) -&gt; bool: import functools # 提升一个方法频繁用相同参数调用场景下的性能 @functools.lru_cache(None) def back_track(s): if not s: return True res = False for i in range(1, len(n+1)): if s[:i] in wordDict: # 做或运算 res = back_track(s[i:]) or res return res return back_track(s) 思路二 动态规划 定义数组dp[]，dp[i]表示字符子串s[0:i]可以在wordDict中找到 初始化，除dp[0]外全部初始化为False 这里建立的不是dp[i]和dp[i-1]的关系，而是dp[i]和dp[i-len(word)]的关系 终止，遍历完整个字符串 12345678910def wordBreak(self, s: str, wordDict: List[str]) -&gt; bool: dp = [False for _ in range(len(s)+1)] dp[0] = True # 第0个位置表示的是字符串中第一个字母前的位置 # 第一个位置是第一个字符后的位置 for i in range(1, len(s)+1): for word in wordDict: if dp[i-len(word)] &amp;&amp; len(word) &lt;= i: if s[i-len(word):i] == word: dp[i] = True return dp[len(s)] || False","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之分割回文串","slug":"Leetcode之分割回文串","date":"2020-04-11T02:59:18.000Z","updated":"2020-07-06T05:15:59.736Z","comments":true,"path":"passages/leetcode-zhi-fen-ge-hui-wen-chuan/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-fen-ge-hui-wen-chuan/","excerpt":"Palindrome Partitioning","text":"Palindrome Partitioning Palindrome Partitioning code with Python title number：131 读题 给定一个字符串S，将S分割成一些子串，使每个子串都是回文串 返回S的所有分割方案（每个方案存储在一个列表中） 示例： 123456输入：&quot;aab&quot;输出：[ [&#39;aa&#39;, &#39;b&#39;], [&#39;a&#39;, &#39;a&#39;, b]] 从示例中可以发现，分割方案中必定存在每个子串均为一个字符的结果 思路一 题目本质上是在求所有可能，即集合，可以使用回溯法 关于回溯法，已经做过多道类似的题目： 组合总和 组合总和Ⅱ 全排列 全排列Ⅱ 子集 子集Ⅱ 具体而言 不断切分字符串，并判断当前子串是否为回文串 若是，则继续切分其后面的子串 若否，则不再切分 直达整个字符串切分完毕，作为一种情况添加到结果集中 123456789101112131415def partition(self, s: str) -&gt; List[List[str]]: res = [] # tmp是当前回溯过程的一个结果 def helper(s, tmp): if not s: res.append(tmp) for i in range(1, len(s)+1): # 当前s为回文子串 if s[:i] == s[:i][::-1]: # 继续进行 helper(s[i:], tmp+[s[:i]]) helper(s, []) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之被围绕的区域","slug":"Leetcode之被围绕的区域","date":"2020-04-10T08:05:03.000Z","updated":"2020-07-06T05:09:01.525Z","comments":true,"path":"passages/leetcode-zhi-bei-wei-rao-de-qu-yu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-bei-wei-rao-de-qu-yu/","excerpt":"Surrounded Regions","text":"Surrounded Regions Surrounded Regions code with Python title number：130 读题 给定一个二维矩阵，包含X和O两种符号 找到所有被X围绕的区域，并将这些区域里所有的O全部用X填充 示例 1234[[X, X, X, X], [[X, X, X, X], [X, O, O, X], ----&gt; [X, X, X, X], [X, X, O, X], [X, X, X, X], [X, O, X, X]] [X, O, X, X]] 说明： 被围绕的区域不会存在于边界上，即边界上的O都不会被填充为X 任何不在边界上，不与边界上的O相连的O最终都会被填充为X 相连是指两个元素在水平或垂直方向上相邻 思路一 根据题意，我们需要将所有除边界上的O和与边界连通的O之外的所有O全部置为X 这涉及到二维数组的深度遍历（类似的题目见单词搜索） 并且为了方便操作，可以事先将所有位于边界上的O和与边界上O相连的O全部标记（比如使用A代替），然后在结束之后再改回来 所以这变成了一个寻找连通区域的问题，我们只需要找到与边界上O连通的O替换为A，最后将剩余的所有O都替换为X，将所有A替换为O即可 123456789101112131415161718192021222324252627282930313233343536def solve(self, board: List[List[str]]) -&gt; None: # 只有一行或者只有一列 if len(board) &lt;= 2 or len(board[0]) &lt;= 2: return row, col = len(board), len(board[0]) def dfs(i, j): # 深度搜索至边界 if i &lt; 0 or j &lt; 0 or i &gt;= row or j &gt;= col or board[i][j] != 'O': return # 替换 board[i][j] = 'A' # 继续遍历其邻接位置（四个方向） dfs(i, j - 1) dfs(i, j + 1) dfs(i - 1, j) dfs(i + 1, j) # 从边界开始， 标记 for i in range(row): # 从第一行和最后一行开始 dfs(i, 0) dfs(i, col - 1) for j in range(col): # 从第一列和最后一列开始 dfs(0, j) dfs(row - 1, j) for i in range(row): for j in range(col): if board[i][j] == 'O': board[i][j] = 'X' if board[i][j] == 'A': board[i][j] = 'O'","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之求根到叶子节点数字之和","slug":"Leetcode之求根到叶子节点数字之和","date":"2020-04-09T08:06:07.000Z","updated":"2020-07-06T05:24:30.024Z","comments":true,"path":"passages/leetcode-zhi-qiu-gen-dao-xie-zi-jie-dian-shu-zi-zhi-he/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-qiu-gen-dao-xie-zi-jie-dian-shu-zi-zhi-he/","excerpt":"Sum Root to Leaf Numbers","text":"Sum Root to Leaf Numbers Sum Root to Leaf Numbers code with Python title number：129 读题 给定一个二叉树，每个结点存放一个0~9之间的数字 每条从根到叶节点的路径表示一个数字 例如：从根到叶子结点路径1-&gt;2-&gt;3代表数字123 计算所有从根到叶子节点生成的数字之和 思路一 我们可以通过深度遍历得到每条路径，然后将其转化为数字，再求和。这是最直接的想法，但是这样的做法包含很多的冗余操作 可以发现，根据题意，路径长度每加一，之前得到的值就要乘十 所以我们可以直接在遍历的过程中计算该数值 具体而言： 深度遍历整棵树，每便利一层，则值为：当前节点值+10*之前的值 递归进行，在左右子树都为空时表示一条路径结束，将其添加到结果集中 12345678910111213141516171819202122def sumNumbers(self, root: TreeNode) -&gt; int: if root is None: return 0 def dfs(root, val, res): if root is None: return val = 10*val + root.val # 叶子节点，路径结束 if not root.left and not root.right: # 向res中添加截止前遍历过的路径之和 res.append(val+res[-1]) return # 递归 if root.left: dfs(root.left, val, res) if root.right: dfs(root.right, val, res) val = 0 res = [0] # res[-1]存储最终结果 dfs(root, val, res) return res[-1]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"nvidia-smi命令详解","slug":"nvidia-smi命令详解","date":"2020-04-08T13:32:01.000Z","updated":"2020-07-06T05:37:10.317Z","comments":true,"path":"passages/nvidia-smi-ming-ling-xiang-jie/","link":"","permalink":"http://zivblog.top/passages/nvidia-smi-ming-ling-xiang-jie/","excerpt":"nividi-smi","text":"nividi-smi 前言nvidia-smi使用来查看GPU的使用情况的 图片一 第一栏中fan参数的百分比值：表示的是风扇转速 第二栏中的Temp表示的是GPU的温度，单位为摄氏度 第三栏中的Perf表示的是性能状态，从p0~p12分别对应max~min 第四栏中的Pwr表示的是能耗，Persistence-M有两个值on/off是持续模式的状态 第五栏中的Bus-id是涉及GPU总线的东西 第六栏中的Memory-Usage表示显存占用 第八栏中的上方是关于ECC的东西 第八栏中下方Compute M是计算模式 图片二 分别显示每个进程对GPU的显存的使用率 注意显存占用和GPU占用并不相同 显卡有GPU和显存等组成，两者的关系类似内存和CPU的关系","categories":[{"name":"工具配置","slug":"工具配置","permalink":"http://zivblog.top/categories/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://zivblog.top/tags/Tools/"}]},{"title":"事实","slug":"事实","date":"2020-04-08T07:03:06.000Z","updated":"2020-07-06T05:47:23.485Z","comments":true,"path":"passages/shi-shi/","link":"","permalink":"http://zivblog.top/passages/shi-shi/","excerpt":"用数据思考，避免情绪化决策","text":"用数据思考，避免情绪化决策 《事实：用数据思考，避免情绪化决策》 汉斯·罗杰斯 &emsp; &emsp;我希望这本书能够改变人们的一些思维方式，使得它们不要受非理性恐惧的困扰，并能够重新把他们的能量投入建设性的行为中。 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;————汉斯 &emsp;&emsp;人类总是有一些情绪化的本能，这些本能可能是进化的产物，也可能是耳熏目染之后的潜意识，不论如何，它们确实阻碍则我们去更好的认识这个世界。 一分为二的本能 人类总向把事情一分为二看待的冲动，而这两类又是互相对立、互相矛盾的。 例如：我们喜欢把世界上的国家分为社会主义国家和资本主义国家；把世界上的人分为穷人和富人。 如何防范一分为二的错误本能： 避免只比较平均数，而是观察总体分布 避免之比较极端情况 避免只俯视，不仰视 负面思维的本能 我们对于坏事总会比好事更加关注 而媒体和社会活动家对于负面新闻会选择性地报道。 与我们自身而言，我们总是对自己经历过的不好的事记忆更深，同时还会因为有坏的事情发生，就不认为世界是在变好 如何防范负面思维的本能： 认清我们更容易获得负面消息的事实，好消息的新闻价值不高 学会区分状态和趋势，同时相信事情可以同时不是好的，但也是在变得更好 认识到循序渐进的进步不会被当成新闻，而正式这种不断的进步让我们的社会变得更好 直线思维的本能 人们总倾向于相信事情是线性发展的 例如：看到一个人口增加的图就会想到人口会无限增加下去 如何避免直线思维的本能： 不要做直线假设。很多事物的发展遵循的是S形曲线、滑梯曲线、驼峰曲线等规律 恐惧的本能 当我们陷入恐惧的时候，我们就无法看到现实。 我们总倾向于接受一些夸张的信息 如何避免恐惧的本能： 我们需要更加理性，要计算真实的风险 认识到：你面临的真实风险，并不取决于它看起来多么吓人，而在于两个因素：危险的程度和发生的概率 采取行动之前，先让自己冷静下来 规模错觉 人们总是容易注意局部而忽略整体。我们总是会注意到一个单一的数字而误判它的重要性。 同时，我们还会系统性的高估了一些其他的比例 如何控制规模错觉： 大的数字总是看起来很大，而单一的数字很容易误导我们，当我们看到单一数字的时候，一定要记得做对比。 二八原则 比例，更加关注比例而不是单一的数字 以偏概全的本能 每个人都会在头脑中自动的进行演绎和归纳。但这种思维结构会让我们在遇到事情的事情倾向于将所有事情都归结为一类 一分为二的本能促使我们将世界分为“我们“和”它们“，而以偏概全的本能使得”我们“认为”他们“是完全一样的 如何避免以偏概全的本能： 我们要经常性的质疑我们的分类方法 在同一类别中寻找不同 在不同类别中寻找相同 在不同类别中寻找不同 注意大多数 注意极端案例 不要假设别人是傻瓜 相信命中注定的本能 我们认为一些事物内在的属性将决定其命运，无论是人民、国家、宗教还是文化 如何控制命中注定的本能： 注意追踪持续的提高，缓慢的改变也仍然是改变 及时更新你的知识 多与老年人对话 单一视角的本能 人们总倾向于认为所有的问题都有单一的原因和单一的解决方案 如何避免单一视角的本能： 检查你的想法，多余不同意见的人讨论 不要相信你在自己的专业领域之外有什么真知灼见 避免在熟悉一种工具之后就倾向于使用该工具解决所有问题 关注数字，而且不仅仅关注数字 当心简单的想法和简单的解决方案 归咎他人的本能 当坏事发生的时候，人们总是图找到一个清晰而简单的理由去责怪其他人 当好事发生的时候，这种本能也会被激发出来 如何控制归咎他人的本能： 寻找原因，而不是寻找坏人 寻找系统，而不是寻找英雄 情急生乱的本能 在我们感知到危险的时候，就立即采取行动 当这种本能被激活的时候，我们的大脑将会丧失思考的能力，而是顺从接收到的指令去行动 如何缓解情急生乱的本能： 深呼吸 坚持了解基础数据 警惕那些带有偏见的预言家 小心过激的行动。通常循序渐进的方案会优于达到阔斧的行动","categories":[{"name":"读书&电影","slug":"读书-电影","permalink":"http://zivblog.top/categories/%E8%AF%BB%E4%B9%A6-%E7%94%B5%E5%BD%B1/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://zivblog.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"Leetcode之路径总和Ⅱ","slug":"Leetcode之路径总和Ⅱ","date":"2020-04-08T02:07:55.000Z","updated":"2020-07-06T05:22:24.901Z","comments":true,"path":"passages/leetcode-zhi-lu-jing-zong-he-ii/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-lu-jing-zong-he-ii/","excerpt":"Path Sum Ⅱ","text":"Path Sum Ⅱ Path Sum Ⅱ code with Python title number：113 读题 给定一棵二叉树，查找满足以下条件的路径 路径从根节点到叶子节点 路径总和等于给定目标和 思路一 回溯法 搜索所有路径，使用temp_path记录当前路径 在访问到叶节点时计算路径总和，若等于给定值则加入结果中 123456789101112131415161718def pathSum(self, root: TreeNode, sum: int) -&gt; List[List[int]]: res = [] if root is None: return [] def dfs(root, sum, temp): if root is None: return # 到达叶节点，并且路径总和等于给定值 if not root.left and not root.right and sum-root.val == 0: temp += [root.val] res.append(temp) return dfs(root.left, sum-root.val, temp+[root.val]) dfs(root.right, sum-root.val, temp+[root.val]) dfs(root, sum, []) return res 关于回溯法与深度优先搜索的区别，请参照回溯法","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之二叉树的锯齿形层次遍历","slug":"Leetcode之二叉树的锯齿形层次遍历","date":"2020-04-07T01:07:03.000Z","updated":"2020-07-06T05:11:46.722Z","comments":true,"path":"passages/leetcode-zhi-er-cha-shu-de-ju-chi-xing-ceng-ci-bian-li/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-er-cha-shu-de-ju-chi-xing-ceng-ci-bian-li/","excerpt":"Binary Tree Zigzag Level Order Traversal","text":"Binary Tree Zigzag Level Order Traversal Binary Tree Zigzag Level Order Traversal code with Python title number：103 读题 给定一个二叉树，返回起结点值的锯齿形层次遍历 即先从左往右，再从右往左进行下一层次遍历，一次类推，层与层之间交替进行 示例： 其锯齿形层次遍历为：[[3], [20, 9], [15, 7]] 思路一 按照二叉树的层序遍历的方法，求得正常情况下的层序遍历结果 再对结果进行后处理，即每隔一层逆置原来的遍历结果 1234567891011121314151617181920212223242526def zigzagLevelOrder(self, root: TreeNode) -&gt; List[List[int]]: if root is None: return [] queue = [root] res = [] # 得到常规的层序遍历结果 while queue: len_ = len(queue) res.append([]) for i in range(len_): node = queue.pop(0) if node.left: queue.append(node.left) if node.right: queue.append(node.right) res[-1].append(node.val) # 调整 tag = False for i in range(len(res)): if tag: res[i] = res[i][::-1] tag = False else: tag = True return res 思路二 上面的思路中进行后调整的做法，会额外的遍历一个结果集，并且需要对其中一半的层进行逆置，额外花费的很多时间 这里我们选择在存储一层结点的时候就按照正向或逆向方式存储，设置一个属性tag用于表示当前层是正向存储还是逆向存储 1234567891011121314151617def zigzagLevelOrder(self, root: TreeNode) -&gt; List[List[int]]: if root is None: return [] queue, res = [root], [] tag = 0 # 表示当前层正向or逆向存储 while queue: res.append([]) for i in range(len(queue)): node = queue.pop(0) if node.left: queue.append(node.left) if node.right: queue.append(node.right) # 正序 or 逆序 if tag % 2 ! = 0: res[-1].insert(0, node.val) else: res[-1].append(node.val) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之二叉树的层序遍历","slug":"Leetcode之二叉树的层序遍历","date":"2020-04-06T07:15:56.000Z","updated":"2020-07-06T05:11:29.233Z","comments":true,"path":"passages/leetcode-zhi-er-cha-shu-de-ceng-xu-bian-li/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-er-cha-shu-de-ceng-xu-bian-li/","excerpt":"Binary Tree Level Order Traversal","text":"Binary Tree Level Order Traversal Binary Tree Level Order Traversal code with Python title number：102 读题 给定一个二叉树，返回按层序遍历得到的结点值 返回的结果为嵌套列表，即每层的节点值分别用一个列表存储 层序遍历：即逐层的，从左往右访问所有节点 思路一 层序遍历一棵树是树的基本操作，操作过程相当于BFS 利用以个队列来存储节点 每次遍历完一层之后判断当前队列中的结点数目（即下一层的结点数，出队该数量的结点，避免判断队列是否为空） 具体操作： 根节点入队 判断当前队列中有多少结点，一次出队并访问 判断其左右子树是否分别存在，存在则入队 1234567891011121314151617def levelOrder(self, root: TreeNode) -&gt; List[List[int]]: if not root: return [] queue = [root] res = [] while queue: # 当前层长度 len_ = len(queue) res.append([]) for i in range(len_): node = queue.pop(0) res[-1].append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return res 思路二 递归 递归访问所有节点，对其左右子树也进行迭代访问 增加一个depth属性，用于标记结点所在的层数 将结点添加到其对应层的列表中 123456789101112def levelOrder(self, root: TreeNode) -&gt; List[List[int]]: res = [] def helper(root, depth): if not root: return if len(res) == depth: res.append([]) res[depth].append(root.val) helper(root.left, depth + 1) helper(root.right, depth + 1) helper(root, 0) return res 思路三 之前在二叉树的中序遍历提到过的颜色标记法，具体思路可看前文 在层序遍历中，需要加一个level属性用于标记层次 1234567891011121314151617def levelOrder(self, root: TreeNode) -&gt; List[List[int]]: w, g = 0, 1 stack = [(root, w, 0)] res = [] while stack: node, color, level = stack.pop() if node: # 结点未访问 if color == w: stack.append((node.right, w, level+1)) stack.append((node.left, w, level+1)) stack.append((node, g, level)) else: if len(res) == level: res.append([]) res[level].append(node.val) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之验证二叉搜索树","slug":"Leetcode之验证二叉搜索树","date":"2020-04-05T07:38:40.000Z","updated":"2020-07-06T05:29:54.144Z","comments":true,"path":"passages/leetcode-zhi-yan-zheng-er-cha-sou-suo-shu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-yan-zheng-er-cha-sou-suo-shu/","excerpt":"Validate Binary Search Tree","text":"Validate Binary Search Tree Validate Binary Search Tree code with Python title number：098 读题 给定一个二叉搜索树，判断其是否是一个有效的二叉搜索树 二叉搜索树特征如下： 节点的左子树只包含小于当前节点的数 节点的右子树只包含大于当前节点的数 所有左子树和右子树自身也必须是二叉搜索树 思路一 根据二叉搜索树的性质，如果我们进行中序遍历，得到的应该是一个升序序列 因此，我们只需进行一次中序遍历，再对遍历得到的序列进行一次遍历 如果存在相邻的两个元素为逆序，则不是二叉搜索树 否则，是二叉搜索树 这个算法的主要优化点在遍历算法，可以尝试时间复杂度更低的，关于中序遍历，可以看这道题的解法 123456789101112131415161718192021def isValidBST(self, root: TreeNode) -&gt; bool: if root is None: return True if root.left is None and root.right is None: return True # 中序遍历 res = [] def inorder(root): if root is None: return inorder(root.left) res.append(root.val) inorder(root.right) inorder(root) # 判断是否有逆序对 for i in range(len(res)-1): if res[i] &gt;= res[i+1]: return False return True 思路二 最大最小值法 由一个点的最大最小值来判断一个结点是否合法 从根节点进行DFS，然后计算每个节点应该的取值范围，如果当前节点不符合就返回 false 例如， 左孩子的范围由父节点的左边界和父节点的值确定 右孩子的范围由父节点的值和父节点的右边界确定 12345678910def isValidBST(self, root: TreeNode): def ds(root, min_, max_): if root is None: return True if root.val &lt;= min_ or root.val &gt;= max_: return False return ds(root.left, min_, root.val) and ds(root.right, root.val, max_) return ds(root, float('-inf'), float(\"inf\"))","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之不同的二叉搜索树","slug":"Leetcode之不同的二叉搜索树","date":"2020-04-04T12:17:58.000Z","updated":"2020-07-06T05:09:09.185Z","comments":true,"path":"passages/leetcode-zhi-bu-tong-de-er-cha-sou-suo-shu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-bu-tong-de-er-cha-sou-suo-shu/","excerpt":"Unique Binary Search Trees","text":"Unique Binary Search Trees Unique Binary Search Trees code with Python title number：096 读题 给定一个整数n，求以1~n为节点组成的二叉搜索树有多少种 示例： 输入：3 输出：5 具体而言： 该题是不同的二叉搜索树Ⅱ的简化版，详细的思路讲解请看这里 思路一 动态规划 定义dp[i]表示i个结点可以有多少种不同结构的二叉树 初始化dp[1]=1 状态转移方程：dp[n]=dp[0]*dp[n-1] + dp[1]*dp[n-2] + dp[n-1]*dp[0] 12345678910def numTrees(self, n): dp = [1]*(n+1) i = 2 while i &lt;= n: res = 0 for j in range(0): res += dp[j] * dp[i-j-1] dp[i] = res i += 1 return dp[n]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之不同的二叉搜索树Ⅱ","slug":"Leetcode之不同的二叉搜索树Ⅱ","date":"2020-04-03T06:14:30.000Z","updated":"2020-07-06T05:09:22.499Z","comments":true,"path":"passages/leetcode-zhi-bu-tong-de-er-cha-sou-suo-shu-ii/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-bu-tong-de-er-cha-sou-suo-shu-ii/","excerpt":"Unique Binary Search Trees Ⅱ","text":"Unique Binary Search Trees Ⅱ Unique Binary Search Trees Ⅱ code with Python title number：095 读题 给定一个整数，生成由1, ..., n为结点的二叉搜索树 示例: 12345678910输入：3输出：[ [1, null, 3, 2], [3, 2, null, 1], [3, 1, null, null, 2], [2, 1, 3], [1, null, 2, null, 3]] 对应于以下五种不同结构的二叉搜索树 思路一 首先，我们要了解二叉搜索树的一个比较好的性质，即在左右子树不为空时： 左子树中的值均小于根节点的值 右子树中的值均大于根节点的值 根据二叉树的性质，我们可以使用递归的方式来构建二叉搜索树 遍历列表1, ...,n，尝试将每一个结点作为根节点，其左边的子列表作为左子树，右边的自列表作为右子树 对左右子树进行同样的处理 至列表只剩一个数或列表为空 例如：把 1 作为根节点，[ ] 空作为左子树，[ 2 … n ] 的所有可能作为右子树；2 作为根节点，[ 1 ] 作为左子树，[ 3…n ] 的所有可能作为右子树 123456789101112131415161718192021222324def generateTrees(self, n: int) -&gt; List[TreeNode]: # n为0 if n == 0: return [] def getAns(start, end): ans = [] # 子列表为空格 if start &gt; end: return [None] # 遍历列表，尝试将每个元素都作为根结点 for i in range(start, end+1): left_tree = getAns(start, i-1) right_tree = getAns(i+1, end) for node_l in left_tree: for node_r in right_node: root = TreeNode(i) root.left = node_l root.right = node_r ans.append(root) return ans return getAns(1, n) 思路二 其实还可以用动态规划解决 定义dp[i][j]表示第i~j个数字的所有可能情况，所以dp[1][n]即为结果集 初始化：若i==j则添加结点val，i&gt;j初始化为空列表，其他情况初始化为[None] 状态转移方程，dp[i][j] = dp[i+1][j]+...dp[j[j]]（i~j之间每个值为顶点的情况之和） 12345678910111213141516171819202122232425262728293031323334def generateTrees(self, n: int) -&gt; List[TreeNode]: if n == 0: return [] dp = [] # 初始化dp数组 for i in range(0, n+1): dp.append([]) for j in range(0, n+1): if i == j: dp[i].append([TreeNode(i)]) elif i &lt; j: dp[i].append([]) else: dp[i].append([None]) dp[0][0] = [None] # 反向遍历 for i in range(n-1, 0, -1): for j in range(i+1, n+1): # i~j每个结点为顶点的情况 for r in range(i, j+1): # 边界判断 left = r+1 if r &lt; j else r # 左右子树的排列组合 for x in dp[i][r-1]: for y in dp[left][j]： node = TreeNode(r) node.left = x node.right = y if r == j: node.right = None # 添加结果 dp[i][j].append(node) return dp[1][n]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之二叉树的中序遍历","slug":"Leetcode之二叉树的中序遍历","date":"2020-04-02T01:29:58.000Z","updated":"2020-07-06T05:12:14.169Z","comments":true,"path":"passages/leetcode-zhi-er-cha-shu-de-zhong-xu-bian-li/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-er-cha-shu-de-zhong-xu-bian-li/","excerpt":"Binary Tree Inorder Traversal","text":"Binary Tree Inorder Traversal Binary Tree Inorder Traversal code with Python title number：094 读题 给定一个二叉树，返回按照中序遍历得到的结点序列 二叉树结点 12345class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None 请尝试使用迭代的方式解决该问题 思路一 递归遍历，左-&gt;根-&gt;右 123456789101112def inorderTraversal(self, root: TreeNode) -&gt; List[int]: res = [] def inorder(root): if root is None: return inorder(root.left) res.append(root.val) inorder(root.right) inorder(root) return res 思路二 鉴于递归效率会比较低，现使用迭代（借助栈）解决 使用栈存储结点 1234567891011121314151617def inorderTraversal(self, root: TreeNode) -&gt; List[int]: res = [] stack = [] # 辅助栈 p = root # 指针 # p或栈为空时 while p or stack: # 左子树不断入栈 while p: stack.append(p) p = p.left p = stack.pop() res.append(p.val) # 访问右子树 p = p.right return res 思路三 在题解中看到了一种比较有趣的方法，作者为其取名颜色标记法 使用颜色标记结点的状态：新结点：白色；已访问结点：灰色。 遇到白色结点，将其标记为灰色并将其右结点，自身，左结点入栈（顺序与中序遍历恰好相反，在出栈时即为中序） 遇到灰色结点，则输出结点 123456789101112131415def inorderTraversal(self, root: TreeNode) -&gt; List[int]: w, g = 0, 1 # 白色&amp;灰色 res = [] stack = [(w, root)] while stack: color, node = stack.pop() if node is None: continue if color == w: stack.append((w, node.right)) stack.append((g, node)) stack.append((w, node.left)) else: res.append(node.val) return res 事实上，这种方法能推广到前序，后续，区别在于调整入栈时的顺序即可","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之反转链表Ⅱ","slug":"Leetcode之反转链表Ⅱ","date":"2020-04-01T02:03:53.000Z","updated":"2020-07-06T05:13:58.386Z","comments":true,"path":"passages/leetcode-zhi-fan-zhuan-lian-biao-ii/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-fan-zhuan-lian-biao-ii/","excerpt":"Reverse Linked List Ⅱ","text":"Reverse Linked List Ⅱ Reverse Linked List Ⅱ code with Python title number：092 读题 给定一个链表和两个值表示链表中的两个位置 反转两个位置之间的链表 请使用一趟扫描完成反转 示例： 输入：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; null, m=2, n=4 输出：1 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; null 思路一 题目要求只能进行一趟扫描，主要的解题思路是： 反转中间部分，再与其余两端不变的部分进行拼接 参照上方的示例， 对位置2~4之间的链表进行反转 再将1和5两段拼接上去 两个关键位置，即1和5需要用指针记下来 注意不能直接返回head，当m=1时会出错，所以需要设置一个虚拟节点指向head 123456789101112131415161718192021222324252627282930313233343536def reverseBetween(self, head: ListNode, m: int, n: int): if m == n: return head first = ListNode(0) first.next = head # 记录拼接点 before_m, after_n = first, None # 记录反转后的链表 between_mn_head, between_mn_end = None, None index = 0 cur_node = first while index &lt; n: index += 1 cur_node == cur_node.next # 找到位置m if index == m-1: before_m = cur_node elif index == m: # 当前的头是反转后的尾 between_mn_end = ListNode(cur_node.val) between_mn_head = between_mn_end elif index &gt; m: # 需要反转的子链表 temp = between_mn_head between_mn_head = ListNode(cur_node.val) between_mn_head.next = temp if index == n: after_n = cur_node.next # 拼接 between_mn_end.next = after_n before_m.next = between_mn_head return first.next 思路二 2020.6.27更新 对比上面的方法，该方法不需要记录区间的前后两个位置 通过不断向区间的前驱位置插入节点的方式进行反转 通过循环遍历区间内部的节点 123456789101112131415161718192021222324252627282930def reverseBetween(self, head: ListNode, m: int, n: int): ''' 由于第一个节点也可能在区间内部，所以需要使用dummy节点 定位到指定区间位置 的 前一个位置 不断将后面的节点插入到区间前去节点的后面 ''' dummy_node = TreeNode(0) dummy_node.next = head pre = dummy_node # 找到区间的前驱节点 for i in ragne(1, n): pre = pre.next # 交换区间的头部，会更新 part_head = pre.next # 交换区间的初始头部 head_ = pre.next for i in range(m, n): temp = head_.next pre.next = temp.next head_.next = part_head temp.next = part_head # 更新头部 part_head = temp return dummy_node.next","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之解码方法","slug":"Leetcode之解码方法","date":"2020-03-31T08:19:36.000Z","updated":"2020-07-06T05:19:04.235Z","comments":true,"path":"passages/leetcode-zhi-jie-ma-fang-fa/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-jie-ma-fang-fa/","excerpt":"Decode Ways","text":"Decode Ways Decode Ways code with Python title number：091 读题 一条包含字母A~Z的消息通过一下方式进行编码： A-&gt; 1 B -&gt; 2 … Z -&gt; 26 给定一个只包含数字的非空字符串，计算该字符串的解码方法总数 思路一 小朋友，不知道你是否联想到了爬楼梯问题 显然，这是一道动态规划的题目 分析一下： 我们可能的编码一共有26种，可以分为两类： 1~9的一个数字的情况 10~26的两个数字的情况 划分子问题 当前元素位一种可能 当前元素与前一个元素是否组成范围内（10~26）的两位数 dp[i]表示到第i个位置时可能的解码方法总数 初始化：dp[0]=0, dp[1]=1 状态转移方程：dp[i] = dp[i-1]+dp[i-2] ，即最后两个一起解码or单独一个解码 结束条件：i == len(nums)-1，即数组被遍历完 注意： 当字符串以0开头时是无法解码的 当字符串以大于2的数组开头时是无法解码的 当前两位大于26时是无法解码的 在字符串中间碰到0的时候要判断前一位是否为1或2，否则返回0 1234567891011121314151617181920212223242526272829def numDecodings(self, s: str) -&gt; int: if s[0] == '0': return 0 if len(s) == 1: return 1 dp = [1] for i in range(1, len(s)): if s[i] == '0': # 30以上 if s[i-1] != '1' and s[i-1] != '2': return 0 else: if i == 1: dp.append(1) else: dp.append(dp[i-2]) continue # 10~19 if s[i-1] == '1': dp.append(dp[i-2]+dp[i-1]) # 20~26 elif s[i-1] == '2' and s[i] &gt;= '1' and s[i]&lt;='6': dp.append(dp[i-1]+dp[i-2]) # 1~9 else: dp.append(dp[i-1]) return dp[-1]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之子集Ⅱ","slug":"Leetcode之子集Ⅱ","date":"2020-03-30T05:02:41.000Z","updated":"2020-07-06T05:32:28.217Z","comments":true,"path":"passages/leetcode-zhi-zi-ji-ii/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zi-ji-ii/","excerpt":"Subset Ⅱ","text":"Subset Ⅱ Subset Ⅱ code with Python title number：090 读题 给定一个可能包含重复元素的整数数组，返回该数组包含的所有可能的子集 结果中不能包含重复的子集 题目理解 输入中包含重复元素，而结果不允许有重复元素，根据之前的题目的经验，我们对数组进行排序，目的是将所有相同的元素聚集到一起，以便于进行去重操作 这是一道进阶版的递归or回溯的题目，下面的几种思路均基于递归 思路一 子集的最大长度即数组的长度，对于子集中每个位置枚举所有可能 以示例[1, 2, 2]为例，见下图 见上图，由空集出发，每一条子路径代表一个解，并且我们要对包含的重复项进行去重操作 1234567891011121314151617def subsetsWithDup(self, nums: List[int]) -&gt; List[List[int]]: nums.sort() n = len(nums) def dfs(i, tmp): res.append(tmp) if i == n: return for j in range(i, n): if j &gt; i and nums[j] == nums[j-1]: continue dfs(j+1, tmp+[nums[j]]) res = [] dfs(0, []) return res 思路二 对数组中每个位置有两种操作：选择 or 不选择，以此构建树型结构 以示例[1, 2, 2]为例，见下图 见上图，由空集出发，这次我们只需要从叶节点中挑选（去除重复）结果即可 12345678910111213141516def subsetsWithDup(self, nums: List[int]) -&gt; List[List[int]]: nums.sort() n = len(nums) res = [[]] pre = [] # 保存重复数字对应的子集 for i in range(n): # 重复元素 if i &gt; 0 and nums[i]==nums[i-1]: pre = [tmp+[nums[i]] for tmp in pre] else: pre = [tmp+[nums[i]] for tmp in res] res += pre return res 思路三 对于数组中的每一个值（可能有多个相同值的元素），列举每个值的所有可能，构建树型结构 以示例[1, 2, 2]为例，见下图 见上图， 元素1有两种可能，即选0个或1个 元素2有三种可能，即选0个或1个或2个 所有的结果都在叶节点中，而且不包含重复项，即只需返回所有叶节点的集合即可 具体而言，我们可以先统计每个元素的个数，然后进行组合即可 1234567891011121314151617from copy import copydef subsetsWithDup(self, nums: List[int]) -&gt; List[List[int]]: dict = &#123;&#125; for i in nums: if i not in dict: dict[i] = 1 else: dict[i] += 1 res = [[]] for i, v in dict.items(): tmp = res.copy() for j in res: for k in range(v): tmp.append(j+[i]*(k+1)) res = tmp return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之分割链表","slug":"Leetcode之分割链表","date":"2020-03-29T12:11:16.000Z","updated":"2020-07-06T05:16:06.292Z","comments":true,"path":"passages/leetcode-zhi-fen-ge-lian-biao/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-fen-ge-lian-biao/","excerpt":"Partition List","text":"Partition List Partition List code with Python title number：086 读题 给定一个链表和一个特定值x 对链表进行分割，使得所有小于x的结点都在大于或等于x的结点之前 保留两个分区中每个结点的初始相对位置 示例 输入：head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3 输出：1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5 题目理解 值得注意的是，题目的要求并不是用给定元素来将链表分割为前小后大的两部分 而是将所有小于给定值的元素移动到大于等于给定元素的前面。即只需要将小于的部分移动到链表的头部即可，并且不能改变相对位置 思路一 因为要求相对位置不能改变，所以不能通过交换链表中结点的值来完成该要求 设置两个虚拟节点head1, head2（使用两个链表），将小于给定值的结点链接到head1后，将大于等与给定值的结点链接到head2后 最后将两个链表二放到链表一之后 注意将链表二最后一个结点的next置为None 123456789101112131415def partition(self, head: ListNode, x: int) -&gt; ListNode: head1 = ListNode(-1) head2 = ListNode(-1) cur = head cur1, cur2 = head1, head2 while cur is not None: if cur.val &lt; x: cur1.next = cur else: cur2.next = cur cur2.next = None cur1.next = head2.next return head1.next","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之删除排序数组中的重复项Ⅱ","slug":"Leetcode之删除排序数组中的重复项Ⅱ","date":"2020-03-28T05:22:35.000Z","updated":"2020-07-06T05:26:00.587Z","comments":true,"path":"passages/leetcode-zhi-shan-chu-pai-xu-shu-zu-zhong-de-chong-fu-xiang-ii/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-shan-chu-pai-xu-shu-zu-zhong-de-chong-fu-xiang-ii/","excerpt":"Remove Duplicates from Sorted Array","text":"Remove Duplicates from Sorted Array Remove Duplicates from Sorted Array code with Python title number：080 读题 给定一个排序数组，原地删除重复出现的元素，使得每个元素最多出现两次（多于2个的，删除到剩2个，不足2个的不予删除） 返回移除后数组的新长度 示例： nums = [1, 1, 1, 2, 2, 3] 函数应返回新长度5，并返回原数组的前五个元素为：1, 1, 2, 2, 3 无需考虑数组中超出新长度后面的元素 思路一 由于是排序之后的数组，所以相同的元素必定出现在一起 直接对数组中重复次数多于2的元素删除多余项 使用单指针，用于遍历 使用一个计数变量count记录当前项的重复次数 注意：直接在数组上删除了元素会导致数组长度变化，从而带来访问越界的问题。所以在每次删除元素之后要使i-- 12345678910111213141516def removeDuplicates(self, nums: List[int]) -&gt; int: # 直接原地删除重复元素 i, count = 1, 1 while i &lt; len(nums): if nums[i] == nums[i-1]: count += 1 if count &gt; 2: nums.pop(i) # 防止数组越界 i -= 1 else: # 新元素，重新计数 count = 1 return len(nums) 思路二 覆盖重复元素，便利列表，将符合数目要求个数的元素依次放到数组头部位置 使用双指针，i用于遍历数组，j用于指示最终符合条件子数组的尾部 使用计数变量count记录当前项的个数 返回j 并没有修改数组长度，只是使用符合条件的子数组覆盖掉了数组中的内容 123456789101112def removeDuplicates(self, nums: List[int]) -&gt; int: j, count = 1, 1 for i in range(1, len(nums)): if nums[i] == nums[i-1]: count += 1 else: count = 1 if count &lt;= 2: nums[j] = nums[i] j += 1 return j","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之单词搜索","slug":"Leetcode之单词搜索","date":"2020-03-27T08:59:38.000Z","updated":"2020-07-06T05:10:45.815Z","comments":true,"path":"passages/leetcode-zhi-dan-ci-sou-suo/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-dan-ci-sou-suo/","excerpt":"Word Search","text":"Word Search Word Search code with Python title number：079 读题 给定一个二维网格和一个单词，判断该单词是否存在与网格中 所谓存在于网格中，即需要使用网格中相邻字母组成单词（上下相邻或左右相邻） 字母不允许被重复使用 思路一 DFS 首先应该明确，所谓相邻可以是左右相邻，也可以是上下相邻。并且这种相邻是双向的，也就是可以是从左到右，也可以是从右到左 其次，要明确符合单词首个单词的位置并非只有一个，所以要用一个双循环来查找所有的起始可能 再次，避免字母被重复使用，进行一次遍历，对使用过的字母进行mask操作，在进行完当前深度搜索之后再恢复 1234567891011121314151617181920212223242526def exist(self, board: List[List[str]], word: str) -&gt; bool: # 找到start point for i in range(len(board)): for j in range(len(board[0])): if self.helper(board, i, j, word, 0): return True return False def helper(self, board, i, j, word, wordIndex): # 能够找到整个单词 if wordIndex == len(word): return True if i &lt; 0 or i &gt;= len(board) or j &lt; 0 or j &gt;= len(board[0]) or board[i][j] != word[wordIndex]: return False # mask当前位置的元素，防止重复使用 board[i][j] = '#' found = self.helper(board, i+1, j, word, wordIndex+1)\\ or self.helper(board, i, j+1, word, wordIndex+1)\\ or self.helper(board, i-1, j, word, wordIndex+1)\\ or self.helper(board, i, j-1, word, wordIndex+1) board[i][j] = word[wordIndex] return found","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之子集","slug":"Leetcode之子集","date":"2020-03-26T01:21:16.000Z","updated":"2020-07-06T05:32:21.937Z","comments":true,"path":"passages/leetcode-zhi-zi-ji/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zi-ji/","excerpt":"Subsets","text":"Subsets Subsets code with Python title number：078 读题 给定一组不含重复元素的整数数组，返回该数组所有的子集 空集是任何集合的子集 思路一 求集合，而非求极值，所以我们选择回溯法而不是动态规划 1234567891011def subsets(self, nums: List[int]) -&gt; List[List[int]]: res = [] length = len(nums) def backtrack(i, temp): res.append(temp) for j in range(i, length): backtrack(j+1, temp+[nums[j]]) backtrack(0, []) return res 思路二 在评论区看到了一个比较有意思的解法 从后往前遍历，每遍历一个数，就将这个数加到当前结果集中所有已得子集上，组成新的子集 123456789def Subsets(self, nums: List[int]) -&gt; List[List[int]]: res = [[]] # 反向遍历 for i in range(len(nums)-1, -1, -1): for sub in res[:]: res.append(sub+[nums[i]]) return res 事实证明，正向遍历也是可以的 123456789def Subsets(self, nums: List[int]) -&gt; List[List[int]]: res = [[]] # 反向遍历 for i in range(len(nums)): for sub in res[:]: res.append(sub+[nums[i]]) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之颜色分类","slug":"Leetcode之颜色分类","date":"2020-03-25T01:38:07.000Z","updated":"2020-07-06T05:29:47.680Z","comments":true,"path":"passages/leetcode-zhi-yan-se-fen-lei/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-yan-se-fen-lei/","excerpt":"Sort Colors","text":"Sort Colors Sort Colors code with Python title number：075 读题 给定一个包含红、白、蓝三种颜色，一共n个元素的数组，对其进行原地排序 使得相同颜色的元素相邻，并且按照红、白、蓝的顺序排列 使用0、1、2表示三种颜色 思路一 比较直接的想法是，遍历数组，统计0,1,2的个数分别为nums1, nums2, nums3 再次遍历数组，将数组中的元素按照每一种颜色的个数重置 数组需要遍历两遍 1234567891011121314151617def sortColors(self, nums: List[int]) -&gt; None: r, w, b = 0, 0 , 0 for i in range(len(nums)): if nums[i] == 0: r += 1 elif nums[i] == 1: w += 1 else: b += 1 for i in range(r): nums[i] = 0 for i in range(r, r+w): nums[i] = 1 for i in range(r+w, r+w+b): nums[i] = 2 思路二 本题其实就是比较经典的荷兰国旗问题 对于这种问题，我们使用三指针解决，只需遍历数组一遍 将数组分为三部分，只需将两侧的两部分排好序，中间部分自然就排好了 指针cur用于遍历数组，指针pre用于标识第一部分的尾部位置，指针tail用于标识第三部分的头部位置 事实上都无需将所有元素都遍历一遍，当cur和tail相遇之后，即可停止了 12345678910111213def sortColors(self, nums: List[int]) -&gt; None: cur, pre, tail = 0, 0, len(nums)-1 while cur &lt;= tail: if nums[cur] == 0: nums[cur], nums[pre] = nums[pre], nums[cur] pre += 1 cur += 1 elif nums[cur] == 2: nums[cur], nums[tail] = nums[tail], nums[cur] tail -= 1 else: cur += 1","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之矩阵置零","slug":"Leetcode之矩阵置零","date":"2020-03-24T04:09:16.000Z","updated":"2020-07-06T05:19:12.642Z","comments":true,"path":"passages/leetcode-zhi-ju-zhen-zhi-ling/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-ju-zhen-zhi-ling/","excerpt":"Set Matrix Zeroes","text":"Set Matrix Zeroes Set Matrix Zeroes code with Python title number：073 读题 给定一个m*n的矩阵，如果一个元素为0，则将其所在的行和列的所有元素都设为0 请使用原地算法 思路一 最先想到的是暴力解决的方法 即遍历整个矩阵，记录为0的元素的行号和列号（这需要使用m+n的额外空间） 再次遍历矩阵，判断当前元素是否与元素0同行或同列，若是，则置为0 如果使用set来存储为0元素的行列号，可以在矩阵不止一个0的时候省去一点空间 由于要求使用原地算法，这种方法不提倡使用 12345678910111213def setZeroes(self, matrix: List[List[int]]) -&gt; None: rows, cols = set(), set() for i in range(len(matrix)): for j in range(len(matrix[0])): if matrix[i][j] == 0: rows.add(i) cols.add(j) for i in range(len(matrix)): for j in range(len(matrix[0])): if i in rows or j in cols: matrix[i][j] = 0 居然通过了，⊙﹏⊙b汗 思路二 这次仍是两次双循环遍历，不过省去了额外的空间 遍历矩阵，对于为0的元素，我们将其所在行、列的非零元素设置为一个很小的数 再次遍历矩阵，将所有等于我们设置的“很小的数”的元素全部置为0 注意并不提倡直接对非0元素直接置零，这样会带来很多次额外的行列遍历 1234567891011121314def setZeroes(self, matrix: List[List[int]]) -&gt; None: modify = -1000000 for i in range(len(matrix)): for j in range(len(matrix[0])): if matrix[i][j] == 0: for k in range(len(matrix[0])): matrix[i][k] = modify if matrix[i][k]!=0 else 0 for k in range(len(matrix)): matrix[k][j] = modify if matrix[i][k] !=0 else 0 for i in range(len(matrix)): for j in range(len(matrix[0])): if matrix[i][j] == modify: matrix[i][j] = 0 思路三 思路二虽然减少了空间的使用，虽然一定程度上减少了遍历的次数，但是还是会在当同一行或列中存在多个0的时候进行多次遍历 改进思路如下： 我们仅使用当前的行或列的第一个元素来表示该行或该列是否需要置0 由于第一行和第一列的标记重叠，所以需要一个额外的标记来表示第一列是否需要置0。同时第一行和第一列需要单独处理 这样，我们就将第一行和第一列用来完成思路一中的功能 最后，遍历第一行和第一列就可以完成矩阵的置零 1234567891011121314151617181920212223242526def setZeroes(self, matrix: List[List[int]]) -&gt; None: # 表示第一列是否置零 is_col = False # 判断第一列是否需要置零 for i in range(len(matrix)): if matrix[i][0] == 0: is_col = True # 第二列开始 for j in range(1, len(matrix[0])): if matrix[i][j] == 0: matrix[i][0] = 0 matrix[0][j] = 0 # 遍历第一行第一列 for i in range(1, len(matrix)): for j in range(1, len(matrix[0])): if not matrix[i][0] or not matrix[0][j]: matrix[i][j] = 0 # 第一行置0 if matrix[0][0] == 0: for j in range(len(matrix[0])): matrix[0][j] = 0 # 第一列置零 if is_col: for i in range(len(matrix)): matrix[i][0] = 0 代码比较长，但是时间复杂度很低（几乎没有重复操作）","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之不同路径","slug":"Leetcode之不同路径","date":"2020-03-23T05:07:29.000Z","updated":"2020-07-06T05:09:31.529Z","comments":true,"path":"passages/leetcode-zhi-bu-tong-lu-jing/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-bu-tong-lu-jing/","excerpt":"Unique Path","text":"Unique Path Unique Path code with Python title number：062 读题 一个机器人位于一个m*n的网格的左上角，机器人每次只能向下或向右移动一格 机器人视图到达网格的右下角，计算有多少种不同的路径 思路一 这是一道典型的动态规划题目（与爬楼梯相同的解题思路） 按照动态规划的分析思路 定义：dp[i][j]表示从起点到作为为[i, j]的位置最多的路径数 初始状态：dp[0][j]和dp[i][0]位于边界，均为1 状态转移方程：dp[i][j] = dp[i-1][j]+dp[i][j-1]，只能来自上面或左边 结束条件：i==m and j==n 1234567def uniquePaths(self, m: int, n:int) -&gt; int: dp = [[1]*n for _ in range(m)] for i in range(m-1): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[-1][-1] 代码优化 前面使用二维数组来表示到达一个位置的路径数，即当前位置的路径数=上方一格的路径数+左边一格的路径数 换个角度，使用一维数组表示，计算一行的数据的时候，直接将上一行搬下来，每一格子的数据等于其本身加上前一个格子的数据（本身其实就是位于其上方的数据） 1234567def uniquePaths(self, m: int, n: int) -&gt; int: dp = [1]*n for _ in range(1, m): for j in range(1, n): dp[j] += dp[j-1] return dp[n-1] 思路二 通过分析我们可以得出，向下移动和向右移动的次数是一定的，分别为m-1和n-1 所以，这变成了一个组合数学的题目，组合问题，C(n-1, m+n-2) 实现该公式的计算即可 123456789def uniquePaths(self, m: int, n: int) -&gt; int: a = b = 1 for i in range(1, n)； a += i for i in range(m, m+n-1): b *= i return b // a","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之第k个排列","slug":"Leetcode之第k个排列","date":"2020-03-22T06:12:40.000Z","updated":"2020-07-06T05:11:12.859Z","comments":true,"path":"passages/leetcode-zhi-di-k-ge-pai-lie/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-di-k-ge-pai-lie/","excerpt":"Permutation Sequence","text":"Permutation Sequence Permutation Sequence code with Python title number：060 读题 给出集合[1, 2, ..., n]，所有元素有n!中排列 按从小到大顺序列出所有排列，给定n个k，返回第k个排列 1=&lt;n=&lt;9, 1=&lt;k=&lt;n! 思路一 我们不可能通过列出所有的情况，然后再去找第k个 原因是，n!已经是极高的时间复杂度了，所以要寻找规律，减少计算的次数 观察给出的示例 n = 3, k = 3 “123”，”132” “213”，”231” “312”，”321” 可以观察到，以1开头的有2!个，以2开头的有2!个，以3开头的有2!个 经过推理我们可以得出，包含n个元素的数组组成的排列中，以每个数字开头的元素有(n-1)!个 因此，如果我们要找第k个元素，先用k / (n-1)!判断第k个元素落在以哪个元素开头的全排列中，即确定了第一位数字 接下来进行迭代，依次得到每一位数字，组合得到最终结果 12345678910111213141516def getPermutation(self, n: int, k: int) -&gt; str: res = None candidates = [str(i) for i in range(1, n+1)] while n != 0: # 计算n-1的阶乘 facto = math.factorial(n-1) # 落在以哪个元素为首的全排列中 i = math.ceil(k / facto) - 1 res += candidatees[i] candidates.pop(i) k -= facto * i n -= 1 return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之合并区间","slug":"Leetcode之合并区间","date":"2020-03-21T01:21:09.000Z","updated":"2020-07-06T05:16:31.319Z","comments":true,"path":"passages/leetcode-zhi-he-bing-qu-jian/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-he-bing-qu-jian/","excerpt":"Merge Interval","text":"Merge Interval Merge Interval code with Python title numbe：056 读题 给出一个区间的集合，合并所有重叠的区间 示例： 输入：[[1,3],[2,6],[8,10],[15,18]] 输出：[[1,6],[8,10],[15,18]] 解释：区间[1,3]和[2,6]重叠, 将它们合并为[1,6] 思路一 通过示例可以明白，所谓重叠，即较大区间的的左端点小于等于较小区间的右端点（所谓较大较小指的是区间左右端点数值的大小） 所以为了简化操作，我们要对区间进行排序（按照左端点的大小排序） 排序过后对区间集合进行遍历，判断两个区间是否有重叠，如果有则合并，否则跳过 1234567891011121314151617181920def merge(self, intervals: List[List[int]]) -&gt; List[List[int]]: if len(intervals) &lt;= 1: return intervals #获取数组的左端点 def get_first(a): return a[0] # 排序 intervals.sort(key=get_first) # 遍历并合并 res = [intervals[0]] for i in range(1, len(intervals)): # 合并 if intervals[i][0] &lt;= res[-1][1]: res[-1] = [res[-1][0], max(res[-1][1], intervals[i][1])] else: res.append(intervals[i]) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"htop命令的内容含义","slug":"htop命令的使用及内容的含义","date":"2020-03-20T12:12:16.000Z","updated":"2020-07-06T05:08:07.510Z","comments":true,"path":"passages/htop-ming-ling-de-shi-yong-ji-nei-rong-de-han-yi/","link":"","permalink":"http://zivblog.top/passages/htop-ming-ling-de-shi-yong-ji-nei-rong-de-han-yi/","excerpt":"htop命令的内容含义","text":"htop命令的内容含义 主要参数 PID、USER、PR、NI、VIRT、RES、SHR、S、%CPU、%MEM、TIME+、COMMAND PID：进程id，可以通过kill PID来关掉进程 USER：该进程的拥有者 PR：进程优先级 NI：nice值，负值表示高优先级，正值表示低优先级 VIRT：virtual memory usage，当前进程需要的虚拟内存，包括进程使用的库、代码、数据等 RES：resident memory usage，当前进程使用的内存大小 SHR：share memory，除了自身进程的共享内存，也包括其他进程的共享内存 S：进程状态 D：不可中断的睡眠状态 R：运行 S：睡眠 T：跟踪/停止 Z：僵尸进程 %CPU：上次更新到现在的CPU占用百分比 %MEM：进程使用的物理内存百分比 *TIME+ *：进程使用的CPU的时间总计，单位为秒 COMMAND：当前进程执行的命令 默认仅显示以上的比较重要的内容，可以通过提示快捷键更改显示内容","categories":[{"name":"工具配置","slug":"工具配置","permalink":"http://zivblog.top/categories/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://zivblog.top/tags/Tools/"}]},{"title":"Leetcode之跳跃游戏","slug":"Leetcode之跳跃游戏","date":"2020-03-20T08:57:34.000Z","updated":"2020-07-06T05:28:09.603Z","comments":true,"path":"passages/leetcode-zhi-tiao-yue-you-xi/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-tiao-yue-you-xi/","excerpt":"Jump Game","text":"Jump Game Jump Game code with Python title number：055 读题 给定一个数组，数组中元素均为非负整数 你的初始位置位于数组的第一个位置 数组中的每个元素代表你在该位置可以跳跃的最大长度 判断你能否到达最后一个位置 例如：对于数组[2, 3, 1, 1, 4]，即我们可以从位置0跳一步到达位置1，再从位置1跳三步到达最后一个位置 再如：对于数组[3, 2, 1, 0, 4]，我们发现不管怎么选都会到达位置3，而这个 位置的可允许最大跳跃长度为0，即无论如何我们都不能到达最后一个位置 思路一 观察示例中不能到达的情况，产生以下想法： 最朴素的情况就是每一个点都向前条一步，如果有一步跳不过去，那么就无法到达 也就是存在nums[i]==0，并且该位置无法跳过，则失败 1234567891011def canJump(self, nums: List[int]) -&gt; bool: length = len(nums) index = 0 # 记录可以到达的位置 for i in range(length): if index &gt;= length-1: return True # i位置跳不过去 if nums[i]==0 and index &lt;= i: retunn False index = i + nums[i] if index &lt; i+nums[i] else index 思路二 值得注意的一个点是：如果从当前点能到达某个位置x，那么位置x之前的所有位置均能到达 由此，我们可以基于贪心来设计一种思路（选择从当前位置能到达的最远位置）： 设置一个点记录最远位置，初始化为0 遍历数组，如果当前位置能到达，并且当前位置+最大跳数&gt;最远距离，则更新最远位置 比较最远位置与数组长度 注意这里是只要能够到达最终位置即可，也就是只需找到任意一种满足条件的情况 123456def canJump(self, nums: List[int]) -&gt; bool: max_ = 0 for i, jump in enumerate(nums): if max_ &gt; i and i+jump &gt; max_: max_i = i + jump return max_i 思路三 动态规划 要判断从第一个位置能否到达最后一个位置，那么我们先判断从第二个位置能否到达最后一个位置 接着再判断从第一个位置能够到达第二个位置 依次执行 定义：dp[i]表示从第i个坐标能跳到的最远位置，dp[i-1]&gt;=i表示可以到达位置i 初始状态：dp[i]=0 状态转移方程：dp[i] = max(dp[i-1], i+nums[i]) 结束条件：i == length-1时结束，判断dp[length-1]是否大于等于length-1 123456789101112131415def canJump(self, nums: List[int]) -&gt; bool: if len(nums) &lt;= 1: return True dp = [0 for _ in range(len(nums))] dp[0] = nums[0] for i in range(1, len(nums)): if dp[i-1] &gt;= i: dp[i] = max(dp[i-1], i+nums[i]) else: dp[i] = dp[i-1] if dp[i] &gt;= len(nums)-1: return True return False","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"nohup的简单使用","slug":"nohup的简单使用","date":"2020-03-19T13:47:02.000Z","updated":"2020-07-06T05:36:15.168Z","comments":true,"path":"passages/nohup-de-jian-dan-shi-yong/","link":"","permalink":"http://zivblog.top/passages/nohup-de-jian-dan-shi-yong/","excerpt":"nohup","text":"nohup 前言 事情的开始是一直蝙蝠。。。 在家连学校的vpn跑程序总是中断，请教了一位大佬，上网查了一些资料，整理成了这篇文章 用过的都说好 nohup和&amp;的区别 &amp;： 在命令之后加&amp;表示在后台运行 不再接收输入，在终端中键入Ctrl+C，并不会打断程序的运行。 结果会输出到终端 但是在关闭session之后，会打断程序 nohup： 表示不打断的运行程序 会自动将程序的输出存储到nohup.out中，不会输出到前台 使用Ctrl+C会打断程序 关掉session，不会打断程序 使用nohup和&amp;实现程序后台运行 一般在linux上执行程序都死在命令行下直接执行，但如果程序运行的时间比较长，而且存在网络不稳定该怎么办呢？ 这时就需要使用借助nohup和其他命令来实现程序的后台运行 nohup：加在命令的前面，表示不挂断的运行命令 &amp;：加在一个命令后面，表示这个命令放在后台执行 例如：nohup python3 main.py &amp;，程序会在后台运行，并且将输出存储到nohup.out中 关闭后台程序 当执行上述命令后，不能通过Ctrl+C中断程序，只能通过kill 命令打断程序 查看进程 jobs：可以查看当前中断后台执行的任务 ps：查看当前时刻的所有后台进程 关闭后台程序 使用上述命令查看到后台进程的jobnum或者PID之后 分别使用kill %jobnum或者kill %PID关闭进程 前后台进程的切换 fg %jobnum：将选中的后台进程切换为前台执行 Ctrl+Z：将正在前台执行的命令放到后台，并且处于暂停状态 bg %jobnum：将选中的后台进程切换为前台执行","categories":[{"name":"工具配置","slug":"工具配置","permalink":"http://zivblog.top/categories/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://zivblog.top/tags/Tools/"}]},{"title":"Leetcode之实现x的n次幂","slug":"Leetcode之实现x的n次幂","date":"2020-03-19T07:27:32.000Z","updated":"2020-07-06T05:26:57.711Z","comments":true,"path":"passages/leetcode-zhi-shi-xian-x-de-n-ci-mi/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-shi-xian-x-de-n-ci-mi/","excerpt":"Pow(x, n)","text":"Pow(x, n) Pow(x, n) code with Python title number：050 读题 实现pow(x, n)，即计算x的n次幂 -100.0 &lt; x &lt; 100.0 n是32位无符号整数，[-2^31, 2^31-1] 思路一 由于是要我们实现x的n次幂，所以不能调用Python库中的函数 最简单的一种思路就是不断累乘，n为多少就乘多少次 很明显，这种思路必定会超时，简单实现一下 123456789def myPow(self, x: float, n: int) -&gt; float: if n == 0: return 1 if n &lt; 0: return 1 / self.myPow(x, -n) res = 1 for _ in range(n): res *= x return res 思路二 简单的递归 比如： 对于n为偶数，想求x^4，可以转化为(x^2)^2 对于n为奇数，想求x^5，可以转化为x*(x^2)^2 由上面的启发，我们想到使用递归，具体思路如下 假n除以二的结果为a 那么myPow(x, n) = myPow(x, a) * myPow(x, n-a) 123456789def myPow(self, x: float, n: int) -&gt; float: if n == 0: return 1 if n == 1: return x if n &lt; 0: return 1 / self.myPow(x, -n) return self.myPow(x, n // 2) * self.myPow(x, n - n // 2) 可惜这种方法也超时了，原因是存在太多的重复计算 思路三 在上面递归的基础上进行优化 为了减少每次递归是调用本身的次数，优化如下： 如果n是偶数，我们将n折半，底数变为x^2 如果n是奇数， 我们将n减去1，底数不变，得到的结果再乘上底数x 123456789def myPow(self, x: float, n: int) -&gt; float: if n == 0: return 1 if n == 1: return x if n &lt; 0: return 1 / self.myPow(x, -n) return self.myPow(x*x, n // 2) if n % 2 == 0 else x * self.myPow(x, n-1)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之字母异位词分组","slug":"Leetcode之字母异位词分组","date":"2020-03-18T06:27:49.000Z","updated":"2020-07-06T05:32:51.852Z","comments":true,"path":"passages/leetcode-zhi-zi-mu-yi-wei-ci-fen-zu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zi-mu-yi-wei-ci-fen-zu/","excerpt":"Group Anagrams","text":"Group Anagrams Group Anagrams code with Python title number：049 读题 给定一个字符串数组，将字母异位词组合到一起 异位词：指字母相同，但排列不同的字符串 所有输入均为小写，不考虑答案输出的顺序 思路一 比较直观的想法是，对数组的每一项元素（字符串）进行排序，然后使用字典存储，结构为{经过排序的字符串:[原字符串]} 遍历字典，取出所有value即可 12345678910111213141516171819def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]: hash_table = &#123;&#125; res = [] def sort_str(str): str = list(str) str.sort() return \"\".join(str) for s in strs: if sort_str(s) in hash_table: hash_table[sort_str(s)].append(s) else: hash_table[sort_str(s)] = [s] for s in hash_table.keys(): res.append(hash_table[s]) return res 思路二 仍然是上面的思路，不过这次我们判断两个词是否是异位词的方式有所改变 参考桶排序的思路，设计一种方法 我们建立一个长度为26的数组（26个字母），每个字母对应一个数组中的下标 每读一个词，遍历其所有字母，并且在相应位置出统计词中出现的字母的个数 如果两个词得到的数组相同，则说明两者之间可以通过交换顺序得到 其余思路相同 1234567891011121314def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]: # 初始化字典 str_dict = collections.defaultdict(list) for s in strs: s_key = [0]*26 # 遍历词中的字母 for c in s: s_key[ord(c)-ord('a')] += 1 str_dict[tuple(s_key)].append(s) for key in str_dict.keys(): res.append(str_dict[key]) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"桶排序","slug":"桶排序","date":"2020-03-18T02:03:25.000Z","updated":"2020-07-06T05:48:12.029Z","comments":true,"path":"passages/tong-pai-xu/","link":"","permalink":"http://zivblog.top/passages/tong-pai-xu/","excerpt":"桶排序","text":"桶排序 概述 桶排序（Bucket Sort）的原理十分容易理解，就是将数组分到有限数量的桶中，再顺序的从桶中取出，即可得到排序结果 桶排序有两个关键点 待排序元素的值域的划分。即确定每个桶代表了什么，或者说是每个桶允许什么元素装入 排序算法的选择。即每个桶中的元素的排列规则 下面通过两个例子理解桶排序使用时的具体细节 实例一 假设我们现在有n个整数，并且知道整数的范围时[0, max)，现使用桶排序对这n个整数进行排序 值域的划分：由于知道n个整数的范围是[0, max)，所以设置max个桶，每一个整数都会唯一的进入一个桶中 排序算法的选择：由于每个桶中的数字都相同，不需要排序 具体： 设置一个长为max的数组bucket，数组中的每个位置是一个桶 遍历n个整数，将对应整数x放到bucket中对应下标的位置（统计值为x的元素的个数，即bucket[x]+=1） 遍历数组bucket，按照对应位置的值的大小，顺序取出对应个数的值 如上图，得到的排序结果应为[2, 3, 3, 3, 4, 4, 6, 6, 8, 9] 实例二 现有数组[-7, 51, 3, 121, -3, 32, 21, 43, 4, 25, 56, 77, 16, 22, 87, 56, -10, 68, 99, 70]，试用桶排序完成对该数组的排序 值域的划分： 我们观察到，上述数组值域的范围比较大，直接申请大小与值域范围相同的数组势必会造成很多空间的浪费 故另辟蹊径，我们将每个桶可以容纳的元素设置一个范围，这里我们设置间隔为10 对此，我们需要设置一个映射规则，来更加方便的将元素放入对应的桶中 $$f(x)=\\frac{x}{10}-c, (c=\\frac{min}{10})$$ 经计算可得，待排序数组中，max=121, min=-10，所以申请桶的个数为14个 $$\\frac{max}{10}-\\frac{min}{10}+1 = 12-(-1)+1=14$$ 排序算法的选择 不同于前一个例子，桶中存放的将是不同的数字，所以需要寻找一个算法对桶中的元素进行排序。 该排序算法的选择，将直接影响整体的性能 排序结果为 桶下标 桶中元素 0 -7, 3,-10 1 3, 4 2 16 3 21, 25, 22 4 32 5 43 6 51, 56, 56 7 68 8 77, 70 9 87 10 99 11 12 13 121 代码示例 12345678910111213def bucketSort(arr): max, min = max(arr), min(arr) bucketArr = [[] for i in range(max // 10 - min//10 + 1)] # 遍历数组，添加到桶中 for i in arr: index = i bucketArr[index].append(i) arr.clear() # 对每个桶中的元素排序 for i in bucketArr: i.sort() arr.extend(i)","categories":[{"name":"算法","slug":"算法","permalink":"http://zivblog.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之旋转图像","slug":"Leetcode之旋转图像","date":"2020-03-17T13:16:08.000Z","updated":"2020-07-06T05:29:41.869Z","comments":true,"path":"passages/leetcode-zhi-xuan-zhuan-tu-xiang/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-xuan-zhuan-tu-xiang/","excerpt":"Rotate Image","text":"Rotate Image Rotate Image code with Python title number：048 读题 给定一个n*n的二维矩阵用于表示一个图像 将图像顺时针旋转90度 必须原地旋转，不能使用额外的二维矩阵 思路一 由于是要原地旋转矩阵，我们需要找到矩阵旋转90度时，元素位置的变化规律 经过观察可以发现，我们只需要将第i行变成第n-i-1列即可 有个比较巧妙的方法，即利用对称轴旋转达到我们的目的 先进行一次对角线为轴的翻转，然后再进行一次以水平对称线为轴的翻转，即可 123456789def rotate(self, matrix: List[List[int]]) -&gt; None: # 先沿着对角线翻转 n = len(matrix) for i in range(n): for j in (i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # 再沿横对称线翻转 for m in matrix: m.reverse()","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之全排列Ⅱ","slug":"Leetcode之全排列Ⅱ","date":"2020-03-16T09:52:27.000Z","updated":"2020-07-06T05:24:56.834Z","comments":true,"path":"passages/leetcode-zhi-quan-pai-lie-ii/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-quan-pai-lie-ii/","excerpt":"Permutations Ⅱ","text":"Permutations Ⅱ Permutations Ⅱ code with Python title number：047 读题 给定一个可能包含重复数字的序列，返回其所有不重复的全排列 思路一 由于序列中可能包含重复数字，所以要在生成全排列的时候去重 与前面的思路相同，先排序，每使用一个数字就将其pop出，防止重复使用 其他并没有特殊之处 12345678910111213141516171819from copy import copydef permuteUnique(self, nums: List[int]) -&gt; List[List[int]]: nums.sort() res = [] def backtrack(nums, pre_list): if len(nums) &lt;= 0: res.append(pre_list) else: for i in range(len(nums)): if i &gt; 0 and nums[i] == nums[i -1]: continue p_list = pre_list.copy() p_list.appen(nums[i]) left_num = nums.copy() left_nums.pop(i) print('p_list is ', p_list, 'left_nums is ', left_num) backtrack(left_nums, p_list) backtrack(nums, []) return res print()信息如下 p_list is [1] left_nums is [1, 2] p_list is [1, 1] left_nums is [2] p_list is [1, 1, 2] left_nums is [] p_list is [1, 2] left_nums is [1] p_list is [1, 2, 1] left_nums is [] p_list is [2] left_nums is [1, 1] p_list is [2, 1] left_nums is [1] p_list is [2, 1, 1] left_nums is []","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之全排列","slug":"Leetcode之全排列","date":"2020-03-15T08:36:08.000Z","updated":"2020-07-06T05:24:49.779Z","comments":true,"path":"passages/leetcode-zhi-quan-pai-lie/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-quan-pai-lie/","excerpt":"Permutations","text":"Permutations Permutations code with Python title number：046 读题 给定一个没有重复数字的序列，返回其所有可能的全排列 思路一 本题是求集合，并不是求极值，所以不适合使用动态规划 与前面的两道题（题目一，题目二）思路相同，使用回溯法，实际上就是对回溯决策树的遍历 主要问题就是明白三个问题对应什么 路径：已经选择的数字 选择列表：当前可供选择的数字 结束条件：所有数字全部选择一遍 因为是数字序列的全排列，所以每个数字只能用一次（不包含重复数字） 以数字序列[1, 2, 3]为例 12345678910111213141516def permute(self, nums: List[int]) -&gt; List[List[int]]: res = [] length = len(nums) def backtrack(start): if start == length: res.append(nums[:]) for i in range(start, length): nums[start], nums[i] = nums[i], nums[start] backtrack(start+1) nums[start], nums[i] = nums[i], nums[start] backtrack(0) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"周知识总结（3.8~3.15）","slug":"周知识总结（3-8-3.15）","date":"2020-03-15T02:44:27.000Z","updated":"2020-07-06T05:49:12.905Z","comments":true,"path":"passages/zhou-zhi-shi-zong-jie-3-8-3.15/","link":"","permalink":"http://zivblog.top/passages/zhou-zhi-shi-zong-jie-3-8-3.15/","excerpt":"周知识总结","text":"周知识总结 3月8日简述向量、标量、矩阵、张量的内涵以及它们之间的联系 向量 又称矢量，是指具有大小和方向的量。在计算机中，向量具有多个维度，每个数表示向量在该维度上的值。例如: [1, 2, 3, 4] 标量 与向量相对应，是一个单独的数 矩阵 指一组具有相同特征和维度的对象的集合，形式上表现为一个二维的表格。在意义上，一个对象是矩阵中的一行；一个特征是矩阵中的一列。 张量 通常是一个广义的矩阵，可以是一个更高维的结构，张量的维数叫做它的秩。在深度学习中经常见到张量，即Tensor 联系 标量可以看作是0阶张量 向量可以看作是一阶张量 试归纳向量的范数 向量的范数是用来衡量空间中向量的大小的量，常见的有以下计算方式： 向量的1范数：向量的各个元素的绝对值之和$$ \\Vert\\vec{x}\\Vert_1=\\sum_{i=1}^N\\vert{x_i}\\vert$$ 向量的2范数：向量的每个元素的平方和在开平方$$\\Vert\\vec{x}\\Vert_2=\\sqrt{\\sum_{i=1}^N{\\vert{x_i}\\vert}^2}$$ 向量的负无穷范数：向量的所有元素中绝对值最小的 $$\\Vert\\vec{x}\\Vert_{-\\infty}=\\min{|{x_i}|}$$ 向量的正无穷范数：向量的所有元素中绝对值最大的 $$\\Vert\\vec{x}\\Vert_{+\\infty}=\\max{|{x_i}|}$$ 总得来说，向量的范数可以表示为：$$L_p=\\Vert\\vec{x}\\Vert_p=\\sqrt[p]{\\sum_{i=1}^{N}|{x_i}|^p}$$ 简述导数与偏导数的区别 导数和偏导数本身并无本质区别，都是在极限存在的情况下自变量变化量趋于0时，函数值的变化量与自变量变化量的比值 对于一元函数y = ax+b，导数只有一个 对于二元函数z = x + y，导数有两个，分别是z关于x的导数和z关于y的导数，称之为偏导数 注意在多元函数求偏导时，要将求偏导之外的变量视为常数 简述随机变量与变量的区别 随机变量表示随机试验各种结果的实值单值函数。 区别 当变量的取值概率不为1时，变量就是随机变量；相对应的，随机变量取值的概率为1时，随机变量就变成了变量 3月9日试简述概率分布与随机变量存在的联系 一个随机变量表示的是一个可能取得的状态 而概率分布表示的是一个随机变量取得每个状态的可能性大小 随机变量分为离散型和连续型 概率分布如何描述 用来描述概率分布的函数有两种 概率质量函数：描述离散型随机变量的概率分布 概率密度函数：描述连续性随机变量的概率分布 什么是条件概率 在某种情况（A， A&lt;S）下，情况B发生的概率，记作：$$P(B|A) = \\frac{P(AB)}{P(A)}$$ 且当A=S时，P(B|A)=P(B)，即情况A的作用是缩小了样本空间 边缘概率与联合概率的内涵与区别 边缘概率 与联合概率相对应，指的是某个事件发生的概率，与其他事件无关，例如：P(X=1) 联合概率： 指的是多个事件的同时发生，例如：P(X=1, Y=2) 简述期望、方差、协方差、相关系数 期望： 指的是每个结果的概率乘以结果的总和 方差 用来度量随机变量与其数学期望之间的偏离程度 $$Var(x) = E((x-E(x))^2)$$ 可以用来衡量数据的离散程度 协方差 衡量两个变量（变化趋势）的相关性大小 $$Cov(x,y)=E((x-E(x))(y-E(y)))$$ 相关系数 衡量变量之间线性相关程度 而且不受变量变化幅度的影响，反映两个变量每单位变化时 $$Corr(x,y) = \\frac{Cov(x,y)}{\\sqrt{Var(x)Var(y)}}$$ 3月10日试简述机器学习的内涵 机器学习，顾名思义，是一种让机器进行学习的技术。这里的机器指的是计算机，是算法运行的载体。 另一个角度来看，也可以讲算法本身视作一个”机器“，接受出入，产生输出 对于一个任务，设计一种算法，使算法能够提取出任务相关的数据中蕴含的规律，这就是是机器学习。 根绝输入机器的数据是否带有标记可以分为监督学习和无监督学习。 试简述什么是神经网络 按照一定的规则将多个神经元起来的网络成为神经网络。对于不同的网络，连接规则会有所差异。 一般来说，神经网络要包含三种层：输入层、输出层、隐藏层 局部最优和全局最优的内涵及区别 优化问题的解一般分为两种：局部最优、全局最优 局部最优指的是在函数值空间的一个有限区域内的最值 全局最优指的是在函数整个取值空间上的最值 试简述机器学习的主要学习方式 监督学习：使用有标签（正确答案）的数据来训练模型。训练得到的模型可以将数据映射到给定标签范围内的一个标签。常见的监督学习算法有：支持向量机、逻辑回归、决策树等 无监督学习：与监督学习相对应，无监督学习使用的数据并没有被特别标识出类别。训练出的模型一般用于推断数据本身存在的一些结构。常见的无监督学习有：聚类等。 半监督学习：使用的数据部分有标签，部分没有标签。属于半监督学习的算法有：拉普拉斯支持向量机等 弱监督学习：使用的数据可以看作是有多个标签的数据（没有标签、一个标签、多个标签）。一般用于将输入数据映射到一组更强的标签。 评估标准中的正确率是否能较好的反映算法的性能 一般情况下正确率能直观的反映分类算法的性能，但是各类数据数量悬殊较大时并不可靠。 比如：1000个样本，正样本990，负样本10.（例如预测一个地区的地震概率） 如果将所有的结果预测为正，可以达到99%的正确率，但这样并不合适 在这里，样本数量较少的标签才是我们关注的 3月11日逻辑回归可以用在那些问题上？ 用于分类。用作分类任务时，关键在于设定一个阈值。 用于概率预测。 注意，逻辑回归仅能用于线性问题。即目标和特征之间时线性关系时才能使用， 在目标和特征之间不是线性关系时不使用 在使用时要挑选与目标为线性关系的特征 特征之间不需要满足条件独立性假设 逻辑回归与朴素贝叶斯有何区别？ 逻辑回归属于判别模型，计算的是条件概率，即根据特征得到最终的目标 朴素贝叶斯属于生成模型，计算的是联合概率 朴素贝叶斯属于贝叶斯，逻辑回归属于最大似然，是两种不同的概率哲学 使用朴素贝叶斯需要特征满足条件独立性假设，即各特征之间相互独立，而逻辑回归无此要求 逻辑回归与线性回归的区别有哪些？ 线性回归的目的是预测，而逻辑回归是用于分类 线性回归y的范围不确定，而逻辑回归中y的范围是(0, 1) 线性回归参数的计算方式是最小二乘法（计算误差），而逻辑回归是极大似然估计（计算使目标出现概率最大的参数） 简要描述梯度下降的步骤 初始化参数，可以随机取值 迭代操作： 计算当前梯度 修改新的变量 向梯度最大的方向前进一步 判断是否终止 结果一般为全局最优或局部最优 梯度下降有哪些关键参数？ 迭代的步长 步长太小，迭代速度过慢 步长太大，迭代太快，易错过最优解 参数的初始值 初始值选取不当可能会导致得到的是局部最优解 标准化处理 对各个特征进行标准化处理，防止特征的取值范围不同而导致梯度下降速度变慢 梯度下降会有什么缺陷？ 在接近极小值是收敛速度变慢 可能会出现之字行下降 3月12日试简要描述主成分分析（PCA）的主要思想 PCA的作用是将高维数据通过线性变换投影到低维空间上去，从而可以在计算时减小计算压力，同时不会影响太多性能（被舍弃的维度是噪声或者冗余信息） 去冗余信息：当向量可以被其他向量线性表示时，该特征是多余的 去噪声：去除较小的特征值对应的特征向量，特征值的大小反映了变换后在特征向量方向上的变换幅度，幅度越大，表示该特征包含的信息量越多，多以要保留特征值较大的。 对角化矩阵，寻找极大线性无关组，保留较大的特征值，组成一个投影矩阵对原始样本矩阵进行投影，投影后得到新样本矩阵。 简要总结PCA的算法流程 对所有样本进行中心化 计算样本的协方差矩阵 对协方差矩阵进行特征值分解 取最大的n个特征值对应的特征向量 标准化特征向量，得到特征向量矩阵 转化样本集中的每个样本，得到降维后的样本矩阵 试分析PCA的主要优缺点 优点 只利用样本本身的方差衡量信息量，不受外界因素影响 得到的各主成分之间正交（无线性关系），可消除原始数据中各特征之间的影响 主要使用特征值分解实现，易于实现和计算 缺点 降维后的各个特征的含义有一定模糊性，可解释性降低 被丢弃掉的非主成分可能包含重要信息，丢弃掉会对数据处理有影响 3月13日试描述过拟合和欠拟合的区别 上图中，横坐标为训练样本数量，纵坐标为误差 从上图中我们可以直观的看出： 欠拟合：在训练集以及测试集上同时具有较高的误差，此时模型具有较高的误差。简言之就是模型还没训练好 过拟合：在训练集上具有较低的误差，但是在测试集上的误差较大，此时模型的方差较大。检验之就是对训练数据拟合的太好了，不能很好的泛华到其他数据上 正常：在训练集和测试集上，同时具有相对较低的偏差及方差 如何解决过拟合和欠拟合问题 解决欠拟合问题 添加特征项。通过组合，泛华，上下文特征等增加特征，有时特征数量较少也会导致模型欠拟合 添加多项式特征 增加模型的复杂程度 减少正则化系数（正则化系数是用来放置过拟合的） 解决过拟合问题 重新清洗数据（数据不纯可能导致过拟合） 增加训练样本的数量 降低模型的复杂程度 增大正则项系数 dropout 3月14日试解释误差、偏差、方差的区别和联系 误差（Error） 误差一般用来描述学习器的实际预测结果与样本的真实结果之间的差异 误差 = 偏差 + 方差 + 噪声，换言之，误差描述的是整个模型的准确程度 偏差（Bias） 偏差描述的是模型拟合训练数据的能力，表示的是模型在样本上的输出与真实值之间的误差，是模型本身的精确程度 偏差越小，表示模型的拟合能力越强（可能产生过拟合）；偏差越大，模型的拟合能力越差（可能产生欠拟合） 方差（Variance） 方差表示的是预测值的变化范围，方差越大，数据的分布越分散，模型的稳定性会越差 方差可以用来衡量模型的稳定性 方差越小，说明模型越稳定，模型的泛化能力就更高；方差越大，则模型的泛化能力越差 什么事经验误差和泛化误差 经验误差：又叫训练误差，指的是模型在训练集上的误差 泛化误差：指的是模型在测试集上的误差 3月15日相较于方差，使用标准差表示数据离散程度有哪些好处 表示离散程度的数字与样本数据点的数量级一致，更适合对数据样本形成感性认知 表示离散程度的数字单位与样本数据的单位一致，方便做后续的分析运算 在样本数据大致符合正态分布的情况下，标准差更方便估算 训练数据类别不平衡会导致哪些问题 类别不平衡指分类任务中不同类别的训练样例数目差别很大的情况 分类算法在使用类别不平衡的数据进行训练时，会影响学习结果，测试结果会变差。 比如：二分类问题中有998个反例，正例有2个，那学习方法只需返回一个永远将新样本预测为反例的分类器，就能达到99.8%的精度；然而这样的分类器没有价值。 常见的类别不平衡问题解决方法 扩大数据集 增加包含小类样本数据的数据 欠采样 对大类数据进行欠采样，使之与小样本数据个数相近 例如：EasyEnsemble算法 过采样 对小类数据进行过采样，以增加小类的数据样本的个数 例如：SMOTE和ADASYN算法 使用新的评测指标 在类别不均衡分类任务中，不适合用正确率来评测 数据代价加权 如果任务本身是要识别小类样本，可以对分类器的小类样本增加权值，对大类样本降低权值，从而让分类器更关注小类样本 转化思路 例如将小类样本当作异常点，将分类任务转化为异常点检测任务 将类别再细分 将大类样本分成多个类别","categories":[{"name":"周知识总结","slug":"周知识总结","permalink":"http://zivblog.top/categories/%E5%91%A8%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://zivblog.top/tags/Artificial-Intelligence/"}]},{"title":"Leetcode之组合总和Ⅱ","slug":"Leetcode之组合总和Ⅱ","date":"2020-03-14T08:53:08.000Z","updated":"2020-07-06T05:33:09.348Z","comments":true,"path":"passages/leetcode-zhi-zu-he-zong-he-ii/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zu-he-zong-he-ii/","excerpt":"Combination Sum Ⅱ","text":"Combination Sum Ⅱ Combination Sum Ⅱ code with Python title number：040 读题 给定一个数组candidates和一个目标数target 找出candidates中可以使数字和为target的组合 candidates中的每个数字在每个组合中只能使用一次 所有数字均为正整数 解集中不能包含重复组合 思路一 相比与39题，该题的不同之处在于每个数字只能使用一次 对与这项要求，我们可以在查找下一个数字时从当前位置的下一个位置开始 而要解决解集中不包含重复数，我们可以对数组进行排序，在检查选择列表时，滑过相同值的部分 仍是套用回溯法文章中提到的模版 123456789101112131415161718192021222324def combinationSum2(self, candidates: List[int], target: int) -&gt; List[List[int]]: if not candidates: return [] candidates.sort() size = len(candidates) res = [] # 递归函数 def backtrack(i, temp_sum, temp_list): if temp_sum == target: res.append(temp_list) return for j in range(i, size): # 再加一个值大于target if temp_sum + candidates[j] &gt; target: break # 滑过连续的相同值 if j &gt; i and candidates[j]==candidates[j-1]: continue # 递归 backtrack(j+1, temp_sum+candidates[j], temp_list + [candidates[j]]) backtrack(0, 0, []) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"回溯法","slug":"回溯法","date":"2020-03-13T08:14:04.000Z","updated":"2020-07-31T02:06:22.883Z","comments":true,"path":"passages/hui-su-fa/","link":"","permalink":"http://zivblog.top/passages/hui-su-fa/","excerpt":"回溯法","text":"回溯法 概述 总体上来说，回溯法（Back Tracking）是一种选优搜索算法，即通过试探的方式寻找达到目标的方式。 算法会依次尝试每个分叉点的所有可能，当探索到某一步时，发现当前的选择并不优或者达不到最终目标时，就退回上一步，再选择另一种可能进行探索。这种走不通路就退回再走的方式就是回溯法了 算法讲解直观感受 假设你要从家去一个地方，而去往这个地方的路上有很多个岔路口。用回溯法来找到去往目的地的方法就是一个岔路口一个岔路口的尝试。如果发现走错了，就返回找到岔路口的下一条路，继续尝试，直到找到目的地。 从上面的例子来看，我们使用回溯法解决问题的时候，其实恰好是一次决策树的遍历 细节 既然是决策树的遍历，那我们需要考虑三个问题： 路径：即已经作出的选择 选择列表：当前可以挑选的可能 结束条件：到达决策树的底层，也就是到达终点，无法再进行决策的条件 下面我们将通过8皇后问题来演示回溯法的使用 所谓八皇后问题，就是一个8*8的棋盘上，放置8个皇后，使得它们无法相互攻击 皇后可以攻击同一行、同一列、和所处两条对角线上的任意单位 决策树的每一层对应棋盘上一行的情况，同一层上每个节点的表示在该层的对应位置放置皇后 而使用回溯法，就是遍历该决策树找到符合条件的路径（决策树中的路径对应一种摆放的方案） 既然是决策树的遍历，当然可以通过剪枝来减少代码的复杂度 剪枝 剪枝的方法也很简单直接，即在走过的路径中出现的可能在后面不会再出现 一般通过一个判断路径合法性的函数来实现 需要注意的是，不论如何优化，都无法使算法的复杂度降低太多，因为回溯法本身就是纯暴力穷举，遍历整棵决策树是无法避免的。 代码模版 代码方面，凡使用回溯法解决的问题，都可以套用以下代码模版 123456789result = []def back_tracking(路径, 选择列表): if 结束条件: result.add(路径) return for 选择in 选择列表: 做选择 back_tracking(路径, 选择列表) 回退 DFS与回溯法 回溯法在实现上时遵循深度优先的原则的，即一步一步往前探索 深度优先搜索的目的是遍历，本质上是无序的，即不关心每次访问的次序，重要的是都被访问过 回溯法的目的是求解，本质上是有序的。即每步都是要求的次序 深度优先搜索可以看作是工具，而回溯法是应用 2020.7.31 更新 回溯法常用于遍历列表所有子集，是深度优先遍历的一种，一般用于全排列，穷尽所有可能，便利的过程实际上是一个决策树遍历的过程 回溯法是纯暴力穷举，时间复杂度一般都很高","categories":[{"name":"算法","slug":"算法","permalink":"http://zivblog.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之组合总和","slug":"Leetcode之组合总和","date":"2020-03-13T08:12:51.000Z","updated":"2020-07-06T05:33:00.368Z","comments":true,"path":"passages/leetcode-zhi-zu-he-zong-he/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zu-he-zong-he/","excerpt":"Combnation Sum","text":"Combnation Sum Combnation Sum code with Python title number：039 读题 给定一个无重复元素的数组和一个目标数 找出数组中所有可使数字和为目标数的组合 数组中元素可被无限制重复使用 所有数字均为整数，解的集合中不能包含重复的组合 思路一 很明显，这是一道典型的使用回溯法解决的问题 关于回溯法，可以看另一篇介绍该算法的文章 这里使用减法的思想，例如：target=7, candidates=[2, 3, 6, 7] 对于候选数字2，只需要找到所有7-2=5的所有组合，加上2就是结果了 对于候选数字3，只需要找到所有7-3=4的所有组合，加上3就是结果了 依次类推 这样，我们就可得到一棵决策树，经优化后如下图 正如图中已经经过剪枝，去掉了一些重复的枝叶，在代码中也要有所体现，即设置搜索起点 还有就是，我们还减去了一些从明显不能得到结果的枝叶，比如，当7-3-6之后的下一层就无需再遍历了 另外。对候选数组进行排序也可以加快搜索速度 对于每一条路径的选择，就是深度优先遍历了 123456789101112131415161718192021222324def combinationSum(self, candidates: List[int], target: int) -&gt; List[List[int]]: size = len(candidates) if size == 0: return [] candidates.sort() path, res = [], [] self._dfs(candidates, 0, size, path, res, target) return resdef _dfs(self, candidates, begin, size, path, res, target): if target == 0: res.append(path[:]) return for index in range(begin, size): residue = target - candidates[index] if residue &lt; 0: break path.append(candidates[index]) self._dfs(candidates, index, size, path, res, residue) path.pop()","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之搜索旋转排序数组","slug":"Leetcode之搜索旋转排序数组","date":"2020-03-12T07:05:37.000Z","updated":"2020-07-13T11:36:19.492Z","comments":true,"path":"passages/leetcode-zhi-sou-suo-xuan-zhuan-pai-xu-shu-zu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-sou-suo-xuan-zhuan-pai-xu-shu-zu/","excerpt":"Search Rotated Sorted Array","text":"Search Rotated Sorted Array Search Rotated Sorted Array code with Python title number：033 读题 假设当前的数组是在升序数组的某个结点上进行了旋转后得到 例如：[0, 1, 2, 4, 5, 6, 7] -&gt; [4, 5, 6, 7, 0, 1, 2] 在当前数组中查找一个给定的目标值， 若该值存在，则返回其索引 若不存在，则返回-1 数组中的数不重复 算法时间复杂度必须是O(logn) 思路一 限定了时间复杂度必须是O(logn)，基本上就是在暗示要使用二分搜索了 但是我们知道二分搜索的作用对象必须是有序数组，这里应该也可以用，我们分析一下： 对于数组[4, 5, 6, 7, 0, 1, 2]: 首先通过观察得到，这个数组包含两个有序子数组（前面的子数组整体大于后面的子数组），并且肯定会有一个子数组的长度是大于等于数组长度/2 这样就是一种很好的性质了，假设我们要找的target=6 首先计算mid=(start+end)/2=3， 比较nums[mid]与nums[start]的大小关系足以令我们确定我们现在是位于哪一部分，之后就可以舍弃另一部分了（这和二分搜索一致） 如果nums[mid]&gt;=nums[start]，则nums[mid]位于左边的有序子数组中 如果nums[mid]&lt;nums[start]，则nums[mid]位于右边的有序子数组中 之后我们要确定target的位置，只需要比较target与有序部分边界的关系即可 当nums[mid]在右边的有序部分时，只需判断target与nums[mid]和nums[end]的关系即可 当nums[mid]在左边的有序部分时，只需判断target与nums[mid]和nums[end]的关系即可 12345678910111213141516171819202122232425def search(self, nums: List[int], target: int) -&gt; int: if len(nums) == 0: return -1 start, end = 0, len(nums)-1 while start &lt; end: mid = (end - start) // 2 + start if nums[mid] == target: return mid # mid在在左边有序部分 if nums[mid] &gt; nums[left]: # target在左边有序部分 if nums[start] &lt;= target &lt;= nums[mid]: right = mid else: left = mid+1 # mid在右边有序部分 else: if nums[mid+1] &lt;= target &lt;= nums[right]: left = mid + 1 else: right = mid return left if nums[left] == target else -1","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之下一个排列","slug":"Leetcode之下一个排列","date":"2020-03-11T08:09:45.000Z","updated":"2020-07-06T05:29:34.978Z","comments":true,"path":"passages/leetcode-zhi-xia-yi-ge-pai-lie/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-xia-yi-ge-pai-lie/","excerpt":"Next Permutation","text":"Next Permutation Next Permutation code with Python title number：031 读题 将给定数字序列重新排列成字典序中下一个更大排列 如果不存在下一个更大排列，则将数字重新排列成最小的排列（升序） 原地操作，额外空间数为常数 例如： 1231, 2, 3 -&gt; 1, 3, 23, 2, 1 -&gt; 1, 2, 31, 1, 5 -&gt; 1, 5, 1 这里比较难理解的是下一个更大排列的含义 用一个比较易理解的方式是，将整组数字组成一个整数，下一个更大排列就是下一个刚刚大于当前数字的整数 例如，给定1, 2, 3 -&gt; 123，则刚刚大于它的数字为132 -&gt; 1, 3, 2 更正式一点的说法如下： 所谓的下一个排列，是在当前的基础上，将尾部的最小升序序列标为降序后的整个排列 比如：1, 1, 5的最小升序为1, 5，将其变为降序，则下一个更大排列为1, 5, 1 思路一 理解了下一个更大排列的含义之后，方法就很清晰了 我们从后往前遍历，找到下降点（即nums[i] &gt; nums[i-1]）处 从后往前找到比下降点大的数，与下降点的数交换位置 由于下降点滑倒了后面，要重新排列下降点之后的数字（降序） 如果没有下降点，则重新排序（升序） 12345678910111213141516171819202122def nextPermutation(self, nums: List[int]) -&gt; None: down_index = None # 从后往前遍历 for i in range(len(nums)-2, -1, -1): if nums[i] &lt; nums[i+1]: down_index = i break # 没有下降点，重新排序 if down_index is None: nums.reverse() else: # 从后向前找到大于下降点的数，交换位置 for j in range(len(nums)-1, i, -1): if nums[down_index] &lt; nums[j]: nums[down_index], nums[j] = nums[j], nums[down_index] break # 对后面部分重新排序 i, j = down_index+1, len(nums)-1 while i &lt; j: nums[i], nums[j] = nums[j], nums[i] i += 1 j -= 1 代码再优化 1234567891011def nextPermutation(self, nums: List[int]) -&gt; None: for i in range(len(nums)-1, 0, -1): if nums[i] &gt; nums[i-1]: nums[i:] = sorted(nums[i:]) for j in range(i, len(nums)): if nums[j] &gt; nums[i-1]: nums[i-1], nums[j] = nums[j], nums[i-1] break return # 找不到下降点 nums.sort() 不同之处在于，这里是先对下降点之后的元素进行了排序","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之两数相除","slug":"Leetcode之两数相除","date":"2020-03-10T07:12:16.000Z","updated":"2020-07-06T05:20:43.335Z","comments":true,"path":"passages/leetcode-zhi-liang-shu-xiang-chu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-liang-shu-xiang-chu/","excerpt":"Divivde Two Integers","text":"Divivde Two Integers Divivde Two Integers code with Python title number：029 读题 给定两个整数，被除数dividend和除数dicisor 将两数相除，不能使用乘法、除法和取余运算 返回两数相除得到的商 除数和被除数都是32位有符号整数，且除数不为0 环境只能存储32位有符号整数，范围为[-2^31, 2^31-1]，若结果溢出，则返回2^31-1 思路一 最朴素的思想 判断除数和被除数是否异号 除数和被除数取绝对值，用被除数不断减去除数，至被除数小于除数 根绝两者是否异号还原结果的真实正负情况 1234567891011def divide(self, divdend: int, dividsor: int) -&gt; int: res = 0 sign = 1 if divd ^ dior &gt;= 0 else -1 divd = abs(divd) dior = abs(dior) while divd &gt;= dior: res += 1 divd -= dior res = res if sign==1 else -res return min(max(-2**31, res), 2**31-1) 思路二 思路一中的方式明显会计算次数比较多，我们考虑是否能减少计算的次数 123456789101112观察：10 &#x2F; 3借鉴二分查找的思想，我们每次将除数翻倍（这里的翻倍通过除数自身加自身实现，而不是乘法）10&gt;3可以，10-3,result+1 -&gt; 7&gt;6可以，result+2 -&gt; 1-12&lt;0不行，所以结果是3再举个例子验证一下：12 &#x2F; 312&gt;3可以，12-3，result+1 -&gt; 9&gt;6可以，9-6result+2 -&gt; 3&lt;6不行，-&gt; 再次从3开始判断-&gt; 3&lt;&#x3D;3，3-3，result+1，所以结果是4 另外，我们判断除数和被除数是否异号————这决定结果的正负。在计算时我们使用绝对值函数取两者的绝对值进行计算 12345678910111213141516171819202122232425262728293031323334def divide(self, dividend: int, divisor: int) -&gt; int: # 特殊：被除数为1，需要判断除数的正负，并且考虑边界问题 if abs(divisor) == 1: result = dividend if 1 == divisor else -dividend return min(2**31 - 1, max(-2**31, result)) # 判断除数和被除数是否异号 sign = (dividend &gt;=0) == (divisor &gt;= 0) # 取绝对值 _divisor， _dividend = abs(divisor)， abs(dividend) result = 0 while _divisor &lt;= _dividend: r, _dividend = self.multi_divide(_divisor, _dividend) result += r # 还原结果的正负号 result = result if sign else -result # 检查边界 return min(2**31 -1, max(-2**31, result))def _multi_divide(self, divisor, dividend): # divisor每次翻倍 result = 0 time_count = 1 while divisor &lt;= dividend: dividend -= divisor result += times_count time_count += times_count divisor += divisor return result, dividend 思路三 声明：这种思路参考自题解 联想我们计算两个数除法时使用的竖式计算可以联想到使用移位与减法的组合 1234567891011121314151617181920212223def divide(self, dividend: int, divisor: int) -&gt; int: # 判断两者是否同号 sign = (dividend &gt; 0) == (dividsor &gt; 0) # 取绝对值 dividend, dividsor = abs(dividend), abs(dividsor) count = 0 # 判断除数翻倍多少次会大于被除数，并将divisor变为该数 while dividend &gt;= divisor: count += 1 divisor &lt;&lt;= 1 result = 0 while count &gt; 0: count -= 1 divisor &gt;&gt;= 1 if divisor &lt;= dividend: result == 1 &lt;&lt; count dicidend -= divisor #还原结果的正负号 if sign: result = - result # 处理边界 return result if -2**31 &lt;= result and result &lt;= 2**31-1 else 2**31-1","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之两两交换链表中的节点","slug":"Leetcode之两两交换链表中的节点","date":"2020-03-09T05:15:46.000Z","updated":"2020-07-06T05:20:35.417Z","comments":true,"path":"passages/leetcode-zhi-liang-liang-jiao-huan-lian-biao-zhong-de-jie-dian/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-liang-liang-jiao-huan-lian-biao-zhong-de-jie-dian/","excerpt":"Swap Nodes in Pairs","text":"Swap Nodes in Pairs Swap Nodes in Pairs code with Python title number：024 读题 给定一个链表，两两交换其中相邻的结点 返回交换后的链表 不能只交换结点内部的值，必须操作实际的结点 示例 1-&gt;2-&gt;3-&gt;4经处理后应为2-&gt;1-&gt;4-&gt;3 思路一 通过示例我们可以发现，相邻结点的交换并没有交集，即每个结点只会作为一个结点的相邻结点进行交换 我们使用递归的方式进行 终止条件：当链表为空或只剩一个元素时终止 返回值：应将当前经过交换之后的子链表返回给上一层 递归主体：接收了上一步经过交换的子链表，以及当前结点，共三个结点。其中我们交换前两个结点。 假设两个待交换结点为head, second head要指向返回的子链表，head-&gt;next=swapPairs(...) second要指向head，这里要使用一个临时变量存储second，也就是head-&gt;next 返回值当然是second，因为现在它是交换后子链表的第一个结点 12345678910def swapPairs(self, head: ListNode) -&gt; ListNode: if not head or not head.next: # 没有结点或只有一个结点 return head second = head.next head.next = self.swapPairs(second.next) second.next = head return second 思路二 按照朴素的思想，我们可以一边遍历一边交换 这种情况下，交换两个相邻的结点实际上需要涉及四个结点：即pre，first，second，tail pre-&gt;next = first-&gt;next first-&gt;next = second-&gt;next second-&gt;next = first 注意，每次移动的步长为2 此外，创建一个虚拟头部结点，方便处理 123456789101112131415def swapPairs(self, head: ListNode) -&gt; ListNode: if head is None or head.next is None: return head dummp = ListNode(-1) dummp.next = head pre = dummp while pre.next and pre.next.next: first = pre.next second = first.next pre.next, second.next, first.next = second, first, second.next pre = first return dummp.next 重点还是第一种递归方法的理解，本身想到了递归但是没有写出来，参考了题解中的代码","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之删除链表倒数第n个结点","slug":"Leetcode之删除链表倒数第n个结点","date":"2020-03-08T05:32:18.000Z","updated":"2020-07-06T05:25:20.101Z","comments":true,"path":"passages/leetcode-zhi-shan-chu-lian-biao-dao-shu-di-n-ge-jie-dian/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-shan-chu-lian-biao-dao-shu-di-n-ge-jie-dian/","excerpt":"Remove Nth Node From End of List","text":"Remove Nth Node From End of List Remove Nth Node From End of List code with Python title number：019 读题 给定一个链表和一个数字n 删除链表的倒数第n个结点 思路一 问题的关键在与确定第n个元素的位置 这里我们使用最简单的方式查找第n个元素 第一次遍历统计整个链表的长度count 使用count-n即确定的待删除结点的位置 再次遍历删除即可 注意，要删除第n个结点，我们要找的实际是第n-1个结点 123456789101112131415161718192021def removeNthFromENd(self, head: ListNode, n: int) -&gt; ListNode: helper = ListNode(-1) helper.next = head first = head count = 0 # 统计链表中元素个数 while first: first = first.next count += 1 index = count - n first = helper # 确定待删除元素的位置 while index: first = first.next index -= 1 # 删除元素 first.next = first.next.next return helper.next 建立辅助结点helper是为了更好的处理边界条件：当n等于链表长度时会溢出 思路二 减少遍历链表的次数，是用双指针进行： 初始时指针p和q分别指向helper p指针先移动n次 之后p和q一起移动，当p指针指向None时，q指针恰好指向待删除结点的前一个元素 12345678910111213141516def removeNthFromENd(self, head: ListNode, n: int) -&gt; ListNode: helper = ListNode(-1) helper.next = head p, q = helper, helper while n: p = p.next n -= 1 while p.next != None: p = p.next q = q.next q.next = q.next.next return helper.next","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之三数之和","slug":"Leetcode之三数之和","date":"2020-03-07T05:46:55.000Z","updated":"2020-07-06T05:25:03.971Z","comments":true,"path":"passages/leetcode-zhi-san-shu-zhi-he/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-san-shu-zhi-he/","excerpt":"3 Sum","text":"3 Sum 3 Sum code with Python title number：015 读题 给定一个包含n个整数的数组 判断数组中是否存在三个元素之和为0 找出所有满足条件且不重复的三元组 思路一 按照惯例，暴力法 穷举所有的三元组的可能，并判断每个三元组的和是否为0 由于要求不能有重复的三元组，额外实现一个函数，用于判断两个三元组是否包含的元素相似 这个算法的时间复杂度已经达到了$O(n^3)$，简单写一下伪代码吧 1234567891011121314151617def threeSum(self, nums: List[int]) -&gt; List[List[int]]: res = [] def notInres(arr): # 判断给定三元组是否在答案中 return False if arr in res else True for i in range(len(nums)): for j in range(len(nums)): for k in range(len(nums)): # 判断当前三元组是否和为0 if nums[i] + nums[j] + nums[k] == 0: # 判断答案中是否包含该三元组 if notInres([nums[i], nums[j], nums[k]]): res.append([nums[i], nums[j], nums[k]]) return res 思路二 上面的暴力法存在太多的重复判断，并且是三层循环，我们尝试减少循环的次数 采用分治的思想，我们假定每个元素a[i]都可能是最终组成和为0的三元组中的一个数字，那么剩下的工作就是找到两个和为-a[i]的元素。这样就将循环减少到了两个 问题现在转化成了：给定一个数组，找出其中两个相加等于一个给定值 对于转化后的问题，我们对数组进行升序排序，使用双指针解决 固定三个指针中的最小的指针i，将另外两个指针分别置为l=i+1和r=n-1，通过双指针的交叉移动，记录满足条件的三元组 当nums[i]&gt;0时直接跳过。因为在此条件下nums[i]之后的元素必大于0，不可能相加为0 当nums[i] == nums[i-1]时，已经对nums[i-1]进行过搜索，再次进行必定会得到相同的结果 计算nums[i]+nums[l]+nums[r]的和， 当大于0时l+=1 当小于0时r-=1 当等于0时l+=1,r-=1 另外，如果数组长度小于3，则返回[] 123456789101112131415161718192021222324252627def threeSum(self, nums: List[int]) -&gt; List[List[int]]: res = [] if len(nums) &lt; 3: return [] nums.sort() for i in range(len(nums)): if i &gt; 0 and nums[i] == nums[i-1]: continue l = i+1 r = len(nums)-1 while l &lt; r: if nums[i]+nums[l]+nums[r]==0: res.append([nums[i], nums[l], nums[r]]) while l &lt; r and nums[l]==nums[l+1]: l = l + 1 while l &lt; r and nums[r]==nums[r-1]: r = r - 1 l += 1 r -= 1 elif nums[i]+nums[l]+nums[r] &gt; 0: r -= 1 else: l += 1 return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之盛水最多的容器","slug":"Leetcode之盛水最多的容器","date":"2020-03-06T07:05:23.000Z","updated":"2020-07-06T05:26:25.870Z","comments":true,"path":"passages/leetcode-zhi-sheng-shui-zui-duo-de-rong-qi/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-sheng-shui-zui-duo-de-rong-qi/","excerpt":"Container With Most Water","text":"Container With Most Water Container With Most Water code with Python title number：011 读题 给定n个非负整数a1, ... , an，每个数代表坐标中的一个点(i, ai) 在坐标内画n条垂直线(i, ai)-&gt;(i, 0)，找出其中两条线，使其与x轴围成的容器内可以容纳最多的水 思路一 两条垂直线能够围成矩形面积取决于两个因素 两条垂直线中较短的一条 两条垂直线之间的距离 按照惯例，在情况可穷举的情况下先尝试暴力法 设置一个变量存储截至当前能获得的最大面积 两个循环控制围成矩形的左右垂直线 123456def maxArea(self, height: List[int]) -&gt; int: maxarea = 0 for i in range(len(height)): for j in range(i+1, len(height)): maxarea = max(maxarea, min(height[j], height[i])*(j-i)) return maxarea 不出意外的超时了 思路二 双指针法 设置两个指针，一个指向最前端的垂直线，一个直线末尾的垂直线 设置一个变量存储截至当前能获得的最大面积 计算两个垂直线围成的面积，并且使指向较短垂直线的指针向内移动 可行性 在思路一中我们分析得到能够影响矩形面积的有两个因素：两条中较短的垂直线以及两条垂直线之间的距离 在我们的指针移动时，必然会带来两条垂直线之间距离的减小。如果移动指向两条之中较长的垂直线的指针，则会受较短的垂直线的限制必然导致面积减少；同样的情况下如果移动指向两条中较短的垂直线的指针才有可能带来面积的增加。 123456789101112def maxArea(self, height: List[int]) -&gt; int: maxarea = 0 l, r = 0, len(height)-1 while l &lt; r: maxarea = max(maxarea, min(height[l], height[r])*(r-l)) if height[l] &lt; height[r]: r -= 1 else: l += 1 return maxarea","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之最长回文子串","slug":"Leetcode之最长回文子串","date":"2020-03-05T07:30:23.000Z","updated":"2020-07-06T05:35:09.263Z","comments":true,"path":"passages/leetcode-zhi-zui-chang-hui-wen-zi-chuan/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zui-chang-hui-wen-zi-chuan/","excerpt":"Longest Palindromic Substring","text":"Longest Palindromic Substring Longest Palindromic Substring code with Python title number：005 读题 给定一个字符串，最大长度为1000 找到字符串中的最长回文子串 思路一 老规矩，先上暴力法 使用一个变量存储当前得到的最长回文子串的长度 双循环控制子串的首尾位置，判断子串是否为回文，并且当前子串长度更长时，更新 1234567891011def longestPalindrome(self, s: str) -&gt; str: # 暴力法 max_length = 0 res = \"\" for i in range(len(s)): for j in range(i+1, len(s)+1): temp = s[i:j] if temp == temp[::-1] and len(temp) &gt;= max_length: max_length = len(temp) res = temp return res 很可惜，超时了 思路二 其实这个问题也能使用动态规划来解决 首先想到，当一个字符串的头尾两个字符都不相等时，那这个字符串一定不是回文串； 紧接着，如果头尾两个字符串相等，我们再对去掉首尾字符的内部子串进行判断 如果内部子串也是回文串，那么继续进行 如果内部子串不是回文串，那么就可以宣布结束了 正式一点，按照动态规划的分析方式 定义状态：d[i][j]：表示子串s[i:j]是否为回文子串 初始化： 将初试dp全部设置为False 或者仅将dp[i][i]设置为True其他设置为False 状态转移方程：dp[i][j] = (s[i] == s[j]) and dp[i+1][j-1] 边界条件：[i+1, j-1]不构成区间，即长度小于2（为0或为1） 由此可以直接制定规则，当字符串长度小于2时直接返回该字符串即可 输出：当dp[i][j]=True时返回i和j即可 1234567891011121314151617181920212223def longestPalindrome(self, s: str) -&gt; str: if len(s) &lt; 2: return s dp = [[False for i in range(len(s))] for j in range(len(s))] for i in range(len(s)): dp[i][i] = True for j in range(1, len(s)): for i in range(0, j): if s[i] == s[j]: if j - i &lt; 3: dp[i][j] = True else: dp[i][j] = dp[i+1][j-1] else: sp[i][j] = False if dp[i][j]: cur_len = j - i + 1 if cur_len &gt; max_len: max_len = cur_len start = i return s[start, start+max_len] 这里有一个细节，并不使用单独的结构存储最长回文子串，而是只存储其长度和起始位置，这样可以减少切片带来的时间消耗 思路三 中心扩散法，参考官方题解 思路一中的暴力法是枚举子串的左右边界，然后判断该子串是否为回文串 而该方法的思路是枚举可能出现回文子串的中心位置，从中心位置向外扩散 注意，字符串长度为奇数和偶数时，枚举的回文中心的形式是不同的 当长度为奇数时，可以直接枚举具体的字符 当长度为偶数时，枚举的不再是字符，而是两个字符的间隙，或者说是枚举两个相邻字符作为中心 使用一下方式可以兼容两种情况 传入重合的索引，则按奇数情况中心扩散 传入相邻的索引，则按偶数情况中心扩散 123456789101112131415161718192021222324252627def longestPalindrome(self, s: str) -&gt; str: length = len(s) if length &lt; 2: return s max_len = 1 res = s[0] # 根据传入的索引进行中心扩散 def center_spread(s, size, left, right): i, j = left, right while i &gt;= 0 and j &lt; size and s[i] == s[j]: i -= 1 j += 1 return s[i+1:j], j-i-1 for i in range(length): # 分别进行奇数和偶数的情况 odd, odd_len = center_spread(s, length, i, i) even, even_len = center_spread(s, length, i, i+1) # 找到当前最长回文子串 cur_max = odd if odd_len &gt;= even_len else even if len(cur_max) &gt; max_len: max_len = len(cur_max) res = cur_max return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"博客其他细节优化","slug":"博客其他细节优化","date":"2020-03-04T12:08:38.000Z","updated":"2020-03-04T12:23:16.867Z","comments":true,"path":"passages/bo-ke-qi-ta-xi-jie-you-hua/","link":"","permalink":"http://zivblog.top/passages/bo-ke-qi-ta-xi-jie-you-hua/","excerpt":"","text":"文章置顶 替换插件 123npm uninstall hexo-generator-index --savenpm install hexo-generator-index-pin-top -- save 在需要置顶的文章的Front-matter中加上top属性，并设置为True 1234567---title: 2020data: 2020-03-04catagoris: ***tags: ***top: true--- 链接中汉字转为拼音 安装插件 1npm i hexo-permalink-pinyin --save 修改配置文件 修改根目录下的配置文件，添加以下配置 123permalink_pinyin: enable: true separator: '-'","categories":[{"name":"博客相关","slug":"博客相关","permalink":"http://zivblog.top/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://zivblog.top/tags/Tools/"}]},{"title":"Leetcode之无重复的最长子串","slug":"Leetcode之无重复的最长子串","date":"2020-03-04T04:51:52.000Z","updated":"2020-07-30T01:51:07.032Z","comments":true,"path":"passages/leetcode-zhi-wu-chong-fu-de-zui-chang-zi-chuan/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-wu-chong-fu-de-zui-chang-zi-chuan/","excerpt":"Longest Substring Without Repeating Characters","text":"Longest Substring Without Repeating Characters Longest Substring Without Repeating Characters code with Python title number：003 读题 给定一个字符串，找出其中不含重复字符的最长子串 思路一 最先应该想到的就是暴力法了 穷举所有可能的子串，并判断该子串中字符是否是无重复的 为了代码的整洁，将判断部分抽象成一个函数 遍历字符串中每个字符 如果该字符不在辅助集合中，则添加进去 如果在集合中，则返回False 12345678910111213141516def lengthOfLongestSubstring(self, s: str) -&gt; int: res = 0 for i in range(len(s)): for j in range(i+1, len(s)+1): if self.isUnique(s[i:j]): res = max(res, j-i) return resdef isUnique(self, s): unique = &#123;&#125; for i in range(len(s)): if s[i] in unique: return False else: unique[s[i]] = 1 return True 很遗憾，时间复杂度太高，超时了 思路二 思路一中存在许多重复的检测，例如 s[i:j]是无重复的，那么在检测s[i:j+1]是就只需要判断s[j+1]是否在s[i:j]中即可 直觉上的想法是遍历前面的子串s[i:j]，依次判断其中的元素是否与第s[j+1]相等 但是这样仍会带来比较高的时间复杂度，所以我们使用滑动窗口来实现 使用集合中作为滑动窗口，初始时i=j（i, j分别为滑动窗口的左端和右端，左闭又开） 向右滑动右端点j，并判断s[j]是否在集合中，如果不在，则将其添加到集合中 如果s[j]在集合中，则向右滑动左端点i 这样就可以判断所有以i为左端点的不重复子串了 123456789101112def lengthOfLongestSubstring(self, s: str) -&gt; int: res, i, j = 0, 0, 0 temp = set() while i &lt; len(s) and j &lt; len(s): if s[j] not in temp: temp.add(s[j]) j += 1 res = max(res, j-i) else: temp.remove(s[i]) i += 1 return res 思路三 滑动窗口 思路二实际上还存在重复判断的现象，例如 s[i:j]和s[i+1, j+1]这两种左端点不同的子串就存在重复部分s[i+1,j] 所以我们使用字典来建立字符到索引的映射，而不是使用集合来判断字符是否存在于子串中 具体的，当s[i,j)中存在s[j&#39;]==s[j]，即使逐渐增加左端点i，在i到达j&#39;+1之前，j&#39;+1仍会是到j就停止的阻碍 所以我们选择不逐渐增加左端点，而是直接跳过s[i, j&#39;]范围内的元素，令i=j&#39;+1 1234567891011def lengthOfLongestSubstring(self, s: str) -&gt; int: n, res = len(s), 0 i, j = 0, 0 temp = &#123;&#125; for j in range(n): if s[j] in temp: i = max(temp[s[j]], i) res = max(res, j-i+1) temp[s[j]] = j+1 return res 写在后面 与双指针类似，都是由两个边界指针进行问题的求解 滑动窗口的核心点时维护一个窗口集，其核心步骤是： 右指针右移 收缩 做指针右移 得到结果","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"【置顶】这里是置顶","slug":"这里是置顶","date":"2020-03-03T09:03:09.000Z","updated":"2020-08-09T06:01:03.240Z","comments":true,"path":"passages/zhe-li-shi-zhi-ding/","link":"","permalink":"http://zivblog.top/passages/zhe-li-shi-zhi-ding/","excerpt":"这是小站的导航页","text":"这是小站的导航页 Leetcode精刷题目 原项目在这里 推荐一个较直观的演示图解力扣 更多题目请见leetcode 该部分所刷的题目参考上面项目中的题目，会有部分题目的扩充，重点是解题思路的扩充，基本做到一题多解，思路的描述相对口语化，美中不足是没有绘制相对直观的图例。 说明（2020.6.23）： 发现一宝藏刷题教程，决定抽时间按顺序来一遍，链接在此：Algorithm Pattern 具体安排为：学习内容 -&gt; 练习题（已做过不再更新）-&gt; Leetcode卡片 -&gt; 剑指Offer 加油，jiu mi~ 更新（2020.8.1） 准备按卡片刷题啦，仍会在本页中给出简要题解思路和可提交代码 加油 简单题目 周一 周二 周三 周四 周五 周六 周日 两数之和 回文数 罗马数字转整数 最长公共前缀 有效的括号 删除排序数组中的重复项 最大子序和 合并两个有序数组 买股票的最佳时机 二叉树的最大深度 买股票的最佳时机Ⅱ 回文串 回文串Ⅱ 只出现一次的数字 最小栈 两数之和Ⅱ 阶乘后的0 多数元素 翻转二进制位 位1的个数 打家劫舍 删除链表元素 反转链表 包含重复数Ⅱ 反转二叉树 使用栈实现队列 丑数 移动0元素 4的阶乘 两个数组的交集 路径之和Ⅲ 两个整数之和 二叉搜索树中的众数 分发糖果 模拟机器人行走 二维网格迁移 平衡二叉树 二叉树的层序遍历Ⅱ 删除排序数组中的重复元素 删除排序数组中的重复元素Ⅱ 删除排序数组中的重复元素 环形链表Ⅱ 回文链表 第一个错误的版本 爬楼梯 反转字符串 斐波那契数 寻找数组的中心索引 搜索插入位置 反转字符串 数组拆分 移除数组 最大连续1的个数 中等题目 周一 周二 周三 周四 周五 周六 周日 两数相加 无重复的最长子串 最长回文子串 盛水最多的容器 三数之和 删除链表倒数第n个结点 两两交换链表中的节点 两数相除 下一个排列 搜索旋转排序数组 组合总和 全排列 全排列Ⅱ 旋转图像 字母异位词分组 实现x的n次幂 跳跃游戏 合并区间 第k个排列 不同路径 矩阵置零 颜色分类 子集 单词搜索 删除排序数组中的重复项Ⅱ 分割链表 子集Ⅱ 解码方法 删除回文子序列 反转链表Ⅱ 二叉树的中序遍历 不同的二叉搜索树Ⅱ 不同的二叉搜索树 验证二叉搜索树 二叉树的层序遍历 路径总和Ⅱ 求根到叶子节点数字之和 被围绕的区域 分割回文串 单词拆分 二叉树的前序遍历 目标和 逆波兰表达式求值 乘积最大子数组 二叉树的右视图 岛屿数量 数字范围按位与 实现Trie 长度最小的子数组 最长公共子序列 添加与搜索单词 数组中第K个最大元素 最大正方形 求众数Ⅱ 二叉搜索树中第K小元素 二叉树的最近公共祖先 除自身以外数组的乘积 搜索二维矩阵Ⅱ 完全平方数 最佳买卖股票时机含冷冻期 零钱兑换 奇偶链表 递增的三元子序列 水壶问题 有序矩阵中第k小的元素 常数时间内插入删除和获取随机元素 分割等和子集 两数相加Ⅱ 四数相加Ⅱ 一和零 最长回文子序列 零钱兑换Ⅱ 朋友圈 在系统中查找重复文件 单词的压缩编码 爱吃香蕉的珂珂 石子游戏 RLE迭代器 排序数组 骑士拨号器 在D天内送达包裹的能力 最佳观光组合 可被K整除的最小整数 可被K整除的最小整数 飞地的数量 驼峰式匹配 两个非重叠子数组的最大和 二叉树寻路 绝对值表达式的最大值 最长定差子序列 飞机座位分配概率 在受污染的二叉树中查找元素 可被三整除的最大和 子串出现的最大次数 子数组异或查询 阈值距离内邻居最少的城市 每个元音包含偶数次的最长子字符串 二叉搜索树中的插入操作 反转链表Ⅱ 排序链表 重排链表 复制带随机指针的链表 字符串解码 克隆图 柱状图中最大的矩形 01矩阵 只出现一次的数字Ⅱ 只出现一次的数字Ⅲ 搜索二维矩阵 第一个错误的版本 寻找旋转排序数组中的最小值 三角形最小路径和 最小路径和 不同路径Ⅱ 最长上升子序列 字符串的排列 找到字符串中所有异位词 删除二叉排序树中的节点 对角线遍历 翻转字符串里的单词 实现strStr 困难题目 周一 周二 周三 周四 周五 周六 周日 鸡蛋掉落 柱状图中最大的矩形 寻找排序数组中的最小值Ⅱ 分割回文串Ⅱ 编辑距离 Lintcode题目补充 主要刷题还在leetcode上 该部分不按难度划分，仅按时间顺序 周一 周二 周三 周四 周五 周六 周日 搜索区间 搜索区间 力扣卡片 数组和字符串 相关文章 排序算法 桶排序 简单选择排序 堆排序 直接插入排序 希尔排序 快速排序 冒泡排序 归并排序 基数排序 回溯法 动态规划 前中后缀表达式的转换及计算 Sword offer 数组中的重复元素 暂停该部分的更新 周知识总结 内容包括机器学习、深度学习、自然语言处理、模型优化等 更新列表 月/周 第一周 第二周 第三周 第四周 第五周 2020年3月 3.8~3.15 3.16~3.22 3.23~3.29 2020年4月 3.30~4.5 4.6~4.12 4.13~4.19 4.20~4.26 2020年5月 4.27~5.3 5.4~5.10 因科研等多方面因素，暂停该部分更新，恢复时间待定（2020.6.23）","categories":[{"name":"置顶","slug":"置顶","permalink":"http://zivblog.top/categories/%E7%BD%AE%E9%A1%B6/"}],"tags":[]},{"title":"Leetcode之删除回文子序列","slug":"Leetcode之删除回文子序列","date":"2020-03-03T08:55:13.000Z","updated":"2020-07-06T05:25:12.776Z","comments":true,"path":"passages/leetcode-zhi-shan-chu-hui-wen-zi-xu-lie/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-shan-chu-hui-wen-zi-xu-lie/","excerpt":"Remove Palindromic Subsequences","text":"Remove Palindromic Subsequences Remove Palindromic Subsequences code with Python title number：1332 读题 给定一个字符串，仅由a和b组成 每次操作可以从字符串中删除一个回文子序列 返回删除给定字符串中所有字符的最小删除次数 注意： 子序列：如果一个字符串可以通过删除原字符串中某些字符而不改变原字符顺序得到，那么这个字符串就是原字符串中的一个子序列 回文：如果一个字符串向后和向前读是一致的，那么这个字符串就是一个回文串 思路一 从题目给出的子序列的定义中可以发现，子序列中的元素在原字符串中可以不连续 又因为字符串只由a和b组成，所以可以得到以下结论： 当字符串为空时，返回0 当字符串全为a或全为b时，返回1 当字符串由a和b组成，返回2（先删除全部的a或b，在删除剩下的） 所以这是一道语文题😂 123456789101112131415def removePalindromeSub(self, s: str) -&gt; int: if s == '': return 0 def isPalindrome(s): # 判断给定字符串是否回文 l, r = 0, len(s) -1 while l &lt; r: if s[l] != s[r]: return False l += 1 r -= 1 return True return 1 if isPalindrome(s) else 2 对于Python，可以通过一些花式操作减少代码量 1234def removePalindromeSub(self, s: str) -&gt; int: if s == '': return 0 return 1 if s == s[::-1] else 2 再次，注意：子序列 !=子串","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之二维网格迁移","slug":"Leetcode之二维网格迁移","date":"2020-03-02T06:14:16.000Z","updated":"2020-07-06T05:13:23.202Z","comments":true,"path":"passages/leetcode-zhi-er-wei-wang-ge-qian-yi/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-er-wei-wang-ge-qian-yi/","excerpt":"Shift 2D Grid","text":"Shift 2D Grid Shift 2D Grid code with Python title number：1260 简单 读题 给定一个m行n列的二维网格和一个整数k 根据规定的操作对二维网格“迁移”k次 每次迁移要进行三种操作： 位于grid[i][j]的元素将会移动到grid[i][j+1] 位于grid[i][n-1]的元素将会移动到grid[i+1][0] 位于grid[m-1][n-1]的元素将会移动到grid[0][0] n是列数，m是行数 返回进行了k次迁移之后的网格 思路一 暴力解决，直接翻译题目的要求 1234567891011121314151617from copy import deepcopydef shiftGrid(self, grid: List[List[int]], k: int) -&gt; List[List[int]]: n = len(grid) m = len(grid[0]) for _ in rnge(k): old = deepcopy(grid) for i in range(n): for j in range(m): if j == m-1: grid[(i+1)%n][0] = old[i][j] elif i == n-1 and j == m-1: grid[0][0] = old[i][j] else: grid[i][j+1] = old[i][j] return grid 思路二 在矩阵的二维表示上并没有发现什么规律，所以我们尝试将二维矩阵变成一维 例如： 12345[[1, 2, 3], k&#x3D;1 [[9, 1, 2], [4, 5, 6] &#x3D;&#x3D;&#x3D;&#x3D;&gt; [3, 4, 5], [7, 8, 9]] [6, 7, 8]] [1, 2, 3, 4, 5, 6, 7, 8, 9] -&gt; [9, 1, 2, 3, 4, 5, 6, 7, 8] 所以，这是一个数组旋转问题，对于数组旋转问题，我们使用循环位移算法（三次翻转） 先把[0, n-k-1]翻转 再把[n-k, n-1]翻转 最后把[0, n-1]翻转 并且对于数组旋转问题，旋转的幅度为数组长度时，是会回到初始的样子的 另外，第189题也是数组旋转 1234567891011121314151617181920212223242526def shiftGrid(self, grid: List[List[int]], k: int) -&gt; List[List[int]]: n, m = len(grid), len(grid[0]) # 二维转一维 arr = [grid[i][j] for i in range(n) for j in range(m)] # 取模，避免不必要的计算 k %= m*n res = [] def reverse(l, r): while l &lt; r: t =arr[l] arr[l] = arr[r] arr[r] = t l += 1 r -= 1 reverse(1, m*n-k-1) reverse(m*n-k, m*n-1) reverse(1, m*n-1) # 一维转二维 row = [] for i in range(n): res.append(arr[i*m, (i+1)*m]) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之模拟机器人行走","slug":"Leetcode之模拟机器人行走","date":"2020-03-01T06:12:31.000Z","updated":"2020-07-06T05:23:16.360Z","comments":true,"path":"passages/leetcode-zhi-mo-ni-ji-qi-ren-xing-zou/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-mo-ni-ji-qi-ren-xing-zou/","excerpt":"Walking Robot Simulation","text":"Walking Robot Simulation Walking Robot Simulation code with Python title number：874 简单 读题 机器人在无限大小的网格上行走 从(0, 0)点出发，面向北方，有三种移动指令 -2：向左转90度 -1：向右转90度 1 &lt;= x &lt;= 9：向前移动x个单位 网格上有障碍物，第i个障碍物位于[obstacles[i][0], obstacles[i][1]] 当机器人视图走到障碍物上方时，它会停留在障碍物的前一个网格方块上，但该路线的其余部分可以继续 求从原点到机器人的最大欧式距离的平方。（根据测试用例发现，此处要求得的是移动过程中的最大距离，而不是原点到终点的距离） 思路一 设置两个变量来存储机器人的当前位置和方向 如果机器人收到了转弯的指令，则更新方向； 如果收到其他指令，则沿当前方向走指定的步数 该问题的关键在与收到指令之后坐标的计算（转向，前进）,参考国际版的题解思路中的规律 左转时：dx, dy = -dy, dx 右转时：dx, dy = dy, -dx 123456789101112131415161718192021222324252627def robotSim(self, commands: List[int], obstacles: List[List[int]]) -&gt; int: dx, dy = 0, 1 # 可以视作速度，初始向北，故dx=0，dy=1 x, y = 0, 0 # 初始位置 distance = 0 # 最大距离 obs_dict = &#123;&#125; # 障碍物，字典 for obs in obstacles: # 元组存储，比列表占用空间小，并且比两个list速度快 obs_dict[tuple(obs)] = 0 # 遍历指令并执行 for com in commands: if com == -2: # 向左转90度 dx, dy = -dy, dx elif com == -1: # 向右转90度 dx, dy = dy, -dx else: # 使用循环，一步一步的走，便于判断与障碍物的关系 for j in range(com): next_x = x + dx next_y = y + dy # 遇到障碍物则停下 if (next_x, next_y) in ons_dict: break x, y = next_x, next_y # 计算当前与原点的距离和最大距离之间的关系 distance = max(distance, x*x + y*y) return distance","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之分发糖果","slug":"Leetcode之分发糖果","date":"2020-02-29T05:59:30.000Z","updated":"2020-07-06T05:15:42.655Z","comments":true,"path":"passages/leetcode-zhi-fen-fa-tang-guo/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-fen-fa-tang-guo/","excerpt":"Distribute Candies","text":"Distribute Candies Distribute Candies code with Python title number：575 简单 读题 给定一个长度为偶数的数组，其中不同的数字代表不同的糖果，每一个数组代表一个糖果 将这些糖果平均分给一个弟弟和一个妹妹 返回妹妹可以获得的最大糖果的种类数 即每个人获得的糖果数必须相同，当是妹妹要获得糖果的种类要尽量的多 思路一 由于糖果的数目是偶数，所以我们要做到两个人的糖果数量一样多，并且每个人只能获得n/2颗糖果 如果糖果种类数大于等于n/2，那么妹妹最多得到n/2种糖果 如果糖果种类数小于n/2，那么妹妹能够得到的糖果种类可以是实际的糖果种类数（至少一种一颗） 至此，分析结束，我们发现这道题并不需要想办法求所有可能的分发，只需要统计糖果的种类个数即可 1234567891011def distributeCandies(self, candies: List[int]) -&gt; int: num = &#123;&#125; for candy in candies: if candy in num: num[candy] += 1 else: num[candy] = 0 if len(num) &gt;= len(candies) // 2: return len(candies) // 2 else: return len(num) 上面是使用字典统计的糖果种类，并且统计了每种糖果的数量，但是后者是我们不需要的，所以简化数据结构，尝试使用列表实现 123456789def distributeCandies(self, candies: List[int]) -&gt; int: num = [] for candy in candies: if candy not in num: num.append(candy) if len(num) &gt;= len(candies) // 2: return len(candies) // 2 else: return len(num) 列表实现超时？没找到原因 还可以使用集合set的特性（没有重复元素）来实现 123456def distributeCandies(self, candies: List[int]) -&gt; int: num = set(candies) if len(num) &gt;= len(candies) // 2: return len(candies) // 2 else: return len(num) 代码再简化（求糖果种类数和n/2的较小值） 12def distributeCandies(self, candies: List[int]) -&gt; int: return min(len(set(candies)), len(candies)//2)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之二叉搜索树中的众数","slug":"Leetcode之二叉搜索树中的众数","date":"2020-02-28T07:27:36.000Z","updated":"2020-07-06T05:13:06.011Z","comments":true,"path":"passages/leetcode-zhi-er-cha-sou-suo-shu-zhong-de-zhong-shu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-er-cha-sou-suo-shu-zhong-de-zhong-shu/","excerpt":"Find Mode in Binary Search Tree","text":"Find Mode in Binary Search Tree Find Mode in Binary Search Tree code with Python title number：501 简单 读题 给定一个二叉搜索树，其中存在相同的数 找出给定树中的所有众数 众数不一定只有一个，不考虑输出顺序 二叉树结构 12345class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None 二叉搜索树的特点 结点左子树中所含结点的值小于当前结点的值 结点右子树中所含结点的值大于当前结点的值 左右子树也都是二叉搜索树 思路一 比较容易想到的是通过遍历树得到所有结点的值，再次遍历有序数组，查找其中的众数 值得注意的是，在二叉树的遍历算法中，对于二叉搜索树，通过中序遍历可以直接得到一个有序数组 12345678910111213141516171819202122232425262728def findMode(self, root: TreeNode) -&gt; List[int]: if not root: return [] self.nums = [] self.inorderTraveral(root) res = [self.nums[0]] max_num, cur_num = 1, 1 for i in range(1, len(self.nums)): if self.nums[i] == self.nums[i-1]: cur_num = cur_num + 1 else: cur_num = 1 if cur_num == max_num: res.append(self.nums[i]) elif cur_num &gt; max_num: res = [] res.append(self.nums[i]) max_num = cur_num return resdef inorderTraveral(self, root): if not root: return self.inorderTraveral(root.left) self.nums.append(root.val) self.inorderTraveral(root.right) 思路二 思路一相当于对树中结点进行了两次遍历，我们尝试减少时间的使用 对树中结点进行遍历，使用字典存储树中的结点及其出现的次数，最后取字典中value最大的key输出 123456789101112131415161718192021def __init__(self): self.res = &#123;&#125; def findMode(self, root: TreeNode) -&gt; List[int]: result = [] if root == None: return [] self.visit(root) Max = max(self.res.values()) for key in self.res: if self.res[key]==Max: result.append(key) return resultdef visit(self, root): if root: if root.val in self.res: self.res[root.val] += 1 else: self.res[root.val] = 0 self.visit(root.left) self.visit(root.right)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之两整数之和","slug":"Leetcode之两整数之和","date":"2020-02-27T07:26:11.000Z","updated":"2020-07-06T05:21:52.603Z","comments":true,"path":"passages/leetcode-zhi-liang-zheng-shu-zhi-he/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-liang-zheng-shu-zhi-he/","excerpt":"Sum of Two Integer","text":"Sum of Two Integer Sum of Two Integer code with Python title number：371 简单 读题 不使用+和-来计算两个数的和 思路一 既然不允许直接使用加法和减法，那么我们只能借助其他的方式来替代这两中运算 首先想到的就是位运算，我们来看一下按位做加法的特点 12340 + 0 = 00 + 1 = 11 + 1 = 01 + 0 = 1 经观察不难发现，这就是位运算中的异或运算 但是使用异或运算只能实现无进位的加法，如何实现进位操作呢，再次观察上面的例子，我们发现，通过与运算可以获得该位置上运算得到的进位 但是，这样得到的进位是在本位置上的，而实际上的进位要在其更高一位的位置上（左侧一位） 所以： 用二进制运算求和可以分为两部分：a和b的无进位结果；a和b的进位情况 前者通过异或运算得到 后者通过与运算和移位（左移一位）得到 循环此过程，直到进位为0，结果即为所求 在Python中需要特殊处理的是： 由于Python中整数不是32位的，我们需要手动对Python中的整数进行处理，手动模拟32位整数 具体来说可以对0x100000000（16进制）取模，得到低位的32位数 123456789101112def getSum(self, a: int, b: int) -&gt; int: mask = 0x100000000 max_int = 0x7FFFFFFF min_int = max_int + 1 while b != 0: # 计算进位 carry = (a &amp; b) &lt;&lt; 1 # 无进位加法 a = (a ^ b) % mask b = carry % mask return a if a &lt;= max_int else ~((a % min_int) ^ max_int)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之路径之和Ⅲ","slug":"Leetcode之路径之和Ⅲ","date":"2020-02-26T07:24:25.000Z","updated":"2020-07-06T05:22:17.864Z","comments":true,"path":"passages/leetcode-zhi-lu-jing-zhi-he-iii/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-lu-jing-zhi-he-iii/","excerpt":"Path Sum Ⅲ","text":"Path Sum Ⅲ Path Sum Ⅲ code with Python title number：437 简单 读题 给定一颗二叉树，每个结点存放一个整数 树的结点的形式 12345class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None 找出路径和等于给定数值的路径总数 路径不需要从根节点开始，也不必在叶子节点结束，但方向需要向下 示例 123456789101112131415root &#x3D; [10,5,-3,3,2,null,11,3,-2,null,1], sum &#x3D; 8 10 &#x2F; \\ 5 -3 &#x2F; \\ \\ 3 2 11 &#x2F; \\ \\3 -2 1返回3,和等于8的路径有:1. 5 -&gt; 32. 5 -&gt; 2 -&gt; 13. -3 -&gt; 11 思路一 初次读到题目，感觉有些复杂：路径的开头可以不是根节点，结束也可以不是叶子结点 简化一下问题，如果我们规定路径的开始结点必须是根节点，那么我们通过一次遍历就可以得到所有的路径 再进一步，我们可以将树中的任意内部节点作为”根节点”，找到所以以该”根节点”为根的二叉树中符合条件的路径 对的，这样就行成了一个递归结构。其实对于这种问题，首先想到的就是使用递归解决，但是困难的地方在于找到其中的递归结构 123456789101112131415161718def pathSum(self, root: TreeNode, sum: int) -&gt; int: if root == None: return 0 return self.paths(root, sum) + self.pathSum(root.left, sum) + self.pathSum(root.right, sum)def paths(self, root, sum): if root == None: return 0 res = 0 if root.val == sum: res += 1 res += self.paths(root.left, sum - root.val) res += self.paths(root.right, sum - root.val) return res 思路二 第一种方法的递归比较好理解，但是是双重递归，时间复杂度比较高 可否减少递归次数，或者减少计算的次数，从而达到减少耗费时间的目的呢，答案是肯定的 我们可以通过一次遍历，得到树中的所有节点 在此基础上，我们进行反向操纵，即每遍历到一个结点，判断在包含该节点的路径上是否路经本身或者子路径符合条件 由于只进行一次遍历，所以每便利到一个结点时进行的反向计算并不会有重复 1234567891011121314151617181920def pathSum(self, root: TreeNode, sum: int) -&gt; int: self.data = [] # 保存路径上的结点 self.count = 0 # 统计符合的路径数目 self.recursive(root, sum) return self.countdef recursive(self, root, sum): if root == None: return 0 self.data.append(root.val) cur = 0 for i in range(len(self.data)-1, -1, -1): cur += self.data[i] if cur == sum: self.count += 1 self.recursive(root.left, sum) self.recursive(root.right, sum) self.data.pop()","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之两个数组的交集","slug":"Leetcode之两个数组的交集","date":"2020-02-25T08:40:23.000Z","updated":"2020-07-06T05:20:28.267Z","comments":true,"path":"passages/leetcode-zhi-liang-ge-shu-zu-de-jiao-ji/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-liang-ge-shu-zu-de-jiao-ji/","excerpt":"Intersection of Two Array","text":"Intersection of Two Array Intersection of Two Array code with Python title number：349 简单 读题 给定两个数组，计算两个数组的交集 结果中的每个元素是唯一的 不考虑输出结果的顺序 思路一 比较直接的想法是，依次判断nums1中的元素是否在nums2中，如果在，则添加到交集中 因为结果中的每个元素是唯一的，所以要事先对数组进行去重操作，可以使用set事先 123456def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: inter = [] for num in set(nums1): if num in set(nums2): inter.append(num) return inter 思路二 比较取巧的方法，使用语言本身的内置函数 123def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: return list(set(nums1) &amp; set(nums2)) 思路三 上面的两种方法对数组的遍历多次数组，这必定会造成时间上的浪费 使用双指针可以对两个数组只遍历一遍 首先对两个数组进行去重操作，之后再进行排序 设置两个指针，分别指向排序后的两个数组的头部 比较指针指向的两个元素是否相同，若相同则添加到交集中，并将两个指针后移 否则将指向较小元素的指针后移 123456789101112131415def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: inter = [] nums1, nums2 = list(set(nums1)), list(set(nums2)) nums1.sort(), nums2.sort() i, j = 0, 0 while i &lt; len(nums1) and j &lt; len(nums2): if nums1[i] == nums2[j]: inter.append(nums1[i]) i += 1 j += 1 elif nums1[i] &lt; nums2[j]: i += 1 else: j += 1 return inter","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之4的阶乘","slug":"Leetcode之4的阶乘","date":"2020-02-24T08:38:55.000Z","updated":"2020-07-06T05:08:26.285Z","comments":true,"path":"passages/leetcode-zhi-4-de-jie-cheng/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-4-de-jie-cheng/","excerpt":"Power of Four","text":"Power of Four Power of Four code with Python title number：342 简单 读题 给定一个整数（32位有符号数），判断这个是是否为4的幂次方 进阶：尝试不使用循环或者递归实现 思路一 比较直接的想法就是不停的除以4直到不能整除，判断最后的数是否为整数 1234def isPowerOfFour(self, num: int) -&gt; bool: while num and num % 4 == 0: num /= 4 return num == 1 思路二 还有一种更为直接的想法，既然给定的数是32位有符号整数，经过计算，32位有符号整数所能表达的最大的4的幂次方为$4^{15}$ 因此，我们可以穷举所有可能，判断给定的数是否在穷举的结果中即可 注意，4的幂肯定是正整数啊 12345def isPowerOfFour(self, num: int) -&gt; bool: prob = [] for i in range(0, 16): prob.append(pow(4, i)) return num in prob 思路三 下面根据数字本身的数学特点想到的方法 首先观察$num = 4^x$，那么，$x = log_4x = \\frac{1}{2}log_2x$，此处的x应该是整数 再进一步，我们只需要判断$log_2x$是否为偶数即可 1234from math import log2class Solution: def isPowerOfFour(self, num: int) -&gt; bool: return num &gt; 0 and log2(num) % 2 == 0 思路四 位运算 因为4的幂次方必定是2的幂次方，观察2的幂次方的二进制表示 123456789102 104 1008 100016 1000032 10000064 1000000128 10000000256 100000000512 10000000001024 10000000000 可以发现，4的幂次方的二进制中，1出现在奇数位上（很重要的特点） 我们想要找到一个特殊的数：奇数位为1，偶数位为0，这样的一个数与4的幂次方进行与运算，得到的结果与原来的数相同 1010101010101010101010101010101 123456789def isPowerOfFour(self, num: int) -&gt; bool: if num &lt;= 0: return False # 是否为2的幂次方 if (num &amp; num - 1) != 0: return False # 是否为4的幂次方 if num &amp; 0x55555555 == num: return True 注意，一定要先判断数字是否为2的幂次方，否则5,9这种数在进行与运算时也会返回True 代码简化 12def isPowerOfFour(self, num: int) -&gt; bool: return num &gt; 0 and (num &amp; num-1)==0 and num &amp; 0x55555555 == num","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之移动0元素","slug":"Leetcode之移动0元素","date":"2020-02-23T08:37:36.000Z","updated":"2020-07-06T05:30:07.001Z","comments":true,"path":"passages/leetcode-zhi-yi-dong-0-yuan-su/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-yi-dong-0-yuan-su/","excerpt":"Move Zeros","text":"Move Zeros Move Zeros code with Python title number：283 简单 读题 给定一个数组，将数组中所有的数字0移动到数字的末尾 同时需要保证非0元素的相对顺序 需要在原数组上进行操作，不能使用额外的存储空间 示例：[0,1,0,3,12] -&gt; [1,3,12,0,0] 思路一 如果没有限制使用额外空间的话，我们可以分别使用两个数组保存0和非0元素，最后将两个数组进行拼接即可 在不能使用额外数组的限制条件下，需要转变一下思路 0元素最后必定出现在数组的末尾，那么我们可以只操作非0元素，最后在数组后面补0即可 使用快慢指针，fast用于遍历数组，slow用于指向非0元素的最后一位 123456789def moveZeroes(self, nums: List[int]) -&gt; None: fast = slow = 0 while fast &lt; len(nums): if nums[fast] != 0: nums[slow] = nums[fast] slow += 1 fast += 1 for i in range(slow, fast): nums[i] = 0 思路二 思路一对数组的遍历多于一遍，我们尝试节省这部分时间 遍历数组，第一次遇到非0元素就与nums[0]交换位置 依次类推，第i次遇到非0元素就与nums[i]交换，直到遍历结束 123456def moveZeroes(self, nums: List[int]) -&gt; int: i, j = 0 for i in range(len(nums)): if nums[fast] != 0: nums[j], nums[i] = nums[i], nums[j] j += 1","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之丑数","slug":"Leetcode之丑数","date":"2020-02-22T03:04:41.000Z","updated":"2020-07-06T05:10:04.146Z","comments":true,"path":"passages/leetcode-zhi-chou-shu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-chou-shu/","excerpt":"Ugly Number","text":"Ugly Number Ugly Number code with Python title number：263 简单 读题 判断给定的数是否为ugly number 所谓ugly number指的是只包含质因数2,3,5的正整数 思路一 问题的关键在于求质数 首先想到的是先将给定的数进行质数分解，之后再判断分解得到的质数序列中是否含有除2,3,5之外的质数 但是这样需要进行质数分解并且需要使用额外的空间来存储质数序列，和额外的时间来再次遍历质数序列 换一种思路，我们对给定的数字不断除以2,3,5，如果最后的数字不是1，则返回False 12345678910111213141516def isUgly(self, num: int) -&gt; bool: if num &lt;= 0: return False while True: last = num if not num % 2: num = num // 2 if not num % 3: num = num // 3 if not num % 5: num = num // 5 if num == 1: return True if last = num: return False 重构一下代码 1234567def isUgly(self, num: int) -&gt; bool: if num &lt;= 0: return False for x in [2, 3, 5]: while not num % x: num = num // x return num == 1 第二种实现方法的用时明显减少 经分析可能是对于8这种只包含其中一个质数的可以减少很多无用的计算和判断","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之使用栈实现队列","slug":"Leetcode之使用栈实现队列","date":"2020-02-22T03:03:30.000Z","updated":"2020-07-06T05:27:06.233Z","comments":true,"path":"passages/leetcode-zhi-shi-yong-zhan-shi-xian-dui-lie/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-shi-yong-zhan-shi-xian-dui-lie/","excerpt":"Implement Queue using Stack","text":"Implement Queue using Stack Implement Queue using Stack code with Python title number：232 简单 读题 使用栈实现队列的以下功能 push(x)：将一个元素放入队列尾部 pop()：从队列首部移除元素 peek()：获取最前端的元素 empty()：返回队列是否为空 只能使用栈的标准操作，对于不支持栈的语言可以使用list代替 思路一 这个题没有什么特别的思路，重要的是理解栈和队列两种数据结构的特点 栈：先进后出，只能在一端进行操作 队列：先进先出，只能在队头出元素，在队尾进元素 我们使用两个栈来实现队列 一个用来反转元素的入队顺序 一个用来存储元素的最终顺序 入队操作 队列是先进先出的，而栈是先进后出的 最新压入栈的元素需要在栈底，所以我们将栈S1中的所有元素移到栈S2中实现顺序的反转，并将新元素压入S1中，再将S2中的元素放回S1，这时S1中元素的顺序就是队列中的顺序了 出队操作 直接从S1中弹出即可 判空操作 只需要检查S1中是否为空即可 取队首元素 使用front存储队首元素 每次出队入队时都要更新该值 需要的时候只需要返回该值即可 1234567891011121314151617181920class MyQueue: def __init__(self): self.stack = [] self.help_stack = [] def push(self, x: int) -&gt; None: while self.stack: self.help_stack.append(self.stack.pop()) self.stack.append(x) while self.help_stack: self.stack.append(self.help_stack.pop()) def pop(self) -&gt; int: return self.stack.pop() def peek(self) -&gt; int: return self.stack[-1] def empty(self) -&gt; bool: return not bool(self.stack) 思路二 上一种方式使用了辅助栈，需要先弹出再还原，每个元素会访问两遍，所以使用的时间比较多 仍然是使用辅助栈，一个用于输入，一个用于输出 当需要查看或者出队时，我们将输出栈中的元素放入输出栈中，从输出栈中进行输出 当输出栈不为空时可直接从输出栈中输出元素 要保证输出栈中为空的时候才能向其中放入元素 并且一次需要将输入栈中的所有元素全放入输出栈 写一个辅助函数shift用于将输入栈中元素一次性全部放入输出栈中 123456789101112131415161718192021222324252627282930class MyQueue: def __init__(self): self.stack_in = [] self.stack_out = [] def push(self, x: int) -&gt; None: self.stack_in.append(x) def pop(self) -&gt; int: self.shift() return self.stack_out.pop() def peek(self) -&gt; int: self.shift() return self.stack_out[-1] def empty(self) -&gt; bool: if not self.stack_in and not self.stack_out: return True return False def shift(self): if not self.stack_out: while self.stack_in: self.stack_out.append(self.stack_in.pop())","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之反转二叉树","slug":"Leetcode之反转二叉树","date":"2020-02-20T02:22:44.000Z","updated":"2020-07-06T05:13:42.721Z","comments":true,"path":"passages/leetcode-zhi-fan-zhuan-er-cha-shu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-fan-zhuan-er-cha-shu/","excerpt":"Inverted Binary Tree","text":"Inverted Binary Tree Inverted Binary Tree code with Python title number： 226 简单 读题 反转二叉树 左右子树互换 示例 给定二叉树结构 12345class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None 思路一 非常经典的树结构的问题，很适合使用递归方法来解决 如果根节点为空，则返回None 否则递归反转其左右子树 边界条件：结点无左右子女 12345678910def invertTree(self, root: TreeNode) -&gt; TreeNode: if root == None: return None right = self.invertTree(root.right) left = self.invertTree(root.left) root.left = right root.right = left return root 思路二 还可以使用迭代的方式进行 类似于深度优先搜索，我们使用一个队列来协助完成 队列中存储所有还未交换左右子女的结点 初始情况下只有根节点在队列中 出队根节点，交换其左右子女，并且左右子女入队；依次执行，直到树被遍历完 本题的重点在于遍历树的每个节点，只要能访问到树的每个节点，皆可以实现二叉树的反转，至于使用哪种遍历方式则没那么讲究 12345678910111213def inverTree(self, root: TreeNOde) -&gt; TreeNode: if root == None: return None queue = [] queue.append(root) while queue &gt; 0: cur = queue.pop(0) cur.left, cur.right = cur.right, cur.left if cur.left != None: queue.append(cur.left) if cur.right != None: queue.append(cur.right) return root 迭代和递归的区别 简单来说，递归是程序调用自身的一种编程技巧，通常把一个大型的复杂的问题转化为一个与原问题相似的规模较小的问题来解决 而迭代是利用变量的原值推算出变量的新值，是A不断调用B的过程 总体来说，递归中一定有迭代，而迭代中不一定有递归。 大部分情况下可以相互转化，优先选择使用迭代，因为递归调用函数浪费空间，并且递归的太深容易造成堆栈的溢出","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之包含重复数Ⅱ","slug":"Leetcode之包含重复数Ⅱ","date":"2020-02-19T08:02:31.000Z","updated":"2020-07-06T05:08:53.336Z","comments":true,"path":"passages/leetcode-zhi-bao-han-chong-fu-shu-ii/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-bao-han-chong-fu-shu-ii/","excerpt":"Contains Duplicate Ⅱ","text":"Contains Duplicate Ⅱ Contains Duplicate Ⅱ code with Python title number：219 简单 读题 给定一个整数数组和一个整数K 判断数组中是否存在两个不同的位置的元素值相等，并且这两个元素的索引之差的绝对值大于K 思路一 因为需要在给定的数组中查找相同元素，找到之后再判断两者索引之差是否符合要求 这里可以使用一个哈希表来存储，将相同元素的下标存储到一起 具体来说，使用一个字典，key为元素值，value为元素的下标 如果nums[i]不在字典中，则将nums[i]添加到字典中，同时将value设置为其索引 如果nums[i]在字典中，则判断当前的nums[i]的索引与字典中nums[i]对应的value的差值是否符合情况 注意：在数组遍历完之前不能因为一次的判断不符合就返回False，正确的做法是更新字典中nums[i]对应的索引 123456789101112def containsNearbyDuplicate(self, nums: List[int], k: int) -&gt; bool: hash = &#123;&#125; for i in range(len(nums)): if nums[i] not in hash: hash[nums[i]] = i else: if i - hash[nums[i]] &lt;= k: return True else: hash[nums[i]] = i return Fasle 题目比较简单，暂时没有想到其他的思路，做一下代码的简化 12345678def containsNearbyDuplicate(self, nums: List[int], k: int) -&gt; bool: hash = &#123;&#125; for index, num in enumerate(nums): if num in hash and index - hash[num] &lt;= k: return True hash[num] = index return False 思路二 这个方法时间复杂度太高，不可行 遍历数组，每检查一个数，就去遍历其后面k个数，看是否有相等的，有则返回True 当数组遍历完仍未发现符合的情况，则返回False 1234567def containsNearbyDuplicate(self, nums: List[int], k: int) -&gt; bool: for index, num in enumerate(nums): for i in range(1, k+1): if index+i &lt; len(nums): if num == nums[index+i]: return True return False","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之反转链表","slug":"Leetcode之反转链表","date":"2020-02-18T08:01:25.000Z","updated":"2020-07-06T05:13:50.795Z","comments":true,"path":"passages/leetcode-zhi-fan-zhuan-lian-biao/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-fan-zhuan-lian-biao/","excerpt":"Reverse Linked List","text":"Reverse Linked List Reverse Linked List code with Python title number：206 简单 读题 反转链表 迭代 or 递归 关键词：链表 思路一 典型的链表操作 最直接的想法就是使用一个等长的数组存储链表的元素 反向遍历数组，并将链表中的结点的值修改即可 12345678910111213def reverseList(self, head: ListNode) -&gt; ListNode: nums = [] cur = head while cur: nums.append(cur.val) cur = cur.next cur = head for i in range(len(nums), 0, -1): cur.val = nums[i-1] cur = cur.next return head 可以通过，但是耗费的时间比较多，对链表进行了两次遍历 思路二 将链表反转，实际上只需要把所有的指针方向改变即可 还有一个要改变的地方是原来的头指针要指向null 这里使用双指针迭代法 设置两个指针：pre和cur 初始情况下：pre=null, cur=head 将cur指向pre，之后不断迭代cur，每次迭代cur都将cur-&gt;next指向pre，同时将pre和cur同时向后移 12345678910def reverseList(self, head: ListNode) -&gt; ListNode: pre = None cur = head while cur: tmp = cur.next cur.next = pre pre = cur cur = tmp return pre 思路三 递归，本质上还是指针方向的改变 既然是递归，我们就像想一下终止条件等问题 终止条件：当前结点或下一节点指向null 递归主体：当前结点的下一个结点的next指向当前结点 12345678910def reverseList(self, head: ListNode) -&gt; ListNode: if head==None or head.next==null: return head # 跳出递归时指向的是最后一个元素 cur = self.reverseList(head.next) head.next.next = head head.next = None return cur 思路四 相信在学习数据结构中链表的插入时，都学过一种名叫头插法的插入方式 可以利用这种方式，在遍历链表的过程中，不断将链表结点添加到链表的头部 123456789101112def reverseList(self, head: ListNode) -&gt; ListNode: if head == None: return cur = head.next # 用于遍历链表 head.next = None head_ = head while cur: temp = cur.next cur.next = head_ head_ = cur cur = temp return head_","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之删除链表元素","slug":"Leetcode之删除链表元素","date":"2020-02-17T07:59:52.000Z","updated":"2020-07-06T05:25:29.843Z","comments":true,"path":"passages/leetcode-zhi-shan-chu-lian-biao-yuan-su/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-shan-chu-lian-biao-yuan-su/","excerpt":"Remove Linked List Elements","text":"Remove Linked List Elements Remove Linked List Elements code with Python title number：203 简单 读题 删除链表中等于给定值val的所有结点 关键词：链表 Python中给定的链表结构 1234class ListNode: def __init__(self, x): self.val = x self.next - None 思路一 常规的链表题目 双指针：pre, cur，分别指向前一个元素和当前元素 初始，pre=head，cur=head 遍历列表，遇到需要删除的结点时，将pre-&gt;next指向cur-&gt;next 需要单独处理几种特殊情况： 链表为空 待删除结点在链表头部 1234567891011121314151617181920def removeElement(self, head: ListNode, val: int) -&gt; ListNode: # 链表为空 if not head: return None # 待删除元素为第一个结点 while head and head.val == val: head = head.next pre, cur = head, head while cur != None: if cur.val == val: # 删除当前元素 cur = cur.next pre.next = cur else: pre = cur cur = cur.next return head 添加一个在头部的辅助结点，将几种特殊情况转化为可以一起处理的通用情况 1234567891011def removeElement(self, head: ListNode, val: int) -&gt; ListNode: prev =ListNode(0) prev.next = head cur = prev while cur.next: if cur.next.val == val: cur.next = cur.next.next else: cur = cur.next return prev.next","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之打家劫舍","slug":"Leetcode之打家劫舍","date":"2020-02-16T04:03:32.000Z","updated":"2020-07-06T05:10:22.782Z","comments":true,"path":"passages/leetcode-zhi-da-jia-jie-she/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-da-jia-jie-she/","excerpt":"House Robber","text":"House Robber House Robber code with Python title number：198 简单 读题 你是一个小偷，计划偷沿街的房子，要求在限定条件下取得尽可能多的现金 当你在同一晚上潜入了相邻的两间房子，警报会被触发 例如：[1,2,3,1] 即相邻的四座房子中分别可以偷到金额为1,2,3,1的现金 最佳方案是偷第一间和第三间房子，获得金额为4的现金 关键词：动态规划 思路一 习惯了暴力求解，这道题其实也可已通过穷举所有可能进行求解，但是考虑所有可能的抢劫方案过于困难 但是这是一道动态规划的题目，天生的动态规划题目，哈哈 动态规划的本质在解决第i个元素取不取的问题，对应到该题目就是第i个房子抢不抢的问题 我们前i个房子能获得的最大价值为dp[i] 判断的依据就是抢与不抢两种情况下哪一种带来的价值最大 如果抢的话，当前获得的总价值就是nums[i] + dp[i-2]（相邻房子不能抢） 如果不抢的话，当前获得的总价值就是dp[i-1] 所以最难确定的状态转移方程就是dp[i]=max(dp[i-2]+nums[i], dp[i-1]) 初始状态：dp[0]=0 返回值为dp的最后一个元素，即所有房间可以获得的最大价值 123456789101112def rob(self, nums: List[int]) -&gt; int: if len(nums) == 0: return 0 if len(nums) == 1: return nums[0] dp = nums dp[0], dp[1] = nums[0], max(nums[0], nums[1]) for i in range(2, len(nums)): dp[i] = max(dp[i-2]+nums[i], dp[i-1]) return dp[len(nums)-1] 由于dp[i]只与dp[i-1]和dp[i-2]有关，设置两个变量交替存储，代替使用dp数组，可以减少空间的使用 123456789101112def rob(self, nums: List[int]) -&gt; int: if not nums: return 0 length = len(nums) if length == 1: return nums[0] prev= nums[0] cur = max(prev, nums[1]) for i in range(2, length): cur, prev = max(prev+nums[i], cur), cur return cur 将cur和pre初始设置为0，可以将nums长为1和0的两种情况包含进来，进一步简化代码 12345def rob(self, nums: List[int]) -&gt; int: cur, pre =0, 0 for num in nums: cur, pre = max(pre+num, cur), cur return cur","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之位1的个数","slug":"Leetcode之位1的个数","date":"2020-02-15T08:54:01.000Z","updated":"2020-07-06T05:28:46.533Z","comments":true,"path":"passages/leetcode-zhi-wei-1-de-ge-shu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-wei-1-de-ge-shu/","excerpt":"Number of 1 Bits","text":"Number of 1 Bits Number of 1 Bits code with Python title number：191 简单 读题 给定一个无符号整数，返回其二进制表达式中1的个数 也称为汉明重量 思路一 比较直接的方法就是，遍历数字的32位，如果某一个二进制位为1，则计数加一，最后返回计数即可 123456def hammingWeight(self, n: int) -&gt; int: n = bin(n) for c in n: if c == '1': count += 1 return count 思路二 按照十进制转二进制的方式，每得到一位，判断其是否为1 注意，区别与之前翻转二进制的题目，这里统计的是1的个数，并不需要补零的操作 12345678def hammingWeight(self, n: int) -&gt; int: count = 0 while n: res = n % 2 if res == 1: count += 1 n //= 2 return count 由于中间涉及比较多的计算，耗费的时间比较多 思路三 我们知道两个不同长度的二进制数进行运算，会将长度较短的二进制数左端补零。 根据这一特性，将n与1进行与运算，将能得到n的最低位数字 之后再将n右移一位 重复以上操作，直到n==0 123456def hammingWeight(self, n: int) -&gt; int: count = 0 while n: count += n&amp;1 n &gt;&gt;= 1 return count 花费的时间比较少 总结 三个思路基本思想一致，都是遍历每位，判断是否是1，然后计数 区别在于获取每一位的方式不同 其中第三种方法分要注意，重点是其中涉及到的二进制运算的知识","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之翻转二进制位","slug":"Leetcode之翻转二进制位","date":"2020-02-15T08:52:46.000Z","updated":"2020-07-06T05:13:32.687Z","comments":true,"path":"passages/leetcode-zhi-fan-zhuan-er-jin-zhi-wei/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-fan-zhuan-er-jin-zhi-wei/","excerpt":"Reverse Bits","text":"Reverse Bits Reverse Bits code with Python title number：190 简单 读题 颠倒给定的32位无符号整数的二进制位 关键词：位运算 无符号整数 计算机中的数是用二进制表示的 最左边的这一位如果用来表示这个数是正数还是负数，这样的数被称为有符号整数 最左边的这一维如果不用来表示这个数是正还是负，这样的数被成为无符号整数，无符号整数只能是正数 位运算相关操作123456789&lt;&lt; 按位左移，左移n位相当于乘以2的n次方&gt;&gt; 按位右移，右移n位相当于除以2的n次方&amp; 按位与，参与计算的两个二进制位同且为1，结果为1，否则为0| 按位或，参与计算的两个二进制位有1，结果为1，否则为0^ 按位异或，参与计算的两个二进制位不同，结果为1，否则为0~ 按位取反，参与计算的二进制位中0变为1，1变成0python中，将整数取反之后要进行切片，去掉前面的0bbin(num) 将整数转化为二进制数 思路一 最先联想到的是字符串的翻转 使用两个指针，分别指向字符串的头和尾 交换两个指针指向的元素，直到指针相遇或相邻（奇数位相遇，偶数位相邻） 但是这个问题中的二进制整数并不能通过下标访问每一位，所以需要有所改动 比较直接的方法就是将二进制转化为字符串再进行翻转，位数不够进行补位，最后再转化为整数 12345def reverseBits(self, n: int) -&gt; int: str1 = bin(n)[2:][::-1] while len(str1) &lt; 32: str1 += '0' return int(str1, 2) 由于是32位无符号整数，我们进行转化得到的数可能是高位有0，而在Python中转化之后是没有的，但是反转之后要在最后面追加0 例如： 1234567str1 = bin(n) # 0b10100101000001111010011100str1 = bin(n)[2:] # 10100101000001111010011100str1 = bin(n)[2:][::-1] # 00111001011110000010100101# 可以看到，翻转之后的数字是不够32位的，所以要在后面追加0while len(str1) &lt; 32: str1 += '0'# 00111001011110000010100101000000 思路二 位运算 回想反转10进制的时候，我们的操作是这样的 12ans = ans * 10 + n % 10n /= 10 同样的，反转二进制我们也可以如此 12ans = ans * 2 + n % 2n /= 2 但是要额外处理的问题还是高位的0 比如：00110 计算得到的是 011，而实际应该得到的是01100 所以，要计算指定次数 -&gt; 32次，而不是ans为0结束 另外，上面的四则元算可以用位运算代替 1234ans = (ans &lt;&lt; 1) | (n &amp; 1)n &gt;&gt;= 1# n&amp;1 == 1, 说明n的最后一位是1, n&amp;1 == 0, 说明n的最后一位是0 123456def reverseBits(self, n: int) -&gt; int: ans = 0 for i in range(32): ans = (ans &lt;&lt; 1) | (n &amp; 1) n &gt;&gt;= 1 return ans","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之多数元素","slug":"Leetcode之多数元素","date":"2020-02-15T08:48:18.000Z","updated":"2020-07-06T05:11:20.404Z","comments":true,"path":"passages/leetcode-zhi-duo-shu-yuan-su/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-duo-shu-yuan-su/","excerpt":"Majority Element","text":"Majority Element Majority Element code with Python title number：169 简单 读题 给定一个大小为n的数组，找到其中多数的元素 多数元素：在数组中出现的次数大于n/2 给定的数组中肯定存在多数元素 关键字：位运算、数组、分治算法 思路一 使用字典结构 如果元素不在字典中，将元素加入字典，并设置value为1 如果元素在字典中，value计数加一 123456789101112def majorityElement(self, nums: List[int]) -&gt; int: count = dict() for x in nums: if x in count.keys(): count[x] += 1 else: count[x] = 1 for key in count.keys(): if count[key] &gt; len(nums)/2: return key 时间复杂度高的感人，不过还是AC了 思路一优化 使用哈希表代替字典结构，这样可以减少空间复杂度，也能减小时间复杂度 123def majorityElement(self, nums: List[int]) -&gt; int: count = collections.Counter(nums) return max(count.keys(), key=count.get) 空间复杂度有所下降，时间复杂度没有明显改善 思路二 将数组中元素排序，排序之后的数组中，多数元素的出现位置有规律 如果多数元素是数组中的最小值，那么数组中第（n为偶数时，n/2+1；n为奇数时n/2）个元素必为多数元素 如果多数元素是数组中的最大值，同理 如果多数元素既不是最小值也不是最大值，那么有序数组的中间元素必为多数元素 123def majorityElement(self, nums: List[int]) -&gt; int: nums.sort() return nums[len(nums)//2] 思路三 随机数（类似抽奖） 因为多数元素在数组中占据的位置大于50%，所以我们可以每次取一个数 遍历一遍数组，判断取出的数是否为多数元素 这种做法可能会永远取不到多数元素（无穷），但是也有可能一次成功（线性时间） 12345678910def majorityElement(self, nums: List[int]) -&gt; int: majority_num = len(nums) // 2 while True: rand = random.choice(nums) count = 0 for x in nums: if x == rand: count += 1 if count &gt; majority_num: return rand 可以AC 思路四 投票算法 遍历nums，初始情况下将第一个元素作为候选的多数元素， 在遍历的过程中，遇到候选的多数元素，则计数器加一，否则减一 当计数器为0时，则遗忘掉之前的元素，使用下一个元素作为新的候选多数元素，继续遍历 这种算法直觉上不好判断它的正确性，我们来分析一下 举个例子：[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7] 在上述例子中，竖线位置处计数器会归零，也就是说，在竖线之前我们忽略掉了同样多数目的多数元素和非多数元素，在剩下的数组元素中，原来的多数元素仍是现在的多数元素，可以放心求解 总会有一组后缀会使计数器大于0，此时的候选多数元素即为所求 1234567891011def majorityElement(self, nums: List[int]) -&gt; int: count = 0 candidate = None for num in nums: if count == 0: candidate = num if num == candidate: count+=1 else: count-=1 return candidate 思路五 想法与思路四类似，不过借用了栈来辅助，更加直观一些 遍历数组，将元素入栈 如果后来的元素与栈顶元素相同，则出栈栈顶元素，否则入栈 栈顶元素即为多数元素，最终返回栈顶元素 123456789def majorityElement(self, nums: List[int]) -&gt; int: stack = [] for num in nums: if len(stack)==0 or stack[len(stack)-1] == num: stack.append(num) else: stack.remove(stack[len(stack)-1]) return stack[len(stack)-1] 时间复杂度感人，但是可以AC 用来帮助理解投票算法","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之阶乘后的0","slug":"Leetcode之阶乘后的0","date":"2020-02-12T05:05:36.000Z","updated":"2020-07-06T05:18:56.240Z","comments":true,"path":"passages/leetcode-zhi-jie-cheng-hou-de-0/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-jie-cheng-hou-de-0/","excerpt":"Factorial Trailing Zeroes","text":"Factorial Trailing Zeroes Factorial Trailing Zeroes code with Python title number：172 简单 读题 给定一个整数n，返回$n!$结果位数中零的个数 例如： 3! = 6，所以返回0 5! = 120，所以返回1 时间复杂度应为$O(logn)$ 关键词：数学 思路一 最直接的想法就是对指定的整数先求阶乘，然后判断阶乘结果尾部0的个数 但是这种方法很容易就溢出，并且这种方法并不满足时间复杂度为O(logn) 思路二 这种题目并没有通用的解法，只能通过对题目的理解寻找解决方案 首先我们知道，结尾处的0与数字10有很强的关联，即每乘一个10，答案的结尾就会出现一个0 所以问题转化成了阶乘中能得出几个10，我们又发现，想要的到10，需要2和5相乘（1*10不行，因为已经出现10了） 所以问题又转化了，转化成寻找阶乘中有多少对2,5 例如： 5! = 120是因为：5! = 5 * 4 * 3 * 2 * 1，其中出现了一对2，5，所以结果的末尾有一个0 再看一个例子：11! = 11 * (5*2) * 9 * (4*2) * 7 * (3*2) * (5*1) * (2*2) * 3 * (2*1) * 1 其中，含2的因子有：(5*2),(4*2),(3*2),(2*2),(1*2) 含5的因子有：(5*2),(5*1) 可以发现，含有2的因子每隔两个出现一次，含有5的因子每隔5个出现一次。因此，2的个数一定是远多余5的 所以问题转化为，阶乘中有多少5 因为每隔5个数出现一个5，所以5的个数使用n/5就可以得到 另外，每个25个数出现的是两个5，每隔125个数，出现的是三个5 综上，5的个数可以通过n/5+n/25+n/125...计算得到 123456def trailingZeroes(self, n: int) -&gt; int: count = 0 while n &gt; 0: count += n//5 n = n // 5 return count 通过修改循环中计算的顺序，每次循环能减少一次计算，时间也大大减少了 123456def trailingZeroes(self, n: int) -&gt; int: count = 0 while n &gt; 0: n = n // 5 count += n return count 代码没有多少，主要考察的是分析问题和问题转化的能力，非常有趣的题目~","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之两数之和Ⅱ","slug":"Leetcode之两数之和Ⅱ","date":"2020-02-12T05:04:08.000Z","updated":"2020-07-06T05:21:40.725Z","comments":true,"path":"passages/leetcode-zhi-liang-shu-zhi-he-ii/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-liang-shu-zhi-he-ii/","excerpt":"Two Sum Ⅱ - Input array is sorted","text":"Two Sum Ⅱ - Input array is sorted Two Sum Ⅱ - Input array is sorted code with Python title number：167 简单 读题 给定一个升序排列的数组，找到两个数，使两者的加和等于目标数 要求返回两个数的下标，第一个数的下标要小于第二个数 说明： 每个输入答案唯一 关键字：数组、双指针、二分查找 思路一 最先想到的当然是暴力破解 双循环，每个元素分别与其他元素相加，判断是否得到目标数 要注意，两个下标不能相等，这个要在求和时判断 12345def twoSum(self, numbers: List[int], target: int) -&gt; List[int]: for i in range(len(numbers)): for j in range(i, len(numbers)): if numbers[i] + numbers[j] == target and i != j: return [i+1, j+1] 可能会超出时间限制 思路一优化 令temp=target-numbers[i]，使用二分查找在其余的元素中查找值与temp相等的数 找到之后，返回下标 123456789101112def twoSum(self, numbers: List[int], target: int) -&gt; List[int]: for i in range(len(numbers)): temp = target - numbers[i] left, right = i+1, len(numbers)-1 while left &lt;= right: mid = int((left+right)/2) if numbers[mid]==temp: return [i+1, mid+1] elif numbers[mid] &lt; temp: left = mid+1 else: right = mid-1 思路二 比较直观的思路，双指针 left指向左端点，right指向右端点 计算两个指针指向的元素的和，判断其与目标数的大小 大于目标数，则right左移 小于目标数，则left右移 12345678910def twoSum(self, numbers: List[int], target: int) -&gt; List[int]: left, right = 0, len(numbers)-1 while left &lt; right: if numbers[left] + numbers[right] &lt; target: left += 1 elif numbers[left] + numbers[right] &gt; target: right -= 1 else: return [left+1, right+1] 代码优化 1234567891011def twoSum(self, numbers: List[int], target: int) -&gt; List[int]: left, right = 0, len(numbers)-1 while left &lt; right: if numbers[left] + numbers[right] == target: return [left+1, right+1] elif numbers[left] + numbers[right] &lt; target: left += 1 else: right -= 1 return []","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之最小栈","slug":"Leetcode之最小栈","date":"2020-02-12T05:03:00.000Z","updated":"2020-07-06T05:34:33.597Z","comments":true,"path":"passages/leetcode-zhi-zui-xiao-zhan/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zui-xiao-zhan/","excerpt":"Min Stack","text":"Min Stack Min Stack code with Python title number：155 简单 读题 设计一个支持push、pop、top的栈，能在常数时间内找到栈中的最小元素 push()：将元素入栈 pop()：删除栈顶元素 top()：获取栈顶元素 getMin()：检索最小元素 关键词：栈、设计 思路一 常规思路，就是在普通栈的基础上，每次入栈的时候更新最小值 但是当最小值被出栈之后，由于最小值没有被更新，所以会出现问题 出栈的时候判断一下最小值有没有被出栈，如果被出栈了，需要遍历栈找到新的最小值 12345678910111213141516171819202122232425262728class MinStack: def __init__(self): self.min = float('inf') self.stack = [] def push(self, s: int) -&gt; None: self.stack.append(s) if s &lt; self.min: self.min = s def pop(self) -&gt;None: if not self.stack: return None temp = self.stack.pop() if temp == self.min: self.min = float('inf') for x in self.stack: if x &lt; self.min: self.min = x def top(self) -&gt; int: if not self.stack: return None temp = self.stack[-1] return temp def getMin(self) -&gt; int: return self.min 思路二 栈内存储的不是实际值，而是真实值与当前最小值之间的差值，并且在push和pop操作时更新最小值 仅当top操作取数据的时候，需要对数据进行还原（栈顶元素+上一个最小值） 关键问题是在还原数据时如何求得上一个最小值 如果栈顶元素小于0，说明栈顶元素是当前的最小值（栈顶元素当前值-上一个最小值，而上一个最小值只会比当前的最小值小），将其出栈会改变栈中的最小值，上一个最小值通过min - 栈顶元素 如果栈顶元素大于0，则出栈栈顶元素对最小值没有影响 1234567891011121314151617181920212223242526272829class MinStack: def __init__(self): self.min = float('inf') self.stack = [] def push(self, x: int) -&gt; None: self.stack.append(x-self.min) if s &lt; self.min: self.min = s def pop(self) -&gt;None: if not self.stack: return None temp = self.stack.pop() if temp &lt; 0: self.min -= temp def top(self) -&gt; int: if not self.stack: return None temp = self.stack[-1] if temp &lt; 0: return self.min else: return self.min + temp return temp def getMin(self) -&gt; int: return self.min","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之只出现一次的数字","slug":"Leetcode之只出现一次的数字","date":"2020-02-12T05:01:34.000Z","updated":"2020-07-06T05:31:35.861Z","comments":true,"path":"passages/leetcode-zhi-zhi-chu-xian-yi-ci-de-shu-zi/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zhi-chu-xian-yi-ci-de-shu-zi/","excerpt":"Single Number","text":"Single Number Single Number code with Python title number：136 简单 读题 给定一个非空数组，数组中只有一个元素出现的次数为1次，其余的元素出现的次数均为两次，找出只出现一次的元素 关键词：位运算，哈希表 不能使用额外空间，并且要将时间复杂度控制在线性时间 思路一 常规思路，时间复杂度取决于排序算法 对数组进行排序，排序后相同的元素都挨在一起 再对数组进行一次遍历即可找到唯一出现一次的元素 12345678def singleNumber(self, nums: List[int]) -&gt; int: nums.sort() for i in range(len(nums), 0, -1): if i-1 != 0 and i-1 &lt; len(nums): if nums[i-1]==nums[i-2]: del nums[i-1] del nums[i-2] return nums[0] 思路二 常规思路，时间复杂度$O(n^2)$ 使用字典结构，每遇到一个字典中未出现过的字，加入字典并计数 遍历字典中的key，取value为1的key 1234567891011def singleNumber(self, nums: List[int]) -&gt; int: dic = dict() for num in nums: if str(num) in dic.keys(): dic[str(num)] += 1 else: dic[str(num)] = 1 for key in dic.keys(): if dic[key] == 1: return key 思路三 常规思路，使用额外的空间 列表no_dup用于存储不重复的元素 遍历nums，如果不在no_dup中，则添加 若在no_dup中出现过，则删除 12345678def singleNumber(self, nums: List[int]) -&gt; int: no_dup = [] for num in nums: if num not in no_dup: no_dup.append(num) else: no_dup.remove(num) return no_dup[0] 思路四 比较难考虑的一种，利用二进制异或的性质： 任何数和本身异或则为0 任何数和0异或为其本身 满足结合律，即$a \\bigoplus a \\bigoplus b = a \\bigoplus b \\bigoplus a = b$ 初始设置single_number=0 遍历整个数组，与single_number依次做异或操作 123456def singleNumber(self, nums: List[int]) -&gt; int: single_number = 0 for num in nums: single_number ^= num return single_number 思路五 数学：$2*(a+b+c)-(a+a+b+b+c)=c$ 利用该公式即可得到唯一出现一次的元素的值（前提是只有一个元素出现一次，其余元素均出现两次） 123def singleNumber(self, nums: List[int]) -&gt; int: single_number = 2*sum(set(nums)) - sum(nums) return single_number","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之回文串Ⅱ","slug":"Leetcode之回文串Ⅱ","date":"2020-02-12T04:59:37.000Z","updated":"2020-07-06T05:17:05.869Z","comments":true,"path":"passages/leetcode-zhi-hui-wen-chuan-ii/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-hui-wen-chuan-ii/","excerpt":"Valid Palindrome Ⅱ","text":"Valid Palindrome Ⅱ Valid Palindrome Ⅱ code with Python title number：680 简单 读题 给定一个字符串，至多删除一个字符，判断能否变成回文串 字符串只包含a-z的小写字母 关键字：字符串 思路一 因为字符串只包含小写字母，无需对字符串进行处理 暴力破解 先判断未删除时是否是回文串 穷举所有的删除可能，然后判断字符串是否回文 思路二 使用双指针分别指向字符串的头部和尾部，遍历，判断指针指向的元素是否相同 若相同，则移动指针 若不同，则分别尝试删除两个指针指向的元素，再继续判断是否是回文串 1234567891011121314151617def validPalindrome(self, s: str) -&gt; bool: if s == s[::-1] return True left, right = 0, len(s)-1 while left &lt; right: if s[left] != s[right]: a = s[:left] + s[left+1:] if a == a[::-1]: return True b = s[:right] + s[right+:] if b == b[::-1]: return True return False else: left += 1 right -=1 return False","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之回文串","slug":"Leetcode之回文串","date":"2020-02-12T04:57:23.000Z","updated":"2020-07-06T05:16:56.550Z","comments":true,"path":"passages/leetcode-zhi-hui-wen-chuan/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-hui-wen-chuan/","excerpt":"Valid Palindrome","text":"Valid Palindrome Valid Palindrome code with Python title number：125 简单 读题 给定一个字符串，判断其是否是回文串 不考虑大小写 从示例来看，不考虑空格和标点 关键字：双指针，字符串 思路一 很容易想到的是双指针（头尾指针） 头指针指向第一个元素，尾指针指向最后一个元素 先判断指针指向的元素是否是数字or字母，不是则跳过 如果两个指针指向的元素不同，返回false 如果两个指针指向的元素相同，则移动指针（头指针向后，尾指针向前） 直到两个指针相遇 123456789101112131415def isPalindrome(self, s: str) -&gt; bool: left, right = 0, len(s)-1 while left &lt; right: if not s[left].isalnum(): left += 1 continue if not s[right].isalnum(): right -= 1 continue if s[left].lower() == s[right].lower(): left += 1 right -= 1 else: return False return True 注意：isalnum()，字符串自带函数，用于判断字符串是否只由数字和字母组成 思路二 还是双指针，只是对字符串进行了预处理，将非数字和字母的元素删除 可以使用额外的空间来存储顺序字母和数字 可以在原字符串上操作，需要从后向前操作，放置数组访问出错 主体操作还是头尾两个指针 12345678910111213def isPalindrome(self, s: str) -&gt; bool: s_temp = [] for i in range(len(s)): if not s[i].isalnum(): s_temp.append(s[i].lower()) left, right = 0, len(s)-1 while left &lt; right: if s[left] == s[right]: left += 1 right -= 1 else: return False return True 空间复杂度比较高，毕竟申请了额外的空间 123456789101112def isPalindrome(self, s: str) -&gt; bool: for i in range(len(s), 0, -1): if not s[i-1].isalnum(): s = s[:i-1] + s[i:] left, right = 0, len(s)-1 while left &lt; right: if s[left].lower() == s[right].lower(): left += 1 right -= 1 else: return False return True 时间复杂度感人，仅击败了5%","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之买股票的最佳时机Ⅱ","slug":"Leetcode之买股票的最佳时机Ⅱ","date":"2020-02-12T04:55:23.000Z","updated":"2020-07-06T05:22:57.568Z","comments":true,"path":"passages/leetcode-zhi-mai-gu-piao-de-zui-jia-shi-ji-ii/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-mai-gu-piao-de-zui-jia-shi-ji-ii/","excerpt":"Best Time to Buy and Sell Stock Ⅱ","text":"Best Time to Buy and Sell Stock Ⅱ Best Time to Buy and Sell Stock Ⅱ code with Python title number：122 简单 读题 给定一个数组，一只股票，第i个元素表示给定股票第i天的价格 可以尽可能多的进行交易，求能获得的最大利润 售出必须在买进之后进行，再次买进时需要先售出持有的股票 思路一 贪心算法，分步操作，每步只选赚钱的 由题意知，因为在买股票前需要把手中的股票先卖出，所以有两种情况 连续上涨交易日：有一段时间股票价格连续上涨，则这段时间的第一天买入，最后一天卖出利润最大 连续下降交易日：有一段时间股票价格连续下降，则不买卖股票最佳，不会亏钱 这样比较不容易理解，可以把一段时间的股票持有等价为在这段时间里每天都买卖， 例：p1,p2,p3,p4,p55天连续上涨，应该第一天买，最后一天卖，即p5-p1；按照上面的理解，也可以表示为p5-p1 = (p2-p1)+(p3-p2)+(p4-p3)+(p5-p4) 算法： 遍历整个价格列表，所有上涨交易都日买卖，所有下降交易日都不买卖 由于我们将所有交易都拆分为了连续两天的交易， 所以，遍历整个列表，计算第i-1日买入且第i日卖出的利润，若利润大于0，则添加到总利润中，若利润小于等于0则不进行买卖 12345678def maxProfit(self, prices: List[int]) -&gt; int: profit_sum = 0 for i in range(1, len(prices)): profit = prices[i] - prices[i-1] if profit &gt; 0: profit_sum += profit return profit_sum 注意：这种算法里的计算方式并不是实际操作，而是将连续时间的股票持有转化为了每天都进行买卖 思路二 仍是我们熟悉的暴力破解，由于数组长度有限，必定可以穷举所有的交易组合，计算相应的利润，取最大值即可 但是时间复杂度太高，有$O(n^n)$ 思路三 动态规划，一般来说，可以用贪心算法解决的，都可以使用动态规划进行解决 定义状态，设置一个二维矩阵dp[i][j]： 第一维i表示第i天，第二维j用来表示是否持有股票（0表示未持有，1表示持有） value为当前的收益 状态转移方程 0-&gt;1-&gt;0-&gt;1-&gt;0…. 初始状态 dp[0][0]=0 dp[0][1]=-prices[0] 输出 dp[len-1][0]为最终结果 123456789101112def maxProfit(self, prices: List[int]) -&gt; int: if len(prices) &lt; 2: return 0 dp = [[0]*2 for i in range(len(prices))] dp[0][0] = 0 dp[0][1] = -prices[0] for i in range(len(prices)): dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices) dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices) return dp[len(prices)-1][0] 耗时感人，仅击败5%~~","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之二叉树的最大深度","slug":"Leetcode之二叉树的最大深度","date":"2020-02-06T05:25:32.000Z","updated":"2020-07-06T05:12:23.212Z","comments":true,"path":"passages/leetcode-zhi-er-cha-shu-de-zui-da-shen-du/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-er-cha-shu-de-zui-da-shen-du/","excerpt":"Maximum Depth of Binary Tree","text":"Maximum Depth of Binary Tree Maximum Depth of Binary Tree code with Python title number：104 简单 读题给定一个二叉树，求其最大深度 最大深度指的是从根节点到最深的叶节点的路径上的结点个数 看一下给定的示例： [3, 9, 20, null, null, 15, 7] ​ 3​ / 9 20​ / ​ 15 7 可以观察到，二叉树是通过层次遍历的顺序来表示的 不过这都不重要，我们在程序中获得的是一棵树 12345class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None 关键词：二叉树、深度优先搜索 思路一 深度优先遍历（DFS），使用递归的方式对二叉树的高度进行求解 如果根节点为空，则树空，高度为0 如果不为空则递归求解其左右子树的高度，并且取其中较大的，再加一 直到到达叶子节点位置 12345678def maxDepth(self, root: TreeNode) -&gt; int: if root is None: return 0 else: left_height = self.maxDepth(root.left) right_height = self.maxDepth(root.right) return max(left_height, right_height) + 1 思路二 还是深度优先遍历（DFS），不过这次我们使用非递归的方式实现。需要借助栈来进行 设置变量depth用于记录树的深度 先将根节点入栈 当栈不为空时，迭代 出栈栈顶元素，更新最大深度（当前结点的深度和最大深度的较大值） 根节点不为空则将根节点的左右结点入栈 123456789101112131415def maxDepth(self, root: TreeNode) -&gt; int: stack = [] depth = 0 if root is not None: stack.append((1, root)) while stack is not None: cur_depth, root = stack.pop() if root is not None: depth = max(cur_depth, depth) stack.append((cur_depth+1, root.left)) stack.append((cur_depth+1, root.right)) return depth 思路三 既然是求最大深度，我们只需要按层遍历，并且记录树的层数，即可得到树的最大深度 层序遍历 or 广度优先遍历 在队列中使用None来划分每一层，当出队时遇到None则深度+1 123456789101112131415161718def maxDepth(self, root: TreeNode) -&gt; int: queue = [] depth = 1 if root is None: return 0 queue.append(root) queue.append(None) while queue: node = queue.pop(0) if node: if node.left: queue.append(node.left) if node.right: queue.append(node.right) elif queue: queue.append(None) depth+=1 return depth List.pop(num)可以弹出指定位置的元素 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之买股票的最佳时机","slug":"Leetcode之买股票的最佳时机","date":"2020-02-06T05:21:10.000Z","updated":"2020-07-06T05:22:49.742Z","comments":true,"path":"passages/leetcode-zhi-mai-gu-piao-de-zui-jia-shi-ji/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-mai-gu-piao-de-zui-jia-shi-ji/","excerpt":"Best Time to Buy and Sell Stock","text":"Best Time to Buy and Sell Stock Best Time to Buy and Sell Stock code with Python title number：121 简单 读题 给定一个数组，一只股票 数组的第i位表示该股票第i天的价格 你只能进行一次买卖，计算最大利润（卖出时间不能早于买入时间） 相关标签：数组，动态规划 思路一 该问题抽象一下，就是求数组中两个数的最大差值（max(price[j]-price[i])，i&lt;=j） 首先想到的当然是暴力法啦 两层循环，外层循环遍历表示买入价格，内层循环遍历表示卖出价格 12345678910def maxProfit(self, prices: List[int]) -&gt; int: if len(prices) &lt; 2: return 0 res = 0 for i in range(len(prices)-1): for j in range(i+1, len(prices)): res = max(res, prices[j]-prices[i]) return res 很遗憾，超时 思路一改进 针对给定的示例[7,1,5,3,6,4]进行观察，我们发现有很多次的计算是无用的，为了更直观 即我们只需要关注之前观察到的最低股价即可，用一个变量记录便利过程中的最低股价，就可以省去内层的循环 1234567891011def maxProfit(self, prices: List[int]) -&gt; int: if len(prices) &lt; 2: return 0 res = 0 min_p = prices[0] for i in range(len(prices)): res = max(res, prices[i]-min_p) min_p = min(min_p, prices[i]) return res 思路二 类似于之前那道Maximum Subarray，这也是一道动态规划的题目 整体思想是: 正向，求得截至当前能买入的最低价 反向，求得当前买入的能卖出的最高价， 然后两者做差即可 以示例做演示：[7,1,5,3,6,4]，则 正向：[7,1,1,1,1,1]，逆向：[7,6,6,6,6,4] 做差并取最大值：5 1234567891011def maxProfit(self, prices: List[int]) -&gt; int: if len(prices) &lt; 2: return 0 max_profit = 0 in_price = prices[0] for i in range(len(prices)): if prices[i] &lt; in_price: in_price = prices[i] elif prices[i] - in_price &gt; max_profit: max_profit = prices[i] - in_price return max_profit 还是思路二 按照动态规划来一遍 定义状态：max_profit是前i天的最大收益 状态转移方程：（分情况讨论） 在第i天售出能不获得最大收益 在第i天售出能获得最大收益，并且是在第i天之前买入的 即前i天的最大收益 = max(前i-1天的最大收益，第i天的价格-前i-1天的最小价格) 初始条件：min_price=prices[0], max_profit=0 list长度为0和1时单独处理 顺手优化了一下代码 12345678910def maxProfit(self, prices: List[int]) -&gt; int: if len(prices) &lt; 2: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: min_price = min(price, min_price) max_profit = max(max_profit, price-min_price) return max_profit 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之合并两个有序数组","slug":"Leetcode之合并两个有序数组","date":"2020-02-06T05:20:48.000Z","updated":"2020-07-06T05:16:23.687Z","comments":true,"path":"passages/leetcode-zhi-he-bing-liang-ge-you-xu-shu-zu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-he-bing-liang-ge-you-xu-shu-zu/","excerpt":"Merge Sorted Array","text":"Merge Sorted Array Merge Sorted Array code with Python title number：88 简单 读题给定两个有序的数组nums1和nums2，将nums2合并到nums1中形成有序数组 nums1中有足够的位置用来存放nums2的元素，不能额外申请存储空间 关键词：数组，双指针 思路一 最直接的想法就是借鉴传统的Merge sort算法： 使用两个指针分别指向两个有序数组的头部，从前往后比较指针指向的元素的大小，将较小的元素放入申请的空间中，并且对应的指针后移 不过这样需要额外申请大小为m+n的空间，由于题目中说明了nums1的空间足够存储两个数组的所有元素，所以可以使用num1的空间来存储合并后的数组，申请大小为m的数组用来存储nums1即可 12345678910111213141516def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None: p, q, f = 0, 0, 0 nums1_temp = nums1[:m] while p &lt; m and q &lt; n: if nums1_temp[p] &lt; nums2[q]: nums1[f] = nums1_temp[p] p += 1 else: nums1[f] = nums2[q] q += 1 f += 1 if p &lt; m: nums1[p+q:] = nums1_temp[p:] if q &lt; n: nums1[p+q:] = nums2[q:] 奇怪，用时比下面的两种还少，内存消耗也没有明显增加…… 思路一改进 如果按照传统的合并算法，至少需要申请大小为m的空间。 我们还知道，num1中本身就有足够的空间来容纳nums2中的元素，而这些位置几种在数组的尾部 所以，由此我们想到，使用双指针从后往前遍历并比较，这样就可以利用num1后面的空闲位置了 需要三个指针，其中两个指针分别指向nums1和nums2中的最后一个元素，另外再有一个指针指向nums1中新添加元素的位置 123456789101112def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None: p, q = m-1, n-1 t = m+n-1 while p&gt;=0 and q&gt;=0: if nums1[p] &lt; nums2[q]: nums1[t] = nums2[q] q -= 1 else: nums1[t] = nums1[p] p -= 1 t -= 1 nums1[:q+1] = nums2[:q+1] 其实指针p、q、t完全可以省略，直接使用m,n,m+n-1代替，简化版如下 123456789def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None: while m&gt;0 and n&gt;0: if nums1[m-1] &lt; nums2[n-1]: nums1[m+n-1] = nums2[n-1] n -= 1 else: nums1[m+n-1] = nums1[m-1] m -= 1 nums1[:n] = nums2[:n] 思路二 其实还有一个更简洁的想法 直接将nums2添加到nums1的尾部，在对nums1进行排序即可 12345def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None: for i in range(len(nums2)): nums1[m+i] = nums2[i] nums1.sort() 但事后想来，这与题目的考查点不符（相关标签中提到了双指针），就当作是一种比较有意思的想法吧，以前掌握两种想法为主 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之最大子序和","slug":"Leetcode之最大子序和","date":"2020-02-06T05:17:45.000Z","updated":"2020-07-06T05:33:27.634Z","comments":true,"path":"passages/leetcode-zhi-zui-da-zi-xu-he/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zui-da-zi-xu-he/","excerpt":"Maximum Subarray","text":"Maximum Subarray Maximum Subarray code with Python title number：53 简单 读题给定一个整数数组，找到一个连续的子串，这个子串的和最大，返回子串的和 例：-2,1,-3,4,-1,2,1,-5,4中能取得最大和的子串为4,-1,2,1，则返回6 思路一 要求返回的是连续最大子序列和，最先想到的就是暴力求解 使用两层循环，外层循环控制子串头部的位置，内层循环控制子串尾部的位置 利用双层循环，穷举求和所有子串的和，返回最大值 该方法超时 1234567891011def maxSubArray(self, nums: List[int]) -&gt; int: max = nums[0] sub_sum = 0 for i in range(len(nums)): for j in range(i, len(nums)): for k in range(i,j+1): sub_sum += nums[k] if sub_sum &gt; max: max = sub_sum sub_sum = 0 return max 思路一优化 简单分析一下，时间复杂度高的原因主要是 ​ 对数组进行了多次的遍历 ​ 进行了多次的重复计算 重复计算的问题，例如：计算[0, 3]的和时就又计算了[0, 0], [0, 1], [0, 2]的和 所以可以在[0, 2]的基础上计算[0, 3]的和 优化方案为： ​ 穷举子序列左端点，遍历其右端点，用sum记录当前和，用max记录最大子序列值 ​ 可以减少一层循环 12345678def maxSubArray(self, nums: List[int]) -&gt; int: max_num = nums[0] for i in range(len(nums)): sum = 0 for j in range(i, len(nums)): sum += nums[j] max_num = max(max_num, sum) return max_num 思路一再优化 可以使用空间换时间的思想，使用数组pre_nums存储截止到i的子序列和 计算[1, 3]的子序列和可以通过pre_nums[3]-pre_nums[1]来得出 这样可以更大程度上减少运算 事实上，我们可以使用原数组表示存储pre_nums，这样连空间都省了 思路二尝试使用动态规划的思想，重点在于寻找状态转移方程 定义状态：dp[i]：表示以nums[i]结尾的连续最大子序列和 状态转移方程：（分情况讨论） 如果dp[i-1]&gt;=0，那么dp[i]=dp[i-1]+nums[i] 如果dp[i-1]&lt;0，那么dp[i]=nums[i] 综合一下两种情况我们可以得到：dp[i]=max(nums[i], dp[i-1]+nums[i]) 初始值：dp[0]=nums[0] 输出：值得注意的是，要遍历所有的dp[i]，取其中最大的返回 12345678910def maxSubArray(self, nums: List[int]) -&gt; int: if len(nums) == 1: return nums[0] # dp = [0 for i in range(len(nums))] dp = nums[:] # 减少了申请数组时的耗时 # dp[0] = nums[0] for i in range(1, len(nums)): dp[i] = max(dp[i-1]+nums[i], nums[i]) return max(dp) 换了种写法，时间减少了近一半，懵逼中…… 12345678910def maxSubArray(self, nums: List[int]) -&gt; int: size = len(nums) result = sum = nums[0] for i in range(1, size): if sum &lt; 0: sum = 0 sum += nums[i] if sum &gt; result: result = sum return result 动态规划问题经常需要分类讨论，因为动态规划问题本身就是通过小问题的最优解来得到大问题的最优解。因此，需要分类讨论大问题的小问题有哪些 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之删除排序数组中的重复项","slug":"Leetcode之删除排序数组中的重复项","date":"2020-02-06T05:17:19.000Z","updated":"2020-07-06T05:25:52.680Z","comments":true,"path":"passages/leetcode-zhi-shan-chu-pai-xu-shu-zu-zhong-de-chong-fu-xiang/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-shan-chu-pai-xu-shu-zu-zhong-de-chong-fu-xiang/","excerpt":"Remove Duplication from Sorted Array","text":"Remove Duplication from Sorted Array Remove Duplication from Sorted Array code with Python title number：26 简单 读题给排序后的数组，删除重复元素，返回修改后数组的长度 关键点：原地操作，不能占用额外的内存空间 标签：双指针和数组 思路一：既然是排序后的数组，说明相同的元素都连续存在 返回新的数组长度，将不重复的元素聚集在数组的前部， 如此便可以不用删除元素，而是将不重复的元素聚集的数组前部，并且不用考虑返回值范围之外的元素是什么。计数不重复元素的个数，返回不重复元素的个数。 设置两个指针，前者用于指向不重复的元素，后者用于遍历数组 初始状态，指针P指向第一个元素，指针Q指向第二个元素， 判断两个指针所指向的元素是否相同， 若相同，则Q向后遍历 若不同，则P先向后移动，再将Q指向位置的元素赋值给P指向位置的元素 最后返回P指向位置的下标（需要+1，数组下标从0开始） 另外，数组长度小于2时直接返回数组长度即可 例： 1,1,2,2,3,4,4 -&gt; 1,2,3,4,3,4,4，返回长度为4 12345678910def removeDuplicates(self, nums: List[int]) -&gt; int: if len(nums)==0: return 0 p = 0 for q in range(1, len(nums)): if nums[p] != nums[q]: p += 1 nums[p] = nums[q] return p+1 思路二： 我们尝试正常的删除元素 但是使用从前向后遍历删除元素，会导致数组访问越界（遍历数组的时候，遍历的次数并不会减少，数组元素减少了，回到之后面的访问越界） 所以可以从后往前遍历，先访问下标大的元素， 初始状态，P指向最后一个元素，Q指向倒数第二个元素 若P指向位置的元素等于Q指向位置的元素，删除Q指向位置的元素，P、Q均向前移动1 若P指向位置的元素不等于Q指向位置的元素，P、Q均向前移动1 最后返回数组长度 另外， 数组长度小于2时直接返回数组长度 与第一种思路不同，相比的两个元素是相邻的，可以只用一个指针，要控制边界 例： 1,1,2,3,3,4-&gt;1,1,2,3,3,4-&gt;1,1,2,3,4-&gt;1,1,2,3,4-&gt;1,2,3,4，返回数组长度4 1234567891011# range(end, start, -1)即可输出倒序的数组，注意是前闭后开# del函数删除数组元素def removeDuplicates(self, nums: List[int]) -&gt; int: if len(nums)&lt;2: return len(nums) for q in range(len(nums), 0, -1): if q-1 != 0: if nums[q-1]==nums[q-2]: del nums[q-1] return len(nums) 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"霍乱时期的爱情","slug":"霍乱时期的爱情","date":"2020-02-05T10:04:45.000Z","updated":"2020-07-06T05:44:15.771Z","comments":true,"path":"passages/huo-luan-shi-qi-de-ai-qing/","link":"","permalink":"http://zivblog.top/passages/huo-luan-shi-qi-de-ai-qing/","excerpt":"霍乱时期的爱情","text":"霍乱时期的爱情 《霍乱时期的爱情》加西亚-马尔克斯 &emsp;&emsp;精神忠贞和肉体忠贞真的可以分而视之吗？ &emsp;&emsp;这本被视作“爱情的百科全书”的巨作，在我看来讲述的确实一个庸俗甚至荒诞的故事。 &emsp;&emsp;出身单身贫苦家庭的文艺青年阿里萨，爱上了一个未成年少女弗尔明娜，他们在一封封情书中热恋。但弗尔明娜的父亲却一心让她嫁给一个上层社会的人。在他们经历离别之后的再次见面，弗尔明娜发现自己心中完美的他不过是自己幻想出来的，于是毅然挥手离开。 &emsp;&emsp;之后的半生中阿里萨逆袭成为航运公司董事长，在成功熬死弗尔明娜的丈夫后，他竟再次表白：“我为你保持了童真”。尽管他在51年中与无数女人睡过。 &emsp;&emsp;在51年冠冕堂皇的忠诚背后可能只是被抛弃后的不甘；在现实的洪流中弗尔明娜当年的背信弃义又显得稀疏平常。即使最后男女主如愿在一起了，但是这样的结局并无浪漫可言，设置透漏这些许荒诞和嘲讽。毕竟弗尔明娜“很难分清自己是出于同情还是爱情”。 &emsp;&emsp;按照惯例，下面是一些原文摘录，好好体会吧。 一个人能为爱情坚守多久，答案是——五十一年九个月零四天。 这份迟来的顿悟是他下了一跳，原来是生命，而非死亡，才是永无止境的。 你要永远记住，对于一对恩爱夫妻，最重要的不是幸福，而是稳定 这些地方走在众人之前，它们已经有了自己的花冠女神。 好吧，我同意结婚，只要你不逼我吃茄子。 他明白他并不爱弗尔明娜，他只是喜欢它的骄傲，但这并不影响他们建立起一桩稳定的婚姻。 我去旅行，是因为我决定要去，而不是我对路上的风景多感兴趣。 诚实的生活方式其实是按照身体的意愿行事，饿的时候吃饭，爱的时候不必撒谎。 当一个女人说“不”的时候，实在等别人再坚持，然后才做最后的决定 智慧往往在已无用武之地之时才来到我身边。 比其婚姻中的巨大灾难，日常的琐碎烦恼更加难以躲避。 无法说明的病，是爱情，不是相思。 影响到你生命的男女之情，才算是爱情。 她因年龄而减损的，又因性格而弥补回来，因而勤劳赢得了更多。 “世上的人分两种，会勾搭的和不会勾搭的。” 他不信任后面这种人：他们一旦越轨，便觉得这件事太不可思议，于是四处炫耀爱情，就好像那是他们刚刚发明出来的似的。而经常做这种事的人恰恰相反，他们活着就是为了这个。他们感觉良好，也守口如瓶，因为知道谨言慎行是性命攸关的大事。他们从不谈论自己的丰功伟绩，也不向任何人吐露秘密，反而装出一副对这种事漠不关心的样子，以致常常招来性无能、性冷淡，甚至不男不女的名声，就像弗洛伦蒂诺·阿里萨这样。 作为一个仍处在孤独中的灵魂，他坚信自己比世界上任何一个人都默默爱得更深。 女人只会对意志坚强的男人俯首称臣，因为只有这样的男人才能带给她们安全感，他们渴望那种安全感，以面对生活的挑战。 可无论他，还是她，都无法说清这种相互依赖究竟是建立在爱情的基础上，还是习惯使然。他们从不曾为此问过自己，因为两人都宁愿不知道答案。 但她并没有把这些当做他最终衰老的确凿标志，而是视之为一次幸福的返老还童。她把他当做一个老小孩，而非一个难以此后的老人。这种自欺欺人对两人来说或许都是一种上天的恩赐，因为这让他们避免了互相同情。 当被人爱着的人死去时，真该带上他所有的东西。 他还太年轻，尚不知道回忆总是会抹去坏的，夸大好的，而也正是由于这种玄妙，我们才得以承担过去的负担。","categories":[{"name":"读书&电影","slug":"读书-电影","permalink":"http://zivblog.top/categories/%E8%AF%BB%E4%B9%A6-%E7%94%B5%E5%BD%B1/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://zivblog.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"被讨厌的勇气","slug":"被讨厌的勇气","date":"2020-01-04T12:24:52.000Z","updated":"2020-03-05T12:41:00.676Z","comments":true,"path":"passages/bei-tao-yan-de-yong-qi/","link":"","permalink":"http://zivblog.top/passages/bei-tao-yan-de-yong-qi/","excerpt":"世界很单纯，人生也人生也一样。 不是世界复杂， 而是你把世界变复杂了。没有一个人是住在客观的世界里， 我们都居住在一个各自赋予其意义的主观的世界。","text":"世界很单纯，人生也人生也一样。 不是世界复杂， 而是你把世界变复杂了。没有一个人是住在客观的世界里， 我们都居住在一个各自赋予其意义的主观的世界。 《被讨厌的勇气》岸见一郞/古贺史健 &emsp;&emsp;世界很单纯，人生也人生也一样。 不是世界复杂， 而是你把世界变复杂了。没有一个人是住在客观的世界里， 我们都居住在一个各自赋予其意义的主观的世界。 &emsp;&emsp;本书介绍了另一位心理学大师阿德勒的“目的论”理论，读一下下面的摘选吧，相信会有一番全新的认识。 &emsp;&emsp;私以为，这种“目的论”更能使人直视内心，不会像“原因论”最终会因把握不当而成为逃避的借口。 按照惯例，下面是一些句子的摘抄 目的论：过去的事情本身并没有什么特殊的意义，是我们为了某个目的而赋予它了意义，我们希望通过赋予某件事情意义来帮助我们顺理成章地去做某事。 无论过去发生了什么事情，现在的状态取决于你赋予既有事件的意义。 人唯有在感觉自己有价值时才会有勇气。 当你着急奔向未来时，说明你已经不喜欢现在了。 人并不是住在客观的世界，而是住在自己营造的主观世界里。你所看到的世界不同于我所看到的世界，而且恐怕是不可能与任何人共有的世界。 小心检视，你的成功是否知识以害怕别人讨厌而换来的。若是如此，那你的成功不幸只是代表“你为了他人活了一辈子”。 至少我不想变成别人，也能悦纳现在的自己。 你的“不幸”并不是生来就有，而是由你亲手选择。 你在人生的某个阶段选择了不幸。这既不是因为你生在了不幸的环境中，也不是你陷入了不幸的境地中，而是因为你认为不幸对你自身而言是一种“善”。 如果一直保持“现在的我”，那么如何应对眼前的事情以及其结果会怎样等问题都可以根据经验进行推测，可谓是轻车熟路般的状态，即使是遇到点状况也能够想办法对付过去。 另一方面，如果选择新的生活方式，那就既不知道新的自己会遇到什么问题，也不知道应该如何应对眼前的事情。未来难以预测，生活就会充满不安，也可能有更加痛苦更加不幸的生活在等着自己。也就是说，即使人们有各种不满，但还是认为保持现状更加轻松、更能安心。 如果要改变对世界或自己的看法就必须改变与世界的沟通方式，甚至改变自己的行为方式。请不要忘记“必须改变”的究竟是什么。你依然是“你” ，只要重新选择生活方式就可以了。 首先，人是作为一种无力的存在生活在这个世界上。并且，人希望摆脱这种无力状态，继而有了普遍欲求。 与此相对应的就是自卑感。人都处于优越性这一“希望进步的状态”之中，树立某些理想或目标并努力为之奋斗。同时，对于无法达成理想的自己就会产生一种自卑感。 自卑感本身并不是坏事。 自卑情节是指把自己的自卑当作某种借口使用的状态。 如果真的拥有自信，就不会自大。正因为有强烈的自卑感才会骄傲自大，那其实是想要故意炫耀自己很优秀。担心如果不那么做的话，就会得不到周围的认可。 健全的自卑感不是来自与别人的比较，而是来自与“理想的自己”的比较。 当一个人想要做自己的时候，竞争势必会成为障碍。 即便不是败者，即便一直立于不败之地，处于竞争之中的人也会一刻不得安心，不想成为败者。而为了不成为败者就必须一直获胜、不能相信他人。 “无法真心祝福过的幸福的人”，就是因为站在竞争的角度来考虑人际关系，把他人的幸福看作“我的失败”，所以才无法给予祝福。 发怒时交流的一种形态，而且不使用发怒这种方式也可以交流。 人在人际关系中一旦确信“我是正确的”，那就已经步入了权力之争。 束缚，是想要支配对方的表现，也是一种基于不信任感的想法。与一个不信任自己的人处在同一个空间里，那就根本不可能保持一种自然状态。 人不可能一个人或者，必须在社会性的环境中，才能称之为“个人”。 把别人视作”敌人“，还是“伙伴”，这至关重要，并且影响你的“生活方式”。 自由，就是不在寻求别人的认可， 但是，这并不意味着可以旁若无人的肆意横行。 自由，就是允许自己被别人讨厌。 “不幸之源”在人际关系，反过来说，“幸福之源”也在人际关系。 拘泥于“认可欲求”的人，实际上也是以自我为中心的人。 在共同体中收到挫折之后，会不可避免的想要逃避到其他共同体中。 通常来说，人们更倾向于逃避到更小的共同体中，那里更容易找到归属感。 但应该知道的是，外面有更广阔的世界，想到这点，你就会明白，眼前的挫折不过是“杯中风暴”。 当我们在人际关系中遇到困难或者看不到出口的时候，首先应该考虑的是倾听”更大共同体的声音“这一原则。 自卑感是”纵向关系“的一种体现。 上帝，请赐予我平静，去接收我无法改变的；给予我勇气，去改变我能改变的；赐我智慧，分辨这两者的区别。 信赖的时候请尽管信赖，悲伤的时候请尽管悲伤。 为遥远的将来设定一个目标，并认为现在是其准备阶段。一直想着”真正想做的是这样的事情，等时机成熟了就去做“，这是一种拖延人生的生活方式。只要在拖延人生，我们就会无所进展，只能每天过着枯燥乏味的单调生活。","categories":[{"name":"读书&电影","slug":"读书-电影","permalink":"http://zivblog.top/categories/%E8%AF%BB%E4%B9%A6-%E7%94%B5%E5%BD%B1/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://zivblog.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"具有约束和后期编辑的自底向上的篇章分析器","slug":"具有约束和后期编辑的自底向上的篇章分析器","date":"2019-11-28T07:48:28.000Z","updated":"2020-04-15T11:07:20.394Z","comments":true,"path":"passages/ju-you-yue-shu-he-hou-qi-bian-ji-de-zi-di-xiang-shang-de-pian-zhang-fen-xi-qi/","link":"","permalink":"http://zivblog.top/passages/ju-you-yue-shu-he-hou-qi-bian-ji-de-zi-di-xiang-shang-de-pian-zhang-fen-xi-qi/","excerpt":"《A Linear-Time Bottom-Up Discourse Parser with Constraints and Post-Editing》论文笔记","text":"《A Linear-Time Bottom-Up Discourse Parser with Constraints and Post-Editing》论文笔记 写在前面 本文已被ACL 2014收录 作者是Wei Feng和Graeme Hirst 该模型目前还是document level上效果最好的模型，虽然近期发表了许多关于encoder-decoder架构的文章，但是只能在句子级别证明模型的可行性，模型虽然十分新颖，但并不具有很强的说服力 提出问题 文本即的篇章分析仍然是一个挑战 Joty et al 2013提出的模型虽然效果比较不错了，但是由于模型的计算复杂度太高，并不具有很好的实践性 思考 先对sentence level建模，再对document level建模，这种分层次的建模过程从性能方面来说是可行的 利用初步建成的树本身的特征对树的结构进行调整，可以使树形更加合理 主要需要解决的问题是时间复杂度的问题 模型结构 模型的整体结构如上图所示 先将document划分为多个sentence，sentence再被划分为多个EDU 单句子级别的处理 先使用句内建树模型$M_{instra}$，形成句子级别的Discourse Tree 使用$P_{intra}$对其进行Post Editing 多句子级的处理 先使用多句子建树模型$M_{multi}$组合已经建成的句子级别的树，生成文本级别的Discourse Tree 使用$P_{multi}$对文本级别的Discourse Tree进行Post Editing 下面分别对每个局部模型的结构进行分析 Intra-sentential结构模型 使用线性链CRF，CRF能更好的捕获上下文信息 第一层是篇章结构$U_j$构成 第二层是二分类节点，表示两个一层节点之间结合的概率 为了提高模型的性能，在其维特比解码时添加了一些commonsense constraints（常识性约束） 不允许两个相邻之间的1-1 transition（即每个Unit只能与唯一的另外一个Unit相结合） 不允许全0序列（即至少有两个Unit会别merge） Multi-sentential结构模型 与单句的结构模型相似 特别的，我们采用滑动窗口的方式来为特定成分形成局部CRF链 例如（如上图所示）， 如果我们想计算$U_{j-1}$和$U_j$之间结合的概率，我们构建了三个局部链，每个链中包含两个上下文 之后我们会寻找具有最高joint probability的线性链，之后计算其边缘概率 同样，我们对维特比解码阶段加入了常识性约束，这种约束只在结构模型的解码阶段添加 Intra-sentential关系模型 线性链CRF 第一层是所有篇章结构$U_j$ 第二层是多分类节点，是对第一层中成对篇章结构之间的关系概率的计算 不同于structure model，relation model的第二层节点并不共享第一层的节点 Multi-sentential关系模型 结构与单句的关系模型相似 使用了滑动窗口 Post Editing 在Discourse Tree初步建立之后，使用树本身的信息对树的形状再进行调整 事实证明，节点在树中的高度信息是有用的，因为有些relation只会在比较高的层次中才会出现 后期编辑的实质的在添加了树结构的特征之后再进行一次树的构建 为了完成该操作，我们维护了一个列表L 参照上图3——9，初始的时候L中会包含所有的Unit，之后会根据概率将其中的成对Unit合并 参照10——12，若前序步骤提出了修改，使用$P^{struct}$和$P^{rel}$重新构建discourse tree 使用的是人工提取的特征，具体内容见论文 写在后面 总结 提出了线性时间复杂度的model 使用的是自底向上的建树方式，两个线性链CRF级联作为局部分类器 在第一个CRF（结构模型）的Viterbi解码时添加了约束 通过后期编辑的方法利用初次构建的树中的信息对Discourse Tree进行的微调 对relation和structure分别建模 CKY-like Bottom-up Parsing 给定一组篇章单元，用linear-chain CRF模型构建可能的内部节点$S_j$与孩子节点$U_{j-1},U_j$以及相邻的可能节点$S_{i+1}$之间的联系，构建一组状态序列 对这组状态序列进行标注，1代表该内部节点成立，0代表不成立，即用序列标注的方式决定对应孩子节点是否应该合并 例如， $S_2$如果成立，则变为${S_2, U_3,…., U_t}$ $S_2$与$S_3$如果同时成立，则使用我们之前提到过的约束，选取其中的一个进行合并：可以是根据规则（具有更大合并概率）或者是根据随机","categories":[{"name":"自然语言处理","slug":"自然语言处理","permalink":"http://zivblog.top/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"}],"tags":[{"name":"NLP","slug":"NLP","permalink":"http://zivblog.top/tags/NLP/"},{"name":"论文笔记","slug":"论文笔记","permalink":"http://zivblog.top/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"}]},{"title":"分层指针网络分析","slug":"分层指针网络分析","date":"2019-11-27T08:21:08.000Z","updated":"2020-03-04T06:47:32.706Z","comments":true,"path":"passages/fen-ceng-zhi-zhen-wang-luo-fen-xi/","link":"","permalink":"http://zivblog.top/passages/fen-ceng-zhi-zhen-wang-luo-fen-xi/","excerpt":"《Hieraechical Pointer Net Parsing》论文笔记","text":"《Hieraechical Pointer Net Parsing》论文笔记 写在前面 该论文被EMNLP 2019收录 作者是南洋理工大学的Liu Linlin等人 本文的分别在句内依存关系分析和句子级的篇章分析上进行了实验，鉴于本人对Dependency parsing并未进行过多了解，但为了文章的完整性，相关内容仅为论文提及的 提出问题 基于转移的自顶向下的利用Pointer Networks分析效果很好并且时间复杂度是线性的 但因为解码器的线性结构，在建立树形结构的时候并不能产生合理的iductive bias 并且在文本长度变得更长之后，decoder的state会难以捕获前面的信息 思考 对树结构中父节点和同层的兄弟节点之间的关系建模，以获得更合理的decoder state 同时指针网络能够捕获更长距离的依赖 模型结构Hierachical Decoder 相比于标准的Pointer Networks，这里的decoder state会更加合理 $d_t = f(d_{p(t)}, d_{s(t)}, d_{t-1}, h_{p(t)})$，对于每一个decoder state，$d_t$由其父节点的decoder state、直接兄弟的decoder state及前一个decoder state和其父节点的encoder hidden state计算得到 $s_{t,i} = \\sigma(d_t, h_i)$，其中$\\sigma$是attention计算函数，$d_t$是decoder state，$h_i$是input hidden state $\\alpha_t = softmax(S_t)$，计算得到Attention分布 Dependency Parsing 使用类似Ma et al (2018)工作中的encoder 用CNN编码得到每个词的字符级表征 将其与word embedding、POS embedding拼接得到input X 使用三层双向LSTM将X转化为hidden state decoder是一个单层单向LSTM，同时维护了一个stack用于$d_t$的计算 另外定义了门控机制来在分层指针网络基础上抽取更有效的信息（定义了两种形式的gating function） (1) $g_t = sigmod(W_{gt}d_{t-1}+W_{gp}d_{p(t)}+W_{gs}d_{s(t)}+b_g)$ (2) $g_t = sigmod(W_{gp}(d_{t-1} \\odot d_{p(t)})+W_{gs}(d_{t-1} \\odot d_{s(t)}) + b_g)$ 更具体的decoder state的计算方式 $h^{‘}t = tanh(W_dd{t-1}+W_pd_{p(t)}+W_sd_{s(t)})$ $h^{‘’}_t = g_t \\odot h^{‘}_t$ $d_t = LSTM(h^{‘’}t, h{p(t)})$ Pointer attention的计算方式 $s_{t,i} = g_1(d_t)^{T}Wg2(h_i)+Ug1(d_t)+Vg2(h_i)+b$ 同时，在每个步骤为解码器提供有关父节点和当前节点同级节点的高阶信息 依存关系分析部分在此之前并无接触，所以总结可能存在问题 Discourse Parsing 模型的架构使用的是Lin et al (2019) Encoder使用的5层的双向GRU，得到词的序列的representation，最后一个hidden state作为EDU的表征，最后得到输入句子的EDU表征的序列 分层解码器使用的是5层单向GRU，$d_t$的计算方式类似于dependency parsing中的计算方式 计算attention score，用于寻找切分的位置k 查找到切分位置之后，对于新形成的两个span，使用分类器预测两者之间的relation和nuclearity 写在后面 本文的主要工作的提出了分层的指针网络，具体来说是decoder state更合理的计算方式 在模型的结构上并没有进行创新，模型结构使用的是Ma et al 2018和Lin et al 2019之前工作中的结构 更进一步的说，2019年的两篇基于指针网络的论文的可测试level均为sentence level，说服性一般 类似encoder-decoder形式的模型，可解释性一般 Dependency Parsing与Discourse Parsing 相似之处是两者都是要建立树形结构 不同之处 依存关系只能位于word之间；篇章关系位于EDU（Span）之间 依存关系分析对于任意位置的两个word均可以；篇章分析只能分析相邻的两个EDU之间的关系 近年来的情况表明，神经网络模型的性能要好于基于特征的模型（模型比较难选择） Pointer Networks 是一种encoder-decoder模型，可以解决输出size依赖于输入size的问题 使用注意力机制作为input的指针 $s_{t,i} = \\sigma(d_t, h_i)$，其中$\\sigma$是attention计算函数，$d_t$是decoder state，$h_i$是input hidden state $\\alpha_t = softmax(S_t)$，计算得到Attention分布 $argmax(\\alpha_t)$，取attention分布中的最大值，即为指针 在parsing中的应用 自定向下深度优先的方式建立树结构（即寻找划分边界） 找到划分边界之后使用分类器预测新得到的两部分之间的relation &amp; nuclearity","categories":[{"name":"自然语言处理","slug":"自然语言处理","permalink":"http://zivblog.top/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"}],"tags":[{"name":"NLP","slug":"NLP","permalink":"http://zivblog.top/tags/NLP/"},{"name":"论文笔记","slug":"论文笔记","permalink":"http://zivblog.top/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"}]},{"title":"篇章分析的递归深度模型","slug":"篇章分析的递归深度模型","date":"2019-11-26T07:56:32.000Z","updated":"2020-03-04T06:57:58.333Z","comments":true,"path":"passages/pian-zhang-fen-xi-de-di-gui-shen-du-mo-xing/","link":"","permalink":"http://zivblog.top/passages/pian-zhang-fen-xi-de-di-gui-shen-du-mo-xing/","excerpt":"《Recursive Deep Models for Discourse Parsing》论文笔记","text":"《Recursive Deep Models for Discourse Parsing》论文笔记 写在前面 论文被EMNLP 2014收录 作者是北京大学的Jiwei Li等人 提出问题 近期虽然在自动篇章分割和sentence level的篇章分析上有所进展，但是document level的篇章分析仍是一个很困难的任务 近期的许多尝试的性能相比与人类仍相差许多 与句子间的依存关系分析相比，篇章单元间的关系没有如此详细的定义，没有句子级语法类似的篇章级的语法 进行篇章单元之间关系的分析所需要的语法等信息，手动构建的特征并无法有效的体现 近期深度学习架构在NLP任务中显示出了较强的在上下文中捕获单元相关语义和句法方面的优势，目前在篇章分析领域还未得到应用 思考 单词的分布式表示构成了子句的表示，因此可以将分布式子句的表示扩展到单据或多句（篇章）级别，并产生整个文本的层次结构 使用深度神经网络来构建两个分类器，以自底向上的方式构建篇章树 模型结构 使用Recursive Neural Networks来构建两个分类器 二分类器，三层神经网络，判断两个篇章单元是否需要连接 多分类器，三层神经网络，判断两个篇章单元之间连接的关系 Span的分布式向量表示 利用Recursive Neural Networks以自底向上的方式获得span的表示 利用子节点的表示通过一定形式的计算来的到其父节点（span）的表示 总结 在计算span的分布式表示时，没有区分句内span和跨句子的span 使用了自底向上的probability CKY-like算法进行篇章树的构建 没有单独训练用于判别nuclearity关系的多分类器，nuclearity和relation是一起进行预测的（两者进行了绑定） 最早的使用神经网络进行篇章分析工作的论文","categories":[{"name":"自然语言处理","slug":"自然语言处理","permalink":"http://zivblog.top/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"}],"tags":[{"name":"NLP","slug":"NLP","permalink":"http://zivblog.top/tags/NLP/"},{"name":"论文笔记","slug":"论文笔记","permalink":"http://zivblog.top/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"}]},{"title":"基于指针网络的通用文本分割神经模型","slug":"基于指针网络的通用文本分割神经模型","date":"2019-11-26T06:45:04.000Z","updated":"2020-04-15T09:09:54.311Z","comments":true,"path":"passages/ji-yu-zhi-zhen-wang-luo-de-tong-yong-wen-ben-fen-ge-shen-jing-mo-xing/","link":"","permalink":"http://zivblog.top/passages/ji-yu-zhi-zhen-wang-luo-de-tong-yong-wen-ben-fen-ge-shen-jing-mo-xing/","excerpt":"《SEGBOT：A Generic Neural Text Segmentation Model With Pointer Network》论文笔记","text":"《SEGBOT：A Generic Neural Text Segmentation Model With Pointer Network》论文笔记 写在前面 本文已被IJCAI 18收录 作者是南洋理工大学的Jing Li等 提出问题 文本分割可以分为两种 Topic Segmentation（主题划分） EDU Segmentation（EDU分割） 目前并没有适用于两者的的性能良好的分割模型 传统的方法并不能有效避免边界稀疏问题 传统的方法更多的还是依赖于人工特征 传统的方法并不能很好的解决输出size变化的问题 思考 对于输出大小变化的问题，可以使用RNN类似的网络结构解决 现在分布式的文本表征已被证明可以很好的捕获语法、句法等信息，所以在编码上使用像GloVe、ELMo等应该会提升性能 此外，使用双向的网络能很好的利用上下文的信息 对于边界稀疏问题，这里选择使用指针网络来选择分割边界 模型结构 模型分为三个阶段 编码阶段 解码阶段 指针阶段 模型的功能是进行文本分割，换句话说是进行分割边界的判定或查找 首先，对于input，我们使用分布式的表征对其进行编码 对于word（词），我们使用GloVe进行编码 对于句子，使用Arora在2017年使用的方法进行编码 编码阶段， 使用双向GRU来编码输入序列 解码阶段 输出中边界数量是变化的，使用基于RNN的模型 基于单向GRU的隐藏层 指针阶段 decoder的输出是输入序列中分割边界的概率分布 使用指针机制克服了传统的seq2seq模型输出维度固定的问题 写在后面 提出了一个端到端的分割模型（SEGBOT），能同时适用于主题分割和EDU分割 使用双向RNN对输入进行编码，使用RNN+Pointer Network来选择输入序列中的分割边界 不需要使用人工特征和其他先验知识 对于EDU分割的实验中，使用未进行fine-tuning的GloVe效果会更好 原因是微调之后的GloVe相比与微调之前在测试集上的vocabulary cover会更少 对比了几种预训练的word embedding，相比之下，像Google embedding的表现会差很多 原因可能是他们在训练的过程中剔除了停用词、数字和标点","categories":[{"name":"自然语言处理","slug":"自然语言处理","permalink":"http://zivblog.top/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"}],"tags":[{"name":"NLP","slug":"NLP","permalink":"http://zivblog.top/tags/NLP/"},{"name":"论文笔记","slug":"论文笔记","permalink":"http://zivblog.top/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"}]},{"title":"句子级篇章分析的线性时间统一框架","slug":"句子级篇章分析的线性时间统一框架","date":"2019-11-25T07:36:51.000Z","updated":"2020-03-04T06:51:48.673Z","comments":true,"path":"passages/ju-zi-ji-pian-zhang-fen-xi-de-xian-xing-shi-jian-tong-yi-kuang-jia/","link":"","permalink":"http://zivblog.top/passages/ju-zi-ji-pian-zhang-fen-xi-de-xian-xing-shi-jian-tong-yi-kuang-jia/","excerpt":"《A Unified Linear-Time Framework for Sentence-Level Discourse Parsing》论文笔记","text":"《A Unified Linear-Time Framework for Sentence-Level Discourse Parsing》论文笔记 写在前面 文章被ACL 2019收录 作者Xiang Lin等，南洋理工大学 提出问题 很多NLP下游任务可以从文本连贯性分析中受益 RST连贯性分析包含两项子任务 Discourse Segmentation（篇章分割），text ——&gt; EDU Discourse Parsing（篇章分析），EDU ——&gt; Discourse Tree 自动的EDU分割的正确性是篇章分析性能的主要影响因素 句子级的篇章分析是篇章分析的重要的第一步 之前的工作依赖于手工制作的词法、句法特征 神经模型可以以一种端到端的方式学习篇章单元的特征表示，特别是使用了更好的预训练的word embedding之后更进一步提高了模型的通用性 但是现在并没有很多工作使用神经网络来进行篇章分析的工作，所以我们尝试使用 作者的思考 基于指针网络的Discourse Segmentation和Discourse Parsing 使用Top-down的方式进行建树，这样的话可以从全局的角度利用更多的信息 使用预训练的语言模型进行句子的编码 模型 Discourse Segmenter（篇章分割） Segmenter的作用就是在句子中寻找分割边界，之前有两种做法： 二分类 序列标注 最近Pointer Networks在篇章分割上的表现也很好 我们看一下图中的过程： 读取整个句子，先进行编码，得到X 将X转化为对应的隐藏状态 对于每个时刻t，我们将当前正在处理的segment的第一个token作为decoder的输入，并产生一个attention score 基于attention score，我们选择分割边界 值得注意的是，我们的分割器，相比于2018年Li的工作，进行了一定的改进 decoder使用encoder state作为输入，而不是word embedding 使用dot attention而不是add attention 使用ELMo或GloVe或BERT作为embedding，更好的利用上下文信息 Discourse Parser（篇章分析） Parser的主体使用的是Pointer Networks 我们看一下图的左边： 对于给定的sentence，我们先进行ELMo或者GloVe进行编码，得到X X作为input，输入到模型中 指针网络的编码器现将整个句子顺序组成一系列的Hidden state，我们使用每个EDU的最后一个隐藏状态来表示EDU 之后使用一个top-down的decoder以深度优先的方式构建Discourse Tree 我们看一下图的右边： 一个堆栈S，S使用特殊的root初始化 每一步，从S的顶部取一$Span_{i:j}$，并使用$e_j$（EDU的representation）生成隐层的隐藏状态$d_t$，将其用于计算EDU representation中的attention score 基于得分，解码器会从中选择一个位置k来进行划分 之后decoder会在新的拆分上预测relation和nuclearity 模型细节 编码器：6层Bi-GRU，最后的hidden state被用作EDU的representation 解码器：6层Bi-GRU，decoder的输入是encoder的hidden state（我们认为encoder的hidden state比word embedding包含更多的信息）；使用dot product作为attention的计算函数 关系分类器：使用两层神经网络作为分类器；将nuclearity和relation联系起来，可以同时做这两个任务 Joint training Segmenter和Parser共享encoder，这在非神经网络模型中是不可能实现的 并且Segmenter和Parser可以作为独立的任务同时进行训练 Segmenter和Parser之间可以互相收益，好的分割可以带来建树上的性能提升，反之亦然 总结 一个有效的句子级篇章分析的神经框架 一个EDU分割器，F1 score达到了95.4 一个自定向下的篇章分析器，F1 score在关系标注上达到了81.7 两个模型进行联合训练，效果都有所提升，分割器达到了95.5，分析器达到了81.7 对于End-to-End的系统，在关系标注上的F1 score达到了77.5，相比于之前的系统有较高提升 篇章分析的时间为线性时间 写在后面 当前的篇章分析的主要方式 Bottom-up：Transition Based和CKY-like Top-down：Encoder-Decoder 当前篇章分析的另一个区别 贪婪的基于转移的算法 线性时间 基于局部信息 表格分析（chart parsing） 正确率更高 速度很慢 篇章连贯性分析 Soricut和Marcu，SPADE 使用句法特征来进行parsing和segmentation的生成模型 之后的工作都集中在研究语法的影响 Joty等，2015年，CODRA 包括一个segmenter和一个两阶段的discourse parser 第一阶段是句子级的篇章分析 第二阶段是多句子的篇章分析 Feng等，2014a 一个基于CRF和人工特征的两阶段的parser Li等，2014 基于Recursive Networks的篇章分析 Ji等，2014 基于shift-reduce的篇章分析的表征学习模型 Wang等，2017 两阶段的parser， 第一阶段基于shift-reduce进行建树，只标记了nuclearity 第二阶段再进行relation的标记 使用SVM + 大量的手工特征 Wang等，2018 使用了LSTM + CRF和ELMo的篇章分割器 Li等，2018 基于Pointer Networks的分割器","categories":[{"name":"自然语言处理","slug":"自然语言处理","permalink":"http://zivblog.top/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"}],"tags":[{"name":"NLP","slug":"NLP","permalink":"http://zivblog.top/tags/NLP/"},{"name":"论文笔记","slug":"论文笔记","permalink":"http://zivblog.top/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"}]},{"title":"基于Attention的分层神经网络的篇章分析","slug":"基于Attention的分层神经网络的篇章分析","date":"2019-11-22T11:06:32.000Z","updated":"2020-04-15T08:56:18.290Z","comments":true,"path":"passages/ji-yu-attention-de-fen-ceng-shen-jing-wang-luo-de-pian-zhang-fen-xi/","link":"","permalink":"http://zivblog.top/passages/ji-yu-attention-de-fen-ceng-shen-jing-wang-luo-de-pian-zhang-fen-xi/","excerpt":"《Discourse Parsing with Attention-based Hierarchical Neural Networks》论文笔记","text":"《Discourse Parsing with Attention-based Hierarchical Neural Networks》论文笔记 写在前面 这篇文章发表在EMNLP 2016 作者是北大的Qi Li、Tianshi Li、Baobao Chang 提出问题 Discourse Parsing依然是一个很有挑战的工作 尽管在近期（2016年）的工作已经显示出神经网络在特征抽取方面的良好性能，但是在篇章分析的工作上，目前性能较好的模型还是需要人工来构建特征 在之前的工作中，只有Li在2014年使用过RNN来计算subtree的representation，但是RNN存在梯度消失问题，而且对长距离依赖的捕获能力也不强；同时传统的变换函数并不能对特征之间的交互进行建模，也不能构建出组合特征 作者的思考 RNN的梯度消失和处理长距离依赖性能较差的问题 使用LSTM来代替RNN，LSTM可以解决梯度消失问题，并且在捕获长距离依赖上效果更好 EDU（由word构成）和Span（由EDU构成）的构成方式并不同 对于两种结构需要分开处理，所以需要构建分层的神经网络 更多的语义信息 对于Span中的每一个EDU，使用Attention，以获取Span中突出的语义信息 同时使用Attention，可以辅助LSTM，使网络获取更长距离的依赖 传统变换函数的缺陷 使用tensor-based的变换函数，对特征之间的交互进行建模，并且可以构造组合特征 解决方案or模型 先来看一下模型的结构图 我们来看一下模型的结构 首先，最下面的分层双向LSTM，分别是EDU级别的Bi-LSTM和Span级别的Bi-LSTM 之后一层Attention，用以捕获Span中的语义信息 再之后经过基于Tensor的变换函数，增加一些组合特征，同时添加一些人工特征 将特征组合之后输入三个分类器，分别用于 判断Span是否该组合的二分类器 判断核关系的多分类器（三分类） 判断Span之间的关系的多分类器 人工特征 之前的工作主要是通过使用特征来完成的 并且之前Li的工作也显示一些基本的特征仍然是有效的 模型加速（两级缓存） probilistic CKY-like算法的复杂度为$O(n^3)$，但是在本项工作中，我们以分层的双向LSTM为模型，计算复杂度为$O(n^4)$ 由于多数计算是重复的，所以可以使用缓存来减少计算复杂度 具体思路见论文 几点解释 为什么使用分层网络结构 EDU和Span的构成不同，需要分开处理，处理之后再进行组合 为什么使用双向LSTM discourse marker通常出现在文本单元的beginning和end，所以需要从两个方向来捕获 LSTM虽然记忆能力比较强，但是序列末尾的token由于经过更少的遗忘，所以对整个表征的影响更大 使用Bi-LSTM就可以对序列的beginning和end分别处理 使用Attention的作用 通过全局上下文关注每个EDU，提取重要的语义信息，剔除不重要的信息 LSTM虽然可以捕获长距离依赖，但是受限于输出的固定维度，在文本很长的始终，LSTM可能不足以捕获整个语义 tensor-based transformation function 直观上，允许两个span的特征之间进行复杂的交互可能有助于识别它们之间的关系 我们使用该函数来增加span特征之间的交互，并且产生一些组合特征 一点细节 使用GloVe对word embedding进行的预训练，并且在训练的时候对word embedding进行了微调，以应对训练集中的OOV情况 使用Stanford CoreNLP ToolKit来处理文本，进行词法，词性信息 初始化模型参数为[-0.012, 0.012]之间的数 dropout为0.03 总结 分层双向LSTM模型 加入了Attention机制 tensor-based transformation function two level cache以加速模型","categories":[{"name":"自然语言处理","slug":"自然语言处理","permalink":"http://zivblog.top/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"}],"tags":[{"name":"NLP","slug":"NLP","permalink":"http://zivblog.top/tags/NLP/"},{"name":"论文笔记","slug":"论文笔记","permalink":"http://zivblog.top/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"}]},{"title":"Word_Representation综述","slug":"Word-Representation综述","date":"2019-11-02T02:41:59.000Z","updated":"2020-03-04T06:45:08.845Z","comments":true,"path":"passages/word-representation-zong-shu/","link":"","permalink":"http://zivblog.top/passages/word-representation-zong-shu/","excerpt":"One-Hot、词袋模型、TF-IDF、n-gram、word2vec、GloVe、ELMo、GPT、BERT、XLNet","text":"One-Hot、词袋模型、TF-IDF、n-gram、word2vec、GloVe、ELMo、GPT、BERT、XLNet 写在前面 一直计划要写一篇综述，奈何知识储备不够，最近在看过相关的论文之后有了一些想法 我们都知道，文本是无法直接放入到模型来训练的，所以就需要将其转化为模型能够识别的形式，也就是向量，这就是文本表征的工作 本文主要是梳理文本表征的常见模型和一些最近表现比较好的模型，作为之前针对每个模型文章的补充 在这里，我会尽量使用比较简短的语言描述各个模型的大体思路，进步以及存在的缺陷 如果您发现有错误，欢迎来信指教&amp;讨论 纲要 离散式的文本表征（忽略词与词之间的关系） One-Hot编码 词袋模型 TF-IDF N-gram 分布式的文本表征 word2vec GloVe ELMo 两段式（预训练+微调） GPT BERT XLNet One-Hot编码 对分词后的词构造无重复的集合，每个词占一位，值为0或1 编码时，整个向量中，该词的位置为1，其他位置为0 例如 文本：篇章分析可能是我喜欢的方向 分词结果：篇章分析、可能、是、我、喜欢、的、方向 对于词“篇章分析”，编码为 : [1, 0, 0, 0, 0, 0, 0] 优缺点 优点：形式简单，易于理解和计算 缺点：忽略了词与词之间的关系，向量维度会随词的增多而快速增长 词袋模型 对文本进行分词，统计每个词出现的次数，构建词袋（可以想像成词：次数的键值对组成的字典） 可以对句子进行编码，每个词的位置是其在文档中出现的次数 例如 文本：NLP is my favorite direction. I will invest time in this direction 词袋：{NLP : 1, is : 1, my : 1, favorite : 1, direction : 2, I : 1, will : 1, invest : 1, time : 1, in : 1, this : 1] 该句的编码为：[1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 2] 优缺点 优点：易于理解 缺点：没有考虑词与词之间的关系 TF-IDF TF、IDF的含义 TF表示的是词频，可以表示为：$TF = \\frac{某文本中w出现的次数}{文本中所有词的个数}$ IDF表示的事逆文档频率指数，可以表示为：$IDF= log \\frac{文档总数}{包含w的文档数+1}$ 基本思想为：一个词在一个文档中出现的次数越多表示这个词越能表示这个文档；一个词在越多的文档中，则这个词对于文档分类的贡献越小 优缺点 优点：简单快速，结果符合实际情况 缺点：单纯以词频衡量词的重要性，不够全面，而且没有考虑词的位置信息 N-gram 使用滑动窗口的方式来进行分词，N表示的是窗口的大小 比如2-gram，就是把两个词当作一组来处理，然后向后移动一个词的长度，再次组成另一组词，然后统计词频生成字典 这种模型一定程度上考虑了词的顺序 例如 文本： John likes to watch movies. Mary likes too. John also likes to watch football games. 若构造的词典为： {“John likes”: 1, “likes to”: 2, “to watch”: 3, “watch movies”: 4, “Mary likes”: 5, “likes too”: 6, “John also”: 7, “also likes”: 8, “watch football”: 9, “football games”: 10} 则第一句话的编码为 [1, 2, 3, 4] 优缺点 优点：一定程度上利用了词的顺序关系 缺点：向量维度会增长非常快 word2vec 有两种：CBOW和Skip-gram CBOW 获得中间词两边的上下文，利用上下文来预测中间的单词 把窗口中的中间词作为y，其他词当作x输入 x输入经过one-hot编码，然后通过一个隐层求和操作，最后通过激活函数softmax，计算每个词的生成概率 训练圣经网络得到的权重矩阵就是文本表示词向量的结果 Skip-gram 通过当前词来预测窗口中上下文词的出现概率 把当前词作为x，把窗口中的其他词当作y，通过一个隐层接一个softmax激活函数来预测其他词的概率 优缺点 优点：分布式的word representation，更大程度上利用了文本内在的信息 缺点： 对每个词只是在windows中进行训练，并没有使用全局信息 每个词的向量表示在训练结束后就确定了，对多义词并不能有有效的进行表示和处理 GloVe Global Vectors for Word Representation 它是一个基于全局词频统计的词表征 共现矩阵 顾名思义，共现就是共同出现的意思 在矩阵中，$X_{ij}$表示的事词j在词i的上下文中出现的次数 论文中用以下公式近似的表达两者之间的关系 $$w^T_iw_j + b_i + b_j = log(X_{ij})$$ 其中$w^T_iw_j$即我们最终要求解的词向量，$b_i$和$b_j$是bias，$X_{ij}$是共现矩阵中的值 优缺点 优点： 结合了LSA和word2vec两者的特征，既使用了全局特征的矩阵分解方法，也了用了局部上下文特征（统计上下文中的出现次数时使用了滑动窗口） ELMo 双层语言模型的深层上下文的词表示 主要想法 使用双向LSTM作为语言模型在语料上训练出词的向量表示 在下游任务重会根据词的上下文对词的向量表示进行调整 使用了三层的双向LSTM（AR语言模型），每层向量表示的内涵是不同的 底层的可以捕获语法等方面的特征 高层的可以捕获语境相关的特征 优缺点 优点： 因为可以在应用的时候动态调整词向量的值，解决了多义词、歧义等问题 学习的范围更广，一定程度上更能表示一个词的意思 缺点： 特征提取器使用的是LSTM而不是transformer，特征提取能力可能不是很高 虽然说的是使用了上下文信息，但是只是对双向LSTM的hidden state进行简单的拼接，并不能有效的整合上下文信息 GPT GPT 1.0 两段式的过程：Pre-training和fine-tuning 先通过无标签的文本去训练生成语言模型 在下游任务中再使用有标签的数据进行监督式的微调 相比于ELMo，改动有两点 特征抽取器使用的是transformer的decoder 采用的是单向语言模型（AR） GPT 2.0 两段式的过程：Pre-training和fine-tuning 先通过无标签的文本去训练生成语言模型 在下游任务中使用无监督的方式进行微调 仍然使用的是transformer的decoder作为特征抽取器 使用的是单向语言模型（不是很了解其中的内涵） 主要的改进： 扩大了transformer的模型容量（加深了层数，增加了参数个数） 使用了更大且很有质量的数据集来进行训练 给出了一种新的生成式任务的做法 即一个词一个词往外蹦，然后根据时间顺序组合起来作为结果 BERT 两段式的过程：Pre-training和fine-tuning 先通过无标签的文本去训练生成语言模型 在下游任务中再使用有标签的数据进行监督式的微调 预训练过程中有两点创新 MLM 典型的AE语言模型，通过对输入序列mask掉一些token，然后使用其他的词去预测这些被mask掉的词 正因如此，模型可以很好的利用上下文的信息，也即双向语言模型 但是mask操作会导致预训练和微调存在差异，BERT通过对mask操作分为三种选择来减缓这种影响 NSP 因为一些下游任务基于句子间的关系的理解，这些关系无法通过语言模型来捕获 所以设计了这个根据一个句子预测下一个句子的任务 优缺点 优点：利用了上下文的信息，是一个双向的模型 缺点： mask操作会导致预训练和微调存在差异 mask的时候是假设被mask的词之间是相互独立的，而这样会丢失一些词之间的关系 XLNet 基于AR语言模型，对生成式的任务有天生的优势 两段式的过程：Pre-training和fine-tuning 具体思路 XLNet是基于AR语言模型的，但是我们知道AR语言模型只能看到词一侧的信息 XLNet是如何让单向的AR语言模型看到上下文的信息的呢？（这也是XLNet的一个比较新颖的贡献） 将待预测的单词固定，对其他的词进行排序 这样就可以在单向的情况下看到后面的词了，也就达到了双向的效果 具体的过程可以取XLNet简单理解中看 在此基础上，XLNet引入了transformer XL的机制，即段循环机制和相对位置编码，使得模型能够捕获更远距离的上下文依赖 优缺点 优点： 解决了BERT中mask操作带来的负面影响 对于生成式的任务和长文档输入的NLP任务表现更加优秀 写在后面 写完上面的内容之后还是有些意尤未尽，有很多地方描述的不够详尽，但是本身水平有限，在后续的时间里会随时纠正其中的错误和补充其中的不够全面的地方 如果您对其中的内容有不同看法或者有好的想法，欢迎来信交流 邮箱 : wjf850300210@163.com","categories":[{"name":"自然语言处理","slug":"自然语言处理","permalink":"http://zivblog.top/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"}],"tags":[{"name":"NLP","slug":"NLP","permalink":"http://zivblog.top/tags/NLP/"},{"name":"论文笔记","slug":"论文笔记","permalink":"http://zivblog.top/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"}]},{"title":"XLNet简单理解","slug":"XLNet简单理解","date":"2019-10-31T09:05:32.000Z","updated":"2020-03-04T06:45:58.051Z","comments":true,"path":"passages/xlnet-jian-dan-li-jie/","link":"","permalink":"http://zivblog.top/passages/xlnet-jian-dan-li-jie/","excerpt":"《XLNet-Generalized Autoregressive Pretrainingfor Language Understanding》论文笔记","text":"《XLNet-Generalized Autoregressive Pretrainingfor Language Understanding》论文笔记 写在前面 今年6月发布的XLNet，在很多任务上的性能都超过了BERT 但BERT本身的地位并不能被忽视 BERT的除了其性能上带来的提升，更关键的是，它证明了一个非常深的模型能够显著提高NLP任务的准确率，并且这个模型性可以从无标记的数据集中预训练得到 另外，它也开启了“两段式”大门，即在大型数据集上预训练，再针对下游任务进行微调 XLNet可以看作是BERT的一个发展，它使用新的结构避免了BERT的缺陷，并且结合了transformer XL的一些思路使其在面对长文本时的性能更加出众 从BERT开始 在之前的文章中我们对BERT做过以此比较详细的介绍，这里再简单的回顾一下 BERT的结构是双向transformer 它的预训练，使用MLM和NSP BERT的局限也在于此， 在MLM中，BERT对输入序列进行的mask操作，使用被mask掉的词的上下文来对其进行预测 正因为如此，BERT的以很好的利用双向语境信息 但也因为如此，BERT的预训练与微调是有差异的，因为应用到下游任务中时，并不会有mask操作 XLNet的作者认为，BERT的缺点主要在于以下几个方面： 首先，是mask操作使得pre-training和fine-tuning之间存在差异 其次，BERT做mask操作时，是认为被mask掉的token之间是相互独立的，并没有利用这些token之间的依赖关系 针对以上的问题，XLNet提出了一种新的结构，并且取得了较好的性能 在XLNet之前 作者认为，当前的预训练模型主要有两种： AR（AutoRegression）：自回归语言模型 根据上文预测下一个单词或者下文预测前一个单词 说道这里，你可能会想到ELMo，ELMo中确实用到了这种LM，而且最后对于两个方向的hidden state做了拼接，从这一点看来，ELMo还是自回归LM，是一种“伪上下文”，并不能很有效的利用上下文信息 优点：对于生成式的下游任务，本身就是单方向的，所以AR可以很好的适应；还有一点是相比于AE，能够学习到token之间的依赖 缺点：只能利用上文或者下文的信息 提前说一句，XLNet提供了一种使用自回归语言模型利用上下文信息的方法，详细的内容过会再讲 AE（AutoEncoder）：自编码语言模型 类似与BERT的自编码方式，破坏掉输入的一部分，再对破坏掉的进行预测，以此来捕捉深层次的双向信息 BERT的做法就是将input中的token进行mask操作 优点：能较好的融入双向语言模型，同时利用待预测单词的上下文 缺点：对输入的破坏会导致预训练过程与微调存在差异，可能导致性能的波动 XLNet的想法是，能否将这两种的优点结合起来，然后还能尽可能的避免其缺点，即 在自回归模型的基础上如何引入双向语言模型 在自编码模型的基础上如何抛掉mask，是pre-training和fine-tuning一致 XLNet详述 上面提到的问题是XLNet致力于解决的，并且在此基础上，XLNet还融合了transformer XL一些思路来获取更大范围的上下文 XLNet仍然是两阶段： LM的pre-training 针对下游任务的fine-tuning下面介绍一下XLNet中的主要“部件” PLM（Permutation Language Modeling，排列语言模型） 在BERT中通过对mask的预测来捕获深层次的上下文信息，但是因此也带来了预训练和微调不一致的问题，XLNet该怎么做呢 首先要明确的是，不同于BERT是一种AE，XLNet是基于AR的 那么问题来了，AR是只能捕获一侧信息的，我们该怎么让它能够利用两侧的信息呢 思考一下，对于一个前向的AR模型，要预测第i个位置的token，如果我们在预测时既能看到上文的词，又能看到下文的词，是不是就能视作是利用了上下文的信息了。在此基础上，也就不需要mask操作了 那应该怎么做呢？ 接上面的假设，对于第i个位置待预测的token，正常的情况下，前向AR可以看到的$[1, i-1]$的词。这里，我们的操作是，固定待预测的token，将其他的词进行排列。这样就可以用AR的单向方式来习得双向信息了 这就是排列语言模型的含义 尽管最为直接的方式是对序列进行排序之后挑选一部分作为输入，但实际上这样是不允许的，因为你不能在fine-tuning的时候对原始序列进行排序，所以输入的必须还是原始序列，所以我们选择在transformer的内部利用attention mask 比如对于序号为1234的句子，先随机取一种排列，比如是3241，根据这个序列我们可以做出下图的mask 解释一下， 在新的排列中，1在最后一个，所以根据前向AR的方式，1能看到234全部，所以第一行中的234未被mask 以此类推，第二行中，2在第二个，只能看到3，所以三的位置未被mask 。。。 Two-stream Self-attention（双流自注意力机制） 打乱了顺序后位置信息变得十分重要，同时对于每个位置来说，需要预测的是对应位置的词，于是输入就不能包含内容信息，否则模型就学习不到东西 于是这里就造成了位置信息与内容信息的割裂，因此在transformer中位置信息+内容信息输入Self-Attention的流之外，还增加了一个只有位置信息作为Self-Attention中query输入的流 这样，就能利用query stream在对需要预测位置进行预测的同时，又不会泄露当前位置的内容信息 具体操作就是用两组hidden state，g和h 其中g中只有位置信息，作为self-attention中的Q h中包含内容信息，作为self-attention中的K和V 如果模型只有一层的话，这样的Query stream就足够了，但是层数一旦多了之后，为了取得更高层的h，就需要Content Stream了。这时h同时作为Q、K、V 对于上图，最下面的蓝色的content stream的输入是e(x)，就是x对应的词向量，不同的词对应不同的词向量 旁边的query stream，这个和后面的Relative Segment Encoding有关，之后细讲 Partial Prediction（部分预测） 在排序后对每个位置进行预测的话，会导致优化过难，训练难以收敛。 所以作者就做了一个类似BERT的操作，即训练时只对每句话部分位置进行预测 XLNet其实看起来更像一个大杂烩，它实际上融合了目前许多优秀的模型的特性 通过PLM预测训练目标，吸收了BERT的双向语言模型 使用更多更有质量的预训练数据，这点与GPT2.0很像 transformer对长文档NLP应用不够友好，于是引入了transformer XL的部件来解决该问题 下面介绍一下在XLNet中用到的transformer XL中的部件 transformer XL中的两个技巧 Segment Recurrent Mechanism（段循环机制） 首先因为训练transformer时，会将文本按一定长度处理成segment（段），这样的话，模型时无法学习到更长的上下文信息的。 所以受RNN的启发，我们能否将前一段计算完成后，将其hidden state保存下来，在之后的分段计算时，将之前保存下来的hidden state和当前段的hidden state拼接起来作为Attention中的K和V，以此来获得更长的上下文信息 对于上图， 该段的前面隐藏层的输出，对应图上的灰色线 前面短的隐藏层的输出，对应上图的绿色线，可以使模型创建长期依赖关系 Relative Position Encoding（相对位置编码） 如果在分段的情况下仍使用transformer的位置编码，会导致每段中的相同位置的位置编码是相同的 但实际情况是，这些段内相对位置相同的编码，对建模的贡献是不相同的；而且模型训练时也会产生歧义 此时就可以使用相对位置编码，不关心句中词的绝对信息，而是词与词之间有多少个词这样的相对信息 Relative Segment Encoding 类似于BERT中的NSP（next sentence prediction），这里也有类似的功能 XLNet提出了Relative Segment Encoding，因为以前BERT是直接分A、B句，每个句子有个segment embedding，XLNet借鉴了relative position的思想，只判断两个token是否在一个segment中，而不是判断他们各自属于哪个segment。 具体实现是在计算attention weight的时候，给query额外操作一波，算出一个额外的权重加到原本的权重上去，跟relative positional encoding差不多。 这样做的优点是之后可以处理更多的segments，而不是像BERT只能处理两个。 与BERT的比较 其实从本质看来，XLNet中的PLM和BERT中的mask是类似的，都是为了解决如和使用上下文信息的目的 区别在于 Bert直接对输入端的序列进行mask操作，赋予mask标记 XLNet则是通过attention mask机制，在transformer内部进行操作，输入的还是原序列，并不会导致预训练和微调的差异 另外，XLNet由于使用的AR语言模型，所以在生成式的NLP任务中会表现更好 因为引入了transformer XL中的机制，对于长文档输入的NLP任务，会比BERT更加优秀 参考资料 https://zhuanlan.zhihu.com/p/71916499 https://github.com/NLP-LOVE/ML-NLP/tree/master/NLP/16.9%20XLNet 《XLNet-Generalized Autoregressive Pretrainingfor Language Understanding》","categories":[{"name":"自然语言处理","slug":"自然语言处理","permalink":"http://zivblog.top/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"}],"tags":[{"name":"NLP","slug":"NLP","permalink":"http://zivblog.top/tags/NLP/"},{"name":"论文笔记","slug":"论文笔记","permalink":"http://zivblog.top/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"}]},{"title":"word2vec简单理解","slug":"word2vec简单理解","date":"2019-10-28T11:52:55.000Z","updated":"2020-03-04T06:44:37.934Z","comments":true,"path":"passages/word2vec-jian-dan-li-jie/","link":"","permalink":"http://zivblog.top/passages/word2vec-jian-dan-li-jie/","excerpt":"《Efficient Estimation of Word Representation in Vector Space》论文笔记","text":"《Efficient Estimation of Word Representation in Vector Space》论文笔记 写在前面 这篇论文发表于2013年，那时的计算能力还不像现在这样，BERT这样超大的模型几乎是不可能的 在word2vec提出之前，使用的基本都是离散的文本表示，这种方式没有使用词与词之间的关系，可想而知性能也是比较差的 虽然在现在看来word2vec（CBOW和Skip-gram）无论从性能和技术本身来说已经比较过时了，但是整篇论文读下来还是被作者的许多比较精妙idea所折服 昨天组会师兄说，不要总是低头自己搞研究，要多抬头看看别人的工作思路，其中最值得借鉴的就是Google的研究人员们的工作思路了。我对此深以为然，确实真正的走在前列的人的思路能影响整个行业的发展。 我们知道，在ML中，真正决定整个模型的上限是数据，而算法只能无限接近这个上限 对于文本数据来说，最关键的就是对文本的表示。这里，我们暂且将其分为以下两种： 文本的离散表示 文本的分布式表示 基于矩阵的分布式表示 基于神经网络的分布式表示 文本的离散表示One-Hot编码 对文本分词后构造无重复的集合，每个词占一位，值为0或1 每个词的表示是一个：该词的位置为1，其他位置为0的向量 例如： 对于文本：我喜欢NLP。 分词结果：[我，喜欢，NLP] 词向量分别为[1, 0, 0], [0, 1, 0], [0, 0, 1] BOW（词袋模型） 对文本分词，统计每个词出现的次数，构建词袋（可以想象成字典） 句子的表示，向量中每个位置的值为对应的词出现的次数 例如： 文本：我喜欢ML，我也喜欢NLP。 词袋{“我” : 2, “喜欢” : 2, “也” : 1, “ML” : 1, “NLP” : 1} 句子的表示为：[2, 2, 1, 2, 1, 2, 1] TF-IDF 这种方法的思想是： 词的重要性随其在文档中出现的次数成正比例增加，同时会随其在整个语料库中不同文本中出现的次数而减少。 换言之就是，一个词在一个文档中出现越多并且在其他文档中出现的次数越少，说明该词越能代表该文章 TF表示的是词频；IDF表示的是逆文本频率指数 $$TF = \\frac{某文本中w出现的次数}{文本中所有词的个数}$$ $$IDF = log \\frac{文档总数}{包含w的文档数+1}$$，加1的目的是防止分母为0 $$TFIDF = TF*IDF$$ n-gram 利用了滑动窗口的方式来进行“分词”，之后再进行词的频率的统计 例如： 对于文本：“见到你的那一刻，这些年承受的孤独都随风而逝了” 我们设置N=2 分词结果为 [“见到、你”, “你、的”, “的、那一刻”, “那一刻、这些年”, “”, “这些年、承受”, “承受、的”, “的、孤独”, “孤独、都”, “都、随风而逝”, “随风而逝、了”] 统计词频 {“见到、你” : 1, “你、的” : 1, “的、那一刻” : 1, “那一刻、这些年” : 1, “这些年、承受” : 1, “承受、的” : 1, “的、孤独” : 1, “孤独、都” : 1, “都、随风而逝” : 1, “随风而逝、了” : 1} 所以文本的表示为[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] 离散表示的缺点 无法利用词与词之间的关系 词表的维度过大 会导致生成的向量稀疏 分布式表示 所谓分布是表示，就是利用词的上下文来表示词的语义 基于矩阵的的分布式表示 比较经典的有“共现矩阵” GloVe 基于神经网络的分布式表示 前馈神经网络语言模型（NNLM） 该模型由输入层、投影层、隐藏层、输入层构成 在输入层，前N个使用one-hot编码， 接着输入层被投影到投影层 隐藏层用来对词典中所有词计算概率分布 对n元语言模型进行建模，定义一个前向窗口，把窗口的最后一个词作为y，前面的词作为x，使用前面的词来预测最后一个次出现的概率 训练过程中得到的中间产物——词向量矩阵，就是我们想要得到的文本表示向量矩阵 循环神经网络语言模型（RNNLM） RNNLM可以突破NNLM的一些局限，可以更有效的表征更复杂的模型 没有投影层，只有输入层、隐藏层、输出层 使用时间延迟连接将隐藏层和自身连接的循环矩阵可以使模型能够利用过去的信息 下面介绍本文的重点，CBOW和skip-gram 这两种模型将会使用尽可能小的计算复杂性来得到词的分布式表示 通过之前的神经网络语言模型的分析，我们知道，大部分复杂性是由非线性隐藏层引起的 所以我们尝试使用更加简单的模型架构来学习词的分布式表示 CBOW 架构类似于NNLM，但是移除了非线性隐藏层，并且投影层由所有词共享,因此所有词会被投影到相同的位置 换言之， CBOW就是使用中间词的上下文，使用上下文来预测中间的词，如图所示 把中间词当作y，把窗口中的其他词当作x输入，x输入使用one-hot编码， 通过一个隐层进行求和操作，之后通过激活函数softmax，计算每个单词的生成概率 而求得的权重矩阵即为文本表示（词向量） skip-gram 与CBOW相反，使用当前词作为带有连续的投影层的对数线性分类器的输入，然后预测当前词之前和之后一定范围内的词。 把中间词作为x，把窗口中的其他词作为y，通过一个隐层接一个softmax激活函数来预测其他词的概率 缺陷 对每个local context window单独训练，并未利用包含在global co-occurence中的信息，后面提出了GloVe 多义词无法处理，因为训练之后每个词的表示都确定下来了，为了解决该问题，后面提出了ELMo 优化方法 层次softmax 整篇文章读下来，就是在极致的减小计算量 而如果只是连接一个softmax的话，计算复杂度还是很高，为O(kh)，k是类别数量，h是文本特征的维度数 所以这里提出了层次softmax（Hierarchiacal softmax）， 将输入层中的词和词组构成特征向量，再将特征向量通过线性变换映射到隐藏层，隐藏层通过求解最大似然函数，然后根据每个类别的权重和模型参数构建Huffman树，将Huffman树作为输出。最终可以将计算复杂度降到$O(hlog_2k)$ 在使用n个训练样本进行训练时，根据每个类别出现的次数作为权重来见Huffman数，出现次数多的类别的样本，路径就会变短。 负例采样 在正确单词之外的负样本进行采样，最终目的就是为了计算量 比如语料库中有10w数据，如果每个神经元均要进行反向传播的话，计算代价太大。 正例对应的神经元肯定需要进行反向传播的，所以从负例中选择一部分神经元进行反向传播，以减少计算量。 已知一个词w，它的上下文为context(w)，那么词w就是正例，其他词就是负例，但是这样来看负例太多了。 在语料中，每个词出现的频率是不一样的，采样的时候要保证频率高的要比频率低的词更容易被选中 随机数产生是均匀分布的，但是取词概率可不是均匀分布的，其概率随着词频大小变化 如果词表的大小为V，我们就将一段长度为1的线段分成V份，但是每段的长度不同（词频不同） 每个词的线段长度由下式确定: $$len(w) = \\frac{count(w)^{3/4}}{\\sum count(u)^{3/4}}$$ 这样，每个词对应的线段都会划分成对应的小块，M份中的每一分都会落在某一个词对应的线段上。 采样的时候，我们是需要从M个位置中采样n个位置就行了，此时采样到的每一个位置对应到的线段所属的词就是我们的负例词 参考资料 《Efficient Estimation of Word Representation in Vector Space》","categories":[{"name":"自然语言处理","slug":"自然语言处理","permalink":"http://zivblog.top/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"}],"tags":[{"name":"NLP","slug":"NLP","permalink":"http://zivblog.top/tags/NLP/"},{"name":"论文笔记","slug":"论文笔记","permalink":"http://zivblog.top/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"}]},{"title":"GloVe浅析","slug":"GloVe浅析","date":"2019-10-28T00:35:10.000Z","updated":"2020-03-04T06:18:58.044Z","comments":true,"path":"passages/glove-qian-xi/","link":"","permalink":"http://zivblog.top/passages/glove-qian-xi/","excerpt":"《Global Vectors for Word Representation》笔记","text":"《Global Vectors for Word Representation》笔记 写在前面 这次换个形式，本文分为两部分 第一部分对论文中提到的两个Related Work进行总结 第二部分按照作者自己的思路对GloVe的流程进行阐述（如果您发现作者在理解上有瑕疵，请及时指正） Related WorkMatrix Factorization Methods 利用低秩近似来分解捕获关于语料库的统计信息的大矩阵 LSA（潜在语义分析）：矩阵是term-document类型的，即行对应term，列对应语料库中不同的文档 HAL（语言的超空间模拟）：矩阵是term-term类型的，即行列均对应单词，entries对应给定单词在另一个单词上下文中出现的次数 HAL相关的方法的一个主要问题是出现最频繁的单词对相似性度量的贡献不成比例 Shallow Window-Based Method 这种方法是学习有助于在本地上下文窗口中进行预测的单词表示 shallow window-based的方法的缺点在于他们不直接对语料库的共现统计数据进行操作，这种类型的模型只扫描corpus中的上下文窗口，这无法利用数据中大量的重复信息 简述 说一下个人感受 GloVe模型并没有严格的数学推导，所以其证明过程并不是完全意义上的等式证明 它更像是一个作者在自身经验的基础上提出的一个相对符合自然语言处理任务的模型 效果好就是王道 首先，明确一些符号的含义 $X_{ij}$：j在i的上下文中出现的次数 $X_i=\\sum_k X_{ik}$：任意词在i上下文中出现的次数 $P_{ij}=P(j|i)=\\frac{X_{ij}}{X_i}$：j在i上下文中出现的概率 其次，还有一张图，也就是所谓的Co-occurrence matrix（共现矩阵） 该如何利用这些Prob呢？ ​ 在该图中Prob的值都比较大，但是考虑当句子很长的时候（包含的词很多），Prob的值会变得很小，这种很小的值所能表是的意义太少 ​ 所以我们考虑使用Prob的比值来扩大值的大小 ​ 比值的意义就是对比i上下文中出现的两个词与i的相关性的大小 ​ 例如： ​ $$\\frac{P(k|ice)}{P(k|steam)} = \\frac{0.7}{0.1} = 7$$ ​ 由于Prob都是在所在的数量级一般是相同的，所以比值一般会得到一个比较大的数 该怎么解读Prob的比值呢？ 根据上面的例子 当Prob大于1的时候，说明k与ice的相关程度更高 当Prob近似于1的时候，说明k与ice和steam的相关程度相近 当Prob小于1的时候，说明k与steam的相关程度更高 模型的建立与优化 设i,j,k为三个word，$w_i,w_j,w_k$为三个word vector 模型假设为$F(w_i, w_j, w_k)=\\frac{P_{ij}}{P{jk}}$，用于评估i,j分别与k的相关程度 用i,j的差异（做差）来反应Prob商的关系，则 $$F((w_i-w_j), w_k)= \\frac{P_{ik}}{P_{jk}}$$ 构造一种线性关系（点乘） $$F((w_i - w_j)^Tw_k)=\\frac{P_{ik}}{P_{jk}}$$ 我们知道，k是target word，i,j是context word。而实际中，k和i以及k和j是arbitrary的。所以在标准是平衡的情况下，$X_{ij}$和$X_{ji}$的值应该是基本相等的，也就是说$X_{ij}$和$X_{ji}$是可随意交换的 我们假设 $$F((w_i-w_j)^Tw_k)=\\frac{F(w_i^T w_k)}{F(w_j^T w_k)} = \\frac{P_{ik}}{P_{jk}}=\\frac{\\frac{X_{ik}}{X_i}}{\\frac{X_{jk}}{X_j}}$$ 我们考虑是否有一个函数能将相减的表达式转化为相除，最直接的一个——指数函数。因此，令F为exp函数 $$w_i^T w_k = log(P_{ik})=log(\\frac{X_{ik}}{X_i})=log(X_{ik})-log(X_i)$$ 通过观察可以发现，$log(X_i)$与k是无关的，也就是说它是一个常数。既然是常数，那我们就可以通过在等式的左边添加一些bias来抵消掉，于是： $$W_i^Tw_k + b_i +b_k = log(X_{ik})$$ 建立损失函数（优化） 我们知道，模型优化的目的就是减小左式与右式之间的差距，使之尽可能的接近 所以我们构建相应的损失函数（加权最小二乘回归模型），通过最小化损失来完成该目标 $$J = \\sum_{i,j=1} f(X_{ij}) (w_i^Tw_j+b_i+b_j - log(X_{ij}))^2$$ 我们可以看到，其中的$log(X_{ij})$是可以直接统计得到的 其中，$f(X_{ij})$的表达式为 $f(X_{ij})$需要满足三个特性： $f(0)=0$，f应该为连续函数 $f(x)$应该是非递减函数，这样rare的co-occurences不会过大 对于较大的x值，$f(x)$应该相对较小，防止frequent的co-occurrences不会过大 参考资料 《Global Vectors for Word Representation》","categories":[{"name":"自然语言处理","slug":"自然语言处理","permalink":"http://zivblog.top/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"}],"tags":[{"name":"NLP","slug":"NLP","permalink":"http://zivblog.top/tags/NLP/"},{"name":"论文笔记","slug":"论文笔记","permalink":"http://zivblog.top/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"}]},{"title":"GPT简单理解","slug":"GPT简单理解","date":"2019-10-24T04:14:43.000Z","updated":"2020-03-04T06:19:20.049Z","comments":true,"path":"passages/gpt-jian-dan-li-jie/","link":"","permalink":"http://zivblog.top/passages/gpt-jian-dan-li-jie/","excerpt":"《Imporving Language Understanding by Generative Pre-Training》 《Language Models are Unsupervised Multitask Learners》 论文笔记","text":"《Imporving Language Understanding by Generative Pre-Training》 《Language Models are Unsupervised Multitask Learners》 论文笔记 写在前面 GPT迄今为止已经有了两个版本，GPT1.0时候的性能已经足够出众，但是由于之后BERT更加出众的表现使GPT1.0并没有受到多大的关注 后面OpenAI的大牛们又提出了GPT2.0，GPT2.0相比于1.0最大的改进是扩大了模型的容量（参数数量），使用更大更优质的数据集，并且性能也有了很大的提升 下面做详细介绍 GPT 1.0 GPT（Generative Pre-Training，生成式预训练），从名字就可以看出来，GPT必然会在生成式的任务重表现良好 GPT 1.0是在论文《Imporving Language Understanding by Generative Pre-Training》中提出来的 下面简要介绍一下GPT 1.0的思路 GPT 1.0也是一种两段式的过程，即： 先通过无标签的文本去训练生成语言模型 再用有标签的数据对模型进行微调 相比于ELMo，GPT 1.0有两点改动 特征抽取器使用的是transformer，而不是RNN 采用的是单向语言模型 因为使用了transformer，所以对特征有更好的抽取；但是使用单向的AR语言模型，没有很好的利用上下文的信息，所以会导致一定的性能下降 下面看一下训练过程 对于给定的无监督的语料的token序列$U = {u_1, …, u_{i-1}}$，模型训练的目标是最大化语言模型的极大似然函数 $$L_1(U) = \\sum_i log P(u_i|u_{i-k},…u_{i-1}; \\Theta)$$ 我们使用一个多层的transformer的decoder作为语言模型： 输入为word embedding和token的位置信息 再第transformer_block的输出向量做softmax，输出为词的概率分布 $$h_0 = UW_e + W_p$$ $$h_l = transformer_block(h_{l-1})$$ $$P(U) = softmax(h_n W_e^T)$$ 下面是fine-tuning（微调） 假设每一条数据为一个单词序列$x_1, … x_m$以及相应的标签$y$，通过之前预训练的模型获得输出向量$h^m_l$，再送入线性输出层，来预测$y$ $$P(y|x^1, … , x^m)=softmax(h_l^m W_y)$$ GPT 2.0 GPT 2.0是在论文《Language Models are Unsupervised Multitask Learners》中提出的 下面简要介绍GPT 2.0结构和特性 GPT 2.0与GPT 1.0相同，使用的仍是transformer的decoder构建的 GPT 2.0使用的仍是单向语言模型，这使它原生就适合生成式的任务 GPT 2.0仍是两段式的过程，即pre-training + fine-tuning GPT 2.0针对下游任务进行微调时使用的是无监督的方式 它的主要改进是选择一条其他的路来强化BERT或者说是GPT1.0与训练阶段 扩大了transformer的模型参数容量（通过加深层数，增加了参数个数） 使用更大的数据集来训练，这也是为什么要进行参数扩容的原因 与BERT的比较 GPT 2.0使用的是transformer的decoder构建的，而BERT使用的是transformer的encoder构建的 GPT 2.0使用的仍是单向的AR语言模型，而BERT使用的事AE语言模型 GPT 2.0的微调阶段使用的是无监督的方式，而BERT使用的是监督的方式 相比于BERT，在预训练阶段采用了多任务的方式，不单单知识在一个任务上进行学习，并且每个任务均要保证其损失函数能够收敛，不同的任务共享主题transformer参数，能进一步提升模型的泛化能力，即便在没有进行微调的情况下依旧能够有不错的表现 GPT 2.0给出了一种新的生成式任务的做法 在GPT 2.0出现之前，生成式的任务一边都是使用RNN、transformer，在输出端直接输出一个序列 而GPT2.0的方式是，就是一个词一个词往外蹦，然后拼接输出的内容作为结果（这种方式与语言模型的用法极其相似，所以GPT 2.0是否可以看作是一种性能出众的语言模型？） 为什么第二阶段不用有监督的方式进行微调？ 对于这一点，参考网上一些大牛的说法 “感觉作者主要是为了证明第一阶段学习到了很多的只是，并且足够通用” 为什么预训练不使用双向语言模型 BERT之所以性能出众的原因就是其使用了双向的语言模型，按正常的思路来说使用双向语言模型应该会成为一种趋势，比如XLNet 参考网上一些大牛的说法 “GPT 2.0这样做的主要目的估计是为了与BERT进行比较，毕竟两者的最大差异就在于此。而且GPT2.0使用了另一种方式来赶超BERT，即提升模型容量和训练数据的大小” 参考资料 《Imporving Language Understanding by Generative Pre-Training》 《Language Models are Unsupervised Multitask Learners》 https://zhuanlan.zhihu.com/p/56865533","categories":[{"name":"自然语言处理","slug":"自然语言处理","permalink":"http://zivblog.top/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"}],"tags":[{"name":"NLP","slug":"NLP","permalink":"http://zivblog.top/tags/NLP/"},{"name":"论文笔记","slug":"论文笔记","permalink":"http://zivblog.top/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"}]},{"title":"ELMo简单理解","slug":"ELMo简单理解","date":"2019-10-24T04:14:26.000Z","updated":"2020-03-04T06:18:21.139Z","comments":true,"path":"passages/elmo-jian-dan-li-jie/","link":"","permalink":"http://zivblog.top/passages/elmo-jian-dan-li-jie/","excerpt":"《Deep contextualized word representations》论文笔记","text":"《Deep contextualized word representations》论文笔记 写在前面（Abstract、Introduction） 深度学习的精髓在于representation，而在NLP任务中，相对应的就是embedding和language model任务 本文提出了一种利用双向LM学习的深层上下文的词表示（deep contextualized word representation） 作者认为一种好的representation模型需要包含两个特点： 词语的用法在语义和语法上的复杂性特点 随上下文（语境）变化，词的含义要有所变化 在本文提出的模型中，每个word representation都是整个输入语句的函数 先在语料上以语言模型为模型训练出双向LSTM，然后利用LSTM生成词语的表征 在应用到下游任务中时 先使用下游任务的（忽略标签的）语料库进行LM的微调 再利用有标签的语料库进行监督学习 ELMo表征是deep的，它是BiLM的所有层的内部表征，产生的word representation内涵的非常丰富的 高层的LSTM可以捕获语境相关的特征 低层的LSTM可以捕获语法方面的特征 将其结合起来必然能丰富生成的表征的内涵 简述（基于论文内容）LM（Language Model） ELMo（Embeddings from Language Model），从其名称可以看出来，模型是与语言模型相关的 FLM（forward language model，前向语言模型） 给定一个序列$(t_1, … t_N)$，前向语言模型通过$t_k$之前的序列来预测$t_k$，可以表示为： $p(t_1, … t_N) = \\prod_{k=1}^{N}p(t_k|t_1, t_2, … t_{k-1})$ BLM（backward language model，后向语言模型） 给定一个序列$(t_1, … t_N)$，前向语言模型通过$t_k$之后的序列来预测$t_k$，可以表示为： $p(t_1, … t_N) = \\prod_{k=1}^{N}p(t_k|t_{k+1}, t_{k+2}, … t_{N})$ BiLM（双向语言模型） 双向语言模型结合了FLM和BLM两者的特点，对于给定的序列$(t_1, … t_N)$，对于任意待预测位置的token，通过其上下文进行预测 假设输入的token的词向量表示为$x_{k}^{LM}$，在每个位置k，每层LSTM都输出相应上下文的表示$h_{k,j}^{ \\rightarrow LM}$ (j表示LSTM层数)。顶层的LSTM输出$h_{k,L}^{\\rightarrow LM}$(L是最大层数)，通过softmax层来预测下一个$token$ 对数似然函数表示如下： $\\sum_{k=1}^N(log p(t_k|t_1,…t_{k-1}; \\Theta_x, \\Theta^{\\rightarrow}{LSTM}, \\Theta_s) + log p(t_k|t{k-1}, … t_N;\\Theta_x, \\Theta^{\\leftarrow}_{LSTM}, \\Theta_s))$ 模型的结构图 最底层是单词的word embedding 往上走是第一层双线LSTM中对应单词位置的embedding，这层编码单词的句法信息更多一些 再之上是第二层的LSTM中对应单词位置的embedding，这层编码的语义信息更多一些 相比于之前的模型只使用最后一层的输出值来作为word embedding，ELMo将所有层的输出值进行线性组合用来作为W E的值，正因为如此，EMLo可以解决同一词的包含多个含义的问题，这个后面会细说 ELMo 对于每一个token，一个L层的BiLM要计算$2L+1$个表征 在下游任务中，会把$R_k$压缩成一个向量： $ELMo_k^{task}$ = $E(R_k; \\Theta^{task})$ = $\\gamma^{task} \\sum_{j=0}^L s_{j}^{task} h_{k, j}^{LM}$ $ s^{task}_j$是softmax-normalized的权重 $\\gamma^{task}$则允许不同的任务对ELMo向量进行缩放 在论文中，作为最终用于实验的预训练模型，为了平衡语言模型之间的perplexity和下游任务的计算复杂度，使用了2层BiLSTM，并且第一层和第二层之间有残差 整个EMLo会为每个token提供一个三层的输出，而下游模型使用的是这三层输出的线性组合 一点想法 上面的内容是根据论文的顺序和内容写的一点笔记（摘抄+翻译），下面说一下读过论文之后的一点想法 EMLo模型的特点从其论文题目中就可以体会到，“deep”和“context”，其中后者更为关键 在此之前的word embeddings是一种静态的方式，也就是说在预训练之后，每个token的表示就完全固定住了，并不会因为出现的上下文的不同而改变表示。很明显这有巨大缺陷。 还有一点来说，ELMo词的表示是学习的范围更广，在一定程度上更能表示一个词的意思 而EMLo是怎么做的呢，事先用一个语言模型学习一个单词的Word Embedding，此时多义词还无法区分，但是在使用的过程中，会随时根据词所在的上下文调整单词的表示，也就解决了多义词，或者说是歧义的问题。 因为ELMo给下游提供的是每个单词的特征形式，所以这类预训练的方法被称为”Feature-based Pre-train” 还有另一种预训练方法是”fine-tuning Pre-train”，之前文章中的BERT就是基于该方法的 参考资料 《Deep contextualized word representations》 https://www.cnblogs.com/huangyc/p/9860430.html","categories":[{"name":"自然语言处理","slug":"自然语言处理","permalink":"http://zivblog.top/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"}],"tags":[{"name":"NLP","slug":"NLP","permalink":"http://zivblog.top/tags/NLP/"},{"name":"论文笔记","slug":"论文笔记","permalink":"http://zivblog.top/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"}]},{"title":"BERT简单理解","slug":"BERT简要理解","date":"2019-10-24T02:43:42.000Z","updated":"2020-03-04T06:10:36.040Z","comments":true,"path":"passages/bert-jian-yao-li-jie/","link":"","permalink":"http://zivblog.top/passages/bert-jian-yao-li-jie/","excerpt":"《BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding》论文笔记","text":"《BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding》论文笔记 BERT是什么 BERT全称Bidirectional Encoder Representation from Transformers，即双向的Transformer编码器 模型主要的创新点都在pre-train上 使用MLM（Masked LM）捕捉词语级别的representation 使用Next Sentence Prediction BERT的贡献点在于 效果极好，刷新了很多NLP任务的最好性能 广泛的通用性（本身的特性决定它可以经过微调适用于很多下游任务） 简述（基于论文内容） 语言模型的预训练对于NLP任务来说是十分重要的 当前预训练语言模型的方式有两种 基于特征的预训练方式，例如ELMo 基于微调的预训练方式，例如GPT 接下来我们要介绍的BERT，是一种基于微调的预训练语言模型 BERT主要包含两部分： pre-training 使用无标记的数据进行预训练 fine-tuning 使用与训练模型的参数作为模型的初始化参数 根据不同的下游任务的标记数据对所有参数进行调整 在微调过程中，除了输出层，其他层的结构不变 关于BERT的预训练分为两块（BERT的主要创新点）： Masked LM（像是完型填空） 很明显，深度双向模型的性能要高过单一的left-to-right和right-to-left的浅层模型， 但是，标准语言模型只能从左往右或从右往左进行训练 为了进行deep bidirectional representation的训练，我们简单的mask掉一部分的input token 如果只是简单的mask掉一些token，会导致pre-training和fine-tuning之间的不匹配问题，因为在下游任务重fine-tuning时是不需要mask掉token的 为了减小这种不匹配的程度，我们对mask做了一些改善，对于确定要进行mask操作的token，有以下三种处理方式： 80%的几率直接mask掉 10%的几率用随机的token代替 10%的几率使用 在进行完mask操作之后，就可以使用其所在的上下文对mask掉的token进行预测（使用交叉熵损失函数） Next Sentence Prediction 许多下游任务基于对句子间的关系的理解，而这些关系是无法通过LM进行捕获的 这里设计了一个根据一个句子生成下一个句子的任务 训练集的构建： 句子对A和B，50%的几率是真实的前后句，label为IsNext 50%的几率不是前后句，label为NotNext 关于fine-tuning 对于每一个下游任务，我们将任务特殊的Input和Output放入BERT中，并且微调每一个参数 迁移策略 BERT将大量传统的下游具体任务中的操作转移到预训练LM上，在预训练之后，只需加上不同的输出层并进行微调，就可以实现各种任务 与之相似的，在图像领域，很多模型都会迁移ImageNet的参数等 BERT的输入表示 从图示可以看出， 对于给定的输入，其输入表示有三部分的embedding组成： token的embedding，表示的是词向量，第一个是CLS标志（classification，即分类符） segment的embedding，用来区分两种句子，因为预训练有时要接受sentence pairs作为输入 Position的embedding，这个是transformer中要用到的，具体可以看一下tansformer的那片文章 说一点感受 MLM的工作原理是从输入中随机掩盖掉一些词，目的是基于其上下文来预测被掩盖的原始词汇，MLM允许representation融合上下文，这就使双向transformer得以应用。而transformer编码器并知道到它真正要预测的单词是哪些（并且按照论文中提到的操作，除了被掩盖掉，还有随机替换和不改变这两种方式），所以必须对每个输入保持分布式的上下文表示。 MLM中，随机替换的词只有15%*10%=1.5%，所以对于文章的原意并没有很大的影响，不会影响模型对于语言的理解 因为transformer有self-attention机制，所以可以理解为BERT自带双向功能 因为双向功能的存在，必须使用MLM来完成token级别的预训练 为了得到句子级别的语义表征，加入了NSP，与MLM联合训练 由于mask在实际应用中，mask不会出现，所以需要尽量减小预训练是mask操作带来的影响，论文取了15%。也就是说每个batch中只有15%用来做预测，所以BERT的收敛速度会很慢 参考资料 《BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding》","categories":[{"name":"自然语言处理","slug":"自然语言处理","permalink":"http://zivblog.top/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"}],"tags":[{"name":"NLP","slug":"NLP","permalink":"http://zivblog.top/tags/NLP/"},{"name":"论文笔记","slug":"论文笔记","permalink":"http://zivblog.top/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"}]},{"title":"《Pointer_Networks》笔记","slug":"指针网络","date":"2019-10-23T01:17:51.000Z","updated":"2020-07-06T05:49:03.841Z","comments":true,"path":"passages/zhi-zhen-wang-luo/","link":"","permalink":"http://zivblog.top/passages/zhi-zhen-wang-luo/","excerpt":"Pointer Network","text":"Pointer Network 写在前面 在学习segbot的时候接触到了指针网络，遂找了一下提出指针网络的开山之作《Pointer Network》 作者对PtrNet的了解到现在也只是论文中原始版本的模型，之后一些应用场景下的变体还未做深入了解 望不吝赐教，谢谢 是什么 简单来说，PtrNet是一种使用的Attention机制的网络结构，能够计算一个由目标序列指向源序列的指针序列 它能有效的解决当前文本序列生成模型的三个问题 目标序列的词表和源序列的词表强相关，这就意味着面对不同的任务或者特定的环境，需要构建相应的词表 传统S2S问题中，输出向量的长度往往是词表的长度。词表的长度是固定的，不能处理动态变长序列，长度作为超参数需要提前指定。每次超参数的修改都需要重新训练模型 许多场景下不允许OOV（Out Of Bag）的存在 模型详述 首先介绍一下attention机制中的对齐系数 在之前的文章《Attention机制简单总结》中，我们有简单介绍过对齐的作用和操作方式 以机器翻译为例，源序列与目标序列中的词并不是顺序对应的，所以需要由控制的使其对应起来，这就是对齐 说白了，对齐其实讲的就是一种相似度，是input和output对应位置的相似度 回到PtrNet，从上面的介绍我们知道了，对齐系数表示的其实是目标序列当前时刻和源序列所有时刻之间的相关性大小。很显然，既然相关性不一样，直觉上我们当然会选择相关性最大的。而这里再通过一个softmax，将目标序列当前时刻的对齐向量标准化，则对其向量中值最大的那个维度就是“Pointer”，只想源序列中与当前时刻相关性最大的词。 这样，解码器的每一个时刻我们都能从源序列中抽取出一个进行输出（例如阅读理解任务），并不需要构建词表，也就解决了词表需要重构的问题 而且，解码器的输出是一个指针序号的序列，并不是具体的词，所以也不会出现OOV问题 看一下模型的示意图吧 左边绿色的部分是输入序列，右边紫色的部分是输出序列 传统的Attention是将对齐向量和hidden state组合为context vector再求概率分布作为Attention层的输出 而PtrNet则是直接将对齐向量a通过softmax，指向输入序列中最有可能是输出的元素 上面的箭头就是所谓的“Pointer”，指向最有可能的输出 参考资料 《Pointer Networks》 https://zhuanlan.zhihu.com/p/73590690","categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://zivblog.top/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"论文笔记","slug":"论文笔记","permalink":"http://zivblog.top/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://zivblog.top/tags/Artificial-Intelligence/"}]},{"title":"常见的模型评估标准","slug":"常见的模型评估标准","date":"2019-10-21T07:56:06.000Z","updated":"2020-07-06T05:43:28.578Z","comments":true,"path":"passages/chang-jian-de-mo-xing-ping-gu-biao-zhun/","link":"","permalink":"http://zivblog.top/passages/chang-jian-de-mo-xing-ping-gu-biao-zhun/","excerpt":"常见的模型评估标准","text":"常见的模型评估标准 写在前面 平时做比赛和看论文的时候会看到一些模型的评估参数，都是碰到了再查，今天下定决心整理一下，给之后的工作省点劲 本文分为两块： 以西瓜书为主要参考资料的模型评估标准论述 以scikit-learn中文文档为主的相关函数使用方法 模型评估标准方法 留出法 简单来说就是将训练数据集划分为互斥的两部分，一部分用来训练模型，一部分用来评估模型的性能 需要注意的是： 训练集和测试集要保持数据的分布一致，从划分数据集时采样的方法来看，可以使用“分层采样” 另外，数据集的划分也存在很多种可能，所以一般都要使用多次留出法对模型进行评估，最后将均值作为评估的结果 此外，划分为两部分的数据集在规模上不宜相差过大，一般取2/3~4/5作为训练集，剩余的用作测试 交叉验证法 在了解留出法之后，理解交叉验证就会容易很多了 交叉验证的思想是： 将数据集划分为k个大小相同的互斥的数据集 使用其中k-1个数据集进行训练，使用剩余的一个作为测试集进行测试 从而进行k次训练和测试，最终返回的是k个测试结果的均值 它还存在一种特殊情况：k=样本个数，这种划分方式我们称为“留一法” 需要注意的是： 数据集划分的时候为了保证各个子集之间数据分布一致，使用“分层采样” 数据集的划分存在多种可能，一般要使用多次交叉验证，最后将均值返回 留一法在数据集较大的时候不适用，因为会十分显著的增加计算成本 自助法 以上两种方法在模型的训练过程中，并没有使用全部的数据，为了解决这个问题，提出了“自助法” 自助法： 对于数据集D，对齐进行随机放回的下采样，建立$D^{&#39;}$ 使用D用来训练模型，使用$D^{&#39;}$来进行测试 值得注意的是： 自助采样仍会一定程度上改变初始数据的分布，对测试结果有一定的影响 所以在初始数据量足够的情况下，使用留出法和交叉验证法比较好 模型性能评估 错误率与精度 错误率是分类错误的样本占样本总数的比例 精度是分类正确的样本占样本总数的比例 混淆矩阵 先解释一下各个值代表的含义： TP：表示被正确分类的正样本的个数 FP：表示被错误分类的负样本的个数 FN：表示被错误分类的正样本的个数 TN：表示被正确分类的负样本的个数 直观来讲，我们希望TP与TN的数量越大越好，而FP与FN的数量越小越好 针对混淆矩阵，又提出了四个二级指标： Accuracy（准确率）= $\\frac{TP+TN}{TP+TN+FP+FN}$：模型判断正确的结果占总观测值的比重 Precision（精确率）= $\\frac{TP}{TP+FP}$：在模型预测是正例的结果中，预测正确的比重 Sensitivity（灵敏度） = Recall（召回率）= $ \\frac{TP}{TP+FN}$：在真实值是正例的所有结果中，模型预测对的比重 Specificity（特异度）= $ \\frac{TN}{TN+FP}$：在真实值是负例的所有结果中，模型预测对的比重 针对上面四个指标，又提出了三级指标： F1-score = $\\frac{2PrecisionRecall}{Precision + Recall}$：综合和精确率与召回率产出的结果 ROC与AUC ROC和AUC是一个从整体上评价二分类模型性能的指标 其中AUC（Area Under Curve）是坐标系中AUC曲线下面的面积 ROC根据真阳率和假阳率分别作为纵坐标和横坐标 真阳率表示正样本被预测为正样本的比例，记为TPR 假阳率表示负样本被预测为正样本的比例，记为FPR 从图形的角度来看，我们希望真阳率越大越好，假阳率越小越好，也就是曲线越上凸越好 AUC的值越大越好 调包指南交叉验证 使用train_test_split对数据集进行划分 12345from sklearn.model_selection import train_test_splitfrom sklearn import datasetsiris = datasets.load_iris()X_train, X_test, y_train, y_test = train_test_split(iris.data, iris.target, test_size=0.25, random_state=0) 验证集的准备和使用 如果将数据集划分为：训练集、验证集、测试集，就会导致训练数据不足，因此这里可以使用交叉验证来实现 12345678910111213from sklearn.model_selection import cross_val_scorefrom sklearn.svm import SVCclf = SVC(kernel='linear', C=1)# cv是整数时，使用k-foldscores = cross_val_score(clf, iris.data, iris.target, cv=5) #5-foldprint(scores)# cv还可以详细设置数据集划分from sklearn.model_selection import ShuffleSplitcv = ShuffleSplit(n_splits=3, test_size=0.3, random_state=0)scores = cross_val_score(clf, iris.data, iris.target, cv=cv)print(scores) 学习到其他奇技淫巧，随时更新 参考资料 西瓜书，《机器学习》周志华 scikit-learn中文文档","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://zivblog.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://zivblog.top/tags/Artificial-Intelligence/"}]},{"title":"Transformer简单理解","slug":"transformer简单理解","date":"2019-10-21T03:07:16.000Z","updated":"2020-07-06T05:40:53.334Z","comments":true,"path":"passages/transformer-jian-dan-li-jie/","link":"","permalink":"http://zivblog.top/passages/transformer-jian-dan-li-jie/","excerpt":"《Attention is all you need》","text":"《Attention is all you need》 背景 传统的序列转换模型都是基于包含Encoder和Decoder的复杂的循环神经网络 比较好的模型都是在Encoder和Decoder之间使用attention连接 在此基础上，Google的Ashish Vaswani们提出了完全基于attention的网络结构——transformer 在机器翻译中有很好的表现，并且并行性更好，训练时间也大大的减少了 Transformer为什么使用transformer 在之前的模型中，关联任意两个输入和输出位置的信号所需要的操作次数都会随位置之间距离的增加而变得困难，所以会导致学习相隔较远距离的两个位置之间的依赖性变得十分困难，transformer中，将这种操作减少到了固定次数 而且因为使用了Multi-head attention，可以进行并行计算了 模型结构 Transformer是一种基于encoder-decoder结构的模型 在论文中 编码器： 由6个相同的层堆叠在一起，每层有两个子层，第一个子层是一个多头的自注意机制，第二层是一个简单的全连接前馈神经网络 另外两个子层外面都添加了一个残差链接，然后进行了层标准化的操作 解码器： 堆叠了6个相同的层，在编码器原有的两层之前加入了Masked Multi-Head Attention 同样也有残差连接和层标准化 这是论文中的给出的结构图，我们来一步步的看一下它的详细执行过程： 在Encoder中： Inputs在经过input embedding之后，再做positional encodings 之后要经过Multi-head attention 在经过position-wise Feed Forward 每个子层之间有残差连接 在Decoder中： 相比与Encoder，除了position encodings，Multi-head attention和position-wise Feed Forward之外，还有Masked Multi-head attention 最后还要经过Linear和Softmax输出概率 子结构介绍 Multi-head attention和Self attention都已经在上一篇文章中有所介绍了，详细请看 接下来说一下positional encodings 我们知道，不管是翻译还是其他文本相关的任务中，序列本身的位置信息是十分有用的。 而在transformer中，我们并没有使用任何的循环或者卷积，也就没有捕获到文本的序列信息。 所以我们要将token（序列中的字符或者词）的相对及绝对位置信息以另一种方式注入到模型中去。 所以这里使用到了positional encoding，也就是位置编码。 位置编码与token的embeddings的维度相同，所以可以直接相加 也可以选择将位置编码和token的embeddings拼接起来 2019.11.29 更新 我们构造的位置编码公式如下： $$PE_{2i}(p)=sin(\\frac{p}{10000^{\\frac{2i}{d_{pos}}}})$$ $$PE_{2i+1}(p)=cos(\\frac{p}{10000^{\\frac{2i}{d_{pos}}}})$$ $d_{pos}$表示的是词嵌入的长度，我们需要构造一个相同长度的$PE$ 其中，p表示词的位置，$PE_i(p)$表示第p个词位置向量汇总的第i个元素的值，然后将词向量与位置向量直接加和 指的注意的是，该向量中不仅包含了绝对位置信息，由于： $$sin(a+b)=sinasinb+cosacosb, cos(a+b)=cosacosb-sinasinb$$ 所以位置$p+k$的位置向量可以表示为位置p向量的线性变换，使得相对位置信息也得到的表示 残差模块 在上面的结构图中我们可以发现，在每个编码器中的每个子层的周围都有一个残差连接 残差的好处在于，由输入x得到输出f(x)变为由输入x得到输出f(x)+x，在对x求偏导是，加入常数项1，不会产生梯度消失的问题 Masked Multi-head attention masked的用法说来简单，就是对序列中对当前没用的位置的值进行掩盖，使其不起作用 在multi-head attention中使用到了padding mask： 在我们输入的每句话长度不同，所以要对较短的数据进行长度补齐（一般是用0），这些填充值并没有什么作用，所以需要masked掉 具体做法是，在填充位置上加上一个趋近于负无穷的数，经过softmax之后，这些位置的概率就会趋近于0，也就是达到了mask的目的 在decoder输入数据中使用了sequence mask： 预测t时刻的输出值$y_t$时，应该使用全部的输入序列和输出序列的$(y_1, … y_{t-1})$，所以训练的时候，就需要将t-1时刻之后的信息全部隐藏掉 具体做法是使用一个上三角矩阵，上三角全为1，下三角全为0，对角线值为0.与输入序列相乘，就达到了目的 最终的线性变换和Softmax层 解码的组件最后会输出一个实数向量，我们现在面临的问题就是如何把浮点数变成一个单词 线性变换层是一个简单的全连接神经网络，它可以把解码组建产生的响亮投射到一个比它大的多的对数几率向量中 比如说我们的模型从训练集中学习了10000个不同的单词，那么对数几率向量就是长度为10000的向量——每个单位长度对应一个单词的分数 接下来的Softmax层便是把这些分数转化成概率，概率最高位置对应的单词就会被选做该时刻的输出 三种不同方式使用的Multi-head Attention encoder-decoder的attention，query来自之前的decoder，keys和values来自encoder的输出。这使得解码器中每个位置能关注到输入序列的所有位置 在encoder中含有self-attention，在self-attention中，所有的keys，values，queries均来encoder之前一层的输出 decoder的self-attention层也一样，不同的是，在scaled dot attention操作中，加了一个masked的操作，保证softmax操作之后不会将非法的values连到attention中 参考资料 《Attention is all you need》 https://spaces.ac.cn/archives/4765/comment-page-1 https://www.cnblogs.com/huangyc/p/9813907.html","categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://zivblog.top/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"论文笔记","slug":"论文笔记","permalink":"http://zivblog.top/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://zivblog.top/tags/Artificial-Intelligence/"}]},{"title":"Attention机制简单总结","slug":"Attention机制简要总结","date":"2019-10-21T03:01:56.000Z","updated":"2020-07-06T05:05:56.019Z","comments":true,"path":"passages/attention-ji-zhi-jian-yao-zong-jie/","link":"","permalink":"http://zivblog.top/passages/attention-ji-zhi-jian-yao-zong-jie/","excerpt":"Attention机制简单总结","text":"Attention机制简单总结 写在前面 按照许多介绍Attention机制的博客的惯例，都会以图像领域的例子作为引子，这里也仿照诸位前辈的套路，对Attention做感性的认识。 实际上，Attention机制刚开始就是应用在图像领域中，并且取得了很好的效果，后来就有人尝试将Attention引入NLP领域中 以人的注意力机制为例，当我们看到一幅画的时候，我们虽然能够看到画的全貌，但是在深入观察的时候，眼睛真正聚焦的只是其中的画的一部分，也就是说，人脑对整幅画面的关注程度是不均衡的。用更形式话的语言来说就是——对于画面的不同局部，在人脑中成像时所占的权重是不同的。这种权重的思想就是AM的核心。 Attention Model在NLP中最早应用的领域是机器翻译。简单来说就是在Decode的时候，由于不同语言语法或者表述上的不同，每个时刻翻译的输出对应输入序列的不同局部，并且并不是顺序对应的，这时候利用Attention机制就很容易能够完成这项工作了。 Attention机制在NLP领域中有很广泛的应用，并且出现了很多变体，这里会尽可能全面的去介绍一下。本人才疏学浅，有遗漏或者表述错误的地方烦请指正。 如有侵权，请联系删除或注明 Attention的一个通用的定义 给定一组向量集合values，以及一个向量query，attention机制就是一种根据query计算values的加权求和的机制 Attention的重点就是每个value的权值的计算。相对应的，权值大的就意味着关注程度高，对于当前输出有更高的作用。 换言之，Attention机制是根据一些规则或者附加信息，对向量集合中抽取向量进行加权求和。 更简单粗暴一点的讲，**只要我们从向量中选取部分向量进行的加权求和，我们就使用的Attention** 更正：Attention与求和没有关系，重点是权重分配，也就是部分向量对于当前任务是积极的还是消极的 翻译任务中的Attention 核心思想：目标语言的每一个字应该是它在源语言中每个字的不同权重的加权和 在Encoder-Decoder结构中，Encoder会把所有的输入序列编码成统一的语义特征C在进行解码，因此，C中必须包含原始序列的全部信息，而它的长度就限制了存储信息的能力，也就限制了翻译的质量。 Attention机制在其中的应用方式就是，在每个时刻输入不同的C（不同的加权和）来解决只有一个C时信息存储能力不足的问题 对于上图来说，就是在Encoder和hidden之间了一层Attention，每一个$c_i$都会自动选取与当前索要输出的y最和是的上下文信息 而如何来选择合适的上下文信息呢，这就直接与权重（姑且以$a_{ij}$来表示）相关了，而权重是通过模型训练得到的 对于机翻的Attention机制，我们做更进一步的解释： 在Encoder的过程中保留每个隐藏状态（$h_1, … , h_n$） 对于Decoder的每一个时刻，此时能得到Decoder的输入和上一步的隐藏状态输出，所以可以得到当前步的隐藏状态，记为$S_t$ 在每一步进行$S_t \\cdot h_i$的到attention score —— 对应图中第二层 利用Softmax将attention score转化为概率分布（和为的概率） —— 对应第三行 按照得到的概率分布，计算Encoder和hidden states的加权和。这里得到的$Attention_t$就是Decoder在t时刻的注意力向量了 Attention机制的诸多变体Self-attention 出自《Attention is all you need》，该文章还提出了tranformer模型，我会尝试在另一篇文章中简单介绍一下 序列中每一字符对其上下文字符的影响作用都不尽相同，每个字对序列的语义信息贡献也不同，可以通过一种机制将源输入序列中字符向量通过加权的方式，融合所有字符的语义向量信息来产生新的向量，从一定程度上增强了语义信息 对于输入文本，我们对其中的每个字分别增强语义向量表示： 我们将每个字作为Query， 每一个文字由成对的&lt;key, value&gt;构成，它们都来自编码层 Self-Attention = $Attention(X, X, X)$，也就是说再序列内部做attention，寻找序列内部的关系 2019.11.1 更新 可以想到的是，在增加了self-attention之后，模型能更好的捕获句子长距离的相互依赖特征。因为self-attention是跨越距离直接将两个句子联系起来，而不是像RNN和LSTM那样通过会有遗忘的问题。 2019.11.29 更新 对于每一个self-attention，均有独立维护的的三个线性映射矩阵$（W_i^V, W_i^K, W_i^Q）$ 将输入的矩阵X与三个映射矩阵相乘，得到self-attention的三个输入Querys、Keys、Values 用Query和Keys的点积计算所有单词相对于当前词的得分score，该分数决定在编码该单词时其他单词给予了多少贡献 将score除以向量维度的平方根，在对其进行softmax归一化。这样对于每个单词都会获得所有单词对该单词编码的贡献分数，当然当前单词将获得最大分数，但也会关注其他单词的贡献大小 对于得到的socre，我们将其乘以每一个对应的value向量，即对所有向量加权求和，最后的输出就是self-attention对该向量的输出 这里额外解释一下Query、Key、Value的传统含义 Query从字面意思来讲，就是查询，查询“我与你们的相似度是多少？” Key是键，即Query要比较的值， Value是值，与Key一一对应， Query与key相似度为a，即Value的权重（通过$Softmax(q_t \\cdot k_s)$，得到$q_t$与$v_s$的相似度，再加权求和） 当Query来自解码层，Key、Value来自编码层时，就是最基本的attention 当Query和Key、Value均来自编码层时，就是我们这里讲的Self-Attention了，因为它计算的事序列内部的依赖关系 2019.10.23 更新 self-attention计算得到的分数值，决定了我们在某位置encode一个词的时候，对句子其他部分的关注程度，比如一些代词与其真正实体间对应关系 Multi-head Attention 对于Scaled dot-product attention，只是除以了一个$\\sqrt{d_k}$，以防止softmax进入梯度极小的区域 $$Attention(Q, K, V) = softmax(\\frac{QK^T}{\\sqrt{d_k}})V$$ 而Multi-head Attention是，从一个向量$q_t$出发 $$Attention(q_t, K, V) = \\sum^m_{s=1} \\frac{1}{z}exp(\\frac{&lt;q_t, k_s&gt;}{\\sqrt{s_k}})v_s$$ $$head_i = Attention(QW^Q_i, KW^K_i, VW^V_i)$$ $$MultiHead(Q, K, V) = Concat(head_1, …, head_h)$$ 注意，这里并行计算的多个Scaled Dot-Product Attention之间的参数是不共享的 2019.11.29 更新 Linear可以看作是一个没有激活函数的全连接层，各自维护了一个线性映射矩阵 multi-head attention即并行多个self-attention 对于每个self-attention的输出进行简单的拼接，并与一个映射矩阵相乘，从而得到整体矩阵的输出 参考：https://www.cnblogs.com/sandwichnlp/p/11612596.html 从两个方面提高了注意力层的性能： 扩展了模型专注于不同位置的能力 给出了注意力层的多个表示子空间 Soft Attention 所谓Soft，就是在求Attention的概率分布的时候，对于句子中的任意一个单词都给出一个概率 也就是说Soft是给每个单词都赋予了一个单词对齐概率 Hard Attention 与Soft Attention相对比来说，Hard Attention并没有为每个单词赋予一个对齐概率 它的做法是，直接从句子中找到某个特定的单词，然后把目标句子单词和这个单词堆砌，而其他输入句子中的单词硬性地规定其对齐概率为0 这种方式明显不够灵活，代价太高 并且已经被证明在图像领域可行，而在文本领域作用不大 Global Attention 在解码过程中，每一时刻的上下文向量都需要计算Encoder中每一个单词（所谓的Global）的Attention权重，再加权得到 Local Attention 首先找到一个对齐位置，在对齐位置左右大小固定的窗口内（所谓的Local）计算注意力权重，最终加权得到上下文向量 静态 Attention 对一个文档或者句子，计算每个词的Attention分布，然后加权得到一个向量来表示这个文档或者句子的向量表示 区别与Soft Attention，静态Attention只计算一个得到句子的向量表示 后面想到的2019.11.1更新 浅析一下attention的本质思想： 将source中的构成元素想象成是由一系列&lt;key, value&gt;数据对组成 如上图所示，给定target中的某个元素的Query，通过计算Query与各个key（K）的相似性与相关性，得到每个key对应value的权重稀疏，然后对value进行甲醛求和，即最终的attention值 而对于attention计算的第一阶段，计算相似度的方式有多种，常见的有：点积、cosin相似性、MLP网络 Attention的计算过程如上图所示， 首先根据Q和K计算权重权重系数 根据Q和K计算相似性 利用softmax进行归一化处理 根据权重对value加权求和 参考资料 https://www.jianshu.com/p/6b2e586f9256 http://www.360doc.com/content/18/0506/06/36490684_751494854.shtml https://blog.csdn.net/hahajinbu/article/details/81940355 https://blog.csdn.net/mpk_no1/article/details/72862348 《Attention is all you need》","categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://zivblog.top/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://zivblog.top/tags/Artificial-Intelligence/"}]},{"title":"GRU的简单理解与实现","slug":"GRU的简单理解与实现","date":"2019-10-16T11:42:08.000Z","updated":"2020-07-06T05:07:40.607Z","comments":true,"path":"passages/gru-de-jian-dan-li-jie-yu-shi-xian/","link":"","permalink":"http://zivblog.top/passages/gru-de-jian-dan-li-jie-yu-shi-xian/","excerpt":"GRU的简单理解与实现","text":"GRU的简单理解与实现 写在前面 之前介绍了传统的RNN和LSTM，GRU可以看作是LSTM的一种变体，它相较于LSTM网络结构更加简单，因此训练起来更加快速。 GRU是LSTM的变体，所以解决的也是RNN中的长距离依赖问题 GRU模型只有两个门：更新门（update gate）和重置门（reset gate） 门控神经网络（GRU） 下面依次介绍GRU模型中的更新门和重置门 ​ 图片来自参考资料1的论文配图 ​ 图片来自网络 更新门 首先，更新门的作用类似与LSTM中的遗忘门和输入门，决定要丢弃哪些信息以及添加哪些新信息 在上图中，z表示的是更新门，更新门的值越大说明前一时刻的状态信息带入的越多 $$h^j_t = (1-z^j_t)h^j_{t-1} + z^j_t \\widetilde{h}^j_i$$ t时刻的激活$h^j_t$是先前激活$h^j_{t-1}$与候选激活$\\widetilde{h}^j_i$之间的线性插值 $$z^j_t = \\sigma(W_z x_t + U_zh_{t-1})^j$$ $z^j_t$是更新门，用于决定unit更新其激活或者内容的程度 $$\\widetilde{h}^j_i = tanh(W_rx_t + U(r_t \\odot h_{t-1}))^j$$ 候选激活，计算方式和传统RNN单元类似 这种在现有状态和新的计算状态之间进行线性求和的过程类似于LSTM的单元，但是GRU没有任何机制可以控制其状态的暴露程度，每次整个状态都会暴露 重置门 重置门决定是否忘记过去的信息 在上图中，r表示的是重置门，重置门的值越小，说明忽略的信息越多 当重置的门趋近于0的时候，该单元相当于读取序列的第一个元素，也就是会完全遗忘掉之前的计算状态 $$r^j_t = \\sigma(W_rx_t+U_rh_{t-1})^j$$ 计算方式类似于更新门 以上就是GRU模型的unit介绍 代码实现1234567891011121314151617181920212223242526272829303132333435import torchimport torch.nn as nnfrom torch.autograd import Variableclass SimpleGRU(nn.Module): def __init__(self, input_size, hidden_size, output_size, num_layers=1): super(SimpleLSTM, self).__init__() self.hidden_size = hidden_size self.num_layers = num_layers # 三层神经网络 self.embedding = nn.Embedding(input_size, hidden_size) self.gru = nn.GRU(hidden_size, hidden_size, num_layers, batch_first=True) self.fc = nn.Linear(hidden_size, output_size) self.softmax = nn.LogSoftmax(dim=1) def forward(self, input, hidden_size): x = self.embedding(input) output, hidden = self.lstm(x, hidden) output = output[:, -1, :] output = self.fc(output) output = self.softmax(output) return output, hidden def initHidden(self): # 对隐含层单元的初始化 hidden = Variable(torch.zeros(self.num_layers, 1, self.num_layers)) # 对隐含单元内部的状态cell的初始化 cell = Variable(torch.zeros(self.num_layers, 1, self.hidden_size)) return (hidden, cell) 如果只是对GRU和LSTM来说的话，一方面GRU的参数更少，因而训练稍快或需要更少的数据来泛化。另一方面，如果你有足够的数据，LSTM的强大表达能力可能会产生更好的结果。 参考资料 《Empirical Evaluation of Gated Recurrent Neural Networks on Sequence Modeling》","categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://zivblog.top/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://zivblog.top/tags/Artificial-Intelligence/"}]},{"title":"支持向量机相关数学知识简介","slug":"支持向量机相关数学知识简介","date":"2019-10-12T03:46:35.000Z","updated":"2020-07-06T05:48:50.989Z","comments":true,"path":"passages/zhi-chi-xiang-liang-ji-xiang-guan-shu-xue-zhi-shi-jian-jie/","link":"","permalink":"http://zivblog.top/passages/zhi-chi-xiang-liang-ji-xiang-guan-shu-xue-zhi-shi-jian-jie/","excerpt":"支持向量机相关数学知识简介","text":"支持向量机相关数学知识简介 写在前面 接上文，这篇文章主要对支持向量机中涉及到的一些数学概念的整理，有表述错误指出还请指正 本文主要介绍以下几个知识点 什么是凸优化问题 拉格朗日乘子法及KKT条件 slater条件 SMO算法的简单介绍 凸优化问题 首先要说一下什么最优化问题 在机器学习等任务中，最主要的任务就是优化，也就是通过使用训练数据对机器学习算法中的参数进行训练，使模型的性能变得更好。那么进行参数更新的时候以什么为标准呢，那就是损失最小化；而损失最小化就是一个优化问题。 什么是凸优化问题 定义 $minimize f(x)$ $subject$ $to$ $g_i(x) &lt;= 0, i=1,…,m$ ​ $h_i(x) = 0, i=1,…p$ 简单来说就是，目标函数$f(x)$需要是凸函数，变量所属的集合是凸集合（凸集合指的是集合内任意两个点之间的连线，连线上的点都在集合内部） 为什么是凸优化 凸优化有着很好的性质，凸优化问题的局部最优解就是全局最优解 也就是说，凸函数的任意局部极值点也是全局极值点 Lagrange乘子法及KKT条件 什么是Lagrange乘子法 Lagrange乘子法是一种寻找变量受一个或多个条件限制时的多元函数极值的方法 该方法将一个有n个变量和k个约束条件的最优化问题转化为一个有n+k个变量的方程组的极值问题，转化后的问题的变量不受约束 例，下图 KKT条件 对于有不等式约束的优化问题，需要满足三个条件，满足这三个条件之后的函数的解就是极小值点 这三个条件就是KKT条件： 给定优化问题：$min f(x)$，subject to $g(x) &lt;= 0$ 则对应拉个朗日问题为：$L(x, \\alpha) = f(x) + \\alpha g(x)$ 要满足： $\\nabla_x L(x^*, \\alpha^*) =\\nabla f(x^*) + \\alpha^* \\nabla g(x^*)=0$ ： 偏导为0 $g(x) &lt;= 0$ ： 约束条件满足原条件 $\\alpha^* &gt;= 0$ ： 拉格朗日乘子非负 $\\alpha^* c(x^*) = 0$ ： 乘子为0或约束至少一个为0 这就是所谓的KKT条件 注意 如果优化问题是优化问题的话，KKT条件就是极小值点（全局极小）存在的充要条件，也就是求出来的解就是最小值点 如果优化问题不是凸优化问题，KKT条件知识极小值点存在的必要条件，KKT点是驻点，可能是极值点 Slater条件 Slater的官方定义为：存在x，使不等式约束$g(x) &lt;= 0$严格成立 也就是说，当slater条件成立且原问题是凸优化问题时，强对偶性成立（强对偶性指的是原问题（最小化）的最优值与对偶问题（最大化）的最优值相等） 因此，满足slater的凸优化问题可以转化为其对应的对偶问题进行求解 SMO简单介绍 SMO是针对求解SVM问题的Lagrange对偶问题 在SVM的对偶问题中，我们最后求解的变量只有一堆拉格朗日乘子，该算法的基本思想就是每次只选取一对$(\\alpha_i,\\alpha_j)$， 首先要明确的是，最小化的凸优化问题被我们转化成了最大化的对偶问题 对偶问题的二次规划表述如下： $max \\sum_{i=1}^n \\alpha_i - \\frac{1}{2}\\sum_{i=1}^n \\sum{j=1}^{n} \\alpha_i \\alpha_j y_i y_j x^T_i x_j$ $s.t. \\sum_{i=1}^n \\alpha_i y_i = 0$ $\\alpha_i &gt;= 0, i = 1,2,…,n$ SMO在整个二次规划中只做了两件事 选取一对参数$(\\alpha_i, \\alpha_j)$ 固定其他$\\alpha $，将$(\\alpha_i, \\alpha_j) $代入上述表达式进行求最优解，获得更新后的$(\\alpha_i, \\alpha_j )$ 不断执行这两个步骤直至收敛 根据上面的介绍，我们知道KKT条件是对偶问题最优解的必要条件 除了拉个朗日乘子非负的约束外，其他条件都是根据目标函数推导得到的最优解必须满足的条件， 如果违背了这些条件，那得到的解必然不是最优解，目标函数的值会减小 所以在SMO的迭代中，$(\\alpha_i, \\alpha_j )$其中如果有一个违背了KKT条件，一轮迭代后，目标函数必然会增大 也就是说，KKT条件违背的程度越大，迭代后的优化效果越明显 所以 为了找到优化程度最大的方向进行优化，SMO先选取违背KKT条件程度最大的变量，第二个变量选择使目标函数值增大最快的变量 如何找到使目标函数值增大最快的变量呢，SMO使用了一个启发式的方法，当确定了第一个变量之后，选择使两个变量对应样本之间最大的变量作为第二个变量。 直观上来说，就是更新两个差别很大的变量会给目标函数带来更大的变化 最后 以上是我在学习SVM的过程中对相关数学概念的简单了解，尚未进行深入的学习 希望对大家有帮助","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://zivblog.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://zivblog.top/tags/Artificial-Intelligence/"}]},{"title":"Dropout浅析","slug":"Dropout浅析","date":"2019-10-10T07:42:17.000Z","updated":"2020-07-06T05:07:05.534Z","comments":true,"path":"passages/dropout-qian-xi/","link":"","permalink":"http://zivblog.top/passages/dropout-qian-xi/","excerpt":"Dropout浅析","text":"Dropout浅析 写在前面 在第一次接触到dropout的时候，就被其极具智慧的思路所折服，这真的是一种能让人眼前一亮的想法 在写这篇文章之前，我查阅过多种形式的资料，有视频，有博客，有书籍。在这里记录一些学习过程中的注意点和思路以供后来者学习查阅 我会尽量详尽的去阐述我对该方法的想法，有不详细或错误的地方欢迎指出 Dropout的提出 2012年，Hintion大佬在论文《Improving neural networks by preventing co-adaptation of feature detectors》正式提出了dropout。 2012年，有是Hinton，还有Alex首次在其论文《ImageNet Classification with Deep Convolutional Neural Networks》中使用了dropout方法，并且凭借该论文提出的AlexNet获得了当年的图像识别冠军。 Dropout提出的原因 我们知道，神经网络一般包含巨量的参数，这样就要求要有大量的训练数据来对这些权重进行训练，但是这也带来了两个问题： 当数据量充足的时候，训练可以进行，但是极其耗费时间 当数据量与模型的复杂程度不匹配的时候，就会导致模型过拟合，缺乏泛化能力 Dropout的功能 为了解决上面阐述的两个问题，我们提出了Dropout，它理所应当要解决这些问题，下面一一阐述 对于与神经网络复杂程度不匹配的数据集规模（网络的复杂程度大于数据集规模），很容易导致过拟合，所以采取以下措施： 对每个训练样本，采用dropout的方法，随机让一部分神经元失效，以此来减少过拟合的程度 具体做法是： 训练阶段，每次更新参数之前，每个神经元有一定的概率被丢弃，假设为p%。这里需要注意，输入层的神经元要尽可能的保留 测试阶段，去掉dropout，所有神经元都保留。这里要注意要乘以(1-p)%，具体原因之后解释 通过模型融合的方式（多个基训练器共同决策）可以提高模型的性能，但是对于神经网络来说，单独训练多个不同的模型的代价太大，而且训练多个模型对训练数据的需求也是极大的；而且由于模型太复杂，即使是多个完整的网络模型融合，还会带来一个新的问题，就是决策的响应时间太长，不利用应用。于是： 由于dropout每次都丢弃部分神经元，可以视作每次都训练了一个不同形状的神经网络 最后测试阶段去掉dropout后，可以视作将多个模型进行融合 也就是说，加了dropout来训练的网络模型，可以视作另一种形式的集成学习，每一个batch训练的都是不同的基分类器 下面通过图片来直观感受一下 本图表示的是完整的神经网络 画红X的表示这部分神经元会在本轮训练中暂时“失效” 本图表示的是不同的训练轮次中，由于“丢弃”不同的神经元而导致神经网络变化成的不同的形状 测试过程中，由于不使用dropout，神经网络又变成了完整的形状 这张图回答了之前留下的小问题：为什么要乘(1-p)% 直观的就是，之前参与训练的都是保留下来的神经元（被保留的概率是(1-p)%），所以求loss和反向传播的时候都是(1-p)%z，为了保证输出期望一致，在启用所有神经元的时候也要乘(1-p)% 为什么Dropout能解决过拟合问题 通过类似取平均的方式减缓过拟合 我们考虑，使用相同的训练数据去训练多个不同的神经网络，对于几个网络的结果，我们可以通过投票或者取平均的方式来进行最终结果的判定 因为综合了多个网络的判定结果，能通过多个不同网络对不同结果的相互抵消来减轻整体上的过拟合 减少神经元之间复杂的共适应关系 在不使用dropout的时候，相邻的或者说是相关的多个神经元在更新权值的时候会相互影响以取得更好的结果。 这种方式虽然能够使模型在训练集上表现的很好，但是在测试集或者其他数据上，这种共适应关系会成为模型泛化的障碍 而使用了dropout之后，由于两个神经元不一定每次都同时出现，权值的更新会更加客观，减轻拥有隐含依赖的节点对整体的影响 从另一个角度来说，这种方式选择性的主动丧失对某些特征的敏感程度来增加鲁棒性 最后 在全连接神经网络中，dropout被大量的使用，通常设置为0.5或者0.3 而卷积神经网络的隐藏层由于其自身的部分连接特性，dropout使用的并不是很多 参考资料 《Improving neural networks by preventing co-adaptation of feature detectors》 《一天搞懂深度学习》李宏毅","categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://zivblog.top/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://zivblog.top/tags/Artificial-Intelligence/"}]},{"title":"CNN理解及简单实现","slug":"CNN的理解及简单实现","date":"2019-10-09T12:39:34.000Z","updated":"2020-07-06T05:06:41.261Z","comments":true,"path":"passages/cnn-de-li-jie-ji-jian-dan-shi-xian/","link":"","permalink":"http://zivblog.top/passages/cnn-de-li-jie-ji-jian-dan-shi-xian/","excerpt":"CNN理解及简单实现","text":"CNN理解及简单实现 写在前面 在前面RNN及LSTM理解中，我们思考了为什么要使用神经网络，并且列举了几点好处： 自动提取特征 数据格式的简易性 调参工作量大大减小 但是实际上并不会有十全十美的东西，也不会有适合与所有问题的解决方案。虽然神经网络在当下的许多任务中表现的十分优秀，但是它也存在一些缺点，下面我们就一起来思考一下 首先，随着我们不断加深神经网络的层数，每个网络层都会增加大量的神经元，与此同时带来的参数也会快速增长。我们知道，参数越多模型就越复杂，而复杂模型带来的问题也有很多 其一，模型容易过拟合 其二，大量参数的学习需要大量的数据为支撑 其三，传统神经网络来说，层数一旦太深，就容易随着反向传播的不断迭代，梯度越来越小，最终梯度趋于0的时候，神经元的权值无法更新，也就相当于对应的神经源并不起作用，同时也很难收敛 其次，由于神经网络内部是一个黑盒，人们并不能对内部工作的具体细节进行有效的解释 最后，耗时耗力，参数多意味着需要大量数据来训练，巨大的训练量也需要很长的训练时间和昂贵的硬件设备 暂时就想到这些，后面会继续补充 卷积神经网络（CNN） 卷积神经网络的最大特征就是它所包含的卷积计算，所以，卷积神经网络是一类包含卷积计算的具有深度结构的前馈神经网络。 卷积神经网络具有表征学习能力，能够按照其阶层结构对输入信息进行平移不变分类（来自“百度百科”）。被广泛应用到计算机视觉（CV）和自然语言处理（NLP）等领域 卷积神经网络可以进行监督学习和非监督学习，其隐含层的卷积和参数共享和层间连接的稀疏性使得卷积神经网络能够以较小的计算量对格点化特征（如像素和音频）进行学习，并且对数据没有额外特征工程的要求（来自“百度百科”） 卷积神经网络被应用到各个领域，像物体分割、风格转换等，但是CNN真正的作用就是一个特征提取器，这就是为什么在很多任务中，在CNN之后都要加各种神经网络的原因了。 为什么使用卷积神经网络 以最典型的图片识别为例： 首先，因为图像是由像素组成的，对于灰度图像（每个像素只有一个采样颜色）来说，如果图片大小为（48*48*1）,如果使用的是全连接神经网络，隐藏层只有一层，包含15个神经单元，则参数个数为：48*48*15*10+15+10=345625。所以参数太多，不便于反向传播计算，而卷积神经网络就相比之下参数少了很多，这个之后会细说。 ​ 其次，许多有用特征（比如鸟喙）在整张图片中占的地方很小，我们需要一个专门针对该类特征的特征选择器对其进行捕捉，传统的全连接神经网络是没有这种功能的，而卷积神经网络的卷积层做的就是该工作。 ​ 第三，除了局部特征，我们还要把握整体的特征，而且还有想缩小图片的需求（图片缩小 -&gt; 像素变少 -&gt; 训练加快），而池化层可以完成该项工作。 ​ 简要的说完这些，我想大概就能理解为什么卷积神经网络为什么在图像识别中表现如此突出了。 下面对卷积神经网络做基本介绍 包含三个基本层：卷积层、池化层、全连接层，这里主要介绍卷积层和池化层 卷基层 如上图所示， 对于一张6*6的图片，我们使用两个3*3的卷积核对其进行扫描，stride设为1（每次卷积和移动一个像素） 计算方法为（以第一次扫描为例）feature_map(1, 1)=1*1 + 0*-1 + 0*-1 + 0*-1 + 1*1 + 0*-1 + 0*-1 + 0*-1 + 1*1 = 3 ​ 这就是最简单的内积公式，按照此方法通过扫描，我们可以得到一个4*4的feature_map，这也就是我们通过一个卷积核抽取出来的特征了 卷积层的特征：局部感知，参数共享 不同的特征提取器（卷积核），对于图像扫描得到的结果是不同的 对于RGB的图像来说，卷积核也要变为深度为3的立体卷积核 池化层 在通过卷积核得到特征之后，我们想要减少数据量同时保留有用信息，这时就用到池化操作了 池化利用的是局部相关性原理，对提取出的特征进行subsampling 常用的池化方式有max-pooling和average-pooling 池化与卷积的操作方式类似，都是通过扫描进行的，不过池化的话是对滑动窗口中的值取max或者average 我们可以思考一下max pooling为什么是有效的？ 对于卷积层提取出来的特征，也就是一个更小的图片，我们对局部区域的像素取最大值，可以视作是提取出对该特征最有效的数值，而被舍弃的，则是对该特征没有特别大帮助的。 与此同时，减小了feature_map的尺寸，减少了参数，减小了计算量，效果却损失不大 但是，在周边信息有效的情况下强行删去，也会导致效果下降，所以最好的办法就是对比一下加上max pooling前后的效果再决定是否使用 Zero Padding 为了方面对边缘或者角上的特征进行提取，我们会加入zero_padding，也就是在图片的周围加上一圈0来填充 通过在周围填充0，也能达到图片经过卷积之后尺寸不变的效果 全连接层 在多次卷积池化之后，已经提取了很多特征，我们需要将其铺平，然后才能作为input输入的全连接层中，最终使用softmax进行分类 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# 使用Pytorchimport torchfrom torchvision import datasets, transformsfrom torch.utils.data import DataLoaderfrom torch.autograd import Variableimport torch.nn.functional as Fimport matplotlib.pyplot as pltimport numpy as np class SimpleCNN(torch.nn.Module): def __init__(self): super(SimpleCNN, self).__init__() # b, 3, 32, 32 layer1 = torch.nn.Sequential() layer1.add_module('conv1', torch.nn.Conv2d(3, 32, 3, 1, padding=1))//输入3维，输出32维，输出大小32＊32 # b, 32, 32, 32 layer1.add_module('relu1', torch.nn.ReLU(True)) layer1.add_module('pool1', torch.nn.MaxPool2d(2, 2)) # b, 32, 16, 16 //池化为16*16 self.layer1 = layer1 layer2 = torch.nn.Sequential() layer2.add_module('conv2', torch.nn.Conv2d(32, 64, 3, 1, padding=1)) # b, 64, 16, 16 处理成64维， 16＊16 layer2.add_module('relu2', torch.nn.ReLU(True)) layer2.add_module('pool2', torch.nn.MaxPool2d(2, 2)) # b, 64, 8, 8 self.layer2 = layer2 layer3 = torch.nn.Sequential() layer3.add_module('conv3', torch.nn.Conv2d(64, 128, 3, 1, padding=1)) # b, 128, 8, 8 处理成128维，4*4 layer3.add_module('rellu3', torch.nn.ReLU(True)) layer3.add_module('pool3', torch.nn.MaxPool2d(2, 2)) #b 128, 4, 4 self.layer3 = layer3 # 全连接输出 layer4 = torch.nn.Sequential() layer4.add_module('fc1', torch.nn.Linear(2048, 512)) layer4.add_module('fc_relu1', torch.nn.ReLU(True)) layer4.add_module('fc2', torch.nn.Linear(512, 64)) layer4.add_module('fc_relu2', torch.nn.ReLU(True)) layer4.add_module('fc3', torch.nn.Linear(64, 10)) self.layer4 = layer4 def forward(self, x): conv1 = self.layer1(x) conv2 = self.layer2(conv1) conv3 = self.layer3(conv2) fc_input = conv3.view(conv3.size(0), -1) fc_out = self.layer4(fc_input) return fc_out model = SimpleCNN() 参考资料 《一天搞懂深度学习》李宏毅","categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://zivblog.top/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://zivblog.top/tags/Artificial-Intelligence/"}]},{"title":"Python之文件的删除","slug":"Python之文件的删除","date":"2019-10-06T11:35:49.000Z","updated":"2020-07-06T05:44:13.047Z","comments":true,"path":"passages/python-zhi-wen-jian-de-shan-chu/","link":"","permalink":"http://zivblog.top/passages/python-zhi-wen-jian-de-shan-chu/","excerpt":"文件删除","text":"文件删除 写在前面 本文主要介绍文件的几种操作，包括： 判断文件是否存在 判断是文件or文件夹 删除文件和文件夹 递归删除文件夹下的所有文件（不包括文件夹） 使用的工具包为os，要记得import奥 判断文件是否存在123import osos.path.exists(path) 删除文件1234import osif os.path.exists(path): os.remove(path) 判断是文件还是文件夹1234567import os# 判断是否为文件print(os.path.isfile(path))# 判断是否为文件夹print(os.path.isdir(path)) 创建文件夹1234import osif not os.path.exists(path): os.makedirs(path) 删除文件夹1234import osif os.path.exists(path): os.removedirs(path) 递归删除文件夹下的所有文件1234567def del_file(dir_path): for i in os.listdir(dir_path): file_path = os.path.join(dir_path, i) if os.path.isfile(file_path) == True: os.remove(file_path) else: del_file(file_path) 介绍一种动态绝对路径的方法12345678'''很多时候会因为文件路径导致程序产生一些模型奇妙的问题一般来说，绝对路径是最保险的，但是缺点就是缺乏动态性这里我们使用：项目文件夹绝对路径+文件夹内相对路径，结合绝对路径和相对路径的优势，基本不会因为文件路径造成问题了'''project_path = os.path.dirname(os.path.abspath(__file__))file_path = os.path.join(project_path, dirname, file_name) 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://zivblog.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://zivblog.top/tags/Python/"}]},{"title":"人间失格","slug":"人间失格","date":"2019-10-05T11:50:40.000Z","updated":"2020-07-06T06:31:48.382Z","comments":true,"path":"passages/ren-jian-shi-ge/","link":"","permalink":"http://zivblog.top/passages/ren-jian-shi-ge/","excerpt":"见即所望，相遇即美好。","text":"见即所望，相遇即美好。 &emsp;&emsp;看这本书之前，看到的一些评论，对于这本书可谓毁誉参半，有些人将其吹捧到了天上，有些人将其踩到了脚底。 &emsp;&emsp;别人眼中平淡安逸的温水世界，在有些人脚下是铺满烧红石头的煎熬之路。 &emsp;&emsp;书中的“我”，内心脆弱，面对生活和世人会慌乱不知所措，不知道如何跟世界相处，我想有些人天生就是这样，有时候社交这样的事情并不是靠练习就可以做到如鱼得水的。 &emsp;&emsp;即便如此，他也是在努力的生活啊。有人会觉得，他并没有努力，因为他总是随波逐流，做太多自毁前程的事情。可是对于一个跟我们这些普通人根本不在一个世界的人来说，他有自己的世界观和价值观，也许我们所鼓吹的成功，他根本就不向往。 &emsp;&emsp;一个人生错了世界，这又能怪谁呢？ &emsp;&emsp;而正是因为意识到自己不该生而为人，但又想在已知的现实中活下去，他才会努力学习各种令人发笑的本领，说些违心但似乎人们爱听的话，这是一个“胆小鬼”积极的方式。就像一个刚出生的小孩在尝试触碰世界一样，可能会慢慢适应，也有可能会被吓到然后缩回去。 &emsp;&emsp;读不懂，只能说明我们与他不在同一个世界，或者说，我们并没有经历那个压抑的年代，这，是一种幸运。 &emsp;&emsp;这本书最可怕的是那种切身的带入感，它让你会不知不觉的携带上那种悲观的情绪，仿佛被世界抛弃。 &emsp;&emsp;成人以来，想不到有什么足够失望的事，生活足够简单，打球，游戏，代码，还有偶尔的一些悸动。 &emsp;&emsp;我自认为是一个无趣的人，不会聊天，不会社交，喜欢停留在舒适的人际圈中静静的生活。 &emsp;&emsp;我慢热也不喜欢热闹，如果对你热情，说明你对我很重要。 &emsp;&emsp;所见即所望，相遇即美好。 &emsp;&emsp;愿生活顺利，学有所成，所爱之人皆在幸福之中。 &emsp;&emsp;That‘s all。 按照惯例，下面是书中的一些句子。 相逢的喜悦乃是转瞬即逝的情愫，而唯有离别的伤痛却刻骨铭心。 我每时每刻都感到不安，感到忐忑，以至于无处可荣，我只有越发地依赖于酒精和麻醉药物给我带来的头晕目眩的感觉，只为求的片刻的平和安宁，结果却反而将自己弄的一塌糊涂。 谁说人非要快乐不可，说的好像快乐由的人选择。 我渴望着狂暴而巨大的欢乐，即是再大的悲哀接踵而至，我也在所不惜。 我是一个畏畏缩缩，总看别人脸色行事，对他人的信赖早已遍布裂纹的人。 我的不幸全来自自身的罪恶，所以不可能向任何人抗议。 我的不幸乃是一个人缺乏拒绝能力所带来的不幸。 “只是一切都将逝去”，这是我一致过着地狱般生活的这个所谓“人”的世界里，或许是唯一可以视为真理的一句话 我天生就是一个不会与人争辩的人，所以只能做出一副疲惫不堪或是感激涕零的表情。 世上所有人的说法，总是显得转弯抹角，含糊不清，其中有一种试图逃避责任似的微妙性和复杂性。 我只是对气氛骤然变换所带来的扫兴感到近于知悉的恐惧，所以，即是明知事后对自己不利，也必定会像往常一样，进行拼死拼活的服务 我甚至认为，与其对世人的“真实生活”感到畏惧，每个夜晚都在辗转难眠的地狱中呻吟叹息，还不如被关进牢房来的畅快和轻松 在我看来，伤口的疼痛就仿佛是它现货的情感，甚而爱情的呢喃。 我彷佛看见世界在一霎那间被地狱之火裹挟着，在我眼前熊熊燃烧起来。 越是对事物感到胆怯的神经质的人，就越是渴望暴风雨降临得更加猛烈 。 在与人交往时，我最介意的，就是唯恐出现那种可怕的沉默局面，所以，天生嘴笨的我才会抢先拼命地搞笑， 于是，我对人类的节俭不禁感到黯然神伤。 我与别人几乎从不交谈，该说些什么，该怎么说，我都摸不着头脑。 表面上我不断地强装出笑脸，可在内心确实对人类拼死拼活地服务，命悬一线的服务，汗流浃背地服务。 他们寥寥数语的责备，在我看来如同晴天霹雳一般，是我几近疯狂，哪里还谈得上以理相争呢。 我一直对人类畏惧不已，并因为这种畏惧而感到颤栗，对自己作为人类的一员的言行也毫无自信，只好将肚子的懊恼深藏进胸中的小匣子里，将精神上的忧郁和过敏封存起来，伪装成天真无邪的乐天外表，把自己一步步地彻底打磨成搞笑的畸人。 这种绝对的追求因为缺乏显式的根据和足够的心理准备，一遇到挫折就会很容易蜕变成强烈的自卑和完全的自暴自弃，要么完美，要么彻底破灭","categories":[{"name":"读书&电影","slug":"读书-电影","permalink":"http://zivblog.top/categories/%E8%AF%BB%E4%B9%A6-%E7%94%B5%E5%BD%B1/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://zivblog.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"机器学习之支持向量机","slug":"机器学习之支持向量机","date":"2019-10-02T10:36:00.000Z","updated":"2020-07-06T05:45:16.251Z","comments":true,"path":"passages/ji-qi-xue-xi-zhi-zhi-chi-xiang-liang-ji/","link":"","permalink":"http://zivblog.top/passages/ji-qi-xue-xi-zhi-zhi-chi-xiang-liang-ji/","excerpt":"支持向量机","text":"支持向量机 算法要点 支持向量机学习的基本想法是求解能够正确划分训练数据集并且几何间隔最大的分离超平面 对训练数据集找到几何间隔最大的超平面意味着以充分大的置信度对训练数据进行分类 支持向量机是：最大化分类间隔的线性分类器 三种情况 训练数据线性可分时，通过硬间隔最大化，得到线性可分支持向量机 训练数据近似线性可分时，通过软间隔最大化，得到线性支持向量机 训练数据线性不可分时，通过使用核技巧及软间隔最大化，得到非线性支持向量机 函数间隔和几何间隔 函数间隔 可以表示分类预测的正确性和确信度 表示为$\\gamma_i = y_i(w \\cdot x_i + b)$ 几何间隔，对函数间隔的法向量w进行规范化等约束，防止参数成比例改变带来的问题 对函数间隔中的$w$和$b$进行归一化处理之后就是几何间隔了 几何间隔表示为：$\\gamma_i = y_i(\\frac{w}{||w||} \\cdot x_i + \\frac{b}{||w||})$ 支持向量 训练数据集的样本点中与分离超平面距离最近的样本点的实例称为支持向量 支持向量是使约束条件式等号成立的点 决定分离超平面时，只有支持向量起作用 间隔边界 支持向量所在的两个超平面称为间隔边界 间隔依赖于分离超平面的法向量$w$，等于$\\frac{2}{||w||}$ 松弛变量 在线性支持向量机中，会存在某些样本点无法满足函数间隔大于等于1的约束条件 为了解决这个问题，对每个点引入松弛变量，使函数间隔加上松弛变量大于等于1 约束条件变为：$y_i(w \\cdot x_i + b) &gt;= 1 - \\xi_i$ 惩罚因子 因为引入了松弛变量的样本点分类的置信度是不足够大的，所以对于每个松弛变量，支付一个代价（乘以一个系数） $C &gt; 0$ C值大时对误分类的惩罚增大，C值小时对误分类的惩罚减小 核函数 非线性分类问题无法在当前的空间内实现分类，需要映射到更高维的空间来寻找分割超平面 所采用的方法是进行一个非线性变换，将非线性问题转换为线性问题 首先使用一个变换将原空间的数据映射到新空间 在新空间中使用线性分类学习方法从训练数据中学习分类模型 核技巧的思想是：在学习和预测过程中，只定义核函数$K(x, z)$，而不显式地定义映射函数 在SVM中的应用就是将目标函数和决策函数中的实例与实例之间的内积使用核函数代替 SMO算法（sequential minimal optimization，序列最小优化算法） SMO算法是支持向量机学习的一种快速算法 不断将原二次规划问题分解为只有两个变量的二次规划子问题，并对子问题进行解析求解，直到所有变量满足KKT条件为止 通过启发式的方法得到原二次规划问题的最优解 SVM算法理解 SVM脉络图 ​ 图片来源：公众号SIGAI 线性分类器 SVM可以说是起源于线性分类器，所以理解线性分类器对理解SVM是有很大帮助的 线性分类器是在n维空间中的分类超平面，将空间分割成两个部分 对于二维空间，线性分类器是一条直线；对于三维空间，线性分类器是一个平面 线性分类器的超平面方程为：$w^Tx + b = 0$，其中$w和b$是通过训练得到的参数 最大化分类间隔（线性可分支持向量机） 一般情况下，给定一组训练样本，可行的线性分类器不止一个 如何在所有可行的线性分类器中选择效果（泛化能力）最好的分类器呢？（有一下几点考虑） 分类平面不应该偏向任何一类 距离两个类别的样本都要尽可能的远 这样，就是我们最大化间隔的基本就形成了；最大化间隔就是SVM的基本思想 如何衡量间隔是最大的呢？ 假设：给定训练样本集I，特征向量有n维，类别标签为-1和+1 SVM为该分类任务寻找最优分类超平面：$w^Tx + b = 0$ 首先，保证每个样本被正确的分类，即： 对于正样本，$w^Tx + b &gt;= 0$ 对于负样本，$w^Tx + b &lt;= 0$ 可以统一写成：$y_i(w^Tx_i + b) &gt;= 0$，其中$y_i$是训练集样本的标签 其次，超平面距离两类样本的距离要尽可能大， 每个样本点到超平面的举例为：$d = \\frac{|w^Tx_i + b|}{||w||}$ $||w||$是向量的L2范数，是一个常数（范数是对向量长度的一种度量） 对于超平面方程，两边同乘不等于0的常数，还是用一个超平面，根据此特性可以化简求解问题 给$w$和$b$加上如下约束，$min_{x_i}|w^Tx_i + b|=1$ 消掉此冗余并化简点到超平面距离计算公式，分类超平面的约束变成：$y_i(w^Tx_i + b)&gt;=1$ 分类超平面与两类样本之间的间隔为： $d(w, b) = min_{x_i,y_i=-1}d(w, b; x_i)+min_{x_i, y_i=1}d(w, b; x_i)= \\frac{2}{||w||}$ 目标是使该间隔最大化，这与最小化$||w||$等价，同时也与最小化$\\frac{1}{2}||w||^2$等价 于是，优化问题最后变成 $$min \\frac{1}{2}w^Tw$$ $$y_i(w^Tx_i+b) &gt;= 1$$ 这是一个凸优化问题，并且满足Slater条件 凸优化问题意味着我们可以得到全局最优解 满足Slater条件意味着我们可以用拉格朗日对偶将其转化为对偶问题（对偶问题的求解会更加简单）进行求解 对偶问题 之前的优化问题中，包含许多的不等式约束，因此通过拉格朗日对偶将其转化成对偶问题，对偶问题为： $$min_\\alpha \\frac{1}{2}\\sum^l_{i=1}\\sum^l_{j=1}\\alpha_i\\alpha_jy_iy_jx_i^Tx_j - \\sum^l_{i=1}\\alpha_i$$ $$\\alpha_i &gt;= 0, i=1,…,l$$ $$\\sum^l_{i=1}\\alpha_iy_i = 0$$ 这里的$\\alpha$是拉个朗日乘子变量，在对偶问题中，它们是优化变量 值得注意的是，只有问题满足强对偶条件，也就是原问题与对偶问题有相同的最优解 强对偶成立的判断依据是Slater条件 梳理一下 初始是最大化间隔：$\\frac{1}{2} ||w||^2，s.t. y_i(w \\cdot x_i + b) - 1 &gt;= 0$ 应用拉格朗日对偶性构建拉格朗日函数（引入拉格朗日乘子$\\alpha $） $L(w, b, \\alpha) = \\frac{1}{2} ||w||^2 - \\sum^N_{i=1}\\alpha_iy_i(w \\cdot x_i + b) + \\sum^N_{i=1}\\alpha_i$ 根据拉格朗日对偶性，原始问题的对偶问题是极大极小问题：$max_\\alpha min_{w, b}L(w, b, \\alpha)$ 对于该问题，我们先求对$w$和$b$的极小，再对$\\alpha $求极大 求极小的方法就是将$L(w, b, \\alpha )$对$w$和$b$求偏导并令其等于0 将偏导数等于0代会，可得： $min_{w, b} L(w, b, \\alpha ) = -\\frac{1}{2} \\sum^N_{i=1}\\sum^N_{j=1} \\alpha_i \\alpha_j y_i y_j(x_i \\cdot x_j) + \\sum^N_{i=1} \\alpha_i$ 下一步是对上式再对$\\alpha $再求极大，但是我们可以对上式两边同乘-1转化为求极小的问题，即： $$max_\\alpha min_{w, b} L(w, b, \\alpha) = min_\\alpha \\frac{1}{2} \\sum^N_{i=1}\\sum^N_{j=1} \\alpha_i \\alpha_j y_i y_j(x_i \\cdot x_j) + \\sum^N_{i=1} \\alpha_i$$ 求得最优解$\\alpha^{*} = (\\alpha^{*}_i, …, \\alpha^{*}_N)$ 计算 $w^{*} = \\sum^N_{i=1}\\alpha^{*}_iy_ix_i$ $b^{*} = y_i - \\sum^N_{i=1}\\alpha^{*}_iy_i(x_i \\cdot x_j)$ 求得分离超平面：$w^{*} \\cdot x + b^{*} = 0$ 决策函数：$f(x) = sign(w^{*} \\cdot x + b^{*})$ 线性支持向量机 引入了惩罚因子和松弛变量 也可以通过转化为对偶问题解决 如下： $$min_\\alpha \\frac{1}{2}\\sum^l_{i=1}\\sum^l_{j=1}\\alpha_i\\alpha_jy_iy_jx_i^Tx_j - \\sum^l_{i=1}\\alpha_i$$ $$0 &lt;= \\alpha_i &lt;= C$$ $$\\sum^l_{j=1}\\alpha_jy_j = 0$$ 相比于线性可分的对偶问题，多了个$\\alpha_i &lt;= C$的约束 分离超平面$\\sum^N_{i=1}\\alpha^{*}_iy_i(x \\cdot x_i) +b^{*} = 0$ 决策函数为$f(x) = sign(\\sum^l_{i=1}\\alpha_i^{*}y_i(x \\cdot x_i) + b^{*})$ 非线性可分支持向量 使用的核技巧，还是线性可分的问题 对偶问题变为 $$min_\\alpha \\frac{1}{2}\\sum^l_{i=1}\\sum^l_{j=1}\\alpha_i\\alpha_jy_iy_j\\phi(x_i)^T\\phi(x_j) - \\sum^l_{i=1}\\alpha_i$$ = $$min_\\alpha \\frac{1}{2}\\sum^l_{i=1}\\sum^l_{j=1}\\alpha_i\\alpha_jy_iy_jK(x_i, x_j) - \\sum^l_{i=1}\\alpha_i$$ $$0 &lt;= \\alpha_i &lt;= C$$ $$\\sum^l_{j=1}\\alpha_jy_j = 0$$ 决策函数为$f(x) = sign(\\sum^l_{i=1}\\alpha^{*}_iy_iK(x , x_i) + b^{*})$，其中$K(x, x_i)= \\phi(x) \\cdot \\phi(x)$ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192import numpy as npimport pandas as pdfrom sklearn.datasets import load_irisfrom sklearn.model_selection import train_test_splitimport matplotlib.pyplot as pltdef create_data(): iris = load_iris() df = pd.DataFrame(iris.data, columns=iris.feature_names) df['label'] = iris.target df.columns = ['sepal length', 'sepal width', 'petal length', 'petal width', 'label'] data = np.array(df.iloc[:100, [0, 1, -1]]) # 将三类转化成两类：（1，-1） for i in range(len(data)): if data[i, -1] == 0: data[i, -1] == -1 return data[:, :2], data[:, -1]class SVM: def __init__(self, max_iter=100, kernel='linear'): self.max_iter = max_iter self._kernel = kernel def init_args(self, features, labels): self.m, self.n = features.shape self.X = features self.Y = labels self.b = 0.0 # 将Ei保存在一个列表中 self.alpha = np.ones(self.m) self.E = [self._E(i) for i in range(self.m)] # 松弛变量 self.C = 1.0 def _KKT(self, i): y_g = self._g(i) * self.Y[i] if self.alpha[i] == 0: return y_g &gt;= 1 elif 0 &lt; self.alpha[i] &lt;self.C: return y_g == 1 else: return y_g &lt;= 1 def _g(self, i): # g(x)预测值，输入xi(X[i]) r = self.b for j in range(self.m): r += self.alpha[j] * self.Y[j] * self.kernel(self.X[i], self.X[j]) return r def kernel(self, x1, x2): # 核函数 if self._kernel == 'linear': return sum([ x1[k] * x2[k] for k in range(self.n)]) elif self._kernel == 'poly': return (sum([ x1[k] * x2[k] for k in range(self.n)]) + 1) **2 return 0 def _E(self, i): # E(x)为g(x)对输入x的预测值和y的差 return self._g(i) - self.Y[i] def _init_alpha(self): # 外层循环遍历所有满足0&lt;a&lt;C的样本点， 检验是否满足KKT index_list = [i for i in range(self.m) if 0 &lt; self.alpha[i] &lt; self.C] # 否则遍历整个训练集 non_satisfy_list = [i for i in range(self.m) if i not in index_list] index_list.extend(non_satisfy_list) for i in index_list: if self._KKT(i): continue E1 = self.E[i] # 如果E2是+，选择最小的；如果E2是负的，选择最大的 if E1 &gt;= 0: j = min(range(self.m), key=lambda x: self.E[x]) else: j = min(range(self.m), key=lambda x: self.E[x]) return i, j def _compare(self, _alpha, L, H): if _alpha &gt; H: return H elif _alpha &lt; L: return L else: return _alpha def fit(self, features, labels): self.init_args(features, labels) for t in range(self.max_iter): # train i1, i2 = self._init_alpha() # 边界 if self.Y[i1] == self.Y[i2]: L = max(0, self.alpha[i1] + self.alpha[i2] - self.C) H = min(self.C, self.alpha[i1] + self.alpha[i2]) else: L = max(0, self.alpha[i2] - self.alpha[i1]) H = min(self.C, self.C + self.alpha[i2] - self.alpha[i1]) E1 = self.E[i1] E2 = self.E[i2] # eta = k11 + k22 - 2k12 eta = self.kernel(self.X[i1], self.X[i1]) + self.kernel( self.X[i2], self.X[i2]) - 2*self.kernel(self.X[i1], self.X[i2]) if eta &lt;= 0: continue alpha2_new_unc = self.alpha[i2] + self.Y[i2] * (E1 - E2)/eta alpha2_new = self._compare(alpha2_new_unc, L, H) alpha1_new = self.alpha[i1] + self.Y[i1] * self.Y[i2] * ( self.alpha[i2] - alpha2_new) b1_new = -E1 - self.Y[i1] * self.kernel(self.X[i1], self.X[i1]) * ( alpha1_new - self.alpha[i1]) - self.Y[i2] * self.kernel( self.X[i2], self.X[i1]) * (alpha2_new - self.alpha[i2]) + self.b b2_new = -E2 - self.Y[i1] * self.kernel(self.X[i1], self.X[i2]) * ( alpha1_new - self.alpha[i1]) - self.Y[i2] * self.kernel( self.X[i2], self.X[i2]) * (alpha2_new - self.alpha[i2]) + self.b if 0 &lt; alpha1_new &lt; self.C: b_new = b1_new elif 0 &lt; alpha2_new &lt; self.C: b_new = b2_new else: # 选择中点 b_new = (b1_new + b2_new)/2 # 更新参数 self.alpha[i1] = alpha1_new self.alpha[i2] = alpha2_new self.b = b_new self.E[i1] = self._E(i1) self.E[i2] = self._E(i2) print(\"train_done!\") def predict(self, data): r = self.b for i in range(self.m): r += self.alpha[i] * self.Y[i] * self.kernel(data, self.X[i]) return 1 if r &gt; 0 else -1 def score(self, X_test, y_test): right_count = 0 for i in range(len(X_test)): result = self.predict(X_test[i]) if result == y_test[i]: right_count += 1 return right_count / len(X_test) def _weight(self): yx = self.Y.reshape(-1, 1) * self.X self.w = np.dot(yx.T, self.alpha) return self.wif __name__ == \"__main__\": X, y = create_data() X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25) plt.scatter(X[:50,0],X[:50,1], label='0') plt.scatter(X[50:,0],X[50:,1], label='1') plt.show() svm = SVM(max_iter=200) svm.fit(X_train, y_train) score = svm.score(X_test, y_test) print(score) 关于凸优化问题、拉格朗日乘子法、slater条件、KKT条件、SMO会在另一篇文章中进行整理参考资料 《统计学习方法（第二版）》 黄海广博士的代码 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://zivblog.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://zivblog.top/tags/Artificial-Intelligence/"}]},{"title":"RNN及LSTM理解","slug":"RNN及LSTM理解","date":"2019-09-27T14:12:45.000Z","updated":"2020-07-06T05:40:29.428Z","comments":true,"path":"passages/rnn-ji-lstm-li-jie/","link":"","permalink":"http://zivblog.top/passages/rnn-ji-lstm-li-jie/","excerpt":"RNN &amp; LSTM","text":"RNN &amp; LSTM 写在前面为什么要使用神经网络呢？ 自动提取特征 很多人可能会有类似的疑问，机器学习已经可以解决绝大部分问题了，为什么还要使用多种神经网络呢？ ​ 我们来回想一下，在传统机器学习模型的搭建过程中，我们首先要把数据处理成能够输入到模型中的形式，这一步我们称作特征工程。而且在很多时候时候，特征工程占据了我们整个项目的绝大多数时间。特征数目过少，我们会无法精确的完成任务；特征数目过多，又会导致模型的泛化能力下降。也就是说，特征构造的好坏直接决定了我们模型的上限，最终还是由“人”来完成的绝大部分工作。 ​ 神经网络的出现，使我们不需要做大量的特征工程的工作，我们只需要直接把数据灌进神经网络中，它就会在训练的过程中自我修正，自动学习到需要的特征。 数据格式的简易性 ​ 传统的机器学习中，我们需要对数据进行一些处理，比如归一化、格式的转化等 ​ 而在神经网络中，我们可以直接把数据投入其中，不需要对数据进行大量额外的处理 调参的工作量大大减小 ​ 在机器学习中，每个参数的调整都拥有背后的理论依据，我们想要将参数调整到一个较好的状态，需要掌握很扎实的算法知识 ​ 对于一个简单的三层神经网络来说，我们只需要随机初始化给每一个神经元一个权重和偏执项，大量的参数调整工作在网络的自学习过程中会自动实现 下面会简单记录一下在学习循环神经网络（RNN）及长短期记忆网络（LSTM）过程中的一些想法 循环神经网络（RNN） 循环神经网络是由John Hopfield等人提出来的神经网络模型 它的最大不同之处就在于它的连接存在着大量的环路，信息在传递的过程中有很大概率在网络中保留；而人工神经网络和卷积神经网络，它们工作的前提是：元素之间相互独立，输入输出之间互不干扰，因此相比于CNN等，RNN就具有了“记忆”的功能，也就拥有了处理对序列信息敏感的数据，例如音频、文本等 ​ 如上图所示，循环神经网络的最大特点就是它的隐含层中包含大量的循环连接 ​ 也就是说输入t时刻的输入$X_t$经过输入层（变为$X_tW_{Xt}$）进入隐含层，而隐含层节点当前时刻的输出$h_t$并不是仅仅与输入层过来的$X_tW_{Xt}$有关，还与上一时刻的输出$h_{t-1}$有关，也就是说这两项共同决定了隐藏层的输出 ​ 在隐含层和输出层的最后一步运算都要经过一个非线性的映射，即激活函数，可以是sigmod或这其他函数 ​ S时刻的输出可以表示为：$S_t = softmax(softmax(W_{Xh}X_t + W_{hh}h_{t-1}) * W_{hY})$ ​ 在这里$W_{Xh}, W_{hh}, W_{hY}$分别表示的是输入层到隐含层的权重，隐含层内上一时刻输出连接到当前时刻输出的权重，隐含层输出到输出层的权重 使用Pytorch实现简单的RNN 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import torchimport torch.nn as nnfrom torch.autograd import Variableclass SimpleRNN(nn.module): # 初始化 def __init__(self, input_size, hidden_size, output_size, num_layers=1): # 定义 super(SimpleRNN, self).__init__() # 超参数定义 self.hidden_size = hidden_size self.num_layers = num_layers # 各层网络：三层，分别是embedding、rnn层、全连接输出层 self.embedding = nn.Embedding(input_size, hidden_size) # batch_size表示可以让输入张量的第一个维度表示batch指标，默认是时间 self.rnn = nn.RNN(hidden_size, hidden_size, num_layers, batch_first= True) self.fc = nn.Linear(hidden_size, output_size) # logsoftmax层 self.softmax = nn.LogSoftmax(dim=1) # 前向运算过程(当前的输入， 上一时刻的输出) def forward(self, input, hidden): # embedding层的计算 # input的尺寸是：(batch_size, num_step, data_dim) x = self.embedding(input) # x的尺寸是：(batch_size, num_step, hidden_size) output, hidden = self.rnn(x, hidden) # output的尺寸：(batch_size, num_step, hidden_size) output = output[:, -1, :] # 获取RNN最后一个时刻的隐含层状态作为这一层的输出 # output的尺寸：(batch_size, hidden_size) # 输入最后一层全连接网络 output = self.fc(output) # output尺寸：(batch_size, output_size) # softmax函数 output = self.softmax(output) return output, hidden # 初始化隐含层神经单元 def initHidden(self): return Variable(torch.zeros(self.num_layers, 1, self.hidden_size))'''rnn层：当第一个维度的尺寸大于一的时候，RNN就会运行多步而RNN的输出output的维度是随着输入x变化的，也就是说，如果x执行的是t个步骤，那么output中就包含了t步的每一步RNN隐含层的输出所以要取最后一个时刻的隐含层状态作为该层的输出'''if __name__ = \"__main__\": # 简单使用 rnn = SimpleRNN(input_size=1, hidden_size=2, output_size=26) # 交叉熵损失函数 criterion = torch.nn.NLLLoss() # adam优化算法 optimizer = torch.optim.Adam(rnn.parameters(), lr=0.001) loss = 0 # 初始化隐含层神经单元 hidden = rnn.initHidden() # 对每一个序列的所有字符进行循环 for t in range(len(seq)-1): # 当前自负作为输入，下一字符作为标签 x = Variable(torch.LongTensor([seq[t]]).unsqueeze(0)) # x尺寸：(batch_size=1, time_steps=1, data_dimension=1) y = Variable(torch.LongTensor([seq[t+1]])) # y尺寸：(batch_size=1, data_dimension=1) output, hidden = rnn(x, hidden) # output尺寸：(batch_size, output_size=26) # hidden尺寸：(layer_size=1, batch_size=1, hidden_size) loss += criterion(output, y) # 计算损失函数 loss = 1.0 * loss/len(seq) # 计算每字符的损失数值 optimizer.zero_grad() # 梯度清空 loss.backward() # 反向传播 optimizer.step() 长短期记忆网络 虽然RNN已经能解决记忆问题了，但是从实践运行的角度来看，RNN的记忆能力有限，只能记住几十部以内的模式，无法完成更长时间的记忆。 直观来讲，是因为每个隐含层单元计算的最后一步都要进过一个非线性激活函数，而这些函数大多输出一个位于[0, 1]之间的数，因此输入值只能保留一个分数进行输出，多步下来就会导致数值（信息）衰减的很快。 LSTM与RNN的区别就是，LSTM使用的是经过改造的RNN的隐藏层单元。既然RNN爱忘事，那么我们就想些办法阻止它，也就是LSTM中加入的门控开关：输入门、输出门、遗忘门。 下面对LSTM的具体内部细节做一下讲解。 下面是简单RNN网络的架构图 LSTM在RNN的基础上引入节点状态信息，并通过遗忘门和输入们更新节点状态，最后通过输出门控制更新后的节点状态信息输出，如下图 贯穿在图上方的水平线为细胞状态，黄色的矩形是学习得到的网络层，粉色圈表示运算操作，黑色的箭头表示向量的传输 首先看一下遗忘门 ​ 遗忘门决定哪些信息需要从细胞状态中被遗忘 ​ 遗忘门以上一层的输出$h_{t-1}$和本层的输入$x_t$作为输入，通过一个sigmod函数，得到输出$f_t$，输出值表示的是上一层的状态被遗忘的概率 ​ $f_t = sigmod(W_f \\cdot [h_{t-1}, x_t] + b_f)$ 之后是输入门 ​ 输入门包含两部分，第一部分使用sigmod函数，输出为$i_t$；第二部分使用tanh函数，输出为$C_t$ ​ 可以理解成$C^{“}_t$是网络中本层的输出，$i_t$是概率，表示的是$C^{“}_t$在网络中被保留的程度 ​ 所以$i_t*C^{“}_t$表示的就是该层被保留的程度 ​ $i_t = sigmod(W_i \\cdot [h_{t-1}, x_t] + b_i)$ ​ $C^{‘’}t = tanh(W_c \\cdot [h{h-1}, x_t] +b_C)$ 最后的是输出门 ​ 输出门用来控制该层的细胞状态有多少被过滤。 ​ 首先使用sigmod函数得到一个[0, 1]之间的概率$o_t$，接着将细胞状态$C_t$通过tanh函数处理后与$o_t$相乘，得到本层的输出（输出会传入下一个细胞作为下个细胞的一个输入，也会直接输出到下一层） ​ $o_t = sigmod(W_o \\cdot [h_{t-1}, x_t] + b_o)$ ​ $h_t = o_t * tanh(C_t)$ 另外 ​ 接上面的知识，$f_t$是遗忘门的输出，控制着上层细胞状态$C_{t-1}$被遗忘的程度，即$f_t*C_{t-1}$表示上一个细胞状态在本细胞状态中的角色 ​ 另外，$i_t * C_t$表示的是本细胞状态的另一部分 ​ 所以，本细胞的细胞状态是$C_t = f_t * C_{t-1} + i_t * C^{“}_t$ 使用Pytorch实现简单的LSTM 1234567891011121314151617181920212223242526272829303132333435import torchimport torch.nn as nnfrom torch.autograd import Variableclass SimpleLSTM(nn.Module): def __init__(self, input_size, hidden_size, output_size, num_layers=1): super(SimpleLSTM, self).__init__() self.hidden_size = hidden_size self.num_layers = num_layers # 三层神经网络 self.embedding = nn.Embedding(input_size, hidden_size) self.lstm = nn.LSTM(hidden_size, hidden_size, num_layers, batch_first=True) self.fc = nn.Linear(hidden_size, output_size) self.softmax = nn.LogSoftmax(dim=1) def forward(self, input, hidden_size): x = self.embedding(input) output, hidden = self.lstm(x, hidden) output = output[:, -1, :] output = self.fc(output) output = self.softmax(output) return output, hidden def initHidden(self): # 对隐含层单元的初始化 hidden = Variable(torch.zeros(self.num_layers, 1, self.num_layers)) # 对隐含单元内部的状态cell的初始化 cell = Variable(torch.zeros(self.num_layers, 1, self.hidden_size)) return (hidden, cell) 参考资料 《Pytorch深度学习原理与实战》 图片来源于网络 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://zivblog.top/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://zivblog.top/tags/Artificial-Intelligence/"}]},{"title":"机器学习之逻辑回归","slug":"机器学习之逻辑回归","date":"2019-09-25T14:11:08.000Z","updated":"2020-07-06T05:45:01.521Z","comments":true,"path":"passages/ji-qi-xue-xi-zhi-luo-ji-hui-gui/","link":"","permalink":"http://zivblog.top/passages/ji-qi-xue-xi-zhi-luo-ji-hui-gui/","excerpt":"逻辑回归","text":"逻辑回归 逻辑回归 逻辑回归，虽然名字中带有“回归”的字样，但是它并不是做回归任务的，而是用回归的思想来做分类 根据数据对分类边界线建立回归公式，以此进行分类 算法概述 以二分类为例，逻辑回归会计算输入的实例在已知x的条件下$P(Y=1|x)$和$P(Y=0|x)$的概率，并将实例分到概率值较大的那一类 优缺点 优点：计算代价不高，易于理解和实现 缺点：容易欠拟合，分类精度可能不高 多项逻辑回归模型可以用于多分类 逻辑回归与最大熵模型都是对数线性模型，当标签值只有两个的时候的最大熵模型就是逻辑回归模型 回归模型：$f(x) = \\frac{1}{1+e^{-wx}}$ 最大熵模型 熵表示的是数据的不确定性，熵越大，不确定性越大 最大熵模型：保留所有的不确定性，将风险降到最低 最大熵模型的学习过程就是在可能的模型集合中选择最优模型，熵最大的情况就是等概率，即最不确定的情况 最大熵模型也可以用于二分类和多分类任务 最大熵模型的具体推导过程还在学习中，后续持续更新 相关数学知识 经验分布：经验分布是指依据样本频率估计概率的方式得到的与实际近似的分布 极大似然估计：利用已知的样本结果，反推最有可能（最大概率）导致这样结果的参数值 代码实现及测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687# 导入相关包from math import expimport numpy as npimport pandas as pd import matplotlib.pyplot as plt from sklearn.datasets import load_irisfrom sklearn.model_selection import train_test_splitdef create_data(): # 加载iris数据集并转化格式 iris = load_iris() df = pd.DataFrame(iris.data, columns=iris.feature_names) df['label'] = iris.target # 选择前100行中的前两列和最后一列，即数据结构为(x, y, label) data = np.array(df.iloc[:100, [0, 1, -1]]) return data[:, :-1], data[:, -1]class LogisticRegressionClassifier: def __init__(self, max_iter=200, learning_rate=0.01): self.max_iter = max_iter self.learning_rate = learning_rate def sigmod(self, x): return 1 / (exp(-x) + 1) def data_matrix(self, X): # 将X转化成矩阵，并将第一行设置成1，这样[1, x][w, b] data_mat = [] for d in X: # print(d) data_mat.append([1.0, *d]) return data_mat def fit(self, X, y): data_mat = self.data_matrix(X) # 初始化权重为0，长度为len(x)+1, 即[b, w] self.weights = np.zeros((len(data_mat[0]), 1), dtype=np.float32) for iter_ in range(self.max_iter): for i in range(len(X)): # w*x + b result = self.sigmod(np.dot(data_mat[i], self.weights)) error = y[i] - result # 权重更新 self.weights += self.learning_rate * error *np.transpose([data_mat[i]]) print('LogisticRegression Model(learning_rate=&#123;&#125;,max_iter=&#123;&#125;)'.format( self.learning_rate, self.max_iter)) def score(self, X_test, y_test): right = 0 X_test = self.data_matrix(X_test) for x, y in zip(X_test, y_test): result = self.sigmod(np.dot(x, self.weights)) # 统计预测正确的数量 if (result &gt; 0 and y==1) or (result &lt; 0 and y==0): right += 1 return right/float(len(X_test))if __name__ == \"__main__\": # 数据准备 X, y = create_data() X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3) # print(X_train, X_test, y_train, y_test) lr_clf = LogisticRegressionClassifier() # 训练 lr_clf.fit(X_train, y_train) # 用测试集测试模型性能 lr_clf.score(X_test, y_test) # 绘制 x_points = np.arange(4, 8) # 拟合曲线weights = [b, Wx, Wy], 曲线为：weights[1]*x + weights[2]*y + b = 0 ---&gt; y = (weights[1]*x + b) / weights[2] y_ = -(lr_clf.weights[1]*x_points + lr_clf.weights[0]) / lr_clf.weights[2] plt.plot(x_points, y_) # 散点 plt.scatter(X[:50, 0], X[:50, 1], label='0') plt.scatter(X[50:, 0], X[50:, 1], label='1') plt.show() print(lr_clf.weights) 参考资料 《统计学习方法（第二版）》 《机器学习实战》 黄海广博士的代码 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://zivblog.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://zivblog.top/tags/Artificial-Intelligence/"}]},{"title":"机器学习之决策树","slug":"机器学习之决策树","date":"2019-09-24T13:55:40.000Z","updated":"2020-07-06T05:44:53.863Z","comments":true,"path":"passages/ji-qi-xue-xi-zhi-jue-ce-shu/","link":"","permalink":"http://zivblog.top/passages/ji-qi-xue-xi-zhi-jue-ce-shu/","excerpt":"决策树","text":"决策树 算法要点 决策树是一种基本的分类与回归方法 决策树模型可以认为是if-then规则的集合，也可以认为是定义在特征空间与类空间上的条件概率分布 决策树的学习过程主要分为三个步骤：特征选择、决策树的生成、决策树的修剪 优点：计算复杂度不高，输出结果易于理解，对中间的缺失不敏感，可以处理不相关特征数据 缺点：可能会产生过度匹配问题 决策树的训练 决策树学习，本质上是从训练数据中归纳出一组分类规则，由于符合这一规则的决策树可能有多个，故我们要寻找的是一个与训练数据矛盾较小的决策树，同时具有较好的泛化能力。 决策树的学习策略是：以损失函数（通常是正则化的极大似然函数）为目标函数的最小化。 递归的选择最优特征（该特征对数据集的划分是当前最优的划分），并根据该特征对训练数据进行分割，直到所有子集中只包含一个类别的数据 具体训练过程 开始，构建根节点，将所有训练数据都放在根节点 选择一个最优特征，按照这一特征将训练数据分割成子集 如果子集已经可以被很好的分类了，则构建叶节点，并将这个子集放到叶节点之中 若还存在子集不能被很好的分类，那么对这些子集选择新的最优特征，继续进行分类 直到所有训练数据子集被基本正确分类，或者没有合适的特征为止 以上步骤进行完毕之后，我们还需要防止决策树的过拟合，也就是对决策树的剪枝，使其拥有较好的泛化能力 决策树的生成值考虑局部最优，决策树的剪枝则需要考虑全局最优 决策树常用的学习算法有：ID3、C4.5、CART 特征选择 特征选择在于选取对于训练数据具有分类能力的特征，特征选择的准则通常使用信息增益和信息增益比 熵表示的是随机变量不确定性的度量；熵越大，随机变量的不确定性就越大 条件熵$H(Y|X)$表示在已知随即便来那个X的情况下随机变量Y的不确定性 信息增益表示得之特征X的信息而使类Y的信息的不确定性减少的程度（也就是X对 最终确定类别Y的贡献度），信息增益越大的特征具有更强的分类能力 特征A对数据集合D的信息增益，定义为：集合D的经验熵（由数据估计得到的熵）$H(D)$与特征A给定条件下D的经验条件熵$H(D|A)$之差，即$g(D, A) = H(D) - H(D|A)$ 根据信息增益选择特征的方式是：计算所有特征的信息增益，并选择信息增益最大的特征作为当前的划分依据 由于信息增益偏向于选择取值较多的特征，所以提出信息增益比来矫正该问题，定义为：特征A对数据集合D的信息增益与训练数据集D关于特征A的值的熵之比 决策树的生成 ID3算法 从根节点开始，对节点计算所有可能的特征的信息增益，选择信息增益最大的特征作为节点的特征，由该特征的不同取值建立子节点，再对子节点递归的调用以上方法；直到所有特征的信息增益均很小或没有特征可以选择为止 ​ ID3算法只有树的生成，所以该算法生成的树容易产生过拟合 C4.5算法 相比于ID3算法，C4.5使用信息增益比为标准来进行决策树的构建 剪枝处理 剪枝的目的主要是为了防止过拟合 在学习时过多的考虑如何提高对训练数据的正确分类，从而构建出过于复杂的决策树 具体来说，剪枝从已经生成的树上裁剪掉一些字数或叶子结点，并将其根节点或父节点作为新的叶节点 通过优化损失函数还考虑了减少模型复杂度，从整体上优化了模型 CART算法 CART：分类与回归树，可以用于回归，也可以用于分类 决策树生成：基于训练数据集生成决策树，生成的决策树要尽量大 决策树剪枝：用验证数据集对已生成的树进行剪枝并选择最优子树，这是用损失函数最小作为剪枝的标准 ​ 首先从生成算法产生的决策树T0底端开始不断剪枝，直到T0的根节点，形成一个子树序列， ​ 然后，通过交叉验证法在独立的验证数据集上对子树序列进行测试，从中选择最优子树 决策树的生成就是递归地构建二叉决策树的过程。对于回归树用平方误差最小化准则；对于分类书用基尼指数最小化准则进行特征选择 代码实现及测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169import numpy as np import pandas as pd import matplotlib.pyplot as plt import mathfrom math import logimport pprint# 利用ID3算法生成决策树class Node: # 结点类，树的节点 def __init__(self, root=True, label=None, feature_name=None, feature=None): self.root = root self.label = label self.feature_name = feature_name self.feature = feature self.tree = &#123;&#125; self.result = &#123; 'label':self.label, 'feature':self.feature, 'tree':self.tree &#125; def __repr__(self): return '&#123;&#125;'.format(self.result) def add_node(self, val, node): self.tree[val] = node def predict(self, features): if self.root is True: return self.label return self.tree[features[self.feature]].predict(features)class DTree: def __init__(self, epsilon=0.1): self.epsilon = epsilon self._tree = &#123;&#125; # 熵 def calc_ent(self, datasets): data_length = len(datasets) label_count = &#123;&#125; for i in range(data_length): label = datasets[i][-1] if label not in label_count: label_count[label] = 0 label_count[label] += 1 ent = -sum([(p/data_length) * log(p/data_length, 2) for p in label_count.values()]) return ent # 经验条件熵 def cond_ent(self, datasets, axis=0): data_length = len(datasets) feature_sets = &#123;&#125; for i in range(data_length): feature = datasets[i][axis] if feature not in feature_sets: feature_sets[feature] = [] feature_sets[feature].append(datasets[i]) cond_ent = sum([(len(p)/data_length)*self.calc_ent(p) for p in feature_sets.values()]) return cond_ent # 信息增益 def info_gain(self, ent, cond_ent): return ent - cond_ent def info_gain_train(self, datasets): count = len(datasets[0]) - 1 ent = self.calc_ent(datasets) best_feature = [] for c in range(count): c_info_gain = self.info_gain(ent, self.cond_ent(datasets, axis=c)) best_feature.append((c, c_info_gain)) # 比较大小 best_ = max(best_feature, key=lambda x: x[-1]) return best_ def train(self, train_data): ''' input: 数据集，特征集，阈值eta output：决策树T ''' _, y_train, featrues = train_data.iloc[:, :-1], train_data.iloc[:, -1], train_data.columns[:-1] # 若D中实例属于同一类Ck，则T为单结点树，并且Ck为结点的类别，返回T if len(y_train.value_counts()) == 1: return Node(root=True, label=y_train.iloc[0]) # 如果特征集A为空，则T为单节点树，将D中实例树最大的类Ck作为该节点的类标记，返回T if len(featrues) == 0: return Node(root=True, label=y_train.value_counts().sort_values(ascending=False).index[0]) # 计算最大信息增益，Ag为信息增益最大的特征 max_feature, max_info_gain = self.info_gain_train(np.array(train_data)) max_feature_name = featrues[max_feature] # 信息增益Ag如果小于阈值eta（相当于特征集为空），则T为单节点树，并将D中是实例数最大的类别Ck作为该节点的类标记 if max_info_gain &lt; self.epsilon: return Node(root=True, label=y_train.value_counts().sort_values(ascending=False).index[0] ) # 构建Ag子集 node_tree = Node( root=False, feature_name=max_feature_name, feature=max_feature ) featrue_list = train_data[max_feature_name].value_counts().index for f in featrue_list: sub_train_df = train_data.loc[train_data[max_feature_name] == f].drop([max_feature_name], axis=1) # 递归生成树 sub_tree = self.train(sub_train_df) node_tree.add_node(f, sub_tree) # pprint.pprint(node_tree.tree) return node_tree def fit(self, train_data): self._tree = self.train(train_data) return self._tree def predict(self, X_test): return self._tree.predict(X_test)def create_data(): datasets = [['青年', '否', '否', '一般', '否'], ['青年', '否', '否', '好', '否'], ['青年', '是', '否', '好', '是'], ['青年', '是', '是', '一般', '是'], ['青年', '否', '否', '一般', '否'], ['中年', '否', '否', '一般', '否'], ['中年', '否', '否', '好', '否'], ['中年', '是', '是', '好', '是'], ['中年', '否', '是', '非常好', '是'], ['中年', '否', '是', '非常好', '是'], ['老年', '否', '是', '非常好', '是'], ['老年', '否', '是', '好', '是'], ['老年', '是', '否', '好', '是'], ['老年', '是', '否', '非常好', '是'], ['老年', '否', '否', '一般', '否'], ] labels = [u'年龄', u'有工作', u'有自己的房子', u'信贷情况', u'类别'] # 返回数据集和每个维度的名称 return datasets, labelsif __name__ == \"__main__\": datasets, labels = create_data() data_df = pd.DataFrame(datasets, columns=labels) dt = DTree() tree = dt.fit(data_df) # print(tree) print(dt.predict(['老年', '否', '否', '一般'])) 参考资料 《统计学习方法（第二版）》 《机器学习实战》 黄海广博士的代码 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://zivblog.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://zivblog.top/tags/Artificial-Intelligence/"}]},{"title":"Leetcode之有效的括号","slug":"Leetcode之有效的括号","date":"2019-09-24T13:52:16.000Z","updated":"2020-07-06T05:30:24.865Z","comments":true,"path":"passages/leetcode-zhi-you-xiao-de-gua-hao/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-you-xiao-de-gua-hao/","excerpt":"有效的括号","text":"有效的括号 题目描述 题目详情见：有效的括号 题目难度：简单 相关标签：栈、字符串 思路 括号匹配是栈的应用之一，这里讲一下思路 只要遇到左括号就入栈，遇到右括号则右括号与栈顶元素匹配， 如果匹配则栈顶元素出栈 如果不匹配则失败 直到所有括号均遍历一遍 可以使用Python的字典{‘左括号’：’右括号’}，右括号是不会有入栈的可能的 几个特殊情况 栈空时的pop操作会报错，所以我们给栈赋初值，并对该初值在字典中建立对应关系 当序列以左括号结尾是，也是需要特殊处理的，这时判断一下栈内的元素个数即可（加上我们的初值长度应该为2） 代码一12345678910111213141516171819def isValid(self, s: str) -&gt; bool: dict = &#123;'(': ')', '[': ']', '&#123;': '&#125;', '?': '?'&#125; stack = ['?'] for c in s: # 左括号，入栈 if c in dict: stack.append(c) # 右括号 else: top = stack.pop() # 匹配失败 if dict[top] != c: return False if len(stack) == 1: return True if len(stack) == 2: # 左括号结尾,匹配失败 return False 代码二1234567891011# 与代码一实现的算法思想是相同的，但是代码实现上更加简洁紧凑def isValid(self,s: str) -&gt; bool: dict = &#123;'(': ')', '[': ']', '&#123;': '&#125;', '?': '?'&#125; stack = ['?'] for c in s: if c in dict: stack.append(c) elif dict[stack.pop()] != c: return False return len(stack) == 1 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之最长公共前缀","slug":"Leetcode之最长公共前缀","date":"2019-09-22T12:08:00.000Z","updated":"2020-07-06T05:34:50.652Z","comments":true,"path":"passages/leetcode-zhi-zui-chang-gong-gong-qian-zhui/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zui-chang-gong-gong-qian-zhui/","excerpt":"最长公共前缀","text":"最长公共前缀 题目描述 题目详情见：最长公共前缀 题目难度：简单 相关标签：字符串 思路 输入只有小写字母，不存在干扰数据，可以直接处理 最直接的思路就是选定一个字符串，将其前缀依次与各个字符串的前缀比较，前缀长度依次加1，时间复杂度很高（不写了，有兴趣的可自行实现） 将字符串数组是做二维数组，按列扫描，直到发现某一列不完全相同，之前的列中任取一行就是最长共同前缀（见代码一） 利用set：每次取每个字符串的同一列，放入set中，如果set长度为1，则是共同字符 利用zip()函数：返回strs的每个字符串的迭代器 前两个字符串找最长公共子串，结果再与第三个字符串找共同前缀，直到整个字符串数组全部参与（见代码二） 这里还可以进行优化：求所有字符串长度的最小值，所有求公共字串的过程都只需要求最小值长度的即可 在讨论区看到了一个超赞的想法，这里记录一下（见代码二） 代码一12345678910111213141516def longestCommonPrefix(self, strs: List[str]) -&gt; str： if not strs: return \"\" # 返回每一列的集合（不含重复元素） ss = list(map(set, zip(*strs))) res = \"\" for i, x in enumerate(ss): x = list(x) # 长度大于1说明该列不完全相同 if len(x) &gt; 1: break # 将完全相同的列的字母添加到最长公共子串中 res = res + x[0] return res 代码二1234567891011def longestCommonPrefix(self, strs): if not strs: return \"\" s1 = min(strs) s2 = max(strs) for i, x in enumerate(s1): if x != s2[i] return s2[:i] return s1 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"机器学习之朴素贝叶斯","slug":"机器学习之朴素贝叶斯","date":"2019-09-22T12:05:14.000Z","updated":"2020-07-06T05:45:08.247Z","comments":true,"path":"passages/ji-qi-xue-xi-zhi-po-su-bei-xie-si/","link":"","permalink":"http://zivblog.top/passages/ji-qi-xue-xi-zhi-po-su-bei-xie-si/","excerpt":"朴素贝叶斯","text":"朴素贝叶斯 算法要点 朴素贝叶斯是基于贝叶斯定理与特征条件独立假设的分类方法 算法概述 对于给定的训练数据集，首先基于特征条件独立假设学习输入输出的联合概率分布； 然后基于此模型，对给定输入的x，利用贝叶斯定理求出后验概率最大的输出y 优缺点 优点：在数据较少的情况下仍然有效，可以完成多分类任务 缺点：对于输入数据的准备方式较为敏感 相关数学知识 先验概率分布 与实验结果无关，与随机抽样无关，反应在进行统计试验之前根据其他有关参数的知识而得知的分布 条件概率 已知某条件的情况下，计算事件发生的概率 $P(事件1|条件) = \\frac{P(时间1 and 条件)}{P(条件)}$ 已知$P(x|c)$求$P(c|x)$，$P(c|x) = \\frac{P(x|c)P(c)}{P(x)}$ 极大似然估计 已知某个参数值能使这个样本出现的概率最大，我们就直接将这个参数的值做为估计的真实值 模型： 高斯模型 多项式模型 伯努利模型 代码实现及测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106import numpy as np import pandas as pd import matplotlib.pyplot as plt from sklearn.datasets import load_irisfrom sklearn.model_selection import train_test_splitfrom collections import Counterimport mathdef create_data(): # 读取数据并返回X，y iris = load_iris() df = pd.DataFrame(iris.data, columns=iris.feature_names) df['label'] = iris.target df.columns = ['sepal length', 'sepal width', 'petal length', 'petal width', 'label'] data = np.array(df.iloc[:100, :]) # 返回X，y return data[:, :-1], data[:, -1]class NaiveBayes: def __init__(self): self.model = None # 数学期望（平均值） def mean(self, X): return sum(X) / float(len(X)) # 标准差（方差的算术平方根 sqrt(sum(x - r)^2)/N） def stdev(self, X): avg = self.mean(X) return math.sqrt(sum([pow(x - avg, 2) for x in X]) / float(len(X))) # 概率密度函数 def gaussian_probability(self, x, mean, stdev): exponent = math.exp(-(math.pow(x - mean, 2) / (2 * math.pow(stdev, 2)))) return (1 / (math.sqrt(2 * math.pi) * stdev)) * exponent # 处理X_train: 取每一条数据的均值和标准差 def summarize(self, train_data): summaries = [(self.mean(i), self.stdev(i)) for i in zip(*train_data)] return summaries # 分类别求出数学期望和标准差 def fit(self, X, y): # 无重复的标记 labels = list(set(y)) # 根据类别标记创建类别标记数个字典键值对 data = &#123;label: [] for label in labels&#125; # 将不同类别标记的实例放到不同的列表中 for f, label in zip(X, y): data[label].append(f) self.model = &#123; label: self.summarize(value) for label, value in data.items() &#125; return 'gassianNB train done !' # 计算概率 def calculate_probabilities(self, input_data): probabilities = &#123;&#125; for label, value in self.model.items(): probabilities[label] = 1 for i in range(len(value)): mean, stdev = value[i] # 计算高斯概率密度函数 probabilities[label] *= self.gaussian_probability(input_data[i], mean, stdev) return probabilities def predict(self, X_test): label = sorted( self.calculate_probabilities(X_test).items(), key=lambda x: x[-1])[-1][0] return label def score(self, X_test, y_test): # 计算预测正确率 right = 0 for X, y in zip(X_test, y_test): label = self.predict(X) if label == y: right += 1 return right / float(len(X_test)) if __name__ == \"__main__\": X, y = create_data() X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3) # print(X_test[0], y_test[0]) model = NaiveBayes() model.fit(X_train, y_train) print('X is [4.4, 3.2, 1.3, 0.2], label is &#123;&#125;'.format(model.predict([4.4, 3.2, 1.3, 0.2]))) print('model score : ', model.score(X_test, y_test)) 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://zivblog.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://zivblog.top/tags/Artificial-Intelligence/"}]},{"title":"xgboost和lightGBM的安装","slug":"xgboost和lightGBM的安装","date":"2019-09-22T11:59:49.000Z","updated":"2020-07-06T05:42:36.504Z","comments":true,"path":"passages/xgboost-he-lightgbm-de-an-zhuang/","link":"","permalink":"http://zivblog.top/passages/xgboost-he-lightgbm-de-an-zhuang/","excerpt":"LightGBM，XGBoost","text":"LightGBM，XGBoost LightGBM，XGBoost作为非常经典的GBDT模型，在机器学习的比赛中使用的频率也是非常之高。这里记录一下安装这两个库的步骤 配置环境 Windows10 Python3.7 Xgboost的安装 官网上有很详细的安装方法，但折腾了半天还是不能使用。所以这里我们选择使用离线安装的方式进行安装 首先在这里下载对应版本的xgboost版本 将目录切换到whl文件所在的目录 使用pip install xgboost-XXXXXX.whl进行安装 安装完成之后，使用import xgboost as xgb测试是否安装成功 lightGBM的安装 LightGBM是微软开源的一个Python工具包 网上大部分的安装教程都是编译安装的，坑点比较多，这里介绍一种简单的安装方式 在这里下载whl安装包 将目录切换到lightGBM所在的目录 使用pip install lightgbm-XXXXX.whl进行安装 使用import lightgbm as lgb测试 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"工具配置","slug":"工具配置","permalink":"http://zivblog.top/categories/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://zivblog.top/tags/Tools/"}]},{"title":"机器学习之感知机模型","slug":"机器学习之感知机模型","date":"2019-09-20T13:59:29.000Z","updated":"2020-07-06T05:44:45.564Z","comments":true,"path":"passages/ji-qi-xue-xi-zhi-gan-zhi-ji-mo-xing/","link":"","permalink":"http://zivblog.top/passages/ji-qi-xue-xi-zhi-gan-zhi-ji-mo-xing/","excerpt":"感知机模型","text":"感知机模型 算法要点 感知机是线性分类模型，属于判别模型，二分类模型 旨在求出特征空间中将实例划分为正负两类的分离超平面 算法概述 感知机是根据输入实例的特征向量对其进行而分类的线性分类模型 感知机学习的策略是极小化损失函数 感知机学习算法是基于随即梯度下降法的对损失函数的最优化算法 输入空间到输出空间的函数（感知机）：$f(x) = sign(w*x + b)$ 损失函数：$L(w, b) = - \\sum_{x_i \\in M}{y_i(w \\cdot x_i + b)}$ 学习策略：在假设空间中选取使损失函数最小的模型参数$w, b$ 优化过程 每次随机选取其中一个误分类点计算损失 损失函数分别对$w, b$求偏导 根据学习率进行参数值的更新 当训练数据集线性可分时，感知机学习算法是收敛的 代码实现及测试1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import pandas as pd import numpy as np from sklearn.datasets import load_irisimport matplotlib.pyplot as plt class Perceptron: def __init__(self): # 初始化模型的参数：w初始化为与data长度相同的一维向量，b初始化为0，learning rate为0.1 self.w = np.ones(len(data[0])-1, dtype=np.float32) self.b = 0 self.l_r = 0.1 def sign(self, x, w, b): y = np.dot(x, w) + b return y def fit(self, X_train, y_train): # 随机梯度下降 is_wrong = False # 有误分点的时候才会进行梯度下降 while not is_wrong: wrong_count = 0 for d in range(len(X_train)): X = X_train[d] y = y_train[d] if y*self.sign(X, self.w, self.b) &lt;= 0: self.w = self.w + self.l_r * np.dot(y, X) self.b = self.b + self.l_r * y wrong_count += 1 if wrong_count == 0: is_wrong = True return 'Perceptron Model' def predict(self, X): if np.dot(self.w, X) + self.b &gt; 0: return 1 else: return -1 def score(self): passif __name__ == \"__main__\": # 加载数据集 iris = load_iris() # 转化数据格式 df = pd.DataFrame(iris.data, columns=iris.feature_names) df['label'] = iris.target df.columns = ['sepal length', 'sepal width', 'petal length', 'petal width', 'label'] data = np.array(df.iloc[:100, [0, 1, -1]]) X, y = data[:, :-1], data[:,-1] # 将实例的target分为两类（感知机是二分类模型）,并且target设为1，-1 y = np.array([1 if i==1 else -1 for i in y]) # 加载模型并训练 perceptron = Perceptron() perceptron.fit(X, y) x_points = np.linspace(4, 7, 10) # 划分超平面 y_ = -(perceptron.w[0] * x_points + perceptron.b) / perceptron.w[1] # 直线 plt.plot(x_points, y_) # 散点图 plt.plot(data[:50, 0], data[:50, 1], 'bo', color='blue', label='1') plt.plot(data[50:100, 0], data[50:100, 1], 'bo', color='orange', label='-1') plt.xlabel('sepal length') plt.ylabel('sepal width') plt.legend() plt.show() # print(perceptron.predict([1, 2])) 参考资料 《统计学习方法（第二版）》 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://zivblog.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://zivblog.top/tags/Artificial-Intelligence/"}]},{"title":"机器学习之K临近算法","slug":"机器学习之K临近算法","date":"2019-09-20T13:56:48.000Z","updated":"2020-07-06T05:44:38.302Z","comments":true,"path":"passages/ji-qi-xue-xi-zhi-k-lin-jin-suan-fa/","link":"","permalink":"http://zivblog.top/passages/ji-qi-xue-xi-zhi-k-lin-jin-suan-fa/","excerpt":"K临近算法","text":"K临近算法 算法要点 KNN是一种有监督的机器学习算法 不具有显示的学习过程，预测 –&gt; 现场投票 结果唯一确定 算法概述 给定一个训练数据集，对于任意的待预测实例，计算该实例与训练集中所有实例的距离，选择与该实例距离最近的K个实例进行投票，实例数最多的类别即被认定为待预测实例的类别 关键参数：K，即允许参与最终投票的实例数 距离度量 欧式距离 曼哈顿距离 各坐标距离的最大值 特殊情况：当k=1的时候，称为最临近算法。也即是只与输入实例点最近的实例的类别有关 K值的取值 选择较小的K值，近似误差会减小，估计误差会增大。也就是说K值的减小就意味着整体模型变得复杂，容易发生过拟合 选择较大的K值，可以减少模型的估计误差，但是学习的近似误差会增大。意味着模型变得简单。 代码实现及测试12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697import math from itertools import combinationsimport numpy as np import pandas as pd import matplotlib.pyplot as plt from sklearn.datasets import load_irisfrom sklearn.model_selection import train_test_splitfrom collections import Counter'''验证数据集：鸢尾花数据集算法：自主实现的KNN辅助： 使用sklearn中的函数将数据集划分为训练集和测试集 使用Counter函数作为计数器'''def show_data(iris): # 转化数据格式 df = pd.DataFrame(iris.data, columns=iris.feature_names) df['label'] = iris.target df.columns = ['sepal length', 'sepal width', 'petal length', 'petal width', 'label'] # 绘制散点图（取前两个维度作为坐标，每一个类别取50个） plt.scatter(df[:50]['sepal length'], df[:50]['sepal width'], label='0') plt.scatter(df[50:100]['sepal length'], df[50:100]['sepal width'], label='1') plt.xlabel('sepal length') plt.ylabel('sepal width') plt.legend() plt.show()class KNN: def __init__(self, X_train, y_train, n_neighbors=3, p=2): # 默认K取3，距离默认使用欧式距离 self.n = n_neighbors self.p = p self.X_train = X_train self.y_train = y_train def predict(self, X): ''' 将输入的X与训练集的各个实例计算距离，取前n_neighbors个进行投票 ''' knn_list = [] # 先将前n个存入knn_list，再计算后len(X_train)-n个，同时比较，将距离更小的替换进来 # 可减小内存压力 for i in range(self.n): # 计算所有实例与待预测实例之间的距离 dist = np.linalg.norm(X - self.X_train[i], ord=self.p) # (距离, target)作为数据对 knn_list.append((dist, self.y_train[i])) for i in range(self.n, len(self.X_train)): max_index = knn_list.index(max(knn_list, key=lambda x: x[0])) dist = np.linalg.norm(X - self.X_train[i], ord=self.p) if knn_list[max_index][0] &gt; dist: knn_list[max_index] = (dist, self.y_train[i]) # 统计实例数最多的类别 knn = [k[-1] for k in knn_list] count_pairs = Counter(knn) max_count = sorted(count_pairs.items(), key=lambda x: x[1])[-1][0] return max_count def score(self, X_test, y_test): ''' 计算预测正确率 ''' right_count = 0 for X, y in zip(X_test, y_test): label = self.predict(X) if label == y: right_count += 1 return right_count / len(X_test)if __name__ == \"__main__\": # 加载数据集 iris = load_iris() # 显示数据 # show_data(iris) # 预处理数据 new_iris = np.column_stack((iris.data, iris.target)) # 划分数据集 X_train, X_test, y_train, y_test = train_test_split(new_iris[:, :4],new_iris[:, -1], test_size = 0.3, random_state=0) clf = KNN(X_train, y_train) print(clf.score(X_test, y_test)) 参考资料 《统计学习方法（第二版）》 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://zivblog.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://zivblog.top/tags/Artificial-Intelligence/"}]},{"title":"Python库之collections","slug":"Python库之collections","date":"2019-09-20T13:49:17.000Z","updated":"2020-07-06T05:38:40.489Z","comments":true,"path":"passages/python-ku-zhi-collections/","link":"","permalink":"http://zivblog.top/passages/python-ku-zhi-collections/","excerpt":"collections","text":"collections 今天看代码的时候发现了collections这个Python库，遂学习一下 collections是什么 collections是一个Python内建的集合模块，提供许多有用的集合类 collections模块提供了特定目标的容器，以提供Python标准内建容器dict、list、set、tuple的替代选择 collections提供的功能模块 namedtuple：用来创建一个自定义的tuple对象，并且规定了tuple元素的个数，并可以用属性而不是索引来引用tuple的某个元素 deque：为了高效实现插入和删除操作的双向列表，适合用于队列和栈 ChainMap：类似字典的容器类，将多个映射集合到一个视图里面 Counter：一个简单的计数器（使用频率较高） OrderedDict：字典的子类，保存了他们被添加的顺序 defaultdict：key不存在时，返回一个默认值，而默认的dict在key不存在是会抛出keyError UserDict：封装了字典对象，简化了字典子类化 UserList：封装了列表对象，简化了列表子类化 UserString：封装了列表对象，简化了字符串子类化 实例 namedtuple 1234567891011121314from collections import namedtuple'''namedtuple允许自定义tuple对象，可以规定tuple的元素个数，允许使用属性来引用元素'''# 定义一个坐标点tuple，并规定元素个数为2Point = namedtuple('Point', ['x', 'y'])p = Point(1, 2)# 使用属性和索引都可以引用元素print(p.x, p.y) # 1 2print(p[0], p[1]) # 1 2 deque 123456789101112from collections import deque'''deque高效实现列表的插入和删除元素，适合用于队列和栈另外还实现了除list本身的append()和pop()方法之外的appendleft()和popleft()，即允许高效的从头部添加和删除元素'''q = deque(['a', 'b', 'c'])q.append('x')q.appendleft('y')print(q) # deque(['y', 'a', 'b', 'c', 'x']) defaultdict 1234567891011from collections import defaultdict'''defaultdict在dict中引用的key不存在的时候，不会抛出KeyError，而是抛出一个预先设定的值'''dd = defaultdict(lambda :'N/A')dd['key1'] == 'abc'print(dd['key1']) # abcprint(dd['key2']) # N/A OrderedDict 1234567891011from collections import OrderedDict'''OrderedDict字典在迭代时是无序的而OrderedDict，保存了他们被添加的顺序'''d = dict([('a', 1), ('b', 2), ('c', 3)])print(d) # &#123;'a': 1, 'c': 3, 'b': 2&#125;od = OrderedDict([('a', 1), ('b', 2), ('c', 3)])print(od) # OrderedDict([('a', 1), ('b', 2), ('c', 3)]) Counter 123456from collections import Counter '''Counter计数器'''print(Counter('programming')) # Counter(&#123;'g': 2, 'm': 2, 'r': 2, 'a': 1, 'i': 1, 'o': 1, 'n': 1, 'p': 1&#125;) ChainMap 1234567891011121314from collections import ChainMap'''ChainMap将多个字典或者映射，将它们从逻辑上合并为一个单一的映射后执行某些操作'''a = &#123;'x': 1, 'z': 3 &#125;b = &#123;'y': 2, 'z': 4 &#125;c = ChainMap(a,b)print(c['x']) # 1 (from a)print(c['y']) # 2 (from b)print(c['z']) # 3 (from a) UserDict、UserList、UserString需要的可以自行查阅官方帮助文档 参考资料 廖雪峰的官方网站 Python官方文档 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://zivblog.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://zivblog.top/tags/Python/"}]},{"title":"Leetcode之罗马数字转整数","slug":"Leetcode之罗马数字转整数","date":"2019-09-19T14:22:59.000Z","updated":"2020-07-06T05:22:37.548Z","comments":true,"path":"passages/leetcode-zhi-luo-ma-shu-zi-zhuan-zheng-shu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-luo-ma-shu-zi-zhuan-zheng-shu/","excerpt":"罗马数字转整数","text":"罗马数字转整数 题目描述 题目详情见：罗马数字转整数 题目难度：简单 相关标签：数字、字符串 思路 我们发现特殊情况下，左边的数字小于右边的数字。也就是说，从左往右看的时候，左边的字符表示的数字小于右边的字符表示的数字，则需要用右边的字符减去左边的（这里可以通过将左边的字符表示的数字取负来实现） 其他情况下（左边的字符大于或等于右边的字符），只需要将它们表示的数字相加即可 建立字典：单个罗马字符与数字之间的映射 使用语言：Python 代码12345678910111213def ramonToInt(s: str): roma_nums = &#123;'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000&#125; num = 0 for i in range(len(s) - 1): if roma_nums[s[i]] &gt;= roma_nums[s[i+1]]: num += roma_nums[s[i]] else: num -= roma_nums[s[i]] last_num = s[len(s)-1] num = num + roma_nums[last_num] return num 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之回文数","slug":"Leetcode之回文数","date":"2019-09-18T13:58:29.000Z","updated":"2020-03-04T06:26:00.952Z","comments":true,"path":"passages/leetcode-zhi-hui-wen-shu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-hui-wen-shu/","excerpt":"尽量使用Python解决，不排除使用C编写代码","text":"尽量使用Python解决，不排除使用C编写代码 题目描述 题目详情请见回文数 题目难度：简单 相关标签：数学 思路 判断一个整数是否是回文数，最直接的想法就是利用字符串来处理 进阶要求：不允许将整数转化为字符串 注意负号会影响回文，例如：-121反过来是121-，所以我们可以认为负数不可能是回文数 我们这里要求的是整数，所以要注意反转数字时的溢出问题（MIN_VALUE~MAX_VALUE） 这里有一点要注意：如果是回文数，显然是不会溢出的，所以溢出的必然不是回文数 总结一下：负数不可能是回文数，反转之后溢出的不是回文数，10的倍数不是回文数 使用字符串（见代码一）： 先判断是否为负数，如果是负数，则返回False 如果是正数，则转化成字符串，再将字符与反转之后的字符串比较 相等，则返回True；否则，返回False 不使用字符串（见代码二）： 主要思想是：取其后半段与前半段进行比较即可，这样不用处理溢出问题 要注意数字的位数是偶数还是奇数 具体做法见代码 代码一12345678910# 一般要求，使用字符串来处理def isPalindrome(self, x: int) -&gt; bool: if x &lt; 0: return False else: x_str = str(x) if x_str[::-1] == x_str: return True else: return False 代码二123456789101112131415161718192021# 具体做法# 1. 每次进行取余操作，去除最低位（y = x % 10）# 2. 将最低为的数字加到取出数的末尾（rN = rN*10 + y）# 3. 每取一个最低为数字，x都要自除以10# 4. 判断x是否小于rN，小于的时候说明已经对半或过半了# 5. 最后判断奇数偶数位分别判断（奇数位的中间一位不需要判断）bool isPalindrome(int x)&#123; int rN=0; if(x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0))&#123; // 负数不是回文数，10的倍数不可能是回文数，因为末位为0 return false; &#125;else&#123; while(x &gt; rN)&#123; rN = rN * 10 + x % 10； x = x / 10; &#125; // 分别处理偶数位和奇数位的情况 return x == rN || x = rN / 10; &#125;&#125; ​ 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"信息熵","slug":"信息熵","date":"2019-09-17T14:22:51.000Z","updated":"2020-07-06T05:48:40.629Z","comments":true,"path":"passages/xin-xi-shang/","link":"","permalink":"http://zivblog.top/passages/xin-xi-shang/","excerpt":"信息熵","text":"信息熵 信息熵定义 任何信息都存在冗余，冗余大小与信息中每个符号的出现概率（不确定性）有关 把信息中排除了冗余后的平均信息量即为信息熵 表征了随机变量X所有情况下的平均不确定度 定义：$H(X)=-\\sum_{x \\in X}{P(x)log(P(X))}$ 概率大，出现的机会多，不确定性就小；反之，概率小，不确定性就大，所以不确定性函数f(X)是概率P(X)的单调递减函数：即概率越大，不确定性越小 独立符号的不确定性是可加的，即$f(P_1, P_2) = f(P_1) + f(P_2) 对定义的理解 下面我们对一些概念做更加通俗的理解： 为什么有的信息量大，有的信息量小？ 有些事情本来不是很确定，例如明天股票的涨跌；所以你的信息对明天股票是涨是跌带来的信息量很小。但是如果告诉你明天NBA决赛开始了，两者似乎没什么联系，但是加入决赛开始大家都去看球不关注股市了，没人坐庄的股票很大概率会跌，所以这句话信息量很大，因为本来不确定的事情便的十分确定了。 有些事本来就很确定，例如太阳从东边升起，你再说100遍，你的话还是没有任何信息量，因为这件事不能更加确定了 所以说信息量的大小跟事情不确定性的变化有关 不确定性的变化与什么有关呢？ 跟事情的可能结果的数量有关。也就是说可能结果数量比较大时，我们得到的新信息才由潜力拥有大量信息。 跟概率有关，尤其是初始概率。比如电影院由225个座位，小明坐哪个座位的结果数量很多，但是如果说一开始就知道小明在第一排最左边的可能是99%，那么结果就几乎确定了，也就是说在这个时候再告诉我小明的什么信息也没有了。 如何衡量不确定性的变化的大小呢？ 不能是负数 信息量之间可以相加 信息量连续依赖于概率，也就是说，某个概率变化了极小一个值，信息量不应该变化很大 信息量的大小跟可能结果数量有关。如果每一个结果出现的概率一样，那么对于可能结果数量多的那个时间，新信息有更大的潜力具有更大的信息量。因为初始状态下不确定性更大 所以数学上，信息熵是信息量的期望（累加和） 举个例子 在自然语言处理中，信息熵只反映内容的随机性（不确定性）和编码情况，与内容本身无关 也就是说，对于一篇文章，其信息熵反映的是文章中字符编码之间的关系，也就是与有多少个不同字符有关，而与一共有多少字符没有关系 一本100万字的中文书平均有多少信息量？ 根据之前的知识，我们知道100万这个数字是没有用的，我们关注的不是文章总共有多少字，而是有多上个字是频繁出现的 我们知道，常用的汉字约7000个，假设每个汉字等概率，那么一个汉字的信息熵为： $H = -(1/7000log(1/7000) +….1/7000log(1/70000)) \\approx 13$ 也就是说，整本书的信息量大约是1300万 所以 信息量的大小和事件发生的概率成反比，表示为： $$h(x) = -log(P(x))$$ 信息量度量的是一个具体事件发生所带来的信息，而熵则是在结果出来之前对可能产生的信息量的期望——考虑该随机变量的所有可能取值，即所有可能发生事件所带来的信息量的期望 信息熵是用来衡量事物不确定性的。信息熵越大，事物越具不确定性，事物越复杂，信息量就越大 如果您发现错误或有疑问，欢迎交流指or指教 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"自然语言处理","slug":"自然语言处理","permalink":"http://zivblog.top/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"}],"tags":[{"name":"NLP","slug":"NLP","permalink":"http://zivblog.top/tags/NLP/"}]},{"title":"词袋模型（BOW）","slug":"词袋模型（BOW）","date":"2019-09-17T14:19:48.000Z","updated":"2020-07-06T05:43:44.408Z","comments":true,"path":"passages/ci-dai-mo-xing-bow/","link":"","permalink":"http://zivblog.top/passages/ci-dai-mo-xing-bow/","excerpt":"词袋模型","text":"词袋模型 词袋模型可以用来干什么？ 词袋模型可以用于表示一段文本，包括句子、篇章等。 词袋模型是如何实现的？ 首先将文本划分为一个个独立的词 将这些词无重复的存到一个“袋子”里，这个就叫做词袋 统计每个词的词频（在该段文本中出现的次数），存入对应词相同的下标位置 这个词频就作为该词的编码 举个例子 John likes to watch movies. Mary likes too. But I do not like. 单词列表：[‘John’, ‘likes’, ‘to’, ‘watch’, ‘movies’, ‘Mary’, ‘too’, ‘But’, ‘I’, ‘do’, ‘not’,’like’] 建立词典：{‘John’: 1, ‘likes’: 2, ‘to’: 1, ‘watch’: 1, ‘movies’: 1, ‘Mary’: 1, ‘too’: 1, ‘But’: 1, ‘I’: 1, ‘do’: 1, ‘not’:1, ‘like’:1} 三句文本的编码为依次为： [1, 2, 1, 1, 1] [1, 2, 1] [1, 1, 1, 1, 1] 词袋模型有什么缺陷？ 忽略了文本的语法和语序信息，仅仅将其看作若干词汇的集合 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"自然语言处理","slug":"自然语言处理","permalink":"http://zivblog.top/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"}],"tags":[{"name":"NLP","slug":"NLP","permalink":"http://zivblog.top/tags/NLP/"}]},{"title":"Leetcode之整数取余","slug":"Leetcode之整数取余","date":"2019-09-17T14:12:38.000Z","updated":"2020-07-06T05:31:28.895Z","comments":true,"path":"passages/leetcode-zhi-zheng-shu-qu-yu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zheng-shu-qu-yu/","excerpt":"整数取余","text":"整数取余 题目描述 题目详情见：整数反转 题目难度：简单 相关标签：数学 思路 输入的数字是32位的有符号整数，要注意是否会产生溢出 值得注意的是题目要求只能用int来存储，那么想要使用Long类型来存储的想法也行不通了 如果没有溢出问题，本题的思路是非常简单的，直接使用栈或者数组记录每一位的数字，再依次乘以相应的10^n累加即可 解决溢出一般有两种思路，一种是转化成字符串，使用try_catch结构来解决；另一种是使用数学的方式来解决 通过数学的方式来解决溢出问题 通过循环求得数字X的每一位，在每一步计算新值的时候都进行溢出判断 int的最大值是MAX_VALUE=2147483647，最小值是MIN_VALUE=-2147483648‬，这里我们假设当前计算结果是anw，下一位为next 当出现anw &gt; MAX_VALUE / 10并且还有next添加时，必定会上溢出 当出现anw == MAX_VALUE / 10并且next &gt; 7时，必定会上溢出 当出现anw &lt; MIN_VALUE / 10并且还有next需要添加时，必定会下溢出 当出现anw == MIN_VALUE / 10并且next &lt; -8时，并定会下溢出 通过转化为字符串来解决溢出问题 先将给定的数字转化成字符串，再利用字符串可以随机访问每一个位置的元素值的特性，依次取值，添加到新的字符串中 使用int()将字符串转化为数字 要注意的是负数的str[0]是不需要参与反转的，只需要再最后转化层整数的时候加负号即可 代码一12345678910111213141516# 由于对于负数取余上的一些不同，我们使用java语言实现该算法class Solution &#123; public int reverse(int x) &#123; int ans = 0; while (x != 0) &#123; int pop = x % 10; if (ans &gt; Integer.MAX_VALUE / 10 || (ans == Integer.MAX_VALUE / 10 &amp;&amp; pop &gt; 7)) return 0; if (ans &lt; Integer.MIN_VALUE / 10 || (ans == Integer.MIN_VALUE / 10 &amp;&amp; pop &lt; -8)) return 0; ans = ans * 10 + pop; x /= 10; &#125; return ans; &#125;&#125; 代码二1234567891011121314151617def reverse(self, x: int) -&gt; int: #MAX_VALUE = 2147483647 #MIN_VALUE = -2147483648 strx = str(x) # 转化成字符串 n = len(strx) # 字符串长度 strxx = '' if x &gt;= 0: for i in range(n): strxx = strx[i] + strxx return int(strxx) if int(strxx)&lt;=2147483647 else 0 else: # 负数反转时要跳过负号 for i in range(1, n): strxx = strx[i] + strxx return -int(strxx) if -int(strxx)&gt;=-2147483648 else 0 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"离线安装Pytorch","slug":"离线安装Pytorch","date":"2019-09-11T08:06:12.000Z","updated":"2020-07-06T05:46:26.820Z","comments":true,"path":"passages/chi-xian-an-zhuang-pytorch/","link":"","permalink":"http://zivblog.top/passages/chi-xian-an-zhuang-pytorch/","excerpt":"离线安装Pytorch","text":"离线安装Pytorch 今天在新电脑上配置环境，无奈暂时没有有线网络和无线网卡，遂使用其他机器下载离线whl包进行了Pytorch的安装，这里略作整理，供有相关需要的同行们查阅。 安装环境 Windows10专业版 Python3.7 操作步骤 首先要下载离线包，由于每个人的电脑硬件配置不同，这里建议如下操作： 打开Pytorch的官网，按照引导选择自己的配置，注意安装工具那里选择pip，这时你会得到一个网址，像这样： 我们复制其中的网址到浏览器打开，就可以在其中选择要下载的离线包了。 之后就是安装了 执行conda install torch-xxxx和conda install torchvision xxxx即可安装成功了。 测试 在python文件中或命令行下的python环境中执行import torch和import torchvision，若成功导入，则说明安装成功。 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"工具配置","slug":"工具配置","permalink":"http://zivblog.top/categories/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://zivblog.top/tags/Tools/"}]},{"title":"conda创建虚拟环境","slug":"Conda虚拟环境创建","date":"2019-09-10T08:17:29.000Z","updated":"2020-07-06T05:06:51.009Z","comments":true,"path":"passages/conda-xu-ni-huan-jing-chuang-jian/","link":"","permalink":"http://zivblog.top/passages/conda-xu-ni-huan-jing-chuang-jian/","excerpt":"conda创建虚拟环境","text":"conda创建虚拟环境 conda是什么？ 简单来说，conda就是一个Python包的管理工具，用于管理Python的各种工具包；同时conda还可以用于虚拟环境之间的创建和切换，可以实现多套环境之间的共存，满足使用者对多重不同环境配置的需求。 更换软件源 conda默认的软件源是国外的，在软件包的安装的时候速度会受限，多以更换为国内的源会有所改善。 这里以Windows下将软件源修改为清华源为例 12345$ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/$ conda config --set show_channel_urls yes注意要删除掉.condarc文件，默认在C:/username/Anaconda/pkgs/free文件夹下 另外，国内主流的文件源还有中科大源，需要的可自行百度。 conda常用命令 1234567891011121314151617181920212223# 列出当前conda环境所链接的所有软件包$ conda list# 列出当前创建的所有虚拟环境$ conda env list# 创建conda虚拟环境$ conda create -n 环境名 python=指定python版本# 在指定环境中安装工具包包$ conda install -n 环境名 工具包名# 激活虚拟环境$ activate 虚拟环境名# 关闭虚拟环境（使用系统默认环境）$ deactivate 环境名# 删除虚拟环境$ conda remove -n 虚拟环境名 --all# 卸载环境中的一个包$ conda remove -n 环境名 包名 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"工具配置","slug":"工具配置","permalink":"http://zivblog.top/categories/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://zivblog.top/tags/Tools/"}]},{"title":"Numpy100题之81~100","slug":"Numpy100题之81-100","date":"2019-09-01T11:22:21.000Z","updated":"2020-03-04T06:35:28.430Z","comments":true,"path":"passages/numpy100-ti-zhi-81-100/","link":"","permalink":"http://zivblog.top/passages/numpy100-ti-zhi-81-100/","excerpt":"学习笔记 答案整理 原文地址：https://zhuanlan.zhihu.com/p/76186124 总结：有些操作过分为了操作而操作，使用频率不高，不必花费过多时间在上面","text":"学习笔记 答案整理 原文地址：https://zhuanlan.zhihu.com/p/76186124 总结：有些操作过分为了操作而操作，使用频率不高，不必花费过多时间在上面 考虑一个数组Z = [1,2,3,4,5,6,7,8,9,10,11,12,13,14]，如何生成一个数组R = [[1,2,3,4]， [2,3,4,5], [3,4,5,6], ...,[11,12,13,14]]? 1234567891011121314151617# np.stride_tricks.as_strided(x, shape, strides, subok, writeable) 按照shape对x进行分块Z = np.arange(1, 15, dtype=np.uint32)R = np.lib.stride_tricks.as_strided(Z, (11, 4), (4, 4))print(R)结果：[[ 1 2 3 4] [ 2 3 4 5] [ 3 4 5 6] [ 4 5 6 7] [ 5 6 7 8] [ 6 7 8 9] [ 7 8 9 10] [ 8 9 10 11] [ 9 10 11 12] [10 11 12 13] [11 12 13 14]] 计算一个矩阵的秩 12345678# np.linalg.svd() 奇异值分解，三个返回值，s的对角线是奇异值，由大到小排列Z = np.random.uniform(0, 1, (10, 10))U, S, V = np.linalg.svd(Z)rank = np.sum(S &gt; 1e-10)print(rank)结果：10 如何找到一个数组中出现频率最高的值？ 1234567# np.bincount(), argmax()# 使用宾count()统计元素值的频率，argmax()返回的索引即为频率最高的元素Z = np.random.randint(0, 10, 50)print(np.bincount(Z).argmax())结果：1 从一个10x10的矩阵中提取出连续的3x3区块 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# np.lib.stride_tricks.as_strided()Z = np.random.randint(0, 5, (10, 10))n = 3i = 1 + (Z.shape[0]-3)j = 1 + (Z.shape[1]-3)C = np.lib.stride_tricks.as_strided(Z, shape=(i, j, n, n), strides=Z.strides + Z.strides)print(C)结果：[[1 4 4 4 3 4 0 4 0 0] [4 3 0 3 0 2 3 1 4 4] [0 2 2 0 2 4 1 2 0 1] [2 2 4 2 2 3 4 0 3 3] [2 0 1 2 0 0 0 0 3 4] [4 1 0 4 4 4 3 1 2 0] [2 0 4 2 2 2 2 3 0 2] [3 0 2 0 3 1 2 3 0 0] [4 0 3 2 0 4 0 0 1 0] [1 4 3 4 4 0 2 4 4 2]][[[[1 4 4] [4 3 0] [0 2 2]] [[4 4 4] [3 0 3] [2 2 0]] [[4 4 3] [0 3 0] [2 0 2]] [[4 3 4] [3 0 2] [0 2 4]] [[3 4 0] [0 2 3] [2 4 1]] [[4 0 4] [2 3 1] [4 1 2]] [[0 4 0] [3 1 4] [1 2 0]] ... [[3 0 0] [0 1 0] [4 4 2]]]] 创建一个满足Z[i,j]==Z[j,i]的子类 1234567891011121314# 类的定义class Symetric(np.ndarray): def __setitem__(self, index, value): i, j = index super(Symetric, self).__setitem__((i, j), value) super(Symetric, self).__setitem__((j, i), value) def symetric(Z): return np.asarray(Z + Z.T - np.diag(Z.diagonal())).view(Symetric) S = Symetric(np.random.randint(0, 10, (5, 5)))S[2, 3] = 42print(S)结果： 考虑p个nxn矩阵和一组形状为(n,1)的向量，如何直接计算p个矩阵的乘积(n,1)？ 12345678910111213141516171819202122232425262728# np.tensordot() 沿指定轴计算张量的点积p, n = 10, 20M = np.ones((p, n, n))V = np.ones((p, n, 1))S = np.tensordot(M, V, axes=[[0, 2], [0, 1]])print(S)结果：[[200.] [200.] [200.] [200.] [200.] [200.] [200.] [200.] [200.] [200.] [200.] [200.] [200.] [200.] [200.] [200.] [200.] [200.] [200.] [200.]] 对于一个16x16的数组，如何得到一个区域(block-sum)的和(区域大小为4x4)? 1234567891011# np.add.reduceat() 功能等同于np.sum()，实际上np.sum()调用的就是前者Z = np.ones((16, 16))k = 4S = np.add.reduceat(np.add.reduceat(Z, np.arange(0, Z.shape[0], k), axis=0), np.arange(0, Z.shape[1], k), axis=1)print(S)结果：[[16. 16. 16. 16.] [16. 16. 16. 16.] [16. 16. 16. 16.] [16. 16. 16. 16.]] 如何利用Numpy数组实现Game of Life? 123456789101112131415161718192021222324252627282930313233''' 生命游戏中，对于任意细胞： 每个细胞有两种状态：存活或死亡。每个细胞与以自身为中心的周围八格细胞产生互动。 1.当前细胞为存活状态时，当周围的活细胞低于2个时， 该细胞因孤独而死亡; 2.当前细胞为存活状态时，当周围有2个或3个活细胞时， 该细胞保持原样; 3.当前细胞为存活状态时，当周围有3个以上活细胞时，该细胞因资源匮乏而死亡; 4.当前细胞为死亡状态时，当周围有3个活细胞时，该细胞变成存活状态(模拟繁殖)。'''def iterate(Z): # Count neighbours N = (Z[0:-2,0:-2] + Z[0:-2,1:-1] + Z[0:-2,2:] + Z[1:-1,0:-2] + Z[1:-1,2:] + Z[2: ,0:-2] + Z[2: ,1:-1] + Z[2: ,2:]) # Apply rules birth = (N==3) &amp; (Z[1:-1,1:-1]==0) survive = ((N==2) | (N==3)) &amp; (Z[1:-1,1:-1]==1) Z[...] = 0 Z[1:-1,1:-1][birth | survive] = 1 return ZZ = np.random.randint(0,2,(50,50))for i in range(100): Z = iterate(Z) print (Z) 结果：[[0 0 0 ... 0 0 0] [0 0 0 ... 0 0 0] [0 0 0 ... 0 0 0] ... [0 0 0 ... 0 0 0] [0 0 0 ... 0 0 0] [0 0 0 ... 0 0 0]] 如何找到一个数组的第n个最大值? 12345678# argsort()排序后读取倒数第n个值Z = np.arange(10000)np.random.shuffle(Z)n = 5print(Z[np.argsort(Z)[-n:]])结果：[9995 9996 9997 9998 9999] 给定任意个数向量，创建笛卡尔积(每一个元素的每一种组合) 1234567891011121314151617181920212223242526# 笛卡尔积：两个集合的组合# np.indices()def cartesian(arrays): arrays = [np.asarray(a) for a in arrays] shape = (len(x) for x in arrays) ix = np.indices(shape, dtype=int) ix = ix.reshape(len(arrays), -1).T for n, arr in enumerate(arrays): ix[:, n] = arrays[n][ix[:, n]] return ixprint(cartesian(([1, 2, 3], [4, 5], [6, 7])))结果：[[1 4 6] [1 4 7] [1 5 6] [1 5 7] [2 4 6] [2 4 7] [2 5 6] [2 5 7] [3 4 6] [3 4 7] [3 5 6] [3 5 7]] 如何从一个正常数组创建记录数组(record array)? 1234567# np.core.records.fromarrays()Z = np.array([(\"Hello\", 2.5, 3), (\"World\", 3.6, 2)])R = np.core.records.fromarrays(Z.T, names='col1, col2, col3', formats='S8, f8, i8')print(R)结果：[(b'Hello', 2.5, 3) (b'World', 3.6, 2)] 考虑一个大向量Z, 用三种不同的方法计算它的立方 12345678910111213# np.power() 对列表、矩阵、数组等求n次方# '*'# np.einsum() 将向量插入某一行或列# 方法一x = np.random.rand()np.power(x, 3)# 方法二x*x*x# 方法三np.einsum('i, i, i-&gt;i', x,x,x) 考虑两个形状分别为(8,3)和(2,2)的数组A和B. 如何在数组A中找到满足包含B中元素的行？(不考虑B中每行元素顺序)？ 12345678910# np.where()A = np.random.randint(0, 5, (8, 3))B = np.random.randint(0, 5, (2, 2))C = (A[..., np.newaxis, np.newaxis] == B)rows = np.where(C.any((3, 1)).all(1))[0]print(rows)结果：[6 7] 考虑一个10x3的矩阵，分解出有不全相同值的行 (如[2,2,3]) 12345678910111213141516171819202122232425262728293031Z = np.random.randint(0, 5, (10, 3))print(Z)E = np.all(Z[:,1:] == Z[:,:-1], axis=1)U = Z[~E]print(U)结果：Z：[[4 0 3] [1 3 3] [2 0 4] [1 0 2] [0 2 2] [3 2 4] [0 1 2] [4 4 2] [0 0 0] [2 1 2]]U：[[1 2 2] [4 4 1] [0 1 3] [0 4 0] [3 1 0] [4 4 0] [1 3 2] [2 3 4] [4 4 1] [1 2 3]] 将一个整数向量转换为二进制矩阵matrix binary的表现形式 12345678910111213141516# np.unpackbits() 把整数转化乘二进制I = np.array([0, 1, 2, 3, 4, 15, 16, 32, 64, 128])B = ((I.reshape(-1, 1)&amp;(2**np.arange(8)))!=0).astype(int)print(B[:,::-1])结果：[[0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 1] [0 0 0 0 0 0 1 0] [0 0 0 0 0 0 1 1] [0 0 0 0 0 1 0 0] [0 0 0 0 1 1 1 1] [0 0 0 1 0 0 0 0] [0 0 1 0 0 0 0 0] [0 1 0 0 0 0 0 0] [1 0 0 0 0 0 0 0]] 给定一个二维数组，如何提取出唯一的(unique)行？ 1234567891011121314# np.ascontiguousarray() 将一个内存不连续存储的数组转化为内存连续存储的数组，加快运行速度Z = np.random.randint(0,2,(6,3))T = np.ascontiguousarray(Z).view(np.dtype((np.void, Z.dtype.itemsize * Z.shape[1])))_, idx = np.unique(T, return_index=True)uZ = Z[idx]print (uZ)结果：[[0 1 0] [0 1 1] [1 0 1] [1 1 0]] 考虑两个向量A和B，写出用einsum等式对应的inner, outer, sum, mul函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# np.einsumA = np.random.uniform(0, 1, 10)B = np.random.uniform(0, 1, 10)print('sum')print(np.einsum('i-&gt;', A))结果：sum4.903677057922876print('A * B')print(np.einsum('i, i-&gt;i', A, B))结果：A * B[0.47153643 0.25317511 0.20142837 0.05835824 0.20308374 0.10641387 0.21122253 0.54794781 0.21782327 0.18996213]print('inner')print(np.einsum('i, i', A, B))结果:inner2.4609515005732665 print('outer')print(np.einsum('i, j-&gt;ij', A, B))结果：outer[[0.47153643 0.22882703 0.27068423 0.41698768 0.22448079 0.33164545 0.67680915 0.39473786 0.37198788 0.35538228] [0.52170974 0.25317511 0.29948609 0.46135679 0.24836641 0.36693382 0.74882428 0.4367395 0.41156883 0.39319634] [0.35089156 0.17028053 0.20142837 0.31029937 0.16704629 0.24679237 0.50364427 0.29374228 0.27681298 0.26445601] [0.06599245 0.03202479 0.03788279 0.05835824 0.03141652 0.04641443 0.09472076 0.05524434 0.05206043 0.04973644] [0.42659055 0.20701571 0.24488317 0.37724128 0.20308374 0.3000337 0.6122971 0.35711226 0.33653076 0.32150798] [0.15130018 0.0734229 0.08685347 0.13379732 0.07202834 0.10641387 0.2171653 0.1266581 0.1193584 0.11403022] [0.14715983 0.07141367 0.08447671 0.13013594 0.07005727 0.10350184 0.21122253 0.12319208 0.11609214 0.11090977] [0.65455427 0.31764186 0.37574514 0.57883347 0.31160871 0.46036729 0.93949967 0.54794781 0.51636785 0.49331711] [0.27611547 0.13399321 0.15850335 0.2441736 0.1314482 0.19420014 0.39631609 0.23114487 0.21782327 0.2080996 ] [0.25204989 0.12231468 0.14468857 0.22289201 0.11999149 0.17727411 0.36177412 0.21099883 0.19883831 0.18996213]] 考虑一个由两个向量描述的路径(X,Y)，如何用等距样例(equidistant samples)对其进行采样(sample)? 12345678910111213141516# np.sumsum(), np.interpphi = np.arange(0, 10*np.pi, 0.1)a = 1x = a*phi*np.cos(phi)y = a*phi*np.sin(phi)dr =(np.diff(x)**2 + np.diff(y)**2)**.5r = np.zeros_like(x)r[1:] = np.cumsum(dr) # integrate pathr_int = np.linspace(0, r.max(), 200) # regular spaced pathx_int = np.interp(r_int, r, x) # integrate pathy_int = np.interp(r_int, r, y)结果： 给定整数n和2D数组X，从X中选择可以解释为具有n度的多项分布的绘制的行，即，仅包含整数并且总和为n的行。 123456789# np.logical_and.reduce(), np.mod()X = np.asarray([[1.0, 0.0, 3.0, 8.0], [2.0, 0.0, 1.0, 1.0], [1.5, 2.5, 1.0, 1.0]])n = 4M = np.logical_and.reduce(np.mod(X, 1) == 0, axis=-1)M &amp;= (X.sum(axis=-1) == n)print(X[M])结果：[[2. 0. 1. 1.]] 计算1D阵列X的平均值的自举95％置信区间（即，对替换N次的阵列的元素进行重新采样，计算每个样本的平均值，然后计算均值上的百分位数）。 123456789X = np.random.randn(100) # random 1D arrayN = 1000 # number of bootstrap samplesidx = np.random.randint(0, X.size, (N, X.size))means = X[idx].mean(axis=1)confint = np.percentile(means, [2.5, 97.5])print (confint)结果：[0.06141008 0.46613253] 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://zivblog.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://zivblog.top/tags/Python/"}]},{"title":"Numpy100题之61-80","slug":"Numpy100题之61-80","date":"2019-08-28T04:54:21.000Z","updated":"2020-03-04T06:34:57.437Z","comments":true,"path":"passages/numpy100-ti-zhi-61-80/","link":"","permalink":"http://zivblog.top/passages/numpy100-ti-zhi-61-80/","excerpt":"学习笔记 答案整理 原文地址：https://zhuanlan.zhihu.com/p/76186124","text":"学习笔记 答案整理 原文地址：https://zhuanlan.zhihu.com/p/76186124 从数组中的给定值中找出最近的值 12345678910# 使用到abs()、flat()、argmin()# 功能分别为：取绝对值、返回一个数组的迭代器，可通过for循环访问、获取最小值的索引Z = np.random.uniform(0, 1, 10)z = 0.5m = Z.flat[np.abs(Z-z).argmin()]print(m)结果：0.5390768396166375 如何用迭代器(iterator)计算两个分别具有形状(1,3)和(3,1)的数组? 1234567891011121314# np.nditer()，传入的数组，返回一个可迭代的迭代器A = np.arange(3).reshape(3, 1)B = np.arange(3).reshape(1, 3)it = np.nditer([A, B, None])for x, y, z in it: z[...] = x + yprint(it.operands[2])结果：[[0 1 2] [1 2 3] [2 3 4]] 创建一个具有name属性的数组类 1234567891011121314151617# 类的定义class NamedArray(np.ndarray): def __new__(cls, array, name=\"no name\"): obj = np.asarray(array).view(cls) obj.name = name return obj def __array_finalize__(self, obj): if obj is None: return self.info = getattr(obj, 'name', \"no name\") Z = NameArray(np.arange(10), \"range_10\")print(Z.name)结果：range_10 考虑一个给定的向量，如何对由第二个向量索引的每个元素加1(小心重复的索引)? 1234567891011121314151617181920# 题设要求对于重复给出的索引每次遇到均+1# 使用bincount()函数，该函数可以对数组中出现的值的次数进行统计，反映在输出向量的相应下标的位置# 方法一Z = np.ones(10) # 给定向量I = np.random.randint(0, len(Z), 20) # 索引向量Z += np.bincount(I, minlength=len(Z))print(Z)结果：[2. 4. 3. 1. 4. 2. 5. 6. 2. 1.]# 方法二# at() 对Z中的元素，根据I中的索引，每次+1np.add.at(Z, I, 1)print(Z)结果：[2. 4. 3. 1. 4. 2. 5. 6. 2. 1.] 根据索引列表(I)，如何将向量(X)的元素累加到数组(F)? 12345678X = [1, 2, 3, 4, 5, 6]I = [1, 3, 9, 3, 4, 1]F = np.bincount(I, X)print(F)结果：[0. 7. 0. 6. 5. 0. 0. 0. 0. 3.] 考虑一个(dtype=ubyte) 的 (w,h,3)图像，计算其唯一颜色的数量 12345678910# 使用unique()函数：对于数组或者列表，去除其中重复的元素，按元素由大到小返回一个无重复的列表或数组w, h = 16, 16I = np.random.randint(0, 2, (h, w, 3)).astype(np.ubyte)F = I[..., 0]*(256*256) + I[..., 1]*256 + I[..., 2]n = len(np.unique(F))print(n)结果：8 考虑一个四维数组，如何一次性计算出最后两个轴(axis)的和？ 123456789# sum(axis=) 指定计算根据的的轴A = np.random.randint(0, 10, (3, 4, 3, 4))sum = A.sum(axis=(-2, -1))print(sum)结果：[[64 55 51 45] [38 55 48 53] [73 73 60 50]] 考虑一个一维向量D，如何使用相同大小的向量S来计算D子集的均值？ 12345678910111213# np.bincount()D = np.random.uniform(0, 1, 100)S = np.random.randint(0, 10, 100)D_sums = np.bincount(S, weights=D)D_counts = np.bincount(S)D_means = D_sums / D_countsprint(D_means)结果：[0.40365511 0.52710526 0.67046511 0.33109763 0.67705689 0.49109846 0.36351819 0.53482213 0.58558006 0.5682075 ] 如何获得点积dot prodcut的对角线? 12345678# diag()，当传入一维数组时，结果形成一个以一维数组为对角线元素的矩阵；当传入的是二维数组时，结果输出矩阵的对角线元素A = np.random.uniform(0, 1, (5, 5))B = np.random.uniform(0, 1, (5, 5))# 5*5与5*5矩阵的点乘积仍是5*5矩阵np.diag(np.dot(A, B))结果：array([0.70100234, 0.92730124, 1.89491706, 1.79228104, 1.48440929]) 考虑一个向量[1,2,3,4,5]，如何建立一个新的向量，在这个新向量中每个值之间有3个连续的零？ 123456# 创建一个足够长度的0矩阵，将向量中的元素按每隔3个0替换一个A = np.array([1, 2, 3, 4, 5])nz = 3A0 = np.zeros(len(A) + (len(A)-1)*nz)A0[::nz+1] = Aprint(A0) 考虑一个维度(5,5,3)的数组，如何将其与一个(5,5)的数组相乘？ 123456789101112131415161718192021222324252627282930313233343536# 将B构造成第三个维度为None的三维数组A = np.ones((5, 5, 3))B = 2*np.ones((5, 5))print(A * B[:,:,None])结果：[[[2. 2. 2.] [2. 2. 2.] [2. 2. 2.] [2. 2. 2.] [2. 2. 2.]] [[2. 2. 2.] [2. 2. 2.] [2. 2. 2.] [2. 2. 2.] [2. 2. 2.]] [[2. 2. 2.] [2. 2. 2.] [2. 2. 2.] [2. 2. 2.] [2. 2. 2.]] [[2. 2. 2.] [2. 2. 2.] [2. 2. 2.] [2. 2. 2.] [2. 2. 2.]] [[2. 2. 2.] [2. 2. 2.] [2. 2. 2.] [2. 2. 2.] [2. 2. 2.]]] 如何对一个数组中任意两行做交换? 12345678910A = np.arange(25).reshape(5, 5)A[[0, 1]] = A[[1, 0]]print(A)结果：[[ 5 6 7 8 9] [ 0 1 2 3 4] [10 11 12 13 14] [15 16 17 18 19] [20 21 22 23 24]] 考虑一个可以描述10个三角形的数组triplets，找到可以分割全部三角形的line segment 1234567891011121314151617181920# repeat(axis=) 复制多维数组的每一个元素，axis来控制复制的行和列# np.roll(array, shift, axis=) array沿axis的方向滚动shift长度 # np.sort() 排序# view() 区别与copy(),与原始数据共享一份内存# np.unique() 返回列表或数组中不重复元素组成的列表或数组faces = np.random.randint(0, 100, (10, 3))F = np.roll(faces.repeat(2, axis=1), -1, axis=1)F = F.reshape(len(F)*3, 2)F = np.sort(F, axis=1)G = F.view(dtype=[('p0', F.dtype), ('p1', F.dtype)])G = np.unique(G)print(G)结果：[( 5, 31) ( 5, 53) (11, 25) (11, 46) (12, 37) (12, 85) (20, 35) (20, 51) (20, 84) (22, 47) (22, 84) (25, 46) (27, 47) (27, 66) (31, 53) (35, 84) (37, 85) (47, 66) (47, 84) (51, 84) (58, 63) (58, 77) (58, 95) (58, 99) (63, 79) (63, 92) (63, 99) (77, 95) (79, 92)] 给定一个二进制的数组C，如何产生一个数组A满足np.bincount(A)==C 123456C = np.bincount([1, 1, 2, 3, 4, 4, 6])A = np.repeat(np.arange(len(C)), C)print(A)结果：[1 1 2 3 4 4 6] 如何通过滑动窗口计算一个数组的平均数? 1234567891011# cumsum() 沿指定轴累加数组元素def moving_average(a, n=3): ret = np.cumsum(a, dtype=float) ret[n:] = ret[n:] - ret[:-n] return ret[n-1:]/nZ = np.arange(20)print(moving_average(Z, n=3))结果：[ 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18.] 考虑一维数组Z，构建一个二维数组，其第一行是(Z [0]，Z [1]，Z [2])，每个后续行移1（最后一行应该是(Z[-3], Z[-2], Z[-1]) 123456789101112131415161718from numpy.lib import stride_tricksdef rolling(a, window): shape = (a.size - window + 1, window) strides = (a.itemsize, a.itemsize) return stride_tricks.as_strided(a, shape=shape, strides=strides)Z = rolling(np.arange(10), 3)print(Z)结果：[[0 1 2] [1 2 3] [2 3 4] [3 4 5] [4 5 6] [5 6 7] [6 7 8] [7 8 9]] 如何对布尔值取反，或者原位(in-place)改变浮点数的符号(sign)？ 123456789101112131415161718192021222324252627282930313233343536373839# lofical_not()逻辑非、negative()数值取反# 方法一# 随机整数Z = np.random.randint(0, 2, 100)np.logical_not(Z, out = Z)结果：array([0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0])# 方法二：# uniform() 均匀分布Z = np.random.uniform(-1.0, 1.0, 100)np.negative(Z, out=Z)结果：array([ 0.05031312, 0.97772171, -0.67264233, -0.04618383, -0.75397481, -0.34317743, -0.53194673, -0.51918606, -0.37304893, -0.4663474 , -0.78875942, 0.01936397, 0.80160394, 0.39005544, -0.93873232, 0.15195121, -0.94860217, 0.2568072 , -0.97441577, 0.03277601, 0.23323496, 0.10736939, -0.16071465, 0.34222035, 0.96903346, 0.58671838, -0.43651958, -0.56495989, 0.24749138, 0.77204365, 0.92396754, 0.73266475, -0.89578353, -0.61700747, 0.68577537, 0.74575805, 0.03375484, 0.61118915, 0.28219652, -0.15861781, 0.04221261, 0.55310498, -0.15580574, 0.60873475, 0.02851121, 0.19668448, -0.04052335, -0.73228185, 0.25773921, -0.90191087, -0.74177161, -0.25423155, -0.25450614, 0.44865308, -0.21338786, 0.59592018, -0.29278901, 0.16500941, 0.28332166, -0.2661733 , -0.93792278, 0.29708284, 0.35718338, -0.70322395, -0.71643805, -0.9543976 , 0.65792415, 0.35181269, -0.78627817, 0.48762508, -0.51068373, 0.76540099, 0.89172685, 0.15993627, 0.64279179, 0.32152709, 0.25847394, -0.36426917, -0.74235575, -0.48144595, 0.51877578, 0.86605299, 0.51672054, 0.79402976, -0.11626431, -0.34747431, 0.59585038, 0.1204304 , 0.35118293, 0.44558852, 0.56999461, -0.4820329 , 0.81815528, -0.29603943, 0.68750352, -0.50152259, -0.85042461, -0.36994314, -0.23032343, 0.43806343]) 考虑两组点集P0和P1去描述一组线(二维)和一个点p,如何计算点p到每一条线 i(P0[i],P1[i])的距离？ 1234567891011121314151617def distance(P0, P1, p): # 计算点到直线的距离 T = P1 - P0 L = (T**2).sum(axis = 1) U = -((P0[:, 0]-p[..., 0])*T[:, 0] + (P0[:, 1]-p[..., 1])*T[:, 1])/L U = U.reshape(len(U), 1) D = P0 + U*T - p return np.sqrt((D**2).sum(axis=1))P0 = np.random.uniform(-10, 10, (10, 2))P1 = np.random.uniform(-10, 10, (10, 2))p = np.random.uniform(-10, 10, (1, 2))print(disrance(P0, P1, p))结果：[ 6.46089551 2.02019414 7.64957844 10.26739442 4.32840633 5.87598718 3.46730169 10.69040697 3.7238278 9.71021116] 考虑两组点集P0和P1去描述一组线(二维)和一组点集P，如何计算每一个点 j(P[j]) 到每一条线 i (P0[i],P1[i])的距离？ 123456789101112131415161718192021222324252627282930313233343536# 区别于上一个题，这里的点更多def distance(P0, P1, p): # 计算点到直线的距离 T = P1 - P0 L = (T**2).sum(axis = 1) U = -((P0[:, 0]-p[..., 0])*T[:, 0] + (P0[:, 1]-p[..., 1])*T[:, 1])/L U = U.reshape(len(U), 1) D = P0 + U*T - p return np.sqrt((D**2).sum(axis=1))P0 = np.random.uniform(-10, 10, (10, 2))P1 = np.random.uniform(-10, 10, (10, 2))p = np.random.uniform(-10, 10, (10, 2))print(np.array([distance(P0, P1, p_i) for p_i in p]))结果：[[ 5.40670646 4.80013481 13.30601528 8.6187585 7.35755714 12.54151718 9.24071207 5.34703263 14.54922937 4.14588354] [ 2.63018703 0.08876084 4.14888539 1.65492189 7.70382067 7.36081638 6.90710177 6.81786912 1.07761109 8.51096456] [ 2.0266857 4.72537985 3.16720835 2.75861123 4.44025815 3.15808096 7.75627919 9.49123505 2.26774137 11.02113161] [ 0.34856518 0.72250344 3.4643871 1.70975185 1.83784162 10.92846839 0.64753047 0.5347269 6.3404948 2.05269702] [12.82851216 14.21297741 6.8487462 14.30053038 7.75964014 0.48502181 1.07738736 7.4534913 3.65341342 8.50158022] [ 4.35980428 5.21646493 6.17805894 6.46221918 2.49150711 8.03708833 1.71241686 1.40535458 7.06802357 2.73535593] [12.91407892 14.72355803 4.92113516 14.05365253 6.65559267 2.09719282 3.26734451 9.57392312 1.44886514 10.64497421] [ 0.26278106 4.226739 9.6454433 0.05753583 9.3296571 0.06745266 14.25882312 14.97942175 8.66727328 16.65261174] [ 1.44097653 3.77673716 1.70901896 2.47012398 3.90447614 4.93446335 5.88189824 7.47118652 0.34370906 9.000505 ] [ 7.46966507 10.6966451 3.60754571 7.64953446 1.57566894 3.00667962 10.52316245 14.30615261 5.43992693 15.66648646]] 考虑一个任意数组，写一个函数，提取一个固定形状的子部分，并以给定元素为中心（fill必要时填充一个值） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# minimum, maximum# 在10*10的数组中，提取5*5的子部分，中心为0Z = np.random.randint(0, 10, (10, 10))shape = (5, 5)fill = 0position = (1, 1)R = np.ones(shape, dtype=Z.dtype)*fillP = np.array(list(position)).astype(int)Rs = np.array(list(R.shape)).astype(int)Zs = np.array(list(Z.shape)).astype(int)R_start = np.zeros((len(shape),)).astype(int)R_stop = np.array(list(shape)).astype(int)Z_start = (P-Rs//2)Z_stop = (P+Rs//2)+Rs%2R_start = (R_start - np.minimum(Z_start,0)).tolist()Z_start = (np.maximum(Z_start,0)).tolist()R_stop = np.maximum(R_start, (R_stop - np.maximum(Z_stop-Zs,0))).tolist()Z_stop = (np.minimum(Z_stop,Zs)).tolist()r = [slice(start,stop) for start,stop in zip(R_start,R_stop)]z = [slice(start,stop) for start,stop in zip(Z_start,Z_stop)]R[r] = Z[z]print (Z)print (R)结果：[[2 5 6 6 7 5 3 3 1 8] [5 7 0 5 6 3 8 2 4 0] [5 5 0 5 8 3 0 9 1 4] [9 3 3 5 0 1 6 7 3 2] [1 7 2 2 6 4 7 7 9 2] [0 5 7 6 2 0 7 7 7 9] [3 2 0 3 1 1 8 4 0 0] [8 1 7 9 8 9 5 0 0 7] [1 1 9 0 4 4 1 9 5 4] [5 1 0 7 6 9 4 1 3 6]][[0 0 0 0 0] [0 2 5 6 6] [0 5 7 0 5] [0 5 5 0 5] [0 9 3 3 5]] 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://zivblog.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://zivblog.top/tags/Python/"}]},{"title":"Numpy之genfromtxt函数","slug":"Numpy之genfromtxt函数","date":"2019-08-26T13:41:24.000Z","updated":"2020-07-06T05:36:52.515Z","comments":true,"path":"passages/numpy-zhi-genfromtxt-han-shu/","link":"","permalink":"http://zivblog.top/passages/numpy-zhi-genfromtxt-han-shu/","excerpt":"genfromtext","text":"genfromtext genfromtxt()函数位于numpy.genfromtxt() 函数的完整形式为 1numpy.genfrom(fname, dtype= , comments='#', delimiter=None, skip_header=0, skip_footer=0, converters=None, missing_values=None, filling_values=None, usecols=None, names=None, excludelist=None, deletechars=None, replace_space='_', autostrip=Falsem, case_sensitive=True, defaultfmt='f%i', unpack=None, usemask=False, loose=True, invalid_raise=True, max_rows=None)[source] 下面详细介绍各个参数的意义： fname：文件名 dtype：表明数据的类型 comments：参数是一个字符串，标志着一个注释的开始符号，默认是“#” delimiter：分隔符，可以是str、int、sequence、optional skip_header：跳过页眉，参数值是个整数，表示跳过的行数，默认为0 skip_footer：跳过页脚，参数值是个整数，表示跳过的行数，默认为0 converters：用以定义转换函数 missing_values：默认情况下空字符串都被标记为缺少，使用该参数可以将更多类型的字符串识别为缺少，例如N/A filling_values：将missing_values识别出的标记为缺少的位置替换为该参数提供的值，可以是单个值、值序列、字典 usecols：参数是一个整数序列，选择读取哪些行 names：处理表格是要为每一列分配一个名称，可以通过显式的dtype来设置；或者names参数接收以个关键字与逗号组成的字符串；将该参数设为True会将文件第一行的内容读作文件名，不管是是注释 exclueslist：一系列要删除的 deletechars：需要删除的连接符，默认为‘’!@#$%^&amp;*()——+=|]}({;:/?&gt;,&lt; replace_space：替换变量名称中的空格 autostrip：设为True可以去掉序列中每一项前后的多余空格 case_sensitive：字段名是否区分大小写 defaultfmt：只有在名字没有定义式才会使用该属性，用以覆盖默认值‘f%i’ unpack：是否对读取的数组进行转置 usemask：构造布尔掩码来追踪丢失数据的出现，返回掩码序列；将该属性设为True后，有缺失数据为True，没有缺失数据则为False loose：不对无效之引发错误 invalid_raise：如果为true，则在检测到列数不一致时引发异常。如果为false，将发出警告并跳过违规行 max_rows：要读取的最大行数。不能同时与skip_footer一起使用。如果给定，值必须至少为1。默认值是读取整个文件 一个例子（代码来自网络，仅作整理，添加注释） 123456789101112# 引入一个数据集import urllib2url = 'http://aima.cs.berkeley.edu/data/iris.csv'u = urllib2.urlopen(url)localFile = open('iris.csv'', 'w')localFile.write(u.read())localFile.close() # 将数据集导入到程序from numpy import genfromtxt,zerosdata = genfomtxt('iris.csv', delimiter=',', usecols=(0, 1, 2, 3))target = genfromtxt('iris.csv', delimiter=',', usecols=(4), dtype=str) 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://zivblog.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://zivblog.top/tags/Python/"}]},{"title":"Numpy100题之41~60","slug":"Numpy100题之41-60","date":"2019-08-23T10:57:41.000Z","updated":"2020-03-04T06:34:34.122Z","comments":true,"path":"passages/numpy100-ti-zhi-41-60/","link":"","permalink":"http://zivblog.top/passages/numpy100-ti-zhi-41-60/","excerpt":"学习笔记 答案整理 原文地址：https://zhuanlan.zhihu.com/p/76186124","text":"学习笔记 答案整理 原文地址：https://zhuanlan.zhihu.com/p/76186124 对于一个小数组，如何用比np.sum更快的方式对其求和？ 1234567# 使用np.add.reduce()，两者功能相同# 但对于小型数组，np.add.reduce()的速度比np.sum()快两倍Z = np.arange(10)np.add.reduce(Z)结果：45 对于两个随机数组A和B，检查它们是否相等 12345678910111213141516171819# np.allclose()可判断两个array是不是每个元素都相等# np.array_equal()判断两个数组是否相等# 创建两个随机整型数组A = np.random.randint(0, 2, 5)B = np.random.randint(0, 2, 5)equal1 = np.allclose(A, B)equal2 = np.array_equal(A, B)ABequal1equal2结果：array([0, 1, 0, 1, 1])array([1, 0, 0, 1, 0])FalseFalse 创建一个只读数组(read-only) 123# 通过设置数组的flags.writeable属性来指定数组是否只读Z = np.zeros(10)Z.flags.writeable = False 将笛卡尔坐标下的一个10x2的矩阵转换为极坐标形式 12345678910111213141516# 使用到开方函数np.sqrt()、反三角函数np.arctan2()函数# 随机生成一个指教坐标系下的坐标Z = np.random.random((10, 2))X, Y = Z[:, 0], Z[:, 1]R = np.sqrt(X**2 + Y**2)T = np.arctan2(Y, X)RT结果：array([0.3944447 , 0.94777816, 0.83140372, 0.74598633, 0.91967574, 0.75524468, 0.79999599, 0.6049436 , 0.43862584, 1.09668726])array([1.45680562, 0.40002162, 1.13268754, 1.00810909, 0.08777813, 0.79438818, 0.19055149, 0.6108188 , 0.61328375, 1.08466593]) 创建一个长度为10的向量，并将向量中最大值替换为1 12345678910111213# 使用argmax()获取想两种最大值的索引Z = np.random.random(10)ZZ[Z.argmax()] = 1Z结果：array([0.15094359, 0.9866758 , 0.19716025, 0.753693 , 0.3756874 , 0.61064317, 0.32985381, 0.37475131, 0.11217617, 0.71798767])array([0.15094359, 1. , 0.19716025, 0.753693 , 0.3756874 , 0.61064317, 0.32985381, 0.37475131, 0.11217617, 0.71798767]) 创建一个结构化数组，并实现x和y坐标覆盖[0,1]x[0,1]区域 1234567891011121314151617# np.meshgrid() 生成网格点坐标矩阵，把两个数组的笛卡尔积内的元素的第一二个坐标分别放入两个矩阵中Z = np.zeros((5, 5), [('x', float), ('y', float)])Z['x'], Z['y'] = np.meshgrid(np.linspace(0, 1, 5), np.linspace(0, 1, 5))Z结果：array([[(0. , 0. ), (0.25, 0. ), (0.5 , 0. ), (0.75, 0. ), (1. , 0. )], [(0. , 0.25), (0.25, 0.25), (0.5 , 0.25), (0.75, 0.25), (1. , 0.25)], [(0. , 0.5 ), (0.25, 0.5 ), (0.5 , 0.5 ), (0.75, 0.5 ), (1. , 0.5 )], [(0. , 0.75), (0.25, 0.75), (0.5 , 0.75), (0.75, 0.75), (1. , 0.75)], [(0. , 1. ), (0.25, 1. ), (0.5 , 1. ), (0.75, 1. ), (1. , 1. )]], dtype=[('x', '&lt;f8'), ('y', '&lt;f8')]) 给定两个数组X和Y，构造Cauchy矩阵C(每个元素：$C_{ij} =1/(x_i - y_j)$) 12345678910111213141516171819202122232425X = np.arange(8)Y = X + 0.5C = 1.0 / np.subtract.outer(X, Y)Cprint(np.linalg.det(C))结果：array([[-2. , -0.66666667, -0.4 , -0.28571429, -0.22222222, -0.18181818, -0.15384615, -0.13333333], [ 2. , -2. , -0.66666667, -0.4 , -0.28571429, -0.22222222, -0.18181818, -0.15384615], [ 0.66666667, 2. , -2. , -0.66666667, -0.4 , -0.28571429, -0.22222222, -0.18181818], [ 0.4 , 0.66666667, 2. , -2. , -0.66666667, -0.4 , -0.28571429, -0.22222222], [ 0.28571429, 0.4 , 0.66666667, 2. , -2. , -0.66666667, -0.4 , -0.28571429], [ 0.22222222, 0.28571429, 0.4 , 0.66666667, 2. , -2. , -0.66666667, -0.4 ], [ 0.18181818, 0.22222222, 0.28571429, 0.4 , 0.66666667, 2. , -2. , -0.66666667], [ 0.15384615, 0.18181818, 0.22222222, 0.28571429, 0.4 , 0.66666667, 2. , -2. ]])3638.1636371179666 打印每个Numpy标量类型的最小值和最大值 123456789101112131415161718192021222324252627# np.iinfo：整型的机器限制，包括最大值最小值# np.finfo, eps：浮点型的机器限制for dtype in [np.int8, np.int32, np.int64]: print(np.iinfo(dtype).min) print(np.iinfo(dtype).max)结果：-128127-21474836482147483647-92233720368547758089223372036854775807for dtype in [np.float32, np.float64]: print(np.finfo(dtype).min) print(np.finfo(dtype).max) print(np.finfo(dtype).eps) 结果：-3.4028235e+383.4028235e+381.1920929e-07-1.7976931348623157e+3081.7976931348623157e+3082.220446049250313e-16 如何打印一个数组中的所有数值? 123456789101112131415161718192021222324# 使用np.set_printoptions(threshold=nan)设置打印时的显示方式# 其中threashold=nan表示输出数组时完全输出，不会使用省略号省略中间数据np.set_printoptions(threshold=np.inf)Z = np.zeros((16, 16))print(Z)结果：[[0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]] 给定标量时，如何找到数组中最接近标量的值？ 1234567891011121314151617# 使用argmin()获取最小值的下标# 最接近指定标量的值，可以通过取每个值与指定标量的绝对值，然后取绝对值最小的Z =np.arange(100)v = np.random.uniform(0, 100)index = (np.abs(Z-v)).argmin()print(Z[index])结果：指定标量v为：33数组Z内容array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99])33 创建一个表示位置(x,y)和颜色(r,g,b)的结构化数组 12345678910# 两个属性，分别是position和colorZ = np.zeros(10, [('position', [('x', float, 1), ('y', float, 1)]), ('color', [('r', float, 1), ('g', float, 1), ('b', float, 1)])])print(Z)结果：[((0., 0.), (0., 0., 0.)) ((0., 0.), (0., 0., 0.)) ((0., 0.), (0., 0., 0.)) ((0., 0.), (0., 0., 0.)) ((0., 0.), (0., 0., 0.)) ((0., 0.), (0., 0., 0.)) ((0., 0.), (0., 0., 0.)) ((0., 0.), (0., 0., 0.)) ((0., 0.), (0., 0., 0.)) ((0., 0.), (0., 0., 0.))] 对一个表示坐标形状为(100,2)的随机向量，找到点与点的距离 12345678910111213141516171819202122232425262728# np.atleast_1d(), np.atleast_2d(), np.atleast_3d()# 分别用于将输入转化为至少具有一个、两个、三个维度的数组Z = np.random.random((10, 2))X , Y = np.atleast_2d(Z[:, 0], Z[:, 1])D = np.sqrt((X - X.T)**2, (Y - Y.T)**2)print(D)结果：[[0. 0.38993115 0.01674273 0.1174607 0.01335761 0.37033472 0.04442136 0.50701389 0.00334056 0.38674937] [0.38993115 0. 0.40667389 0.50739185 0.40328876 0.01959643 0.34550979 0.11708273 0.38659059 0.00318179] [0.01674273 0.40667389 0. 0.10071797 0.00338513 0.38707745 0.0611641 0.52375662 0.02008329 0.4034921 ] [0.1174607 0.50739185 0.10071797 0. 0.1041031 0.48779542 0.16188206 0.62447459 0.12080126 0.50421007] [0.01335761 0.40328876 0.00338513 0.1041031 0. 0.38369232 0.05777897 0.52037149 0.01669817 0.40010697] [0.37033472 0.01959643 0.38707745 0.48779542 0.38369232 0. 0.32591336 0.13667917 0.36699416 0.01641465] [0.04442136 0.34550979 0.0611641 0.16188206 0.05777897 0.32591336 0. 0.46259252 0.0410808 0.342328 ] [0.50701389 0.11708273 0.52375662 0.62447459 0.52037149 0.13667917 0.46259252 0. 0.50367333 0.12026452] [0.00334056 0.38659059 0.02008329 0.12080126 0.01669817 0.36699416 0.0410808 0.50367333 0. 0.38340881] [0.38674937 0.00318179 0.4034921 0.50421007 0.40010697 0.01641465 0.342328 0.12026452 0.38340881 0. ]] 如何将32位的浮点数(float)转换为对应的整数(integer)? 1234567# 使用astype(copy = False)修改数据类型Z = np.arange(10, dtype=np.int32)Z = Z.astype(np.float32, copy=False)print(Z)结果：[0. 1. 2. 3. 4. 5. 6. 7. 8. 9.] 如何读取以下文件? 见genfromtxt函数详细介绍的博客 对于Numpy数组，enumerate的等价操作是什么？ 123456789101112131415161718192021222324252627282930# enumerate指的是枚举# numpy中可以通过np.ndenumerate()和np.ndindex()实现枚举Z = np.arange(9).reshape(3, 3)for index, value in np.ndenumerate(Z): print(index, value)结果：(0, 0) 0(0, 1) 1(0, 2) 2(1, 0) 3(1, 1) 4(1, 2) 5(2, 0) 6(2, 1) 7(2, 2) 8for index in np.ndindex(Z.shape): print(index, Z[index]) 结果：(0, 0) 0(0, 1) 1(0, 2) 2(1, 0) 3(1, 1) 4(1, 2) 5(2, 0) 6(2, 1) 7(2, 2) 8 生成一个通用的二维Gaussian-like数组 12345678910111213141516171819202122232425262728# np.meshgrid() 生成网格点坐标矩阵，把两个数组的笛卡尔积内的元素的第一二个坐标分别放入两个矩阵中X, Y = np.meshgrid(np.linspace(-1, 1, 10), np.linspace(-1, 1, 10))D = np.sqrt(X*X + Y*Y)sigma, mu = 1.0, 0.0G = np.exp(-((D-mu)**2/(2.0*sigma**2)))print(G)结果：[[0.36787944 0.44822088 0.51979489 0.57375342 0.60279818 0.60279818 0.57375342 0.51979489 0.44822088 0.36787944] [0.44822088 0.54610814 0.63331324 0.69905581 0.73444367 0.73444367 0.69905581 0.63331324 0.54610814 0.44822088] [0.51979489 0.63331324 0.73444367 0.81068432 0.85172308 0.85172308 0.81068432 0.73444367 0.63331324 0.51979489] [0.57375342 0.69905581 0.81068432 0.89483932 0.9401382 0.9401382 0.89483932 0.81068432 0.69905581 0.57375342] [0.60279818 0.73444367 0.85172308 0.9401382 0.98773022 0.98773022 0.9401382 0.85172308 0.73444367 0.60279818] [0.60279818 0.73444367 0.85172308 0.9401382 0.98773022 0.98773022 0.9401382 0.85172308 0.73444367 0.60279818] [0.57375342 0.69905581 0.81068432 0.89483932 0.9401382 0.9401382 0.89483932 0.81068432 0.69905581 0.57375342] [0.51979489 0.63331324 0.73444367 0.81068432 0.85172308 0.85172308 0.81068432 0.73444367 0.63331324 0.51979489] [0.44822088 0.54610814 0.63331324 0.69905581 0.73444367 0.73444367 0.69905581 0.63331324 0.54610814 0.44822088] [0.36787944 0.44822088 0.51979489 0.57375342 0.60279818 0.60279818 0.57375342 0.51979489 0.44822088 0.36787944]] 对一个二维数组，如何在其内部随机放置p个元素? 123456789101112131415161718192021# np.put(ind, [])：将数组中索引为ind的元素用[]中的元素代替# 与之相对np.take(ind)：将数组中索引为ind的元素取出# np.random.choice(a, size=,replace=True, p=None)：从a中随机选取size个元素，replace表示抽样之后是否放回，p为每个元素被选取的概率，默认等概率n = 10p = 3Z = np.zeros((n, n))np.put(Z, np.random.choice(range(n*n), p, replace=False), 1)print(Z)结果：[[0. 0. 0. 0. 0. 1. 0. 1. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 1. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]] 减去一个矩阵中的每一行的平均值 123456789101112131415161718# np.mean(a, axis, dtype, out, keepdims)# axis不设置表示对所有元素求均值，axis为0表示对各列求均值，axis为1表示对各行求均值X = np.random.rand(5, 10)Y = X - X.mean(axis=1, keepdims=True)print(Y)结果：[[-0.03275755 -0.03035167 -0.08707745 -0.25124861 0.03642215 -0.04187207 -0.25630029 0.49229668 -0.03462927 0.20551809] [ 0.08456354 -0.39740261 0.2759206 -0.22989044 -0.03611724 -0.59011478 0.23584573 0.28327169 0.09127001 0.2826535 ] [ 0.3791585 0.1788899 -0.2672872 0.17179428 -0.0422312 -0.39381341 -0.45286872 0.33314372 0.35918018 -0.26596606] [ 0.24243083 -0.4746942 0.2044127 0.2530425 -0.15927489 -0.57245357 0.24327986 -0.00992776 0.23649468 0.03668986] [-0.25147254 0.45156914 0.28612509 -0.10173569 -0.08643743 0.15675954 0.41942699 -0.42012685 -0.03718232 -0.41692593]] 如何通过第n列对一个数组进行排序? 12345678910111213# argsort()返回的是数组值从小到大的索引值Z = np.random.randint(1, 10, (3, 3))print(Z)print(Z[Z[:, 1].argsort()])结果：[[6 7 6] [7 2 3] [5 3 8]][[6 2 9] [6 5 1] [1 5 8]] 如何检查一个二维数组是否有空列？ 1234567# 使用any、~# any()用于判断给定的可迭代参数是否全部为False，若全部为False则返回FalseZ = np.random.randint(0, 3, (3, 10))print((~Z.any(axis=0)).any())结果：False 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://zivblog.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://zivblog.top/tags/Python/"}]},{"title":"Numpy100题之21-40","slug":"Numpy100题之21-40","date":"2019-08-22T05:52:42.000Z","updated":"2020-03-04T06:34:10.305Z","comments":true,"path":"passages/numpy100-ti-zhi-21-40/","link":"","permalink":"http://zivblog.top/passages/numpy100-ti-zhi-21-40/","excerpt":"学习笔记 答案整理 原文地址：https://zhuanlan.zhihu.com/p/76186124","text":"学习笔记 答案整理 原文地址：https://zhuanlan.zhihu.com/p/76186124 用tile函数去创建一个8x8的棋盘样式矩阵 1234567891011121314# tile(array, num) 将原矩阵横向、纵向地复制# 将array复制num次；若num是个n元组，则依次是各个维度上复制的次数Z = np.tile(np.array([[1, 0], [1, 0]]), (4,4))print(Z)结果：[[1 0 1 0 1 0 1 0] [1 0 1 0 1 0 1 0] [1 0 1 0 1 0 1 0] [1 0 1 0 1 0 1 0] [1 0 1 0 1 0 1 0] [1 0 1 0 1 0 1 0] [1 0 1 0 1 0 1 0] [1 0 1 0 1 0 1 0]] 对一个5x5的随机矩阵做归一化 12345678910111213# 归一化：将数据转化乘(0, 1)或(-1, 1)之间的小数# 归一化：(Z - Z.min)/(Z.max - Z.min)Z = np.random.random((5, 5))Zmax, Zmin = Z.max(), Z.min()Z = (Z - Zmin)/(Zmax - Zmin)print(Z)结果：[[0.49837306 0.08864194 0.68784483 0.84959538 0.53010616] [0.62847499 0.06661639 0.64068999 1. 0.17954986] [0.73358673 0. 0.04020008 0.95159169 0.14104298] [0.99773013 0.50224238 0.28422327 0.62605846 0.02929286] [0.91979782 0.81827956 0.19822701 0.78475044 0.54114787]] 创建一个将颜色描述为(RGBA)四个无符号字节的自定义dtype？ 12345color = np.dtype([(\"r\", np.ubyte, 1), (\"g\", np.ubyte, 1), (\"b\", np.ubyte, 1), (\"a\", np.ubyte, 1)])color结果：dtype([('r', 'u1'), ('g', 'u1'), ('b', 'u1'), ('a', 'u1')]) 一个5x3的矩阵与一个3x2的矩阵相乘，实矩阵乘积是什么？ 12345678910# 使用dot()进行矩阵间的点乘Z = np.dot(np.ones((5, 3)), np.ones((3, 2)))print(Z)结果：[[3. 3.] [3. 3.] [3. 3.] [3. 3.] [3. 3.]] 给定一个一维数组，对其在3到8之间的所有元素取相反数？ 123456Z = np.arange(11)Z[(3 &lt; Z)&amp;(Z &lt;= 8)] *= -1Z结果：array([ 0, 1, 2, 3, -4, -5, -6, -7, -8, 9, 10]) 下面脚本运行后的结果是什么? 1234567891011121314# 注意Python自带的sum()函数和numpy中的sum()函数的区别# numpy中的sum()是对矩阵中所有元素的求和# Python中的sum()传入的是参数列表，即对所有传入的数据全部加和from numpy import *print(sum(range(5),-1))结果：10 # 即0~4累加print(sum(range(5),-1))结果：9 # 即0~4累加，再加-1 考虑一个整数向量Z,下列表达合法的是哪个? 1234567891011Z**Z # 合法，结果为[ 1, 1, 4, 27, 256]2&lt;&lt;Z&gt;&gt;2 # 不合法Z&lt;-Z # 合法，结果为[False, False, False, False, False]1j*Z # 合法，结果为[0.+0.j, 0.+1.j, 0.+2.j, 0.+3.j, 0.+4.j]Z/1/1 # 合法，结果为[0., 1., 2., 3., 4.]Z&lt;Z&gt;Z # 不合法 下列表达式的结果分别是什么? 1234567891011np.array(0) /np.array(0)结果：nannp.array(0) //np.array(0)结果：0 #但是0作为分母np.array([np.nan]).astype(int).astype(float)结果：array([-2.14748365e+09]) 如何从零位对浮点数组做舍入? 12345678910# 创建一个指定格式的随机数组Z = np.random.uniform(-10, +10, 10)Z结果：array([ 2.4142539 , 6.56990199, 8.70723106, 5.97495463, -5.30474813, -0.69522623, 0.69668324, -7.06029374, -8.52539933, 5.67250038])print (np.copysign(np.ceil(np.abs(Z)), Z))结果：[ 3. 7. 9. 6. -6. -1. 1. -8. -9. 6.] 如何找到两个数组中的共同元素? 12345678910111213141516# 创建两个数组Z1 = np.random.randint(0,10,10)Z2 = np.random.randint(0,10,10)Z1Z2结果：array([7, 6, 1, 7, 8, 5, 2, 0, 1, 5])array([2, 2, 6, 0, 8, 7, 7, 8, 0, 6])# 使用intersect1d()函数求两个数组的交集print(np.intersect1d(Z1,Z2))结果：[2 4 5 6 7 8] 如何忽略所有的Numpy警告(尽管不建议这么做)? 123# 可以忽略python的所有警告import warningswarnings.filterwarnings(\"ignore\") 下面的表达式是正确的吗? 12345# 虚数np.sqrt(-1) ==np.emath.sqrt(-1)结果：False 如何得到昨天，今天，明天的日期? 12345678910111213# 使用到np.datetime64和np.timedelta64yesterday = np.datetime64('today', 'D') - np.timedelta64(1, 'D')today = np.datetime64('today', 'D')tomorrow = np.datetime64('today', 'D') + np.timedelta64(1, 'D')print('Yesterday is ' + str(yesterday))print('Today is ' + str(today))print('Tomorrow is ' + str(tomorrow))结果：Yesterday is 2019-08-21Today is 2019-08-22Tomorrow is 2019-08-23 如何得到所有与2016年7月对应的日期? 123456789101112# 使用arange()，设置起始点为七月和八月，元素类型设为datetime64的日Z = np.arange('2016-07', '2016-08',dtype='datetime64[D]')print(Z)结果：['2016-07-01' '2016-07-02' '2016-07-03' '2016-07-04' '2016-07-05' '2016-07-06' '2016-07-07' '2016-07-08' '2016-07-09' '2016-07-10' '2016-07-11' '2016-07-12' '2016-07-13' '2016-07-14' '2016-07-15' '2016-07-16' '2016-07-17' '2016-07-18' '2016-07-19' '2016-07-20' '2016-07-21' '2016-07-22' '2016-07-23' '2016-07-24' '2016-07-25' '2016-07-26' '2016-07-27' '2016-07-28' '2016-07-29' '2016-07-30' '2016-07-31'] 如何直接在位计算(A+B)\\*(-A/2)(不建立副本)? 123456789101112131415161718192021# 使用函数add()计算加法，使用negative()计算取负值，使用multiply()计算乘法，使用divide()计算除法# 并且使用这些函数的out属性指定输出的矩阵，不再自动创建新矩阵# 创建三个数组A = np.ones(3)*1B = np.ones(3)*2C = np.ones(3)*3np.add(A, B, out=B)np.divide(A, 2, out=A)np.negative(A, out=A)np.multiply(A, B, out=A)结果：&gt;&gt;&gt; np.add(A, B, out=B)array([3., 3., 3.])&gt;&gt;&gt; np.divide(A, 2, out=A)array([0.5, 0.5, 0.5])&gt;&gt;&gt; np.negative(A, out=A)array([-0.5, -0.5, -0.5])&gt;&gt;&gt; np.multiply(A, B, out=A)array([-1.5, -1.5, -1.5]) 用五种不同的方法去提取一个随机数组的整数部分？ 12345678910111213141516171819# %, np.floor, np.ceil, astype, np.trunc# 创建随机数组Z = np.random.uniform(0, 10, 10)结果：&gt;&gt;&gt; print(Z - Z%1)[3. 6. 1. 4. 8. 7. 5. 6. 5. 5.]&gt;&gt;&gt;&gt;&gt;&gt; print(np.floor(Z))[3. 6. 1. 4. 8. 7. 5. 6. 5. 5.]&gt;&gt;&gt;&gt;&gt;&gt; print(np.ceil(Z)-1)[3. 6. 1. 4. 8. 7. 5. 6. 5. 5.]&gt;&gt;&gt;&gt;&gt;&gt; print(Z.astype(int))[3 6 1 4 8 7 5 6 5 5]&gt;&gt;&gt;&gt;&gt;&gt; print(np.trunc(Z))[3. 6. 1. 4. 8. 7. 5. 6. 5. 5.] 创建一个5x5的矩阵，其中每行的数值范围从0到4 123456789101112# 先创建全为0的矩阵，再讲0~4依次加到每一行Z = np.zeros((5, 5))Z += np.arange(5)print(Z)结果：[[0. 1. 2. 3. 4.] [0. 1. 2. 3. 4.] [0. 1. 2. 3. 4.] [0. 1. 2. 3. 4.] [0. 1. 2. 3. 4.]] 通过一个可生成10个整数的函数，来构建一个数组 12345678910# 使用np.fromiter()函数从一个可迭代对象创建一个一维数组def generate(): for x in range(10): yield xZ = np.fromiter(generate(), dtype=float, count=-1)print(Z)结果：[0. 1. 2. 3. 4. 5. 6. 7. 8. 9.] 创建一个长度为10的随机向量，其值域范围从0到1，但是不包括0和1 12345678# 使用linspace(start, end, num, endpoint=)# 创建一个指定起始点的元素个数为num的间隔均匀的数组，endpoint指定数组中是否包含endZ = np.linspace(0, 1, 11, endpoint=False)[1:]Z结果：array([0.09090909, 0.18181818, 0.27272727, 0.36363636, 0.45454545, 0.54545455, 0.63636364, 0.72727273, 0.81818182, 0.90909091]) 创建一个长度为10的随机向量，并将其排序 12345678# 使用sort()函数对数组排序Z = np.random.random(10)Z.sort()print(Z)结果：[0.09179728 0.39609427 0.39989882 0.52910508 0.5780039 0.66504509 0.73527613 0.77932581 0.9451393 0.99063504] 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://zivblog.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://zivblog.top/tags/Python/"}]},{"title":"Numpy100题之1~20","slug":"Numpy100题之1-20","date":"2019-08-21T12:02:58.000Z","updated":"2020-07-06T05:36:20.738Z","comments":true,"path":"passages/numpy100-ti-zhi-1-20/","link":"","permalink":"http://zivblog.top/passages/numpy100-ti-zhi-1-20/","excerpt":"学习笔记 答案整理 原文地址：https://zhuanlan.zhihu.com/p/76186124","text":"学习笔记 答案整理 原文地址：https://zhuanlan.zhihu.com/p/76186124 导入Numpy并简写为np 1import numpy as np 打印Numpy的版本信息和配置说明 123456import numpy as np# 版本信息print(np.__version__)# 配置说明np.show_config 创建长度为10的空向量 123456# 空向量使用zeros()函数创建Z = np.zeros(10)print(Z)结果：[0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] 如何找到任意数组的内存大小 12345678# 定义大小为10*10的空数组Z = np.zeros((10*10))# 输出内存大小print(Z.size * Z.itemsize)结果：800 从命令行得到Numpy中add函数的说明文档 123456789101112131415161718192021222324252627282930np.info(np.add)结果：add(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])Add arguments element-wise.Parameters----------x1, x2 : array_like The arrays to be added. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which may be the shape of one or the other).out : ndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or `None`, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs.where : array_like, optional Values of True indicate to calculate the ufunc at that position, values of False indicate to leave the value in the output alone.**kwargs For other keyword-only arguments, see the :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.Returns-------add : ndarray or scalar The sum of `x1` and `x2`, element-wise. This is a scalar if both `x1` and `x2` are scalars. 创建一个长度为10并且除了第五个值为1的空向量 123456Z = np.zeros(10)Z[4] = 1Z结果：array([0., 0., 0., 0., 1., 0., 0., 0., 0., 0.]) 创建一个值域范围从10到49的向量 1234567Z = np.arange(10, 50)Z结果：array([10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49]) 反转一个向量 12345678910111213Z = np.arange(50)Z = Z[::-1]Z‘’‘解释：np.array[起点:终点:步长]若起点终点未给出则自动设为最小值和最大值，步长为-1则表示倒序‘’‘结果：array([49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]) 创建一个3*3并且值从0到8的矩阵 12345678# 可以先创建0~8的一维矩阵，再利用reshape()函数调整矩阵形状Z = np.arange(9).reshape(3, 3)Z结果：array([[0, 1, 2], [3, 4, 5], [6, 7, 8]]) 找到数组[1, 2, 0, 0, 4, 0]中非0元素的位置索引 1234567# 使用nonzero()函数，可返回非0元素索引z = np.array([1, 2, 0, 0, 4, 0])nz = np.nonzero(z)print(nz)结果：[0, 1, 4] 创建3*3的单位矩阵 12345678# 使用函数eye()创建单位矩阵Z = np.eye(3)Z结果：[[1., 0., 0.], [0., 1., 0.], [0., 0., 1.]] 创建一个3*3*3的随机矩阵 12345678910111213141516# 使用random()函数创建随机矩阵Z = np.random.random((3, 3, 3))Z结果：array([[[0.46112045, 0.8449696 , 0.93452669], [0.40335357, 0.19589526, 0.06190673], [0.59191213, 0.5485013 , 0.04418769]], [[0.19128822, 0.87667495, 0.52180477], [0.20406144, 0.24655701, 0.5104405 ], [0.10757664, 0.29771709, 0.03340503]], [[0.18824317, 0.70162351, 0.98969992], [0.05169308, 0.10910609, 0.26606144], [0.16278269, 0.4546617 , 0.86494887]]]) 创建一个10*10的随机矩阵并找到矩阵中的最大值和最小值 123456789# 使用max()、min()函数获取矩阵中的极值Z = np.random.random((10*10))Zmin, Zmax = Z.min(), Z.max()ZminZmax结果：0.00188398126643218870.9990252431012059 创建一个长度为30的随机向量并找到它的平均值 123456789101112131415# 使用random()创建随机向量，使用mean()计算平均值Z = np.random.random(30)m = Z.mean()Zm结果：array([0.65300995, 0.20141719, 0.14618305, 0.04388761, 0.11318013, 0.69235091, 0.21181151, 0.57945835, 0.65998752, 0.53460023, 0.73048382, 0.06537182, 0.09899469, 0.24646227, 0.1852686 , 0.39034113, 0.83176693, 0.61448157, 0.50298701, 0.67282915, 0.59650845, 0.22505482, 0.69479162, 0.62462672, 0.24771051, 0.17731379, 0.8212477 , 0.00564217, 0.21590246, 0.69027938])0.41579836854559904 创建一个二维数组，其中边界值为1，其余值为0 12345678910111213141516# 创建一个全为1的数组，再将中间的数字改为0Z = np.ones((10, 10))Z[1:-1,1:-1] = 0Z结果：array([[1., 1., 1., 1., 1., 1., 1., 1., 1., 1.], [1., 0., 0., 0., 0., 0., 0., 0., 0., 1.], [1., 0., 0., 0., 0., 0., 0., 0., 0., 1.], [1., 0., 0., 0., 0., 0., 0., 0., 0., 1.], [1., 0., 0., 0., 0., 0., 0., 0., 0., 1.], [1., 0., 0., 0., 0., 0., 0., 0., 0., 1.], [1., 0., 0., 0., 0., 0., 0., 0., 0., 1.], [1., 0., 0., 0., 0., 0., 0., 0., 0., 1.], [1., 0., 0., 0., 0., 0., 0., 0., 0., 1.], [1., 1., 1., 1., 1., 1., 1., 1., 1., 1.]]) 对于一个存在在数组，如何添加一个用0填充的边界? 123456789101112131415161718192021222324252627# 使用pad(array, pad_width, mode, **kwargs)填充矩阵边界Z = np.ones((5, 5))Z = np.pad(Z, pad_width=1, mode='constant', constant_values=0)print(Z)结果：[[0. 0. 0. 0. 0. 0. 0.] [0. 1. 1. 1. 1. 1. 0.] [0. 1. 1. 1. 1. 1. 0.] [0. 1. 1. 1. 1. 1. 0.] [0. 1. 1. 1. 1. 1. 0.] [0. 1. 1. 1. 1. 1. 0.] [0. 0. 0. 0. 0. 0. 0.]]Z = np.pad(Z, pad_width=2, mode='constant', constant_values=0)Z结果：array([[0., 0., 0., 0., 0., 0., 0., 0., 0.], [0., 0., 0., 0., 0., 0., 0., 0., 0.], [0., 0., 1., 1., 1., 1., 1., 0., 0.], [0., 0., 1., 1., 1., 1., 1., 0., 0.], [0., 0., 1., 1., 1., 1., 1., 0., 0.], [0., 0., 1., 1., 1., 1., 1., 0., 0.], [0., 0., 1., 1., 1., 1., 1., 0., 0.], [0., 0., 0., 0., 0., 0., 0., 0., 0.], [0., 0., 0., 0., 0., 0., 0., 0., 0.]]) 以下表达式运行的结果分别是什么? 123456789101112131415161718192021222324# NaN: not a number, inf: infinity0*np.nan结果：nannp.nan == np.nan结果：Falsenp.nan is np.nan结果：Truenp.inf &gt; np.nan结果：Falsenp.nan-np.nan结果：nan0.3 == 3*0.1结果：False 创建一个5x5的矩阵，并设置值1,2,3,4落在其对角线下方位置 123456789101112# 使用diag(v, k=0)函数创建对角阵# v是对角线元素# k默认为0.k&gt;0则对角线之上，k&lt;0则对角线之下Z = np.diag(1+np.arange(4), k=-1)Z结果：array([[0, 0, 0, 0, 0], [1, 0, 0, 0, 0], [0, 2, 0, 0, 0], [0, 0, 3, 0, 0], [0, 0, 0, 4, 0]]) 创建一个8x8的矩阵，并且设置成棋盘样式 123456789101112131415# 使用zeros()先创建0矩阵，再填充为1的位置Z = np.zeros((8, 8), dtype=int)Z[1::2,::2] = 1Z[::2, 1::2] = 1Z结果：array([[0, 1, 0, 1, 0, 1, 0, 1], [1, 0, 1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 0, 1, 0, 1], [1, 0, 1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 0, 1, 0, 1], [1, 0, 1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 0, 1, 0, 1], [1, 0, 1, 0, 1, 0, 1, 0]]) 考虑一个 (6,7,8) 形状的数组，其第100个元素的索引(x,y,z)是什么? 12345# 使用unravel_index(num,array.shape)求指定形状的矩阵中第num个元素的索引print(np.unravel_index(100, (6, 7 ,8)))结果：(1, 5, 4) 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://zivblog.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://zivblog.top/tags/Python/"}]},{"title":"Python之lambda匿名函数","slug":"Python之lambda匿名函数","date":"2019-08-21T07:23:46.000Z","updated":"2019-08-21T08:53:42.000Z","comments":true,"path":"passages/python-zhi-lambda-ni-ming-han-shu/","link":"","permalink":"http://zivblog.top/passages/python-zhi-lambda-ni-ming-han-shu/","excerpt":"","text":"什么是匿名函数？ 匿名函数，顾名思义就是具体的函数名但是有函数功能的函数或子程序。lambda函数可以接收任意多个参数并且返回单个表达式的值。 为什么要使用匿名函数？ 在函数功能不是很复杂的情况下，如果不想去费神命名一个函数时，可以使用匿名函数。也就是说匿名函数可以使代码变得更简洁，但是相对应的会增加阅读代码时的难度，所以不要盲目的使用匿名函数。 使用ambda定义匿名函数有什么要注意的？ lambda函数不能包含命令 包含的表达式不能超过一个 使用lambda定义匿名函数的格式？ lambda 参数列表 : 表达式 使用lambda定义匿名函数和常规函数定义的区别？ 1234567# 常规函数定义def sum(x, y): return x + y# 使用lambda定义add = lambda x, y : x + yadd(1, 2) lambda的用法 1234567891011121314151617181. 将lambda函数赋值给一个变量，通过这个变量简洁调用lambda函数add = lambda x, y : x + yadd(1, 2)2. 将lambda函数赋值给其他函数，从而将其他函数用该lambda函数替换# 例如对标准库中的函数time.sleep，可以使用lambda将其覆盖掉，下一次调用sleep的使用就是定义的lambda函数的内容了time.sleep = lambda x:None3. 将lambda函数作为其他函数的返回值def add(x, y): return lambda x, y : x + y4. 将lambda函数作为参数传递给其他函数# 部分Python内置函数接收函数作为参数，例如：filter函数sorted函数map函数reduce函数 另外，lambda是Python的关键字，Python的关键字还有： 1234import keywordkeyword.kwlist['False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield'] 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://zivblog.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://zivblog.top/tags/Python/"}]},{"title":"Numpy学习笔记（进阶）","slug":"Numpy学习笔记（进阶）","date":"2019-08-14T14:13:52.000Z","updated":"2020-03-04T06:36:11.884Z","comments":true,"path":"passages/numpy-xue-xi-bi-ji-jin-jie/","link":"","permalink":"http://zivblog.top/passages/numpy-xue-xi-bi-ji-jin-jie/","excerpt":"学习笔记 参考资料：Numpy官方文档","text":"学习笔记 参考资料：Numpy官方文档 进阶操作广播法则 使用广播法则能使通用函数处理不具有相同形状的输入 广播第一法则：如果所有的输入数组维度均不相同，会填充1在较小维度的数组上，使所有的数组拥有一样的维度。 广播第二法则：确定长度为1的数组沿着特殊的方向表现的好像它有沿着该方向最大形状的大小。对于数组来说，沿着该维度的数组元素的值理应相同。 应用了广播法则之后，所有的数组的大小就会匹配了。 索引技巧 除了Python本身提供的索引整数和切片，数组还可以被整数数组和布尔数组索引。 通过数组索引，例子： 1234567891011121314151617181920212223242526272829303132333435363738394041# 创建数组from numpy import *a = arange(12)**2# 使用一维数组索引，得到的结果也是一维数组i = array([1, 1, 3, 8, 5])a[i]结果：array([ 1, 1, 9, 64, 25])# 使用二维数组索引，得到的结果也是二维数组j = array([[3, 4], [9, 7]])a[j]结果：array([[ 9, 16], [81, 49]])# 若被索引的数组是多维时，每个索引数列指向a的第一维# 在这里，每个索引数列中的元素指定其中的一行palette = array( [ [0,0,0], [255,0,0], [0,255,0], [0,0,255], [255,255,255] ] ) image = array( [ [ 0, 1, 2, 0 ], [ 0, 3, 4, 0 ] ] )palette[image] 结果：array([[[ 0, 0, 0], [255, 0, 0], [ 0, 255, 0], [ 0, 0, 0]], [[ 0, 0, 0], [ 0, 0, 255], [255, 255, 255], [ 0, 0, 0]]]) 索引可以不止一维，但每一维的索引数组形状需要相同 例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# 创建数组a = arange(12).reshape(3,4)a结果：array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]])# 多维索引i = array([[0, 1], [1, 2]])j = array([[2, 1], [3, 3]])a[i, j]结果：array([[ 2, 5], [ 7, 11]])'''得到的是a[0, 2],a[1, 1], a[1, 3], a[2, 3],且两个为一组'''a[i, 2]结果：array([[ 2, 6], [ 6, 10]])a[:, j]结果：array([[[ 2, 1], [ 3, 3]], [[ 6, 5], [ 7, 7]], [[10, 9], [11, 11]]])# 可以借助列表先将两个索引组合起来，使用列表进行索引l = [i, j]a[l]结果：array([[ 2, 5], [ 7, 11]])# 这里不能使用数组将i，j组合起来，因为外层数组会被当作索引的第一维，报错或得到的结果不正确 使用数组索引作为目标来赋值 12345678910111213# 创建数组a = arange(5)a结果：array([0, 1, 2, 3, 4])a[[1, 3, 4]] = 0a结果：array([0, 0, 2, 0, 0])# 多次赋值以最后一次赋值为结果 通过布尔数组索引 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# 创建数组a = arange(12).reshape(3, 4)b = a &gt; 4b结果：array([[False, False, False, False], [False, True, True, True], [ True, True, True, True]], dtype=bool)# 实际上是返回所有为True的位置的元素值a[b]结果：array([ 5, 6, 7, 8, 9, 10, 11])# 此功能可用于赋值，比如，将a中所有大于4的值赋值为0b = a &gt; 4a[b] = 0a结果：array([[0, 1, 2, 3], [4, 0, 0, 0], [0, 0, 0, 0]])# 对每一个维度给一个一维布尔数组来选择我们想要的切片a = arange(12).reshape(3, 4)b1 = array([False, True, True])b2 = array([True, False, True, False])a[b1, :]结果：array([[ 4, 5, 6, 7], [ 8, 9, 10, 11]])a[b1]结果：array([[ 4, 5, 6, 7], [ 8, 9, 10, 11]])a[:, b2]结果：array([[ 0, 2], [ 4, 6], [ 8, 10]])a[b1,b2] 结果：array([ 4, 10]) 注意：一维数组的长度必须和想要切片的维度或轴的长度一致，前面的例子中，b1是一个秩为1长度为三的数组(a的行数)，b2(长度为4)与a的第二秩(列)相一致 ix_()函数 ix_()函数可以组合不同向量以得到多元组的结果，例如使用向量a、b、c组成的三元组来计算a+b*c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869# 创建向量a = array([2, 3, 4, 5])b = array([8, 5, 4])c = array([5, 4, 6, 8, 3])ax, bx, cx = ix_(a, b, c)axbxcx结果：# 从形式上来看转化了向量的形状，使之符合计算的需求array([[[2]], [[3]], [[4]], [[5]]])array([[[8], [5], [4]]])array([[[5, 4, 6, 8, 3]]])ax.shapebx.shapecx.shape结果：(4, 1, 1)(1, 3, 1)(1, 1, 5)result = ax + bx * cxresult结果：array([[[42, 34, 50, 66, 26], [27, 22, 32, 42, 17], [22, 18, 26, 34, 14]], [[43, 35, 51, 67, 27], [28, 23, 33, 43, 18], [23, 19, 27, 35, 15]], [[44, 36, 52, 68, 28], [29, 24, 34, 44, 19], [24, 20, 28, 36, 16]], [[45, 37, 53, 69, 29], [30, 25, 35, 45, 20], [25, 21, 29, 37, 17]]])# 读取结果中的一个元素result[3, 2, 4]结果：17# 使用向量中的一个值进行计算a[3] + b[2] * c[4]结果：4 + 5 * 3 = 17 线性代数 数组运算 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# 导入数组计算的的包和函数from numpy import *from numpy.linalg import *# 创建数组a = array([[1.0, 2.0], [3.0, 4.0]])print(a)结果：[[ 1. 2.] [ 3. 4.]]# 求转置a.transpose()结果：array([[ 1., 3.], [ 2., 4.]])# 求逆矩阵inv(a)结果：array([[-2. , 1. ], [ 1.5, -0.5]])# 生成对角矩阵u = eye(2) # 2*2u结果：array([[1., 0.], [0., 1.]])# 求点积j = array([[0.0, -1.0], [1.0, 0.0]])dot (j, j)结果：array([[-1., 0.], [ 0., -1.]])# 求矩阵的迹（特征值之和）trace(u)结果：2.0# 求解线性矩阵方程y = array([[5.], [7.]])solve(a, y)结果：array([[-3.], [ 4.]])# 计算矩阵特征值、特征向量eig(j)结果：(array([ 0.+1.j, 0.-1.j]), array([[ 0.70710678+0.j , 0.70710678-0.j ], [ 0.00000000-0.70710678j, 0.00000000+0.70710678j]])) 矩阵类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# 创建矩阵A = matrix('1.0 2.0; 3.0 4.0')A结果：matrix([[ 1., 2.], [ 3., 4.]])# 判断类型type(A)结果：numpy.matrixlib.defmatrix.matrix# 求矩阵的转置A.T结果：matrix([[ 1., 3.], [ 2., 4.]])X = matrix('5.0 7.0')Y = X.TY结果：matrix([[ 5.], [ 7.]])# 矩阵相乘print(A*Y)结果：[[ 19.] [ 43.]]# 求逆矩阵print(A.I)结果：[[-2. 1. ] [ 1.5 -0.5]]# 求解线性矩阵方程solve(A, Y)结果：matrix([[-3.], [ 4.]]) 注意 Numpy的两个基本对象：N维数组对象，通用函数对象 矩阵继承自数组对象的二维数组对象 直方图 可以使用histogram函数应用到一个数组会返回：直方图数组和箱式向量 注意这里只返回数据，并直接绘制出具体的图形 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://zivblog.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://zivblog.top/tags/Python/"}]},{"title":"Numpy学习笔记（基础）","slug":"Numpy学习笔记（基础）","date":"2019-08-14T14:09:03.000Z","updated":"2020-03-04T06:35:54.502Z","comments":true,"path":"passages/numpy-xue-xi-bi-ji-ji-chu/","link":"","permalink":"http://zivblog.top/passages/numpy-xue-xi-bi-ji-ji-chu/","excerpt":"笔记 学习笔记 参考资料：Numpy官方文档","text":"笔记 学习笔记 参考资料：Numpy官方文档 基础知识 Numpy是用来处理多维数组的工具，在Numpy中，维度叫做轴，轴的个数叫做秩。 例如，[1, 2, 3]是一个秩为1的数组，因为它只有一个维度，即一个轴。轴的长度为3. 而[[1, 0, 0], [0, 1, 2]]的秩为2，即两个轴。第一个轴的长度为2，第二个轴的长度为3。 Numpy的数组类叫做ndarray，可以处理多维的数组。需要注意的是numpy.array和array.array,后者只能处理简单的一维数组。ndarray的对象属性有： ndarray.ndim：数组轴的个数，即秩。 ndarray.shape：数组在每一个维度上大小的维度，是一个元组，例如：一个n排m列的数组的shape是(n, m)，这个元组的长度是秩，因为这个数组只有两个轴。 ndarray.size：数组元素的总和，等于shape属性元组中元素的乘积。 ndarray.dtype：数组中元素类型。注意一个数组中的元素类型是统一的。 ndarray.itemsize：元素的字节大小。 ndarray.data：包含实际数组元素的缓冲区。 例子： 123456789101112131415161718192021from numpy import *# 创建一个长为15且内容为0~14的数组，并转化成3*5的数组a = arange(15).reshape(3,5)print(a)print('a.ndim is ',a.ndim)print('a.dtype is ', a.dtype)print('a.shape is ', a.shape)print('a.itemsize is ', a.itemsize)print('a.size is ', a.size)结果：[[ 0 1 2 3 4] [ 5 6 7 8 9] [10 11 12 13 14]] a.ndim is 2a.dtype is int32a.shape is (3, 5)a.itemsize is 4a.size is 15 创建数组 使用array()函数将常规的Python列表和元组转化为数组，数组类型可在创建时指定 例子： 1234567from numpy import * a = array([1, 2, 3])或b = array((1, 2, 3))或c = array([(1, 2, 3), (1, 2, 3)]) 使用可用于创建指定数组的函数，数组类型可在创建时指定 例子： 12345678910111213# 创建全为0的指定形式的数组zeros((3, 5)) # 创建全为1的指定形式和类型的数组ones((3, 4,), dtype=int32) # 创建内容随机的指定形式的数组empty((4, 3)) # arange()函数，返回的是数组而非列表arange(10, 40, 6) random.random((2, 3)) 基本运算 数组间的运算是按照元素来进行的，将结果存入新的数组 例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from numpy import *a = array([(2, 4), (6, 8)])b = arange(4).reshape((2, 2)) # 对应元素值之差c = a - bprint(a)print(b)print(c) 结果：[[2 4] [6 8]] [[0 1] [2 3]] [[2 3] [4 5]] # b^2b**2结果：array([[0, 1], [4, 9]], dtype=int32) # sin(a)sin(a)结果：array([[ 0.90929743, -0.7568025 ], [-0.2794155 , 0.98935825]])10*sin(a)结果：array([[ 9.09297427, -7.56802495], [-2.79415498, 9.89358247]]) # 判断每个元素是否符合要求a &lt; 3结果：array([[ True, False], [False, False]]) # 3*aa *= 3结果：[[4, 8], [12, 16]] 注意矩阵乘法需要使用dot()函数或创建矩阵对象实现，直接相乘得到的是元素对应相乘 例子： 1234567891011# 元素对应乘积a*b结果：array([[ 0, 4], [12, 24]]) # 矩阵点乘dot(a, b)结果：array([[ 8, 14], [16, 30]]) 若两个矩阵相加使用+=，则精度更精确的要作为接收的数组 用于计算的函数 例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788# e^xd = exp(a*1j)d结果：array([[-0.41614684+0.90929743j, -0.65364362-0.7568025j ], [ 0.96017029-0.2794155j , -0.14550003+0.98935825j]]) d.dtype.name 结果：'complex128'# 数组中元素值之和a = random.random((2, 3))print('the sum of a is ', a.sum())​ 结果：array([[0.89005106, 0.20091997, 0.35641668], [0.15765842, 0.16708008, 0.38590499]]) the sum of a is 2.1580312015631193 # 数组中元素的最大值a.max() 结果：0.8900510634052407 # 按第一个坐标轴求最大值（每列中的最大值）a.max(axis=0) 结果：array([0.89005106, 0.20091997, 0.38590499]) # 指定坐标轴进行计算b = arange(12).reshape(3, 4)b print('b.shape is ', b.shape# 按第一个坐标轴计算，即按列加和b.sum(axis=0)# 按第二个坐标轴计算，即按行加和b.sum(axis=1) 结果：array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]])b.shape is (3, 4) array([12, 15, 18, 21]) array([6, 22, 38]) # 求数组中的最小值print('b.min is ', b.min())print('b.min in each row ', b.min(axis=1)) 结果：b.min is 0b.min in each row is [0, 4, 8] # 矩阵累积和（顺序自矩阵中元素之和）b.cumsum()结果：array([ 0, 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 66], dtype=int32) # 按行计算b.cumsum(axis=1)结果：array([[ 0, 1, 3, 6], [ 4, 9, 15, 22], [ 8, 17, 27, 38]], dtype=int32) # 按列计算b.cumsum(axis=0)结果：array([[ 0, 1, 2, 3], [ 4, 6, 8, 10], [12, 15, 18, 21]], dtype=int32) 通用函数 常见的有sin()，cos()，exp()等，作用于数组时按元素计算，返回结果仍是数组。 常见的有 1exp(A), sqrt(A), add(A, B), all(), alltrue(), any(), apply(), along axis(), argmax(), argmin(), argsort(), average(), bincount(), ceil(), clip(), conj(), conjugate(), corrcoef(), cov(), cross(), cumprod(), cumsum(), diff(), dot(), floor(), inner(), inv(), lexsort(), max(), maximum(), mean(), median(), min(), minimum(), nonzero(), outer(), prod(), re(), round(), sometrue(), sort(), std(), sum(), trace(), transpose(), var(), vdot(), vectorize(), where() 此类函数的使用详情请到官网查询官网 求逆矩阵：np.linalg.inv(arr) 求行列式：np.linalg.det(arr) 求特征值与特征向量：e,v = np.linalg.eig(arr) 切片、索引和迭代 一维数组可以被索引、切片和迭代，与列表和其他Python序列操作相同 例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243# 迭代a = arange(10)**3a结果:array([ 0, 1, 8, 27, 64, 125, 216, 343, 512, 729], dtype=int32)# 根据索引访问数组内容a[2]结果：8# 切片a[2:5]结果：array([ 8, 27, 64])# 前6个元素，每两个有一个设置为-1000a[:6:2] = -1000a结果：array([-1000, 1, -1000, 27, -1000, 125, 216, 242, 512, 729], dtype=int32)# 逆置数组a[::-1]结果：array([729, 512, 343, 216, 125, 64, 27, 8, 1, 0], dtype=int32)# 遍历数组for i in a: print(i)结果：[ 0, 1, 8, 27, 64, 125, 216, 343, 512, 729] 多维数组可以每个轴有一个索引，这些索引由一个逗号分割的元素给出 例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465# 使用fromfunction创建数组def f(x, y): retuen 10*x + y# f是函数，(5, 4)是数组的形状，得到的数组内容是下标在函数中经过计算得到的值b = fromfunction(f, (5, 4), dtype=int)b结果：array([[ 0, 1, 2, 3], [10, 11, 12, 13], [20, 21, 22, 23], [30, 31, 32, 33], [40, 41, 42, 43]])# 索引访问数组内容b[2,3]结果：23# 对一个维度使用切片# 读取第二列的内容b[:5, 1]结果：array([ 1, 11, 21, 31, 41])# 多个维度上使用切片# 读取第2、3行b[1:3, :]结果：array([[10, 11, 12, 13], [20, 21, 22, 23]])# 缺失的索引默认为全部# 读取倒数第一行b[-1]结果：array([40, 41, 42, 43])# 多维数组的迭代是以第一个轴为基准的for row in b: print(row) 结果：[0 1 2 3][10 11 12 13][20 21 22 23][30 31 32 33][40 41 42 43]# 对数组中每个元素进行计算，使用flat(迭代器)for element in b.flat: print(element, end=',') 结果：0,1,2,3,10,11,12,13,20,21,22,23,30,31,32,33,40,41,42,43, 形状操作 改变数组形状，目标形状包含的元素个数要与原数组的元素个数相同 例子： 123456789101112131415161718192021222324252627282930313233343536373839404142# 创建数组# floor()函数：向下取整a = floor(10*random.random((3, 4)))结果：array([[ 6., 7., 4., 3.], [ 0., 0., 2., 6.], [ 7., 7., 8., 6.]])# 转化成一维数组a.reval()a结果：array([ 6., 7., 4., 3., 0., 0., 2., 6., 7., 7., 8., 6.])# 修改形状# 转化成6*2,但不修改真正的数组内容a.reshape(6, 2)结果：array([[6., 0.], [5., 5.], [5., 6.], [1., 3.], [4., 7.], [6., 4.]])# 使用resize()直接修改数组本身a.resize((2, 6))结果：array([[ 6., 7., 4., 3., 0., 0.], [ 2., 6., 7., 7., 8., 6.]])# 转置a.shape = (6, 2)a.transpace()结果：array([[ 6., 4., 0., 2., 7., 8.], [ 7., 3., 0., 6., 7., 6.]]) 组合不同的数组（stack） 可以沿不同轴将数组堆叠在一起 例子： 12345678910111213141516171819202122232425262728293031# 创建数组a = floor(10*random.random((2, 3)))ab = floor*(10*random.random(2, 2))b结果：array([[ 1., 5.], [ 6., 7.]])array([[ 5., 5.], [ 4., 5.]])# 组合# 按行组合vstack((a, b))结果：array([[ 1., 5.], [ 6., 7.], [ 5., 5.], [ 4., 5.]])# 按列组合hstack((a, b))结果：array([[ 1., 5., 5., 5.], [ 6., 7., 4., 5.]]) 另一个例子： 123456789101112131415161718192021222324252627a = array([4, 2])b = array([2, 8])# newaxis相当于创建了一个维度，这里是将a由1*2转化成2*1# 可以用于从多维数组中取一列，但并不改变列的信息，不会取出来之后变成了一维数组a[:,newaxis]结果：array([[ 4.], [ 2.]])# 将两个一维数组组合起来column_stack((a[:, newaxis], b[:, newaxis]))结果：array([[ 4., 2.], [ 2., 8.]])vstack((a[:, newaxis], b[:, newaxis]))结果：array([[ 4.], [ 2.], [ 2.], [ 8.]]) 将数组分割成几个小数组（split） 可以沿水平轴分割(hsplit())，或者指定返回相同形状的数组的个数，或者指定在那些列之后进行分割 例子： 123456789101112131415161718192021222324252627# 创建数组a = floor(10*random.random((2,12)))a结果：array([[ 3., 7., 0., 6., 0., 6., 8., 5., 8., 2., 7., 1.], [ 7., 7., 2., 3., 4., 8., 8., 5., 2., 5., 5., 4.]])# 沿水平轴分割，分割成三个形状相同的数组hsplit(a, 3)结果：[array([[ 3., 7., 0., 6.], [ 7., 7., 2., 3.]]), array([[ 0., 6., 8., 5.], [ 4., 8., 8., 5.]]), array([[ 8., 2., 7., 1.], [ 2., 5., 5., 4.]])]# 在第三列、第四列之后进行分割hsplit(a, (3, 4))结果：[array([[ 3., 7., 0.], [ 7., 7., 2.]]), array([[ 6.], [ 3.]]), array([[ 0., 6., 8., 5., 8., 2., 7., 1.], [ 4., 8., 8., 5., 2., 5., 5., 4.]])] 复制和视图 对数组进行处理是，它们的有时不会拷贝到新数组 完全不拷贝 1234567891011121314a = arange(12)b = aprint(b is a)结果：Trueb.shape = 3, 4a.shape结果：(3, 4)b就是a本身 视图和浅复制 12345678910111213141516171819202122232425262728293031323334# 不同的数组对象分享同一个数据。视图方法创造一个新的数组对象指向同一数据c = a.view()c is a 结果：Flase# c是a的视图，则a是c的basec.base is a结果：True# c是否有自身的数据c.flags.owndata结果：False# 视图的形状改变不影响数组本身c.shape = 2, 6a.shape结果：(3, 4)# 视图内容的改变会改变原数组c[0, 4] = 1234a结果：array([[ 0, 1, 2, 3], [1234, 5, 6, 7], [ 8, 9, 10, 11]]) 深复制 完全复制数组和它的数据 例子： 123456789101112131415161718192021# 完全拷贝，d与a是完全无关的两个实体d = a.copy()d is a结果：False# d也不是a的视图d.base is a结果：False# d的内容的修改也不会影响ad[0, 0] = 9999a结果：array([[ 0, 10, 10, 3], [1234, 10, 10, 7], [ 8, 10, 10, 11]]) 方法总览 创建数组 12arange, array, copy, empty, empty_like, eye, fromfile, fromfunction, identity, linspace, logspace, mgrid, ogrid, ones, ones_like, r , zeros, zeros_like 转化 1astype, atleast 1d, atleast 2d, atleast 3d, mat 操作 12array split, column stack, concatenate, diagonal, dsplit, dstack, hsplit, hstack, item, newaxis, ravel, repeat, reshape, resize, squeeze, swapaxes, take, transpose, vsplit, vstack 询问（判断） 1all, any, nonzero, where 排序 1argmax, argmin, argsort, max, min, ptp, searchsorted, sort 运算 1choose, compress, cumprod, cumsum, inner, fill, imag, prod, put, putmask, real, sum 基本统计 1cov, mean, std, var 基本线性代数 1cross, dot, outer, svd, vdot 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://zivblog.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://zivblog.top/tags/Python/"}]},{"title":"乌合之众","slug":"乌合之众","date":"2019-08-06T07:08:12.000Z","updated":"2020-07-06T05:48:28.467Z","comments":true,"path":"passages/wu-he-zhi-zhong/","link":"","permalink":"http://zivblog.top/passages/wu-he-zhi-zhong/","excerpt":"乌合之众","text":"乌合之众 《乌合之众》庞勒&emsp;&emsp;群体是有共同目的的人的集合，群体智力低下，盲目而极端，保守又善变，充满原始的暴力和嗜血的欲望。&emsp;&emsp;“多数人永远正确”的认识，理应受到更多的思考。切记要保留独立思考的能力，不能因为入群之后便将人云亦云视为了理所当然。 不做过多评价，下面是一些摘抄 除了破坏之外，群体的施威无法起到任何作用。 群体对理性并不适应，却急于行动。 科学向我们许诺真理，但科学从未向我们许诺过和平和幸福。 群体无法接受任何观点，只能骗。 群体成员的思想感性有一种相互统一的倾向，自觉的个性消失了，出现了一个群体心理。 分散的千万个体在受到强烈的情绪冲击是，在特定时刻也会变成群体。 孤立的个人具有主宰自己的反应行为的能力，群体则缺乏这种能力。 在才智层面完全不同的个体，拥有的本能、情绪和情感却非常相似。 群体并不叠加智慧，叠加出来的都是愚蠢。 在群体中，任何情绪和行为都会传染，而且传染性很大，大到个体会欣然为了群体利益而牺牲个人利益。 群体急于遵循任何冲动，完全不考虑是否对自己有利。 群体认为一切都是确定的，怀疑什么什么就是真的，并走极端。 任何信仰的胜利都需要血流成河，群体则提供血液。 群体的渴望虽然狂热，但从不持久。 群体的言论易受暗示影响，暗示的起点一般是某个人大脑里制造出的模模糊糊的幻觉，如果这第一份错觉随后被第二个人肯定，就会发生交叉感染。所以目击证人最多的事一定是最可疑的事。 群体表达情感时，总表现出简单化、极端化的特点，不是极爱就是极恨。 群体习惯了夸张的情绪，所以只能对极端情感有反应 群体随时准备背叛弱者，在强权面前卑躬屈膝。 一套思想对社会的影响与它包含多少真理无关。 向群众灌输思想，其表现形式必须很绝对、很强硬、很直白，否则就会不起作用。 群体推理的特征，就是把表面有点儿相似的不同东西联系起来，并瞬间把具体经验普遍化。 群体只能进行形象思维，只被形象打动。 在群体中，好感会迅速变成崇拜，讨厌刚一产生就变成了仇恨。 群体新年的特征是盲目服从、强烈的排异性以及狂热的扩散欲。 传统支配人，尤其是群体中的人。 以暴力革命为代价无疑能改变制度的命哼，但制度的本质不会发生变化。 在生活中成功的条件是拥有判断力、经历、进取精神和意志，这些东西都是书本里学不到的。 幻想无疑都是虚假的影子，可幻想最终推动者各个民族创造了最自豪的艺术和最伟大的文明。 各个民族进化的主要因素从来都不是真理，而是谬误。 知道如何影响群体的演说家从不诉诸理性，而是操纵情绪。 创造文明的主因是情感而不是理性，理性一般不起作用，这些情感的东西包括荣耀、牺牲、信仰、爱国以及对光荣的热爱。 任何聚集成群的动物都有服从领袖的本能。 群体领袖都很专制，实际上专制才是拥有追随者的前提条件。 简单、纯粹的断言，不带任何逻辑，没有任何根据，是洗脑群体最有效的方法之一。 反复的断言，会是信息以特别的方式深入人心，并最终能被人接受为不证自明的真理。 当一个人遭受争议时，就不再拥有气场，为了让群众敬畏，必须预期保持距离。 当信念的力量完全消失，一切上层家住才会迅速土崩瓦解。 群体中的人，一旦被取悦就容易被说服，跟他说什么他都特别愿意接受。 人们并不会因为彼此相信而彼此相似，但他们因为相似，所以几乎无限地相信公众的判断力。 断言永远不会太狠，恐吓的话永远也不过分。 群体永远需要主任，并本能的在经历旺盛、信念坚定的人中寻找。 演讲成功与否完全取决于一个人的气场而不是他说了什么。 表面自由的增加必然以真正自由的减少为代价。 为了追求理想，从野蛮走向文明；当理想失去了价值，从文明走向衰落和灭亡。","categories":[{"name":"读书&电影","slug":"读书-电影","permalink":"http://zivblog.top/categories/%E8%AF%BB%E4%B9%A6-%E7%94%B5%E5%BD%B1/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://zivblog.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"mysql解压版安装配置","slug":"mysql解压版安装配置","date":"2019-04-17T07:32:55.000Z","updated":"2020-07-06T05:35:43.379Z","comments":true,"path":"passages/mysql-jie-ya-ban-an-zhuang-pei-zhi/","link":"","permalink":"http://zivblog.top/passages/mysql-jie-ya-ban-an-zhuang-pei-zhi/","excerpt":"mysql安装时有安装版和解压版两种方式，本文讲解的是解压版的配置过程。 本文使用的mysql5.5，你可以选则喜欢的版本进行下载。","text":"mysql安装时有安装版和解压版两种方式，本文讲解的是解压版的配置过程。 本文使用的mysql5.5，你可以选则喜欢的版本进行下载。 下载Mysql 在这里下载mysql，并解压到你喜欢的目录下。 配置Mysql 将mysql主文件夹下的my.default.ini改名为my.ini并移动到bin目录下 如果没有则创建my.ini并移动到bin目录下 添加以下内容 123456789101112131415161718192021[Client]port = 3306[mysqld]# 端口port = 3306# 安装目录basedir=D:\\mysql-5.5.62# 数据存放目录datadir=D:\\mysql-5.5.62\\data# 最大连接数max_connections=200# 服务器端默认字符集character-set-server=utf8# 创建新表时使用的默认存储引擎default-storage-engine=INNODBsql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES [mysql]# 客户端默认字符集default-character-set=utf8 将mysql下的bin目录添加到Path环境变量中 安装Mysql服务 以管理员打开cmd 将目录切换到mysql下的bin目录 执行mysqld install 启动mysql服务 控制面板-&gt;管理工具-&gt;服务 -&gt; mysql -&gt; 启动 填坑 原有mysql服务卸载不完全 12执行sc delete mysql 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"工具配置","slug":"工具配置","permalink":"http://zivblog.top/categories/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://zivblog.top/tags/Tools/"}]},{"title":"Pycharm2017版激活","slug":"Pycharm2017版激活","date":"2019-04-15T10:57:11.000Z","updated":"2020-03-04T06:37:05.026Z","comments":true,"path":"passages/pycharm2017-ban-ji-huo/","link":"","permalink":"http://zivblog.top/passages/pycharm2017-ban-ji-huo/","excerpt":"本教程仅供个人学习使用，如有需要，请前往官方渠道购买正版产品。","text":"本教程仅供个人学习使用，如有需要，请前往官方渠道购买正版产品。 Pycharm下载 在这里选择2017版的pycharm下载，注意要选择professional版本的。 communtiy版本的是可以免费使用的，基本功能都有，可以满足日常使用。 下载完成后按指示安装即可。 安装完成后打开如下图所示 Pycharm激活 从这里下载http://idea.lanyus.com/jar/JetbrainsCrack-2.6.2.jar 将下载的jar包放在Pycharm安装目录下的bin目录下 修改pycharm.exe.vmoptions和pycharm64.exe.vmoptions文件，使用记事本打开即可 在其文件末尾添加-javaagent:你的pycharm安装目录\\bin\\JetbrainsCrack-2.6.10-release-enc.jar 重新启动Pycharm，选择Activiate code，输入以下内容 1BIG3CLIK6F-eyJsaWNlbnNlSWQiOiJCSUczQ0xJSzZGIiwibGljZW5zZWVOYW1lIjoibGFuIHl1IiwiYXNzaWduZWVOYW1lIjoiIiwiYXNzaWduZWVFbWFpbCI6IiIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IkZvciBlZHVjYXRpb25hbCB1c2Ugb25seSIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiQUMiLCJwYWlkVXBUbyI6IjIwMTctMTEtMjMifSx7ImNvZGUiOiJETSIsInBhaWRVcFRvIjoiMjAxNy0xMS0yMyJ9LHsiY29kZSI6IklJIiwicGFpZFVwVG8iOiIyMDE3LTExLTIzIn0seyJjb2RlIjoiUlMwIiwicGFpZFVwVG8iOiIyMDE3LTExLTIzIn0seyJjb2RlIjoiV1MiLCJwYWlkVXBUbyI6IjIwMTctMTEtMjMifSx7ImNvZGUiOiJEUE4iLCJwYWlkVXBUbyI6IjIwMTctMTEtMjMifSx7ImNvZGUiOiJSQyIsInBhaWRVcFRvIjoiMjAxNy0xMS0yMyJ9LHsiY29kZSI6IlBTIiwicGFpZFVwVG8iOiIyMDE3LTExLTIzIn0seyJjb2RlIjoiREMiLCJwYWlkVXBUbyI6IjIwMTctMTEtMjMifSx7ImNvZGUiOiJEQiIsInBhaWRVcFRvIjoiMjAxNy0xMS0yMyJ9LHsiY29kZSI6IlJNIiwicGFpZFVwVG8iOiIyMDE3LTExLTIzIn0seyJjb2RlIjoiUEMiLCJwYWlkVXBUbyI6IjIwMTctMTEtMjMifSx7ImNvZGUiOiJDTCIsInBhaWRVcFRvIjoiMjAxNy0xMS0yMyJ9XSwiaGFzaCI6IjQ3NzU1MTcvMCIsImdyYWNlUGVyaW9kRGF5cyI6MCwiYXV0b1Byb2xvbmdhdGVkIjpmYWxzZSwiaXNBdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlfQ&#x3D;&#x3D;-iygsIMXTVeSyYkUxAqpHmymrgwN5InkOfeRhhPIPa88FO9FRuZosIBTY18tflChACznk3qferT7iMGKm7pumDTR4FbVVlK&#x2F;3n1ER0eMKu2NcaXb7m10xT6kLW1Xb3LtuZEnuis5pYuEwT1zR7GskeNWdYZ0dAJpNDLFrqPyAPo5s1KLDHKpw+VfVd4uf7RMjOIzuJhAAYAG+amyivQt61I9aYiwpHQvUphvTwi0X0qL&#x2F;oDJHAQbIv4Qwscyo4aYZJBKutYioZH9rgOP6Yw&#x2F;sCltpoPWlJtDOcw&#x2F;iEWYiCVG1pH9AWjCYXZ9AbbEBOWV71IQr5VWrsqFZ7cg7hLEJ3A&#x3D;&#x3D;-MIIEPjCCAiagAwIBAgIBBTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE1MTEwMjA4MjE0OFoXDTE4MTEwMTA4MjE0OFowETEPMA0GA1UEAwwGcHJvZDN5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO&#x2F;5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij&#x2F;78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB&#x2F;xVy&#x2F;VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE&#x2F;EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl&#x2F;GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9 常见问题failed to create JVM: error code -1 在网上查阅了一些经验，最终是以以下方案解决的。 卸载java并删除注册表： 卸载java并删除环境变量 win+r，输入regedit启动注册表管理器 删除HKEY_CURRENT_USER\\Software\\JavaSoft 删除HKEY_LOCAL_MACHINE\\SOFTWARE\\JavaSoft 重新安装java并配置环境变量 从这里下载java8并安装 我的电脑-&gt;右键属性-&gt;高级系统设置-&gt;环境变量 系统变量中新建JAVA_HOME变量，值为你的java安装目录 选中系统变量中的Path，点击编辑，新建两条路径 打开cmd，依次输入java、javac、java -version确认安装配置正确 重新激活即可 key is invalid 从http://idea.lanyus.com/下载最新的补丁 删除 `C:/Users/用户名/.PycharmXXXX.XX文件 重新进入就不会有问题了 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"工具配置","slug":"工具配置","permalink":"http://zivblog.top/categories/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://zivblog.top/tags/Tools/"}]},{"title":"hexo博客主题配置","slug":"hexo博客主题配置","date":"2019-04-12T08:50:17.000Z","updated":"2020-07-06T05:07:55.941Z","comments":true,"path":"passages/hexo-bo-ke-zhu-ti-pei-zhi/","link":"","permalink":"http://zivblog.top/passages/hexo-bo-ke-zhu-ti-pei-zhi/","excerpt":"hexo博客主题配置","text":"hexo博客主题配置 在这里，挑选一款自己喜欢的主题，下载。 解压，将整个主题文件夹放到博客主文件夹下的themes文件夹下。 将主配置文件中的theme字段后的landscapes改为你主题文件夹的名称。 配置主题文件夹中的config.yml。 具体配置在主题的文档中都有，各个主题的配置过程都大同小异，请参照文档配置。 本站使用的主题是ad，欢迎来信交流。 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"博客相关","slug":"博客相关","permalink":"http://zivblog.top/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://zivblog.top/tags/Tools/"}]},{"title":"Pycharm使用小技巧","slug":"Pycharm使用小技巧","date":"2019-04-07T10:27:13.000Z","updated":"2020-03-04T06:37:34.747Z","comments":true,"path":"passages/pycharm-shi-yong-xiao-ji-qiao/","link":"","permalink":"http://zivblog.top/passages/pycharm-shi-yong-xiao-ji-qiao/","excerpt":"Pycharm的一些使用技巧 不断更新中","text":"Pycharm的一些使用技巧 不断更新中 打开时显示最后一次打开的项目or显示欢迎界面 file -&gt; settings -&gt; Appearance&amp;Behavior -&gt; System steeings -&gt; Reopen … 勾选or取消勾选 Pycharm使用conda虚拟环境 使用conda env list可以查看创建的虚拟环境 File -&gt; Settings -&gt; Project XXXX -&gt; Project Interpreter -&gt; add local Python Interpreter 选择Existing environment -&gt; XXXX/Anaconda/envs/your_env_name/python.exe 设置Pycharm文件编码 file -&gt; settings -&gt; Editor -&gt; File Encodings 按照自己的意愿设置即可 设置文件模版 file -&gt; Settings -&gt; Editor -&gt; File and Code Templates 此处以设置python文件模板为例 点击“Python Script” 字段解释 123456789101112131415161718192021$&#123;USER&#125; 当前系统用户$&#123;DATE&#125; 当前系统日期$&#123;TIME&#125; 当前系统时间$&#123;PRODUCT_NAME&#125; 创建文件的IDE名称也可直接添加文本信息其他可用：$&#123;PROJECT_NAME&#125; - 当前项目的名称。$&#123;NAME&#125; - 在文件创建过程中在“新建文件”对话框中指定的新文件的名称。$&#123;YEAR&#125; - 今年。$&#123;MONTH&#125; - 当月。$&#123;DAY&#125; - 当月的当天。$&#123;HOUR&#125; - 目前的小时。$&#123;MINUTE&#125; - 当前分钟。$&#123;PRODUCT_NAME&#125; - 将在其中创建文件的IDE的名称。$&#123;MONTH_NAME_SHORT&#125; - 月份名称的前3个字母。 示例：一月，二月等$&#123;MONTH_NAME_FULL&#125; - 一个月的全名。 示例：一月，二月等 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"工具配置","slug":"工具配置","permalink":"http://zivblog.top/categories/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://zivblog.top/tags/Tools/"}]},{"title":"苏州大学计算机考研初复试总结","slug":"苏州大学计算机考研初复试总结","date":"2019-04-04T07:11:47.000Z","updated":"2020-07-06T05:47:53.190Z","comments":true,"path":"passages/su-zhou-da-xue-ji-suan-ji-kao-yan-chu-fu-shi-zong-jie/","link":"","permalink":"http://zivblog.top/passages/su-zhou-da-xue-ji-suan-ji-kao-yan-chu-fu-shi-zong-jie/","excerpt":"苏州大学计算机考研初复试总结","text":"苏州大学计算机考研初复试总结 写在前面很早就想写一篇总结了，一直没有着手，一来是没有构思好具体的结构，另一方面是成绩还没出来，总觉得这个时候发篇总结容易打脸。 先介绍一下自己的情况吧。本科山东某双非本科，今年报考的是苏州大学的计算机专硕，专业课代号872。初试分数365，排名15。 典型工科男，没什么文笔，写的可能像是流水账一样，大家多担待。 今年由于政策变动，录取结果出的可能会晚一些。 今年统考全日制软件专硕取消了，不过计算机专硕最终扩招了，整体名额和去年差不多。 4月8日更新 成绩出来了，有幸上岸，感谢感谢。 备考时间安排 正式开始大约是在4月中旬，在之前也有看过一些高数，寒假结束之前差不多听完了朱伟的恋练有词。 英语真题从5月份开始，大约一周做一年的真题。 6月结束之前看完了汤老师的高数基础班和李永乐老师的线性代数。 暑假的时候看了一遍王道的数据结构和操作系统，听完了线代和高数的强化班。 九月份开始听徐涛的政治强化班并开始做数学的真题。 十月份开始刷肖秀荣的1000题并做了苏大近15年的真题。 十一月主要回顾了一遍高数和线代的笔记。 十一月中旬开始背作文和政治的大题。 每天的有效学习时间一般在8~9个小时。 使用参考书 英语：《恋练有词》、真题黄皮书（英一、英二）、《恋练有辞写作宝典》 政治：《核心考案》（徐涛）、《1000题》（肖秀荣）、《冲刺背诵笔记》（徐涛）、《肖四》、《肖八》 数学：《高数复习讲义》（汤家凤）、《线性代数辅导讲义》（李永乐）、《1800题》（汤家凤）、《真题》（张宇）、《张宇八套卷》 专业课：王道考研的《数据结构》和《操作系统》、近15年真题 视频网课 恋练有词（18年）。不建议看最新的，太拖了。 语法（唐静）。有时间可以看一下，开倍速或者跳着看都行。 阅读（唐迟）。可以针对实在看不懂的阅读来看一下，没必要全看。 徐涛政治强化班。不建议看基础班。 徐涛时政押题直播班。b站就可以看，一般直播之后过一天就有了。 汤家凤高数基础班、强化班。个人感觉跟着汤老师还是很踏实的，就是方言比较严重。 李永乐线代基础班、强化班。 汤家凤公众号的一些直播录像。 几点建议 专业课请务必重视专业课真题，尤其是操作系统，个人感觉苏大的专业课个性化很强，想拿高分不是很容易，有时间和机会的化可以看一下苏大本科的期末考试题。 英语阅读要认真练，每一篇文章都要认真去读。建议做完一遍之后隔几天再拿出来当作翻译精读一下。 英语重点就是阅读，请多花些时间在上面。 肖秀荣的四套卷一定要做，很真题。说实话都有些怀疑他是不是被派来泄题的（滑稽保命）。 李永乐的线代讲义一定要做，这么多年线代辅导独一份不是盖的，有时间可以听一下李永乐的强化班，有些技巧书里没有。 汤家凤的高数还是很踏实的，就是有点方言，个人比较推荐看一下他中值定理部分的强化班，很详细。 数学必须必须必须多做题，做真题，模拟题不建议做。真题值得刷好几遍（注意控制时间，模拟考场氛围）。 政治1000题的主要作用就是巩固知识点，不要太较真了，如果嫌多的话可以做徐涛的优题库，题量小一点。 政治马原建议看一下视频，其中的一些政治经济学的东西自己不太好懂。 政治看视频的话建议徐涛强化班，比较生动有趣。 没学过操作系统的，建议看mooc，苏大的老师讲的。 想到再来补充吧 经验之谈 考研不仅是知识上的较量，更是心态的较量，考研期间保持心情愉快是很关键的。 考研过程中收获的也不仅仅是最终的录取结果，还有心态和眼界上的提升。 请务必合理评估自己的实力，选择一个能通过半年多努力上岸的学校，这点很重要也很现实。 一个合适的研友对你来说不仅是学习上的陪伴，还是精神上的陪伴。一定要找一个肯沉下心学习的一起学习，如果你自制力强的也可以自己进行。 做规划是很有必要的，长短期都要大致有个计划。比如今天回宿舍前将明天的计划做一下，每个月结束前对上个月总结以下，对下个月计划一下。 数学和专业课值得花最多的时间去准备，英语学习需要贯穿整个备考过程。 不管初试复试分数占比如何，初试分数高一些总归是有好处的。根据今年的政策来说，初试成绩高一点可以让你更容易选到心仪的导师。 有问题一定要及时解决，不要害怕去请教别人，不要嫌请教别人花时间，给别人讲题也能加深你对知识的认识。 政治不建议暑假结束之前看，没必要，更会占用暑假最珍贵的数学强化时间。 政治和英语作文在最后两个月开始就行，时间很足够。 最后两个月基本就是政治和英语作文，其他题型的练习了，所以数学一定要在暑假结束之前打好底子，不然后期会手忙脚乱。 心态平和，按照自己的计划一步一步的进行，不要被别人的进度影响。 苏大的报名人数还是挺多的，不过不要害怕，做好自己就好了。 不要太过于追求技巧和方法，脚踏实地的练习才是最关键的。 文笔一般，大家凑活看吧，有问题可以联系我，本文也会继续补充。 下面的是复试的一点总结复试成绩不是很理想，就不谈什么经验了，说一下复试的流程吧。 今年是先选导师后复试，初试成绩高一点对联系导师还是有些优势的。 时间安排 复试通知 招生计划 资格审查 上机 面试 体检 一共是两天的时间 联系导师 注意有礼貌 不要同时联系多个同组的老师，会很尴尬（别问我为什么知道=_=） 有条件的话可以联系几个目标院校的学长学姐问一下。 研究方向 导师简介 学院导师联系方式 笔试（上机+选择） 前15年的上机真题很多考验群里都有，我在博客上也有整理（其实就是稍微整理了一下思路）。 主要就是文件操作和一些简单数据处理。 最后提交的程序一定要编译通过，有步骤分的。 进机房需要鞋套，可以提前买，学校里面的超市里也有卖的。 选择题刷二级c语言单选就可以了，但是还是有点区别的。总之二级c语言刷一段时间，40+应该没问题。 19年的上机题我有记过，一并放在本站了，需要的自取。 复试主要拉分的就是机试，一定要好好准备。 面试 面试分为三块：自我介绍（英文）、文献翻译、专业课知识（抽题，最多三次）。 今年专硕分了4组，面试顺序按成绩的升序排的。 今年的自我介绍要求用ppt来讲，时间在5分钟以内。 文献翻译大致就是一些数据结构和操作系统的知识，平时注意一些专业名词即可。 专业课知识包含的面很广，本科学的都有机会问到，还有一些当前的热点事件等。 据说跨考的同学答不上来的话会问一些本科本专业学的东西，所以不用害怕。 面试拉分不大，成绩给的也都挺高的。 其实面试不用紧张，尽可能去说就可以了，不会的可以说以下自己的看法，注意礼貌。 关于本科院校其实大家根本不用担心什么本科院校歧视什么的。 本科院校好的话顶多在联系导师的时候占点优势，在其他地方没什么差别。 一来初试和上机对于本科是哪里的根本没有关系，就看谁肯下功夫。 二来复试中的面试根本不会看你的成绩单之类的东西。 现阶段把初试的分数尽量考高点就是最大的优势了。 你们最关心的 总结了一下最近被问到的问题 面试时是否会问大学时的项目经验？ 我面试的时候，下面打分的老师们几乎都不讲话，也没有提问，全程只有一个助理在指导你该干什么。进去的时候不让带奖状、证书、成绩单等，老师们根本没时间看。还有就是你的初试分数如果低一点的话可以在自我介绍是适当加一些自己的各种经历，可能会是加分项。 上机题只能用c语言么？ 是的。20年的暂时还不知道，不过之前都是c语言程序设计。只能用有限的头文件，c++里的stl都不能用。主要考察的是文件操作，把历年的上机题敲两遍就差不多了。 上机使用什么工具？ 上机只能用vs2010，因为这边的机房电脑上只有这个，提前熟悉一下，有突发情况的话可以现场问监考的老师。 上机题必须全部做出来才有分么？ 不是。上机题一般有一道，但分为很多问，或者要求实现多个函数（今年）。每一问、每个函数都有分数。值得注意的是提交的程序必须是编译通过并且有输出的。 我去年4月份的进度？ 去年四月份差不多才算正儿八经的开始。刚听完去年学长们的经验分享。进度大约是高数听完了汤家凤的基础班，英语听完了恋练有词。 需不需要初试之前联系导师，与什么要注意的？ 个人感觉初试之前联系必要性不高，除非是很抢手的导师。毕竟连初试能不能过都不确定，导师那边也不好给答复，这个时候联系最大的作用就是留个印象。 联系导师首先要有礼貌，邮件里注意礼貌用于，将自己的意图表达清楚，附上自己的简历。 不要同时给多个同组的导师发邮件，在一个导师确定没有机会或长时间没有回复时再联系下一个。 看数据结构之前需不需要先看c语言的相关内容？ 数据结构主要考察的是思想，解决问题的思路。 数据结构答题时用伪代码即可，不用过分注意语法错误，达到能在注释的帮助下使别人看懂你的代码即可。 如果看数据结构的时候看不懂书上的代码，相应的查以下即可，主要就是循环、顺序、选择几种结构。 专业课是围绕真题还是以课本/辅导书为主？ 首先我的专业课成绩刚刚够三位数，在这里直说几点教训。 操作系统要重视真题，适应苏大的出题方式。 数据结构要重视每一个点，不要有遗漏。 我是直接看的王道，看完之后做了一遍真题，做的时候又回顾的知识点，最后又过了一遍知识点和真题。 出初试成绩后联系导师的模版 尊敬的XX教授： ​ 您好，我叫XXX，就读于XX，目前为大四在读。 ​ 我今年参加了贵校计算机专业硕士的入学考试，总成绩为XXX分，专业排名为XX，其中数学XXX，英语XX，专业课XXX，政治XX。按照往年的分数线，我将有机会参加贵校的研究生复试，我希望能够有幸攻读您2019年的研究生，所以十分冒昧给您发这封邮件。 ​ 我大学期间成绩在专业前XX%，专业课成绩良好，曾多次获得校级二等奖学金，优秀学生干部等荣誉。我已经通过了英语六级考试，具备一定的英文文献阅读能力，相信这对以后的科研工作会有所帮助。 ​ 大学课余期间我积极学习知识，具有对未知领域强烈的好奇心和一定的自学能力。曾自学一段时间的机器学习算法和python，参加过相关的线上比赛。后来接触到XX，十分感兴趣，希望能跟随一名该方面的专家进行研究学习，在这个方向上有所建树。 ​ 我目前正在积极准备研究生复试和毕业设计，毕业设计是XX的研究。 ​ 冒昧请问老师您是否还有统招名额，如果我能够通过取得苏州大学的研究生入学资格，希望能有机会攻读您的2019级研究生。如果能有幸攻读您的研究生，我将踏实学好专业知识并努力完成您下达的任务，竭力向您一样在行业内取得不俗的成就。 ​ 再次感谢您能在百忙之中阅读我的邮件，并对冒昧打扰致以歉意，同时期待收到您的回复。随邮件附个人简历及成绩证明。 ​ 祝老师生活工作愉快。 ​ 此致敬礼 ​ 学生：XXX ​ XXXX年X月X日 复试之前需要联系导师么？ 今年的政策不一样，复试之前必须先填一个表，必须导师那边同意之后才能填的，因为每个老师名额有限。 今年的情况是，只要复试前联系好导师，最后上岸后就确定是你联系的导师了，一般不能再改了。 由此看来，初试成绩高一点对选导师还是很友好的。 硕导和博导的区别？ 说实话我也不是很清楚，但是从另一个角度来说，有博士生招生资格的一般资历比较老，而且这样的话你就会有同门的博士生师兄，还是比较好的。 学硕和专硕在选导师时有没有区别？ 只要注意老师是的招生名额里是否有专硕招生，因为有的导师是不收专硕的。 其他的没有区别，放手去联系吧，说不定有大佬就同意了呢。 读研的方向怎么确定？ 学硕的化报名的时候就填一个方向，专硕报名时不用填。 根据你选的实验室和联系的导师的方向而定。 专业课面试如何准备？ 说实话，到时候就算不会也没什么问题，如实说就行了，比如说：学过去的时间比较长了，而且用的也不多，忘得差不多了。 最好是会。 想复习的话看看本科期间学过的专业课，比如数据库等（我今年就抽了两个数据库的题，都不会。。。） 再关注一些计算机方面的热点新闻即可。 对跨考是否友好 专业课考两门，如果有些基础的话，这一点可以忽略。 初试解决了专业课，其实大家都差不多。 复试好好准备上机就可以了，面试还是很友好的。 福利 准备初试和复试的一点电子版的资料，有些是考研群里的，搬运整理了一下。 请自取 最后别人的经历和经验用来听听，或者吸取一些有用的部分就好了，找到自己的复习节奏和方法才能事半功倍。 谢谢你的观看，考研过程中有问题可以联系我，我会尽力给出一点建议。 发邮件或加qq都可以。 就这样，祝大家都能成功上岸。 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"}],"tags":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"}]},{"title":"2019上机题回忆","slug":"2019年上机题回忆","date":"2019-04-04T07:10:01.000Z","updated":"2020-07-06T05:05:43.276Z","comments":true,"path":"passages/2019-nian-shang-ji-ti-hui-yi/","link":"","permalink":"http://zivblog.top/passages/2019-nian-shang-ji-ti-hui-yi/","excerpt":"2019上机题回忆","text":"2019上机题回忆 数据放在D盘根目录下名为Data.txt的文本文件中。 文件中存储有100个不超过32768的非负整数。 编写函数read_file()：读取文件中的数据，按文件中顺序存放在arr中 编写函数print()：将arr中的内容显示在屏幕上，每行10个数，每个整数占6列 编写函数count()：统计0~9在arr中所有整数中出现的次数，并存放到res中 编写函数print_res()：将res输出，每行5个元素，可复用print() 编写函数sort_array()：将arr中的整数按因子和升序排列，因子和相等的则按原大小排列（1和其本身也是因子） 编写函数filter_array()：对arr进行筛选，将偶数筛选出来放在头部，其他的放在后面。若使用辅助数组扣10分 编写函数write_file()：将偶数质数分解，每个数占一行写到output.txt中 给定主函数，修改一处扣5分。 满分100分。 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"}],"tags":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"},{"name":"c语言","slug":"c语言","permalink":"http://zivblog.top/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"hexo+github博客绑定域名","slug":"hexo之github博客绑定域名","date":"2019-04-01T02:27:12.000Z","updated":"2020-07-06T05:07:59.795Z","comments":true,"path":"passages/hexo-zhi-github-bo-ke-bang-ding-yu-ming/","link":"","permalink":"http://zivblog.top/passages/hexo-zhi-github-bo-ke-bang-ding-yu-ming/","excerpt":"从阿里云购买域名，绑定到托管在Github上的博客。","text":"从阿里云购买域名，绑定到托管在Github上的博客。 写在前面由于我们的网站主题是托管在github上的，也就相当于服务器在国外的情况，所以购买的域名并不需要备案，只需要实名认证一下就可以了。实名认证的时间大约在1~2天，速度还是很快的。 购买域名 首先我们需要注册一个阿里云账户，在这里注册。可以使用支付宝账户登录。 注册完之后进行实名认证等工作。 依次选择产品-&gt;精选-&gt;域名注册，输入你想要的域名进行购买。（这里建议可以一次多买几年，因为之后再续费的话费用会变高） 在阿里云的控制台中选择域名进行管理。 一开始的话，域名的状态是未实名认证的，认证以下就可以了，过程就不赘述了。 域名绑定 域名实名认证之后就可以开始下面的操作了。 首先在本地的博客主目录下的source文件夹下创建CNAME文件（注意是大写，并且没有文件后缀名）。 将你注册的域名写入CNAME 在github上托管你的博客的仓库的setting中，找到github pages，在custom domain中填入的你域名。 进入阿里云控制台域名管理界面，点击解析。 添加两条记录。 其中要填入的记录值可以通过ping你的github耳机域名获得 1ping yourname.github.io 再次在本地将你的博客生成一遍，同步到github上之后就可以用你自己的域名访问啦。 基本命令 1234hexo clean 清空数据库和生成的静态网页文件hexo g 生成静态网站hexo s 本地预览网页情况（通过localhost:4000访问）hexo d 同步到github上 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"博客相关","slug":"博客相关","permalink":"http://zivblog.top/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://zivblog.top/tags/Tools/"}]},{"title":"hexo博客中添加图片","slug":"hexo博客中添加图片","date":"2019-04-01T02:09:41.000Z","updated":"2020-03-04T06:20:56.908Z","comments":true,"path":"passages/hexo-bo-ke-zhong-tian-jia-tu-pian/","link":"","permalink":"http://zivblog.top/passages/hexo-bo-ke-zhong-tian-jia-tu-pian/","excerpt":"本文使用的是安装插件的方式添加图片，需要其他方式的请另行百度。","text":"本文使用的是安装插件的方式添加图片，需要其他方式的请另行百度。 首先在主配置文件中将post_asset_folder设置为true。 修改设置之后每次用hexo n &quot;&quot;创建文件是都会生成一个同名的文件夹，你所有的相关资源都应该放在这里面。 接下来需要安装一个插件，使用npm install hexo-asset-image --save安装。 出现上述提示就表示安装好了，下面的warning可以不用在意。 插件位置 在文件中引用图片时使用![文件替代文字](文件夹名/图片名)即可。 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"博客相关","slug":"博客相关","permalink":"http://zivblog.top/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://zivblog.top/tags/Tools/"}]},{"title":"苏州大学2018年复试上机题","slug":"苏州大学2018年复试上机题","date":"2019-03-19T08:38:16.000Z","updated":"2020-03-04T07:18:56.687Z","comments":true,"path":"passages/su-zhou-da-xue-2018-nian-fu-shi-shang-ji-ti/","link":"","permalink":"http://zivblog.top/passages/su-zhou-da-xue-2018-nian-fu-shi-shang-ji-ti/","excerpt":"","text":"题目描述 读取文件中的20000个数字，求其最大子集 子集中的数字互不为倍数，互不为因数，最大公约数为1 不允许使用预设的排序函数qsort() 题目分析 从二进制文件中读取数据（wb，rb） 排序（任意，这里使用的是选择排序） 首先判断是否为素数，加入结果集 对于非素数的数字，求其与结果集中的各个数字是否最大公约数全为1，加入结果集 将结果集写入文件中 代码结构 void make_data() 生成数据集（1~500，排除3,5,7） void swap(int *a, int *b) 交换传入的两个整数 int compare(int a, int b) 比较两个整数的大小 int selection_sort(int *ptr) 选择排序 int is_prime(int n) 判断传入的数字是否为素数 int gcd(int a, int b) 求两个数的最大公约数 void filter_data(int *data, int *result) 筛选符合条件的数据 void display(int *ptr, int n) 输出传入的数据集 void output(int *result, int count) 将结果集输出到文件 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;// 数据文件路径#define DATA_PATH \"C://Users//Y//Desktop//data.dat\"// 输出文件路径#define OUTPUT_PATH \"C://Users//Y//Desktop//output.txt\"// 文件中共20000条数据#define N 20000// 文件中数据的值位于1~500之间#define MAX 500void make_data()&#123; /* 生成数据 */ // 申请数据空间 int *num = (int*)malloc(sizeof(int)*N); int i, n = 1; FILE *fp = fopen(DATA_PATH, \"wb\"); // 生成20000条数据 for(i = 0; i &lt; N; i++)&#123; if(n &gt; 500) n = 1; if(n == 3 || n == 5 || n == 7) n++; num[i] = n; // debug // printf(\"%d \", num[i]); n++; &#125; // printf(\"source:\\n\"); // display(num, N); // 将数据写入文件中 fwrite(num, sizeof(int), N, fp); free(num); fclose(fp);&#125;void swap(int *a, int *b)&#123; /* 交换传入的两个数字 */ int temp = *a; *a = *b; *b = temp;&#125;int compare(int a, int b)&#123; /* 比较传入的两个数字的大小 */ if(a &lt; b) return -1; if(a &gt; b) return 1; if(a == b) return 0;&#125;void selection_sort(int *ptr)&#123; /* 选择排序 */ int i, j; for(i = 0; i &lt; N; i++)&#123; for(j = i + 1; j &lt; N; j++) if(compare(ptr[i], ptr[j]) &gt; 0) swap(&amp;ptr[i], &amp;ptr[j]); &#125;&#125;int is_prime(int n)&#123; /* 判断传入的数字是否为素数 */ int i; if(n &lt; 2) return 0; for(i = 2; i*i &lt;= n; i++)&#123; if(n % i == 0) return 0; &#125; return 1;&#125;int gcd(int a, int b)&#123; /* 求两个数字的最大公约数 */ if(a % b == 0) return b; return gcd(b, a % b);&#125;int filter_data(int *data, int *result)&#123; /* 筛选数据 */ int result_count = 0; int i, j; for(i = 0; i &lt; N; i++)&#123; // printf(\"data[%d] = %d\\n\", i, data[i]); if(data[i] &lt; 2)&#123; continue; &#125; else if(is_prime(data[i]))&#123; // 素数，且未在结果集中 // printf(\"\\nis prime\\n\"); for(j = result_count - 1; j &gt;= 0; j--)&#123; if(data[i] == result[j]) break; &#125; if(j == -1) // debug // printf(\"result_count = %d\", result_count); result[result_count++] = data[i]; &#125; else&#123; // 是否与结果集最大公约均数为1 for(j = 0; j &lt; result_count; j++)&#123; if(gcd(data[i], result[j]) != 1) break; &#125; if(j == result_count) result[result_count++] = data[i]; &#125; &#125; return result_count;&#125;void display(const int *data, int count)&#123; /* 输出传入的整数集 */ int i; printf(\"\\n\"); for(i = 0; i &lt; count; i++)&#123; printf(\"%d \", data[i]); &#125;&#125;void output(const int *result, int result_count)&#123; /* 将结果集输出到文件中 */ int i; FILE *fp = fopen(OUTPUT_PATH, \"w\"); for(i = 0; i &lt; result_count; i++)&#123; // printf(\"%d \", result[i]); fprintf(fp, \"%d \", result[i]); &#125; fclose(fp);&#125;int main()&#123; int *data, *result; int result_count; FILE* fp; data = (int*)malloc(sizeof(int)*N); result = (int*)malloc(sizeof(int)*100); // 生成数据 make_data(); // 读取数据 fp = fopen(DATA_PATH, \"rb\"); fread(data, sizeof(int), N, fp); // 输出读取的数据 // printf(\"\\ndata: \\n\"); // display(data, N); // 排序 selection_sort(data); // 排序后的数据 // printf(\"\\nsort:\\n\"); // display(data, N); // 筛选数据，返回数据个数 result_count = filter_data(data, result); printf(\"\\nresult_count: %d\\n\", result_count); // 结果输出到文件 output(result, result_count); // 输出结果 display(result, result_count); free(result); free(data); fclose(fp); return 0;&#125; 欢迎来信交流||指教。","categories":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"}],"tags":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"},{"name":"c语言","slug":"c语言","permalink":"http://zivblog.top/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"ubuntu下安装docker","slug":"ubuntu下安装docker","date":"2019-03-16T07:59:52.000Z","updated":"2020-07-06T05:41:07.684Z","comments":true,"path":"passages/ubuntu-xia-an-zhuang-docker/","link":"","permalink":"http://zivblog.top/passages/ubuntu-xia-an-zhuang-docker/","excerpt":"ubuntu &amp; docker","text":"ubuntu &amp; docker ubuntu中安装的docker 系统版本ubuntu server 16.04 卸载可能存在的旧版本 1$ sudo apt-get remove docker docker-engine docker-ce docker.io 更新apt包索引 1$ sudo apt-get update 安装以下包使apt可以通过https使用存储库 1$ sudo apt-get install -y apt-transport-https ca-certificates curl software-properties-common 添加docker官方GPG密钥 1$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - 设置stable存储库 1$ sudo add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\" 更新apt索引包 1$ sudo apt-get update 安装最新版本的Docker CE 1$ apt-cache madison docker-ce 可安装列表 1$ apt-cache madison docker-ce 安装指定版本的docker 1$ sudo apt-get install docker-ce=&lt;VERSION&gt; docker基本命令 启动docker 1$ sudo systemctl start docker 查看docker 1$ systemctl status docker 关闭docker 1$ sudo systemctl stop docker 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"工具配置","slug":"工具配置","permalink":"http://zivblog.top/categories/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://zivblog.top/tags/Tools/"}]},{"title":"xshell连接虚拟机","slug":"xshell连接虚拟机","date":"2019-03-16T04:53:26.000Z","updated":"2020-07-06T05:42:55.586Z","comments":true,"path":"passages/xshell-lian-jie-xu-ni-ji/","link":"","permalink":"http://zivblog.top/passages/xshell-lian-jie-xu-ni-ji/","excerpt":"xshell","text":"xshell 查看虚拟机ip 1$ ipconfig 从这里下载xshell6。 启动xshell6，依次选择文件-&gt;新建，协议选择ssh，ip填入第一步查找到的ip，端口为22。 ubuntu中安装openssh 1sudo apt install openssh-server 安装openssh报错 1234567891011121314Reading package lists... DoneBuilding dependency tree Reading state information... DoneSome packages could not be installed. This may mean that you haverequested an impossible situation or if you are using the unstabledistribution that some required packages have not yet been createdor been moved out of Incoming.The following information may help to resolve the situation:The following packages have unmet dependencies: openssh-server : Depends: openssh-client (= 1:7.2p2-4ubuntu2.8) Depends: openssh-sftp-server but it is not going to be installed Recommends: ssh-import-id but it is not going to be installedE: Unable to correct problems, you have held broken packages. 需卸载掉默认安装的openssh-client（因版本较新，而openssh-server依赖的版本较旧）： 1sudo apt-get autoremove openssh-client 然后再重新安装它们： 1sudo apt-get install openssh-client openssh-server 启动sshd服务: 1sudo /etc/init.d/ssh start 查看ssh是否成功启动 1service sshd status 设置ssh开机自启动 1chkconfig sshd on 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"工具配置","slug":"工具配置","permalink":"http://zivblog.top/categories/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://zivblog.top/tags/Tools/"}]},{"title":"vs2010的简单使用","slug":"vs2010的简单使用","date":"2019-03-16T04:51:23.000Z","updated":"2020-03-04T06:43:36.380Z","comments":true,"path":"passages/vs2010-de-jian-dan-shi-yong/","link":"","permalink":"http://zivblog.top/passages/vs2010-de-jian-dan-shi-yong/","excerpt":"复试的上机要求使用vs2010编写c语言控制台程序。之前没有用过这款软件，与codeblocks还是有很大差异的，这里记录一些使用的方法，希望对后来人有帮助。 研究生复试的上机要求使用vs2010编写c语言控制台程序。之前没有用过这款软件，与codeblocks还是有很大差异的，这里记录一些使用的方法，希望对后来人有帮助。","text":"复试的上机要求使用vs2010编写c语言控制台程序。之前没有用过这款软件，与codeblocks还是有很大差异的，这里记录一些使用的方法，希望对后来人有帮助。 研究生复试的上机要求使用vs2010编写c语言控制台程序。之前没有用过这款软件，与codeblocks还是有很大差异的，这里记录一些使用的方法，希望对后来人有帮助。 创建项目 打开vs2010，在右上方菜单栏选择文件-&gt;新建-&gt;项目。 选择win32控制台应用程序，填写项目名称，文件存储位置。 在应用程序向导中注意应用程序类型选择控制台应用程序，附加选项勾选空项目，取消勾选预编译头。 添加源文件 在项目文件夹中源文件文件夹上选择添加-&gt;新建项。 选择c++文件，填写文件名即可。 生成程序 编写完代码后，点击上方工具栏中的生成-&gt;编译完成编译工作。 编译完成后在菜单栏选择项目-&gt;仅用于项目-&gt;仅链接“项目名”完成链接工作。 可在文件夹中点击文件名.exe执行，也可以直接使用F5运行。 调试 找到一个位置，右键-&gt;断点-&gt;插入断点。 按F5运行程序，程序会运行到断点位置，软件面板下方看到当前变量 的值 按ctrl + F11快捷键，程序会单步执行，下方显示变量的当前值 在调试过程中鼠标悬停在变量上可以查看变量当前的值 选中变量可以添加监视，在下方监视中查看 关于安全周期检测 使用scanf和printf，在编译时会提醒该方法不安全，需要使用scanf_s 在项目文件夹上右键属性-&gt;配置属性-&gt;C\\C++-&gt;预处理器-&gt;右侧下拉菜单中点击编辑-&gt;添加——CRT_SECURE_NO_DEPRECATE 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"工具配置","slug":"工具配置","permalink":"http://zivblog.top/categories/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://zivblog.top/tags/Tools/"}]},{"title":"ubuntu修改软件源","slug":"ubuntu修改软件源","date":"2019-03-16T04:49:26.000Z","updated":"2020-07-06T05:41:44.305Z","comments":true,"path":"passages/ubuntu-xiu-gai-ruan-jian-yuan/","link":"","permalink":"http://zivblog.top/passages/ubuntu-xiu-gai-ruan-jian-yuan/","excerpt":"ubuntu软件源","text":"ubuntu软件源 图形界面下 在设置中的”软件和更新“中 修改Download from为Other 在弹出框汇中选择China 选择mirrors.aliyun.com 点击 Choose Server 非图形界面下 备份/etc/apt/sources.listcp /etc/apt/sources.list /etc/apt/souces.list.bak 修改文件内容sudo gedit /etc/apt/sources.list修改为： 123456789101112deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial main restricted universe multiverse deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-security main restricted universe multiverse deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-updates main restricted universe multiverse deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-backports main restricted universe multiverse ##测试版源 deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-proposed main restricted universe multiverse # 源码 deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial main restricted universe multiverse deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-security main restricted universe multiverse deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-updates main restricted universe multiverse deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-backports main restricted universe multiverse ##测试版源 deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-proposed main restricted universe multiverse # Canonical 合作伙伴和附加 deb http:&#x2F;&#x2F;archive.canonical.com&#x2F;ubuntu&#x2F; xenial partner deb http:&#x2F;&#x2F;extras.ubuntu.com&#x2F;ubuntu&#x2F; xenial main 保存 退出 运行sudo apt update使更新生效 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"工具配置","slug":"工具配置","permalink":"http://zivblog.top/categories/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://zivblog.top/tags/Tools/"}]},{"title":"win7下安装ubuntu双系统","slug":"win7下安装ubuntu双系统","date":"2019-03-16T01:21:24.000Z","updated":"2020-07-06T05:42:12.000Z","comments":true,"path":"passages/win7-xia-an-zhuang-ubuntu-shuang-xi-tong/","link":"","permalink":"http://zivblog.top/passages/win7-xia-an-zhuang-ubuntu-shuang-xi-tong/","excerpt":"windows &amp; ubuntu","text":"windows &amp; ubuntu 工具： ubuntu16.04 64位 easyBCD UltraISO 步骤： 在硬盘上划分区域 我的电脑-&gt;右键-&gt;管理-&gt;磁盘管理 选择较大的盘符-&gt;右键-&gt;压缩卷-&gt;选择压缩的大小（用于安装系统的磁盘） 制作启动盘： 格式化u盘，注意选择fat32格式 打开UltraISO软件 选择ubuntu16.04镜像 点击启动-&gt;写入硬盘镜像 写入方式为usb-HDD+ 点击便捷启动-&gt;写入新的驱动器引导扇区-&gt;Syslinux 点击写入，等待文件拷贝完成 安装系统 将系统启动盘插在电脑上 重启电脑，进入启动项选择，选择U盘启动 进入安装界面-&gt;选择中文或英文-&gt;点击安装Ubuntu 准备界面，可以联网安装，也可以安装完成后手动更I型呢 安装类型-&gt;选择其他选项 分区设置-&gt;选中刚才分好的空闲分区（可能不是“空闲“，点击“-”即可） 新建分区-&gt;点击”+“-&gt;”用于“设置成交换空间，分区类型-&gt;逻辑分区（小于物理机内存即可，例如8000M）, 新建分区-&gt;点击”+“-&gt;设置ubuntu的启动引导分区（200M差不多就够了），用于Ext4日志文件系统，挂载点/boot 新建分区-&gt;设置”/“主分区，相当于Win7的系统C盘,同样的方法,将剩余空间设置“/home”分区,用于存在文件。 点击”继续“-&gt;”继续“-&gt;安装 easyBCD修改系统启动项 添加新引导-&gt;选择linux-&gt;Drive选择刚才设置的/boot分区 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"工具配置","slug":"工具配置","permalink":"http://zivblog.top/categories/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://zivblog.top/tags/Tools/"}]},{"title":"centos6下升级内核并安装docker","slug":"centos6下内核升级及docker安装","date":"2019-03-14T02:48:48.000Z","updated":"2020-03-04T06:11:21.380Z","comments":true,"path":"passages/centos6-xia-nei-he-sheng-ji-ji-docker-an-zhuang/","link":"","permalink":"http://zivblog.top/passages/centos6-xia-nei-he-sheng-ji-ji-docker-an-zhuang/","excerpt":"centos内核升级及docker安装","text":"centos内核升级及docker安装 升级内核 查看系统版本 1cat /etc/issue 查看内核版本 1uname -r 导入public key 1rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org 安装ml内核（主线最新版本） 1yum --enablerepo=elrepo-kernel -y install kernel-ml 安装lt内核（长期支持版本） 1yum --enablerepo=elrepo-kernel -y install kernel-lt 以上两个版本二选一即可 修改主配置文件 123vim &#x2F;etc&#x2F;grub,conf将default&#x3D;1改为default&#x3D;0 重启系统即可 导入public key时若报错 error: https://www.elrepo.org/RPM-GPG-KEY-elrepo.org: import read failed(2). 使用yum -y update nss即可 安装docker 使用yum install docker-io安装 报错 12No package docker-io available.Error: Nothing to do yum install docker-io，这句话是用源安装docker，可是源一般是国外源，用这个命令因为GFW被墙，根本安装不了。 使用以下命令安装即可 1yum install https:&#x2F;&#x2F;get.docker.com&#x2F;rpm&#x2F;1.7.1&#x2F;centos-6&#x2F;RPMS&#x2F;x86_64&#x2F;docker-engine-1.7.1-1.el6.x86_64.rpm 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"工具配置","slug":"工具配置","permalink":"http://zivblog.top/categories/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://zivblog.top/tags/Tools/"}]},{"title":"苏州大学2013年复试上机题","slug":"苏州大学2013年复试上机题","date":"2019-03-13T12:39:43.000Z","updated":"2020-03-04T07:07:32.540Z","comments":true,"path":"passages/su-zhou-da-xue-2013-nian-fu-shi-shang-ji-ti/","link":"","permalink":"http://zivblog.top/passages/su-zhou-da-xue-2013-nian-fu-shi-shang-ji-ti/","excerpt":"","text":"题目描述 从一个文件中读取航班信息，从另一个文件中读取航班路径请求，并输出需要的信息。 判断一个特定的机场能否经过指定次数的跳数到达指定机场。一次跳跃是指从始发机场到目的地之间的一次任意两个机场之间的航行 例如：PVG到PEK是PVG-&gt;CAN-&gt;PEK。所以PVG-&gt;CAN是一跳，CAN-&gt;PEK也是一跳。 路径输入文件PathInput_2013.txt，文件包含多对始发点与终点的序列，文件第一行有一个数字，表示有多少个数据对。 12345676[PVG, CAN][CAN, PEK][PVG, CTU][CTU, DLC][DLC, HAK][HAK, LXA] 路径请求文件PathRequest_2013.txt，文件中包含一系列序列[起始点，终点]及最大跳数，第一行是一个数字，表示有多少个序列。 1232[PVG, DLC, 2][PVG, LXA, 2] 输出文件Output.txt，对于请求文件中的每个请求，输出请求并在其后跟YES或NO,表示是否能在指定跳数之内完成请求。 每个机场名均为三个大写字母，任意[起始/终点]对之间均是单向的。 题目分析 使用图解决问题 图使用邻接表存储图 根据Pathinput.txt中的序列建立邻接表 使用深度优先遍历判断图中初始点和终点之间是否有同路且跳数是否符合要求 代码结构 struct Edge：边结点 struct Vertex：顶点 struct Graph：图 int find(Vertex* vertices, int count, char src[4])：从顶点表中查找指定的结点，并返回下标 void add_edge(Graph* g, char src[4], char dst[4])：构造邻接表 bool is_possible(Graph* g, bool* visited, char src[4], char dst[4],int step)： 判断两个点之间是否可达 深度优先遍历 void destruct(Graph* g)：释放邻接表 void display(Graph* g)：输出图 int main()： 打开文件 读取PathInput.txt文件 读取PathRequest.txt文件 判断是否满足 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219#include&lt;math.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;time.h&gt;#include&lt;stdbool.h&gt;// 邻接表数据结构typedef struct Edge&#123; // 边结点 int index; char city[4]; struct Edge* next;&#125;Edge;typedef struct&#123; // 顶点 char city[4]; Edge* first;&#125;Vertex;typedef struct&#123; // 图中的结点 int size; int capacity; Vertex* vertices;&#125;Graph;int find(Vertex* vertices, int count, char src[4])&#123; // 从顶点表中查找指定的结点，并返回下标 int i; for(i = 0; i &lt; count; i++) if(strcmp(src, vertices[i].city) == 0) break; return i;&#125;void add_edge(Graph* g, char src[4], char dst[4])&#123; /* */ int i, j; Edge* e; // 添加起始点 i = find(g-&gt;vertices, g-&gt;size, src); if(i == g-&gt;size)&#123; strcpy(g-&gt;vertices[g-&gt;size].city, src); g-&gt;vertices[g-&gt;size].first = NULL; g-&gt;size++; &#125; // 添加终点 j = find(g-&gt;vertices, g-&gt;size, dst); if(j == g-&gt;size)&#123; strcpy(g-&gt;vertices[g-&gt;size].city, dst); g-&gt;vertices[g-&gt;size].first = NULL; g-&gt;size; &#125; // 查找终点 for(e = g-&gt;vertices[i].first; e != NULL; e = e-&gt;next)&#123; if(strcmp(e-&gt;city, dst) == 0) break; &#125; // 图中未发现终点，将其添加到图的首部 if(e == NULL)&#123; e = (Edge*)malloc(sizeof(Edge)); strcpy(e-&gt;city, dst); e-&gt;index = j; e-&gt;next = g-&gt;vertices[i].first; g-&gt;vertices[i].first = e; &#125;&#125;bool is_possible(Graph* g, bool* visited, char src[], char dst[], int step)&#123; /* 判断两个节点之间是否可达 深度优先遍历 */ int current; Edge* e; // 在图中查找起始点 current = find(g-&gt;vertices, g-&gt;size, src); // 已经被访问过或 if(step == 0 || visited[current]) return false; else&#123; visited[current] = true; for(e = g-&gt;vertices[current].first; e != NULL; e = e-&gt;next)&#123; // 以起始点直接可达的点钟是否有终点 if(strcmp(e-&gt;city, dst) == 0 &amp;&amp; step == 1) return true; // 递归 else if(is_possible(g, visited, e-&gt;city, dst, step - 1)) return true; &#125; visited[current] = false; &#125; return false;&#125;void destruct(Graph* g)&#123; /* 释放图的内存空间 按行消除 */ int i; for(i = 0; i &lt; g-&gt;size; i++)&#123; while(g-&gt;vertices[i].first != NULL)&#123; Edge* e = g-&gt;vertices[i].first-&gt;next; free(g-&gt;vertices[i].first); g-&gt;vertices[i].first = e; &#125; &#125; free(g-&gt;vertices);&#125;void display(Graph* g)&#123; int i; Edge* edge; // 邻接列表 printf(\"adjacency list:\\n\"); for(i = 0; i &lt; g-&gt;size; i++)&#123; printf(\"%s: \", g-&gt;vertices[i].city); for(edge = g-&gt;vertices[i].first; edge != NULL; edge = edge-&gt;next) printf(\"%s \", edge-&gt;city); printf(\"\\n\"); &#125; printf(\"\\n\");&#125;int main()&#123; FILE* fpi = fopen(\"PathInput_2013.txt\", \"r\"); FILE* fpr = fopen(\"PathRequest_2013.txt\", \"r\"); FILE* fpo = fopen(\"Output_2013.txt\", \"w\"); char line[16]; char src[4]; char dst[4]; bool* visited; // 访问标识 int step; int num; Graph g; // 三个文件均被成功打开 if(!fpi || !fpr || !fpo)&#123; printf(\"failed to open files.\\n\"); exit(-1); &#125; // 全部初试化为0 memset(line, 0, sizeof(line)); // 从文件中读取第一行的数字 if(fgets(line, sizeof(line), fpi) != NULL)&#123; g.size = 0; // 将字符串转化成int g.capacity = atoi(line) * 2; g.vertices = (Vertex*)malloc(g.capacity * sizeof(Vertex)); memset(g.vertices, 0, g.capacity); &#125; // 读取序列并用邻接表 while(fgets(line, sizeof(line), fpi) != NULL)&#123; // 读取起始点 memcpy(src, line + 1, 3); src[3] = '\\0'; // 读取终点 memcpy(dst, line + 6, 3); dst[3] = '\\0'; // 添加边 add_edge(&amp;g, src, dst); &#125; display(&amp;g); // 输出航班信息 printf(\"flight info:\\n\"); visited = (bool*)malloc(g.size); if(fgets(line, sizeof(line), fpr) != NULL) num = atoi(line); // 读取请求文件 while(fgets(line, sizeof(line), fpr) != NULL)&#123; memcpy(src, line + 1, 3); src[3] = '\\0'; memcpy(dst, line + 6, 3); dst[3] = '\\0'; step = line[11] - '0'; memset(visited, false, g.size); // 判断是否可行 if(is_possible(&amp;g, visited, src, dst, step))&#123; printf(\"[%s, %s, %d, YES]\\n\", src, dst, step); fprintf(fpo, \"[%s, %s, YES]\\n\", src, dst); &#125;else&#123; printf(\"[%s, %s, %d, NO]\\n\", src, dst, step); fprintf(fpo, \"[%s, %s, NO]\\n\", src, dst); &#125; &#125; //释放内存和关闭文件 destruct(&amp;g); free(visited); fclose(fpi); fclose(fpr); fclose(fpo);&#125; 欢迎来信交流||指教。","categories":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"}],"tags":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"},{"name":"c语言","slug":"c语言","permalink":"http://zivblog.top/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"苏州大学2017年保研上机题","slug":"苏州大学2017年保研上机题","date":"2019-03-13T07:36:11.000Z","updated":"2020-03-04T07:17:37.027Z","comments":true,"path":"passages/su-zhou-da-xue-2017-nian-bao-yan-shang-ji-ti/","link":"","permalink":"http://zivblog.top/passages/su-zhou-da-xue-2017-nian-bao-yan-shang-ji-ti/","excerpt":"","text":"题目描述 文本文件input.txt里面放了一堆整数，仅仅以空格分割，其中第一个整数为k，第二个整数代表维度，剩余的整数作为点的坐标。 读取整数k和维度，并读取剩余的整数组成指定维度的点。 从所有点钟找到距离最近的两个点并输出它们的坐标和距离。 分别输出距离这两个点最近的k个点的坐标。 题目分析 先读取文件中的前两个数，第一个k，第二个是dimension，后面每dimension个数字组成一个点 循环计算距离最近的两个点，输出这两个点及其距离 对这两个点分别计算所有点到其距离，输出最近的k个 一开始点的维数未知，故点的结构体中使用指针存储坐标，每读取一个点申请一个整形的空间 代码结构 struct Point：坐标点的结构体 double distance(Point* a,Point* b)：计算两个点之间的距离 void swap(Point* a, Point* b)：交换传入的两个坐标点 int compare(Point* a, Point* b)：比较传入的两个点与指定点之间的距离 void selection_sort(Point* points, int begin, int end)：选择排序 void sorted_by_distance(Point* points, int begin, int end, int pivot)：根据与指定点知道见的距离排序 void display_point(Point* p)：显示一个点 void display_all(Point* points, int count)：显示所有点 display_nearest(Point* points, int count, int pivot, int k)：显示离指定点最近的k个点 int main()： 统计文件中的整数个数 读取前两个数字 按照维度读取每个坐标点 双循环查找最近的两个坐标点 查找并输出离这两个点最近的k个点 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;float.h&gt;typedef struct&#123; int* vector; // 坐标维度未知，使用指针 int dimension; // 坐标维度&#125;Point;Point point;double distance(Point* a, Point* b)&#123; /* 求传入的两个点之间的距离 fabs(), 求浮点数的绝对值 pow(x, y),求x的y次方 sqrt(),开根号 */ double dist = 0.0; int i; for(i = 0; i &lt; a-&gt;dimension; i++)&#123; dist += pow(fabs(a-&gt;vector[i] - b-&gt;vector[i])*1.0, 2); &#125; return sqrt(dist);&#125;void swap(Point* a, Point* b)&#123; /* 交换传入的两个点 */ Point temp = *a; *a = *b; *b = temp;&#125;int compare(Point* a, Point* b)&#123; /* 比较传入的两点浴指定点之间的距离 */ double dista = distance(a, &amp;point); double distb = distance(b, &amp;point); if(dista &lt; distb) return -1; if(dista &gt; distb) return 1; if(dista == distb) return 0;&#125;void selection_sort(Point* points, int begin, int end)&#123; /* 根据与指定点之间的距离选择排序 */ int i, j; for(i = begin; i &lt; end; i++)&#123; for(j = i+1; j &lt; end; j++) if(compare(&amp;points[i], &amp;points[j]) &gt; 0) swap(&amp;points[i], &amp;points[j]); &#125;&#125;void sorted_by_distance(Point* points, int begin, int end, int pivot)&#123; point = points[pivot]; selection_sort(points, begin, end);&#125;void display_point(Point* p)&#123; /* 输出一个点 */ int j; printf(\"(\"); for(j = 0; j &lt; p-&gt;dimension - 1; j++)&#123; printf(\"%2d, \", p-&gt;vector[j]); &#125; printf(\"%2d)\", p-&gt;vector[p-&gt;dimension-1]);&#125;void display_all(Point* points, int count)&#123; /* 输出所有点 */ int i; for(i = 0; i &lt; count; i++) display_point(&amp;points[i]); printf(\"\\n\");&#125;void display_nearest(Point* points, int count, int pivot, int k)&#123; /* 输出离指定点最近的k个点 */ // 排序 int i; sorted_by_distance(points, 0, count, pivot); printf(\"the nearest %d points to \", k); display_point(&amp;points[0]); printf(\"\\n\"); for(i = 1; i &lt;= k; i++) display_point(&amp;points[i]); printf(\"\\n\");&#125;int main()&#123; FILE* fp = fopen(\"input_2017bao.txt\", \"r\"); Point* points; int k, dimension, val, count, point_count; int i, j; // 统计文件中国的数字个数 count = 0; while(fscanf(fp, \"%s\", &amp;val) != EOF) count++; rewind(fp); // 读取k和维度 fscanf(fp, \"%d\", &amp;k); fscanf(fp, \"%d\", &amp;dimension); printf(\"k = %d\\ndimension = %d\\n\", k, dimension); // 计算点的个数 point_count = (count - 2) / dimension; // 申请存储空间 points = (Point*)malloc(sizeof(Point) * point_count); for(i = 0; i &lt; point_count; i++)&#123; points[i].dimension = dimension; // 申请一个点的存储空间 points[i].vector = (int*)malloc(sizeof(int*)*dimension); for(j = 0; j &lt; dimension; j++) fscanf(fp, \"%d\", &amp;points[i].vector[j]); &#125; // 显示所有点 display_all(points, point_count); int lhs, rhs, pivot; double min = distance(&amp;points[0], &amp;points[1]); for(pivot = 0; pivot &lt; point_count - 1; pivot++)&#123; sorted_by_distance(points, pivot + 1, point_count, pivot); if(distance(&amp;points[pivot], &amp;points[pivot+1]) &lt; min)&#123; lhs = pivot; rhs = pivot + 1; min = distance(&amp;points[pivot], &amp;points[pivot + 1]); &#125; &#125; printf(\"the shortest distance: %f\\n\", min); printf(\"the nearest two points:\\n\"); display_point(&amp;points[lhs]); display_point(&amp;points[rhs]); printf(\"\\n\"); display_nearest(points, point_count, lhs, k); display_nearest(points, point_count, 1, k); fclose(fp);&#125; 欢迎来信交流||指教。","categories":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"}],"tags":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"},{"name":"c语言","slug":"c语言","permalink":"http://zivblog.top/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"苏州大学2016年保研上机题","slug":"苏州大学2016年保研上机题","date":"2019-03-10T08:48:01.000Z","updated":"2020-03-06T10:50:58.538Z","comments":true,"path":"passages/su-zhou-da-xue-2016-nian-bao-yan-shang-ji-ti/","link":"","permalink":"http://zivblog.top/passages/su-zhou-da-xue-2016-nian-bao-yan-shang-ji-ti/","excerpt":"","text":"题目描述 从服务器上将两个数据文件input.txt和words.txt下载到本地电脑根文件夹。 在words.txt中存储了不超过30000条的英文单词，每个单词占一行。单词最大长度为20，且单词内没有空格，文件中无重复单词。 input.txt中存储了一个丢失了空格和标点符号的英文文章。每行不超过128`个字符，请将第一行和最后一行显示在屏幕上。 将words.txt中的最后三行显示在屏幕上。 利用words.txt中的单词作为字典，采用正向最大匹配切分单词算法（从左往右匹配，尽量取长词）对input.txt中的文本进行单词切分。且粉饰注意单词大小写，切分分割标记采用空格，将切分后的结果写入到out.txt中。 正想最大匹配切分算法（例）：有待切分字符串abcdefg，单词最大长度为5，则先判断abcde是否为单词，若不是则舍弃最后一个字母接着判断，即判断abcd是否为单词；只有一个字母时可直接认定是单词。 给定主函数为： 123456789101112131415161718int main()&#123; char words[SIZE][24]; clock_t start, finish; // 计算程序使用的时间 start = clock(); showFirstAndLastLine(\"input_2016b.txt\"); //将input文件的第一行和最后一行显示在屏幕上 int count = ReadWords(\"words_2016b.txt\", words); //读取英文字典，并返回单词数量 showTheLastThreeLines(count, words); //此处可以添加处理逻辑以实现题目的第3点要求 //建议将需要的功能实现为多个函数后在此直接或者间接调用 maxMatch(words, count, \"input_2016b.txt\", \"output_2016b.txt\"); finish = clock(); printf(\"Total time:%lf\\n\", (double)(finish - start) / CLOCKS_PER_SEC);&#125; 不允许修改主函数内容，不允许使用以下头文件之外的头文件 1234#include &lt;time.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt; 题目分析 问题3：文件中单词之间没有分隔符，可直接使用fgets(字符数组，长度，文件指针)按行读取读取并输出。 问题4：文件中单词按行存储，可使用格式化读取fscanf(文件指针，格式，字符数组)的方式读取到一个单词数组中，输出最后三行（即最后三个单词）。 使用qsort()对单词数组进行排序，使用bsearch()在指定数组中查询单词是否存在 代码结构 void showFirstAndLastLine(const char filename[])： 输出input.txt文件中第一行和第三行的内容 int ReadWords(const char filename[], char Words[SIZE][24]) 读取words.txt中的单词 void showTheLastThreeLines(int count, char Words[SIZE][24]) 输出words.txt中最后三行的内容（即最后三个单词） int compare(const void* a, const void* b) 比较传入的两个字符 void maxMatch(char Words[SIZE][24], int count, const char input[], const char output[])： 获取单词整箱最大匹配 int main() 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;time.h&gt;#define SIZE 30000void showFirstAndLastLine(char filename[])&#123; /* 输出input.txt中的第一行和最后一行的内容 */ FILE* fp = fopen(filename, \"r\"); char buf[128]; char temp[128]; // 输出第一行的内容 if(fgets(buf, 128, fp) != NULL)&#123; printf(\"%s\\n\", buf); &#125; // 输出最后一行的内容 while((fgets(temp, 128, fp) != NULL)) strcpy(buf, temp); fclose(fp); printf(\"%s\\n\", buf);&#125;int ReadWords(const char filename[], char words[SIZE][24])&#123; /* 读取word.txt的内容 */ int count = 0; char buf[24]; FILE* fp = fopen(filename, \"r\"); while(fscanf(fp, \"%s\", buf) != EOF) strcpy(words[count++], buf); fclose(fp); return count;&#125;void showTheLastThreeLines(count, words)&#123; /* 输出最后的word.txt的三行 */ int i = 1; while(i &lt;= 3)&#123; printf(\"%s\\n\", words[count - i]); i ++; &#125;&#125;int compare(const void* a, const coid* b)&#123; // 顺序比较两个字符串 return strcmp((char*)a, (char*)b);&#125;void maxMatch(char words[SIZE][24], int count, const char input[], const char output[])&#123; char buf[128]; char substr[128]; char *result; int i; int begin, length; // 打开文件 FILE* fin = fopen(input, \"r\"); FILE* fout = fopen(output, \"w\"); // 对words进行升序排序 qsort(words, count, sizeof(words[0]), compare); // 读取文件内容 while(fscanf(fin, \"%s\", buf) != EOF)&#123; begin = 0; length = strlen(buf); while(begin != length)&#123; // 将buf+begin中的20个字符复制到substr中 memcpy(substr, buf+begin, 20); for(i = 20; i &gt; 0; i--)&#123; substr[i] = '\\0'; // 从大到小，按个数在words中找substr if(bsearch(substr, words, count, sizeof(substr), compare)) break; &#125; // 输出到文件 fprintf(fout, \"%s\", substr); // 指针后移 begin += strlen(substr); &#125; fprintf(fout, \"\\n\"); &#125; fclose(fin); fclose(fout);&#125;int main()&#123; char words[SIZE][24]; clock_t start, finish; start = clock(); showFirstAndLastLine(\"input_2016b.txt\"); //将input文件的第一行和最后一行显示在屏幕上 int count = ReadWords(\"words_2016b.txt\", words); //读取英文字典，并返回单词数量 showTheLastThreeLines(count, words); //此处可以添加处理逻辑以实现题目的第3点要求 //建议将需要的功能实现为多个函数后在此直接或者间接调用 maxMatch(words, count, \"input_2016b.txt\", \"output_2016b.txt\"); finish = clock(); printf(\"Total time:%lf\\n\", (double)(finish - start) / CLOCKS_PER_SEC);&#125; 欢迎来信交流||指教。","categories":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"}],"tags":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"},{"name":"c语言","slug":"c语言","permalink":"http://zivblog.top/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"苏州大学2017年复试上机题","slug":"苏州大学2017年复试上机题","date":"2019-03-09T15:21:53.000Z","updated":"2020-03-04T07:18:22.759Z","comments":true,"path":"passages/su-zhou-da-xue-2017-nian-fu-shi-shang-ji-ti/","link":"","permalink":"http://zivblog.top/passages/su-zhou-da-xue-2017-nian-fu-shi-shang-ji-ti/","excerpt":"","text":"题目描述 二进制数据文件data.bin中存放了若干整数，编写程序： 读取所有数据。 每相邻的两个整数为一对坐标，构成二维平面上的坐标点 以每个坐标点为圆心，以该点与其后面第一个点的欧氏距离为半径r，计算每个圆包含的坐标点数，计算最后一个点时以其和第一个点的欧式距离为半径。 计算所有圆的点密度值，输出密度值最大的5个坐标点，以及院中包含的点数和点密度值 坐标点 包含点数 点密度 (x坐标, y坐标) (占5列, 右对齐) (占7列, 右对齐, 保留2位小数) 圆的点密度为：圆包含的点除以圆面积，在圆上也包含该点，$\\pi = 3.14$ 题目分析 二进制文件读取时用fread(data, sizeof(int), count, fp)函数每四位读做一个整数 每两个整数为一个坐标 定义结构体存储坐标和密度值 利用文件位置标记计算文件中的整数个数，申请整数数组、坐标数组的空间 按密度值按降序排序 代码结构 struct Coordinate 坐标点结构体 struct Circle 圆结构体 包含：圆心坐标、半径、圆中点的个数、点密度 static int compare(const Circle* a, const Circle* b) 比较传入的圆的点密度 static void swap(Circle* a, Circle* b) 交换传入的两个圆的位置 void selection_sort(Circle *ptr, int count) 跟据圆的点密度进行选择排序 int read_file(const char* filename, const char* mode, int* data) 根据文件中的点的个数申请空间 读取文件内容 double distance(Coordinate* a, Coordinate* b) 计算两个点之间的距离 double area(Circle* a) 计算圆的面积 void display(Circle* circles, int count) 输出圆的圆心坐标，圆中包含的点的个数，点密度 int create_circles(int * data, int coune, Circle* circles) 初始化圆的信息，包括圆心坐标、圆中点的个数、点密度 int main() 读取文件 输出坐标点 计算圆的相关属性 按照点密度排序 输出点密度最高的5个 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;time.h&gt;#include&lt;time.h&gt;#define PI 3.14typedef struct&#123; int x; int y;&#125;Coordinate;typedef struct&#123; double r; // 半径 Coordinate point; // 坐标 int points_num; // 范围内坐标点个数 double density; // 圆密度&#125;Circle;static int compare(const Circle* a, const Circle* b)&#123; /* 比较传入的圆的圆密度 */ if(a-&gt;density &gt; b-&gt;density) return -1; else if(a-&gt;density &lt; b-&gt;density) return 1; else return 0;&#125;static void swap(Circle* a, Circle* b)&#123; /* 交换传入的两个圆 */ Circle temp = *a; *a = *b; *b = temp;&#125;void selection_sort(Circle *ptr, int count)&#123; /* 根据圆密度进行选择排序 */ int i, j; for(i = 0; i &lt; count; i++)&#123; for(j = i + 1; j &lt; count; j++) if(compare(&amp;ptr[i], &amp;ptr[j]) &gt; 0) swap(&amp;ptr[i], &amp;ptr[j]); &#125;&#125;int read_file(const char* filename, const char* mode, int* data)&#123; /* 读取文件 */ FILE* fp = fopen(filename, mode); int count = 0; if(!fp)&#123; printf(\"failes to open file.\\n\"); exit(0); &#125; // 计算文件中的整数个数，申请内存空间 fseek(fp, 0, SEEK_END); count = ftell(fp) / sizeof(int); data = (int*)malloc(sizeof(int)*count); rewind(fp); fread(data, sizeof(int), count, fp); fclose(fp); return count;&#125;double distance(Coordinate* a, Coordinate* b)&#123; /* 计算两个坐标之间的距离 */ int val; val = (a-&gt;x - b-&gt;x) * (a-&gt;x - b-&gt;x) + (a-&gt;y - b-&gt;y) * (a-&gt;y - b-&gt;y); return sqrt((double)val);&#125;double area(Circle* c)&#123; // 计算圆的面积 return (c-&gt;r * c-&gt;r) *PI;&#125;void display(Circle* circles, int count)&#123; /* 输出传入的圆 */ int i; for(i = 0; i &lt; count; i++)&#123; printf(\"(%d, %d) %5d %7.2f\\n\", circles[i].point.x, circles[i].point.y, circles[i].points_num, circles[i].density); &#125;&#125;int create_circles(int* data, int count, Circle* circles)&#123; int circles_num = count - 1; int i, j; // 申请存储圆的数组空间 circles = (Circle*)malloc(sizeof(Circle) * circles_num); // 初始化圆数组 for(i = 0; i &lt; circles_num; i++)&#123; circles[i].point.x = data[i]; circles[i].point.y = data[i + 1]; circles[i].points_num = 0; &#125; // 计算圆的半径（与后面点之间的距离为r） for(i = 0; i &lt; circles_num; i++)&#123; circles[i].r = distance(&amp;circles[i].point, &amp;circles[(i+1)%circles_num].point); &#125; // 统计在圆内的点的个数（与该点之间距离小于半径） for(i = 0; i &lt; circles_num; i++)&#123; for(j = 0; j &lt; circles_num; j++)&#123; if(distance(&amp;circles[i].point, &amp;circles[j].point) &lt;= circles[i].r) circles[i].points_num++; &#125; &#125; // 计算圆的圆密度 for(i = 0; i &lt; circles_num; i++)&#123; circles[i].density = circles[i].points_num / area(&amp;circles[i]); &#125; return circles_num;&#125;int main()&#123; int *data = NULL; int count = 0; int circles_num = 0; int i; Circle* circles = NULL; // 读取文件，返回圆的个数 count = read_file(\"data_2017.bin\", \"rb\", data); printf(\"data:\\n\"); // 输出坐标点 for(i = 0; i &lt; count; i++)&#123; printf(\"%d \", data[i]); &#125; printf(\"\\n\"); // 计算圆的半径，圆中的坐标点个数，圆密度 circles_num = create_circles(data, count, circles); // 按圆密度排序 selection_sort(circles, circles_num); printf(\"result:\\n\"); // 输出密度最高的前五个 display(circles, 5);&#125; 欢迎来信交流||指教。","categories":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"}],"tags":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"},{"name":"c语言","slug":"c语言","permalink":"http://zivblog.top/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"苏州大学2016年复试上机题","slug":"苏州大学2016年复试上机题","date":"2019-03-08T09:16:40.000Z","updated":"2020-03-04T07:16:23.592Z","comments":true,"path":"passages/su-zhou-da-xue-2016-nian-fu-shi-shang-ji-ti/","link":"","permalink":"http://zivblog.top/passages/su-zhou-da-xue-2016-nian-fu-shi-shang-ji-ti/","excerpt":"","text":"题目描述 文本文件input.txt由若干英文单词和分隔符（空格、回车、换行）组成，根据如下说明编写程序统计不同单词出现的次数（频度）。将统计结果按出现频度从高到低排序，并将出现频度大于5的单词及其频度输出到文件output.txt中。 文件格式单词,次数，每个单词占一行 多个连续分隔符被视为一个分隔符 大小写敏感，即大小写不同的为两个单词 每个单词长度不超过20个字符 单词的数量未知，使用静态大数组将扣5分 题目分析 不允许使用静态大数组，先读取一遍文件，统计单词个数；或者每发现一个新单词，动态申请空间 分割符不用处理，使用以下函数按单词读取 1fscanf(fp, &quot;%s&quot;, buf); 定义结构体，存储单词及其频度 根据频度降序排序 代码结构 struct Word： 单词，频度结构体 int compare(const Word* lhs, const Word* rhs)： 比较传入的两个字符的出现次数 void swap(Word* a, Word* b)： 交换传入的两个字母的顺序 void insertion_sort(Word* ptr, int count) 插入排序 int find(Word* words, int count, char* str) 在words中查找str，并返回下标 若没有则返回数组的长度 int main()： 打开文件 统计文件中的单词个数 申请存储空间 读取文件内容，并统计相同单词的个数 按单词的出现频度排序 输出单词及其频度，并输出到文件 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;math.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;typedef struct&#123; int freq; char str[20];&#125;Word;int compare(const Word* lhs, const Word* rhs)&#123; /* 比较传入的两个字符的出现次数 */ if(lhs-&gt;freq &gt; rhs-&gt;freq) return -1; else if(lhs-&gt;freq &lt; rhs-&gt;freq) return 1; else return 0;&#125;void swap(Word* a, Word* b)&#123; /* 交换传入的两个字母的顺序 */ Word temp = *a; *a = *b; *b = temp;&#125;void insertion_sort(Word* ptr, int count)&#123; /* 插入排序 */ int i, j; for(i = 1; i &lt; count; i++)&#123; j = i; Word ref = ptr[i]; while(j &gt; 0 &amp;&amp; compare(&amp;ptr[j - 1], &amp;ref) &gt; 0)&#123; ptr[j] = ptr[j - 1]; j --; &#125; ptr[j] = ref; &#125;&#125;int find(Word* words, int count, char* str)&#123; // 在words中查找str，并返回下标 int i; for(i = 0; i &lt; count; i++)&#123; // 比较两个单词是否相等 if(strcmp(words[i].str, str) == 0) break; &#125; return i;&#125;int main()&#123; FILE* fpr = fopen(\"input_2016.txt\", \"r\"); FILE* fpw = fopen(\"output_2016.txt\", \"w\"); int i; Word* words; char buf[20]; int count = 0; // 统计该文件中共有多少单词 while(fscanf(fpr, \"%s\", buf) != EOF)&#123; count++; &#125; // 申请空间 words = (Word*)malloc(sizeof(Word)*count); rewind(fpr); count = 0; // 按单词读取文件内容，并统计个数 while(fscanf(fpr, \"%s\", buf) != EOF)&#123; // 判断之前的单词中是否有与当前单词相同的 i = find(words, count, buf); if(i == count)&#123; // 复制 strcpy(words[count].str, buf); words[count].freq = 0; count++; &#125; words[i].freq++; &#125; insertion_sort(words, count); // 将频度大于5的单词写入文件并输出 for(i = 0; i &lt; count &amp;&amp; words[i].freq &gt; 5; i++)&#123; fprintf(fpw, \"%s, %d\\n\", words[i].str, words[i].freq); printf(\"%s, %d\\n\", words[i].str, words[i].freq); &#125; free(words); fclose(fpr); fclose(fpw);&#125; 欢迎来信交流||指教。","categories":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"}],"tags":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"},{"name":"c语言","slug":"c语言","permalink":"http://zivblog.top/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"苏州大学2015年复试上机题","slug":"苏州大学2015年复试上机题","date":"2019-03-08T02:40:45.000Z","updated":"2020-03-19T11:01:12.739Z","comments":true,"path":"passages/su-zhou-da-xue-2015-nian-fu-shi-shang-ji-ti/","link":"","permalink":"http://zivblog.top/passages/su-zhou-da-xue-2015-nian-fu-shi-shang-ji-ti/","excerpt":"","text":"题目描述 从网页上下载input.dat文件，里面是用二进制编写的，里面放了一堆int型的数，每个数占4字节，每次读取两个，这两个数构成一个坐标。 处于第一象限的坐标为有效点，问其中有多少个有效点。 从键盘输入k和n，从第一问中的有效点中找出距离小于n，距离小于n的点的个数要大于k，将它们以文本格式输出到文件中。 题目分析 文件中的数据用二进制编写，故要用fread()读取 读取时每两个点做成一个坐标 要定义结构体，用于存储坐标点 要动态申请空间，不能使用大数组 12345678判断整数数组大小fseek(fp, 0, SEEK_END); // 文件标记指针指向文末total = ftell(fp); // 获取文件标记指针位置，即文件的位数count = total / sizeof(int); // 计算整数个数coord_count = count / 2; // 计算坐标点个数num = (int*)malloc(sizeof(int)*count); // 为整数数组申请空间xy = (Coordinate*)malloc(sizeof(Coordinate)* coord_count); // 为坐标数组申请空间 代码结构 struct Coordinate： 坐标点结构体 double distance(const Coordinate* a, const Coordinate* b)： 计算传入的两点之间的距离 void swap(Coordinate* a, Coordinate* b)： 交换传入的两点的位置 int comapre(const Coordinate* a, const Coordinate *b)： 比较传入的两点与指定点之间的距离 void selection_sort(Coordinate *ptr, int begin, int end)： 根据各点与指定点之间的距离进行排序 void display(Coordinate *ptr, int count) 输出传入的坐标数组 void make_data()： 生成随机数据 int main()： 读取文件，生成整数数组和坐标数组 遍历，判断有效点并计数 根据输入的k和n找出符合的坐标点，输出并写入文件 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdbool.h&gt;#include&lt;string.h&gt;#include&lt;time.h&gt;typedef struct&#123; int x; int y;&#125;Coordinate;Coordinate point;double distance(const Coordinate *a, const Coordinate *b)&#123; /* 计算两个坐标点的距离 */ int val; val = (a-&gt;x - b-&gt;x)*(a-&gt;x - b-&gt;x) + (a-&gt;y - b-&gt;y)*(a-&gt;y - b-&gt;y); return sqrt((double)val);&#125;void swap(Coordinate* a, Coordinate* b)&#123; /* 交换传入的两个坐标点 */ Coordinate temp = *a; *a = *b; *b = temp;&#125;int compare(const Coordinate* a, const Coordinate* b)&#123; /* 比较传入两个坐标点与指定点之间的距离 */ double dista = distance(a, &amp;point); double distb = distance(b, &amp;point); if(dista &gt; distb) return 1; if(dista &lt; distb) return -1; if(dista == distb) return 0;&#125;void selection_sort(Coordinate *ptr, int begin, int end)&#123; /* 根据距离选择排序 */ int i, j; for(i = begin; i &lt; end; i++)&#123; for(j = i+1; j &lt; end; j++)&#123; if(compare(&amp;ptr[i], &amp;ptr[j]) &gt; 0) swap(&amp;ptr[i], &amp;ptr[j]); &#125; &#125;&#125;void make_data()&#123; /* 生成随机数据 */ FILE* fp; int *num; int i; fp = fopen(\"org_2015.dat\", \"wb\"); num = (int*)malloc(sizeof(int) * 128); srand(time(NULL)); for(i = 0; i &lt; 128; i++) num[i] = rand() % 128 - 64; // 二进制方式写入文件 fwrite(num, sizeof(int), 128, fp); free(num); fclose(fp);&#125;void display(Coordinate* ptr, int count)&#123; /* 输出传入的坐标点数组 */ int i; for(i = 0; i &lt; count; i++) printf(\"(%2d, %2d) \", ptr[i].x, ptr[i].y); printf(\"\\n\");&#125;int main()&#123; FILE* fp; Coordinate* xy; int* num; int i; int count, coord_count; //生成数据文件 make_data(); fp = fopen(\"org_2015.dat\", \"rb\"); //申请空间 fseek(fp, 0, SEEK_END); count = ftell(fp) / sizeof(int); coord_count = count / 2; num = (int*)malloc(sizeof(int)*count); xy = (Coordinate*)malloc(sizeof(Coordinate)* coord_count); rewind(fp); // 读取文件 fread(num, sizeof(int), count, fp); fclose(fp); // 有效点计数和存储 int valid = 0; fp = fopen(\"output_2015.txt\", \"w\"); for(i = 0; i &lt; count; i += 2)&#123; if(num[i] &gt; 0 &amp;&amp; num[i+1] &gt; 0)&#123; xy[valid].x = num[i]; xy[valid].y = num[i+1]; valid++; &#125; &#125; printf(\"valid points:\\n\"); display(xy, valid); printf(\"total: %d\\n\", valid); int k, n, pivot; // 获取k，n的值 printf(\"k = \"); scanf(\"%d\", &amp;k); printf(\"n = \"); scanf(\"%d\", &amp;n); pivot = 0; // 遍历有效点 while(pivot &lt; valid)&#123; // 挨个点判断 point.x = xy[pivot].x; point.y = xy[pivot].y; pivot ++; // 根据与point点的距离将xy排序 selection_sort(xy, pivot, valid); printf(\"the points with a distance of less than %d to (%2d, %2d) are:\\n\", n, point.x, point.y); fprintf(fp, \"the points with a distance of less than %d to (%2d, %2d) are:\\n\", n, point.x, point.y); // 到指定点距离至少为n，且距离至少为n的点不少于k的指定点 // 若排序后的xy中第k个点到指定点距离仍小于n，则遍历输出 int i = 0; int j = 0; // 统计符合条件的点的个数 while(i &lt; valid &amp;&amp; distance(&amp;xy[i], &amp;point) &lt; (double)n)&#123; i++; &#125; // 输出 if(i &gt; k)&#123; while(j &lt;= i)&#123; printf(\"(%2d, %2d) %7.2f\\n\", xy[j].x, xy[j].y, distance(&amp;xy[j], &amp;point)); fprintf(fp, \"(%2d, %2d) %7.2f\\n\", xy[j].x, xy[j].y, distance(&amp;xy[j], &amp;point)); j ++; &#125; &#125; &#125;&#125; 欢迎来信交流||指教。","categories":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"}],"tags":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"},{"name":"c语言","slug":"c语言","permalink":"http://zivblog.top/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"Pytorch更新与安装","slug":"Pytorch更新与安装","date":"2019-03-07T08:19:06.000Z","updated":"2020-07-06T05:39:59.079Z","comments":true,"path":"passages/pytorch-geng-xin-yu-an-zhuang/","link":"","permalink":"http://zivblog.top/passages/pytorch-geng-xin-yu-an-zhuang/","excerpt":"pytorch 更新与卸载","text":"pytorch 更新与卸载 写在前面 本文讲解的是pytorch 更新与卸载 使用pip和conda进行操作 Pytorch更新 使用pip更新 12345# 列举可更新的包pip list --otdated --format=legacy# 更新pip install --upgrade pytorch torchvision 使用conda更新 1234# 添加源服务器conda config --add channels soumith#更新conda update pytorch torchvision Pytorch卸载 使用pip卸载 1pip uninstall torch 使用conda卸载 123conda uninstall pytorchconda uninstall libtorch 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"工具配置","slug":"工具配置","permalink":"http://zivblog.top/categories/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://zivblog.top/tags/Tools/"}]},{"title":"Leetcode之两数相加","slug":"Leetcode之两数相加","date":"2019-03-06T13:41:16.000Z","updated":"2020-07-06T05:21:18.611Z","comments":true,"path":"passages/leetcode-zhi-liang-shu-xiang-jia/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-liang-shu-xiang-jia/","excerpt":"Add Two Nums","text":"Add Two Nums 题目描述 题目详情见：两数相加 题目难度：中等 相关标签：链表，数学 思路 很遗憾，不能将链表中的元素读出来形成整数再相加，这样会内存泄漏 只能按照作者的思路，按位相加，计算本位的结果和进位的值 要注意每一位的结果都应该是整数，不是浮点数 python中//是取整除操作，向下取整 代码一是笔者实现的，其中有些地方不够简练，没有体现python的简洁的特点 代码二是leetcode评论区的大神实现的，思路与笔者相同，不过代码看起来更简练 代码一1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def addTwoNumbers(self, l1, l2): \"\"\" :type l1 ListNode :type l2 ListNode :rtype: ListNode \"\"\" # 结果链表 re = ListNode(0); # 结果列表工作指针 r = re # 进位 carry = 0; while(l1 or l2): # 读取该位的数据 if l1: x = l1.val else: x = 0 if l2: y = l2.val else: y = 0 # 计算 s = carry + x + y # 计算进位和结果 carry = s // 10 #取整除 r.next = ListNode(s%10) r = r.next # 原链表的指针后移 if(l1 != None): l1 = l1.next if(l2 != None): l2 = l2.next if(carry &gt; 0): r.next = ListNode(1) return re.next 代码二12345678910111213141516171819202122class Solution: def addTwoNumbers(self, l1, l2): \"\"\" :type l1: ListNode :type l2: ListNode :rtype: ListNode \"\"\" re = ListNode(0) r=re carry=0 while(l1 or l2): x= l1.val if l1 else 0 y= l2.val if l2 else 0 s=carry+x+y carry=s//10 r.next=ListNode(s%10) r=r.next if(l1!=None):l1=l1.next if(l2!=None):l2=l2.next if(carry&gt;0): r.next=ListNode(1) return re.next 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"苏州大学2014年复试上机题","slug":"苏州大学2014年复试上机题","date":"2019-03-06T12:36:35.000Z","updated":"2020-03-04T07:11:48.924Z","comments":true,"path":"passages/su-zhou-da-xue-2014-nian-fu-shi-shang-ji-ti/","link":"","permalink":"http://zivblog.top/passages/su-zhou-da-xue-2014-nian-fu-shi-shang-ji-ti/","excerpt":"","text":"题目描述 从网页上下载input.dat文件，这里面是用二进制编写的，里面放了一堆int类型的数，每个数占4个字节，每次读取两个，这两个数构成一个坐标。 规定处以第一象限的数是有效点（x &gt; 0&amp;&amp;y &gt; 0）,问共有 多少个有效点。 现用户从键盘输入一个左边和数字k，输出k个离该点最近的点的坐标和每个坐标到该点的距离，写入output.txt中。 题目分析 文件使用二进制编写，读取的时候要使用fread(buffer, size, count, fp)函数。 定义坐标点结构体，用该结构体定义坐标点数组。 定义计算输入点到各个点的距离的函数，判断距离是否符合条件，符合者输出。 代码结构1234567891011121314151617181920struct Coordinate) # 坐标点的结构 double distance(const Coordinate* a, const Coordinate* b) # 计算两个点之间的距离void swap(Coordinate* a, Coordinate* b) # 交换传入的两个坐标int compare(const Coordinate* a, const Coordinate* b) # 比较传入的两个坐标点与指定坐标点距离的大小void selection_sort(Coordinate *ptr, int begin, int end) # 根据与传入点的距离排序void display(Coordinate* ptr, int count) # 输出传入的坐标点void make_data() # 生成随机数据int main() 生成数据 计算文件中有多少整数，多少坐标点 根据整数个数和坐标点个数申请空间 统计合法点个数 筛选距指定坐标点最近的k个坐标点 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdbool.h&gt;#include&lt;string.h&gt;#include&lt;time.h&gt;typedef struct&#123; int x; int y;&#125;Coordinate;Coordinate point;double distance(const Coordinate* a, const Coordinate* b)&#123; /* 计算两个点之间的距离 */ int val = (a-&gt;x - b-&gt;x) * (a-&gt;x - b-&gt;x) + (a-&gt;y - b-&gt;y) * (a-&gt;y - b-&gt;y); return sqrt((double) val);&#125;void swap(Coordinate* a, Coordinate* b)&#123; /* 交换传入的两个坐标 */ Coordinate temp = *a; *a = *b; *b = temp;&#125;int compare(const Coordinate* a, const Coordinate* b)&#123; /* 比较两个传入的点与指定点的距离 */ double dista = distance(a, &amp;point); double distb = distance(b, &amp;point); if(dista &lt; distb) return -1; if(dista &gt; distb) return 1; else return 0;&#125;void selection_sort(Coordinate* ptr, int begin, int end)&#123; /* 选择排序 */ int i, j; for(i = begin; i &lt; end; i++)&#123; for(j = i+1; j &lt; end; j++)&#123; if(compare(&amp;ptr[i], &amp;ptr[j])) swap(&amp;ptr[i], &amp;ptr[j]); &#125; &#125;&#125;void display(Coordinate* ptr, int count)&#123; /* 输出传入的坐标数组 */ int i; for(i = 0; i &lt; count; i++) printf(\"(%2d, %2d) \", ptr[i].x, ptr[i].y); printf(\"\\n\");&#125;void make_date()&#123; /* 生成数据 */ FILE *fp = fopen(\"org_2014.dat\", \"wb\"); int *num; int i; // 大小为128的数组 num = (int*)malloc(sizeof(int)*128); // 初始化随机种子 srand(time(NULL)); for(i = 0; i &lt; 128; i++) num[i] = rand()%128 - 64; // 以二进制的方式读取数据 fwrite(num, sizeof(int), 128, fp); // 释放空间 free(num); fclose(fp);&#125;int main()&#123; FILE* fp; Coordinate* xy; int *num; int count, coord_count; int i; // 生成随机数据 make_date(); // 读取数据 fp = fopen(\"org_2014.dat\", \"rb\"); // 求文件有多少整数 // 使文件指针指向文件结尾 fseek(fp, 0, SEEK_END); // 获取当前文件指针位置相对于文件首的偏移字节数 count = ftell(fp) / sizeof(int); // 坐标点个数 coord_count = count / 2; // 根据坐标点个数申请内存空间 num = (int*)malloc(sizeof(int)*count); xy = (Coordinate*)malloc(sizeof(Coordinate) * coord_count); // 文件指针回到文件首 rewind(fp); // 二进制方式按四个字节为一个数读取 fread(num, sizeof(int), count, fp); fclose(fp); // 输出读取的结果 for(i = 0; i &lt; count; i+=2) printf(\"(%2d, %2d) \\n\", num[i], num[i+1]); // 统计合法坐标的个数 int valid = 0; fp = fopen(\"output_2014.txt\", \"w\"); for(i = 0; i &lt; count; i += 2)&#123; if(num[i] &gt; 0 &amp;&amp; num[i + 1] &gt; 0)&#123; xy[valid].x = num[i]; xy[valid].y = num[i + 1]; valid++; &#125; &#125; // 输出合法坐标 printf(\"valid points:\\n\"); display(xy, valid); printf(\"total: %d\\n\", valid); // KNN // 找离指定坐标最近的k个坐标点 int k; printf(\"Coordinate: \"); scanf(\"%d %d\", &amp;point.x, &amp;point.y); printf(\"k = \"); scanf(\"%d\", &amp;k); selection_sort(xy, 0, valid); printf(\"the nearest %d points to (%d, %d) are:\\n\", k, point.x, point.y); for(i = 0; i &lt; k; i++)&#123; printf(\"(%2d, %2d) %7.2f\\n\", xy[i].x, xy[i].y, distance(&amp;xy[i], &amp;point)); fprintf(fp, \"(%2d, %2d) %7.2f\\n\", xy[i].x, xy[i].y, distance(&amp;xy[i], &amp;point)); &#125; fclose(fp);&#125; 欢迎来信交流||指教。","categories":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"}],"tags":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"},{"name":"c语言","slug":"c语言","permalink":"http://zivblog.top/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"Leetcode之两数之和","slug":"Leetcode之两数之和","date":"2019-03-05T12:29:59.000Z","updated":"2020-03-04T06:27:15.269Z","comments":true,"path":"passages/leetcode-zhi-liang-shu-zhi-he/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-liang-shu-zhi-he/","excerpt":"leetcode之twoSum","text":"leetcode之twoSum 题目描述 题目详情见：两数之和 题目难度：简单 相关标签：数组、哈希表 思路 先说题目要求，不能重复利用数组中的相同元素，所以想使用双层循环的同学在内层循环中不能再次访问外层循环正在访问的元素 问题解决的关键在于，计算当前值与指定target的差，并快速判断差是否在给定的数组中（这样，我们自然而然的就想到了python中的字典）。实现见代码一。 另一种思路是使用首尾递进查找：需要列表是有序的（假设为升序）。首先将首尾元素加起来，若大于target，则tail–；若小于target，则head–。实现见代码二 代码一12345678910111213141516171819class Solution: def twoSum(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: List[int] \"\"\" hashmap = &#123;&#125; for index, num in enumerate(nums): another_num = target - num; if another_num in hashmap: return [hashmap[another_num], index] hashmap[num] = index return None # 说明“”“ enumerate()：用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在for循环当中。”“” 代码二123456789101112131415161718192021222324252627class Solution: def twoSum(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: List[int] \"\"\" sorted_id = sorted(range(len(nums)), key=lambda k: nums[k]) head = 0 tail = len(nums) - 1 sum_result = nums[sorted_id[head]] + nums[sorted_id[tail]] while sum_result != target: if sum_result &gt; target: tail -= 1 elif sum_result &lt; target: head += 1 sum_result = nums[sorted_id[head]] + nums[sorted_id[tail]] return [sorted_id[head], sorted_id[tail]] # 说明\"\"\"sorted(iterable, key=None, reverse=False)：对传入的列表进行排序操作，返回的是一个新的列表，不对原列表进行操作；默认升序sort()：在原列表上操作\"\"\" 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"苏州大学2012年复试上机题","slug":"苏州大学2012年复试上机题","date":"2019-03-04T10:00:00.000Z","updated":"2020-03-04T07:03:16.074Z","comments":true,"path":"passages/su-zhou-da-xue-2012-nian-fu-shi-shang-ji-ti/","link":"","permalink":"http://zivblog.top/passages/su-zhou-da-xue-2012-nian-fu-shi-shang-ji-ti/","excerpt":"","text":"题目描述 从服务器上下载数据文件org.dat，文件以二进制方式存放一系列整数，每个整数占4个字节，从第一个整数开始，每两个整数组成一个坐标点。 规定处于第一象限的坐标点为有效点，统计文件中由多少个点，多少个有效点。 每个有效点与坐标原点构成一个矩形，求最小矩形的面积。 找出符合该条件的点：以该点为原点，其他有效点仍是有效点 对有效点进行分组，每个有效点仅属于一个分组，组内：若对组内所有点的x进行排序，当x1 &gt; x2时，y1 &gt; y2。 题目分析 读取文件，两个整数为一个点，四位为1个整数 判断有效点（第一象限）并得到最小的x和y 对有效点排序，并输出 找合适的有效点：x1 &gt; x2 &amp;&amp; y1 &gt; y2 代码结构12345678910111213141516171819202122232425struct Corrdinate 点的结构体void swap(Coordinate *a, Coordinate *b) 交换传入的两个点 int compare(const Coordinate *lhs, const Coordinate *rhs) 比较两个点，根据其x坐标 void selection_sort(Coordinate *ptr, int begin, int end) 选择排序 void display(Coordinate *ptr, int count) 展示坐标点 void make_data() 生成数据int main() 读取文件，两位读作一个坐标点 得到其中的有效点（第一象限） 排序 最小矩形即最小的x*y 对有效点： 选择排序 x1 &gt; x2 &amp;&amp; y1 &gt; y2 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdbool.h&gt;#include&lt;string.h&gt;#include&lt;time.h&gt;#include&lt;math.h&gt;typedef struct&#123; int x; int y;&#125;Coordinate;void swap(Coordinate *a, Coordinate *b)&#123; /* 交换传入的两个数据 */ Coordinate temp = *a; *a = *b; *b = temp;&#125;int compare(const Coordinate *lhs, const Coordinate *rhs)&#123; /* 比较传入的点 根据x坐标比较 */ if(lhs-&gt;x &lt; rhs-&gt;x) return -1; if(lhs-&gt;x &gt; rhs-&gt;x) return 1; else return 0;&#125;void selection_sort(Coordinate *ptr, int begin, int end)&#123; /* 选择排序 */ int i, j; for(i = begin; i &lt; end; i++) for(j = i+1; j &lt; end; j++) if(compare(&amp;ptr[i], &amp;ptr[j]) &gt; 0) swap(&amp;ptr[i], &amp;ptr[j]);&#125;void display(Coordinate *ptr, int count)&#123; /* 展示坐标点 */ int i; for(i = 0; i &lt; count; i++) printf(\"(%2d, %2d) \", ptr[i].x, ptr[i].y); printf(\"\\n\");&#125;void make_data()&#123; /* 生成数据 */ FILE *fp = fopen(\"org_2012.dat\", \"wb\"); int *num = (int*)malloc(sizeof(int)*128); int i; // 随机数生成其初始化 srand(time(NULL)); for(i = 0; i &lt; 128; i++) num[i] = rand() % 128 - 64; // 二进制方式写入文件 fwrite(num, sizeof(int), 128, fp); free(num); fclose(fp);&#125;int main()&#123; FILE *fp; Coordinate *xy; int *num; int n, count; // 随机生成数据 make_data(); fp = fopen(\"org_2012.dat\", \"rb\"); // 函数设置文件指针stream的位置 fseek(fp, 0, SEEK_END); // ftell(): 得到文件位置指针当前位置相对于文件首的偏移字节数 // 计算有多少个整型数据 count = ftell(fp) / sizeof(int); n = count / 2; num = (int*)malloc(sizeof(int) * count); xy = (Coordinate*)malloc(sizeof(Coordinate)*n); // 将文件指针重置 rewind(fp); // 二进制形式兑取文件 fread(num, sizeof(int), count, fp); fclose(fp); int k = 0, j, i; // RAND_MAX：rand返回的最大值 int minx = RAND_MAX; int miny = RAND_MAX; // 读取文件内容，两个一组 for(i = 0; i &lt; count; i += 2)&#123; if(num[i] &gt; 0 &amp;&amp; num[i + 1] &gt; 0)&#123; xy[k].x = num[i]; xy[k].y = num[i + 1]; // 得到最大值和最小值 if(minx &gt; xy[k].x) minx = xy[k].x; if(miny &gt; xy[k].y) miny = xy[k].y; // 第一象限点的个数 k++; &#125; &#125; // 排序 selection_sort(xy, 0, k); // 输出所有点 printf(\"valid points:\\n\"); display(xy, k); // 点的个数和第一象限的点的个数 printf(\"n - %d k = %d\\n\", n, k); printf(\"min area = %d\\n\", minx * miny); int sorted = 0; // 有效点中的符合条件的点 while(sorted &lt; k)&#123; selection_sort(xy, sorted, k); printf(\"points grouped by (%2d, %2d):\", xy[sorted].x, xy[sorted].y); miny = xy[sorted++].y; for(i = sorted; i &lt; k; i++)&#123; if(xy[i].y &gt;= miny)&#123; miny = xy[i].y; printf(\"(%2d, %2d) \", xy[i].x, xy[i].y); swap(&amp;xy[i], &amp;xy[sorted++]); &#125; &#125; printf(\"\\n\"); &#125;&#125; 欢迎来信交流||指教。","categories":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"}],"tags":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"},{"name":"c语言","slug":"c语言","permalink":"http://zivblog.top/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"苏州大学2010年复试上机题","slug":"苏州大学2010年复试上机题","date":"2019-03-04T06:48:23.000Z","updated":"2020-03-04T07:02:27.798Z","comments":true,"path":"passages/su-zhou-da-xue-2010-nian-fu-shi-shang-ji-ti/","link":"","permalink":"http://zivblog.top/passages/su-zhou-da-xue-2010-nian-fu-shi-shang-ji-ti/","excerpt":"","text":"题目描述 从ftp上下载make.exe和org.dat，运行make.exe，输入准考证后三位生成data.txt，文件为二进制编码。 data.txt中存有2048个整数，其中前n个为非0数，收2048-n个为0，将其读入数组，计算非0数的个数。 选出n个数中的最大数和最小数。 选出n个数中的最大素数。 将n个数从大到小排序，平均分成三段，选出中间一段的最大值和最小值。 题目分析 遍历寻找非0数与0的位置，并记录其索引。 遍历数据，寻找数据中的最大值和最小值以及最大素数。 将数据排序，划分为三段，截取中间一段，读取其最大值和最小值 注意二进制编码的文件要用fread读取. 代码结构12345678910111213141516bool is_prime(int num) 判断传入的数字是否为素数int compare(int a, int b) 比较传入的两个数的大小关系void selection_sort(int *ptr, int count) 对传入的数组进行选择排序 void make_data() 产生随机数据 int main() 读取数据 寻找最大值、最小值、最大素数 划分数据，获取中间一段的最大值、最小值 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdbool.h&gt;#include&lt;string.h&gt;#include&lt;time.h&gt;bool is_prime(int num)&#123; /* 判断传入的数字是否为素数 */ int i; if(num &lt; 2) return false; for(i = 2; i*i &lt;= num; i++)&#123; if(num % i == 0) return false; &#125; return true;&#125;void swap(int *a, int *b)&#123; /* 交换传入的两个数的值 */ int temp = *a; *a = *b; *b = temp;&#125;int compare(int a, int b)&#123; /* 比较传入的两个数的大小关系 */ if(a &lt; b) return -1; else if(a == b) return 0; else return 1;&#125;void selection_sort(int *ptr, int count)&#123; /* 选择排序 */ int i, j; for(i = 0; i &lt; count; i++)&#123; for(j = i + 1; j &lt; count; j++)&#123; if(compare(&amp;ptr[i], &amp;ptr[j]) &gt; 0) swap(&amp;ptr[i], &amp;ptr[j]); &#125; &#125;&#125;void make_data()&#123; // 制造数据,xieru data文件 int i; int num[2048]; FILE *fp = fopen(\"data_2010.txt\", \"wb\"); if(!fp)&#123; printf(\"File opening failed\"); return EXIT_FAILURE; &#125; srand(time(NULL)); for(i = 0; i &lt; 1000; i++)&#123; num[i] = rand() % 4096; &#125; for(i = 1000; i &lt; 2048; i++) num[i] = 0; fwrite(num, sizeof(int), 2048, fp); fclose(fp);&#125;int main()&#123; FILE *fp; int num[2048]; int min = RAND_MAX; int max = 0; int max_prime = 0; int n, i; //制造数据 make_data(); // 读取数据 fp = fopen(\"data_2010.txt\", \"rb\"); if(!fp)&#123; printf(\"File opening failed\"); return EXIT_FAILURE; &#125; fread(num, sizeof(int), 2048, fp); // 判断有多少非0数 for(n = 0; n &lt; 2048; n++)&#123; if(num[n] == 0) break; &#125; printf(\"n = %d\\n\", n); // 找最大值，最小值，最大素数 for(i = 0; i &lt; n; i++)&#123; if(min &gt; num[i]) min = num[i]; if(max &lt; num[i]) max = num[i]; if(is_prime(num[i]) &amp;&amp; num[i] &gt; max_prime) max_prime = num[i]; &#125; printf(\"min = %d,\\nmax = %d,\\nmax_prime = %d\\n\", min, max, max_prime); selection_sort(num, n); // 中间一段的最大值和最小值（降序排列） printf(\"min in mid_seg = %d\\nmax in mid_seg = %d\\n\", num[n/3*2-1],num[n/3]); fclose(fp);&#125; 欢迎来信交流||指教。","categories":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"}],"tags":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"},{"name":"c语言","slug":"c语言","permalink":"http://zivblog.top/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"苏州大学2011年复试上机题","slug":"苏州大学2011年复试上机题","date":"2019-03-04T05:36:49.000Z","updated":"2020-03-04T07:02:51.077Z","comments":true,"path":"passages/su-zhou-da-xue-2011-nian-fu-shi-shang-ji-ti/","link":"","permalink":"http://zivblog.top/passages/su-zhou-da-xue-2011-nian-fu-shi-shang-ji-ti/","excerpt":"","text":"题目描述 该数位于1000~9999之间。 该数是素数。 十位数和个位数所组成的数是素数，百位数和个位数组成的数是素数。 个位数和百位数组成的数是素数，个位数和十位数组成的数是素数。 例：1991，需分别判断1991，91，91，19，19 题目分析 分别取需判断数字的百位，十位，个位数存入一个三维数组中 组成指定数字进行判断 符合条件的输出 代码结构1234567bool is_prime(int num) 判断传入的数字是否是素数void split(int n, int num[]) 获取n的各个位置的数，存储在num中 int main() 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;stdio.h&gt;#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;bool is_prime(int num)&#123; /* 判断传入的数字是否是素数 */ int i; if(num &lt; 2) return false; for(i = 2; i*i &lt; num; i++)&#123; if(num % i == 0) return false; &#125; //printf(\"%d is prime. \\n\", num); return true;&#125;void split(int n, int num[])&#123; /* 拆分数字，分别获取其各个位上的数字 */ int i; for(i = 0; i &lt; 4; i++)&#123; num[i] = n % 10; n = n / 10; &#125;&#125;int main()&#123; int i, j; int num[4]; for(i = 1000; i &lt; 9999; i++)&#123; if(is_prime(i))&#123; // 直接传入num数组，之后就可以访问 split(i, num); // 依次分别为百位和个位，十位和个位，个位和百位，个位和十位 if(is_prime(num[1]*10 + num[0]) &amp;&amp; is_prime(num[2]*10 + num[0]) &amp;&amp; is_prime(num[0]*10 + num[2]) &amp;&amp; is_prime(num[0]*10 + num[1])) printf(\"%d\\n\", i); &#125; &#125;&#125; 欢迎来信交流||指教。","categories":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"}],"tags":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"},{"name":"c语言","slug":"c语言","permalink":"http://zivblog.top/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"matplotlib实践","slug":"matplotlib实践","date":"2019-03-03T14:23:48.000Z","updated":"2019-10-21T03:08:34.000Z","comments":true,"path":"passages/matplotlib-shi-jian/","link":"","permalink":"http://zivblog.top/passages/matplotlib-shi-jian/","excerpt":"折线图&amp;散点图","text":"折线图&amp;散点图 用matplotlib绘制折线图和散点图 更多图的绘制请见这里 使用matplotlib绘制折线图123456789101112131415161718192021222324252627import matplotlib.pyplot as pltinput_value = [1, 2, 3, 4, 5]squares = [1, 4, 9, 16, 25]# 传入squares列表，指定线条粗细为5plt.plot(input_value, squares, linewidth=5)# 设置标题,指定字体为24号plt.title(\"Squares Numbers\", fontsize=24)# 设置x轴和y轴的标题plt.xlabel(\"Value\", fontsize=14)plt.ylabel(\"Squares of Value\", fontsize=14)# 设置刻度标记的大小plt.tick_params(axis='both', labelsize=14)# 打开matplotlib显示器plt.show() 使用matplotlib绘制散点图123456789101112131415161718192021222324252627import matplotlib.pyplot as pltx_values = list(range(1001))y_values = [x**2 for x in x_values]# 绘制散点图，设置点的颜色为(0, 0, 0.8),点的外围颜色为黑色，指定点的大小为40# plt.scatter(x_value, y_value, c=(0, 0, 0.8), edgecolors='black', s=40)# 使用颜色映射plt.scatter(x_values, y_values, c=y_values, cmap=plt.cm.Blues, edgecolors='none', s=40)# 设置标题并给坐标轴加上标签plt.title(\"Square Number\", fontsize=24)plt.xlabel(\"Value\", fontsize=14)plt.ylabel(\"Square of Value\", fontsize=24)# 设置刻度标记的大小plt.tick_params(axis='both', which='major', labelsize=14)# 自动保存图表plt.savefig('squares_plot.png', bbox_inches='tight')plt.show() 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://zivblog.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://zivblog.top/tags/Python/"}]},{"title":"Python随机漫步","slug":"Python随机漫步","date":"2019-03-03T14:20:11.000Z","updated":"2019-10-21T03:08:52.000Z","comments":true,"path":"passages/python-sui-ji-man-bu/","link":"","permalink":"http://zivblog.top/passages/python-sui-ji-man-bu/","excerpt":"随机漫步：每一步都是随机决策","text":"随机漫步：每一步都是随机决策 所谓随机漫步，每次行走都完全是随机的，没有明确的方向，结果是由一系列随机决策决定的， 例如：漂浮在水滴上的花粉因不断受到水分子的挤压而在水面上的移动 randomwalk.py123456789101112131415161718192021222324252627282930313233343536373839404142from random import choiceclass RandomWalk(): ''' 生成随机漫步数据的类 ''' def __init__(self, num_points=5000): # 初始化随机漫步属性 self.num_points = num_points # 所有随机漫步都始于(0,0) self.x_values = [0] self.y_values = [0] def fill_walk(self): # 计算随机漫步包含的所有点 # 不断漫步，直至达到列表的指定长度 while len(self.x_values) &lt; self.num_points: # 决定前进方向以及沿这个方向上的距离 # 方向在左：1，右：-1上选择 x_direction = choice([1, -1]) # 距离在1~4中间选择 x_distance = choice([0, 1, 2, 3, 4]) x_step = x_direction * x_distance y_direction = choice([1, -1]) y_distance = choice([0, 1, 2, 3, 4]) y_step = y_direction * y_distance # 拒绝原地踏步 if x_step == 0 and y_step == 0: continue # 计算下一个点的x和y值 next_x = self.x_values[-1] + x_step next_y = self.y_values[-1] + y_step # 将计算得到的下一个点的值添加到列表中 self.x_values.append(next_x) self.y_values.append(next_y) rw_visual.py12345678910111213141516171819202122232425262728293031import matplotlib.pyplot as pltfrom randomwalk import RandomWalknumber = 0# 不断模拟随机漫步while True: rw = RandomWalk(50000) rw.fill_walk() # 设置绘图窗口大小 plt.figure(dpi=128, figsize=(10, 6)) point_numbers = list(range(rw.num_points)) plt.title(\"No.\" + str(number) + \" RandomWalk\") plt.scatter(rw.x_values, rw.y_values,c=point_numbers,cmap=plt.cm.Blues, edgecolors='none', s=1) # 突出起点和终点 plt.scatter(0, 0, c='green', edgecolors='none', s=100) plt.scatter(rw.x_values[-1], rw.y_values[-1], c='red', edgecolors='none', s=100) # 隐藏坐标轴 plt.axes().get_xaxis().set_visible(False) plt.axes().get_yaxis().set_visible(False) plt.show() keep_running = input(\"Make another walk ? (y/n)\") if keep_running == 'n': break 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://zivblog.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://zivblog.top/tags/Python/"}]},{"title":"Python函数的几点注意","slug":"Python函数的几点注意","date":"2019-03-03T13:49:23.000Z","updated":"2019-04-01T13:15:12.000Z","comments":true,"path":"passages/python-han-shu-de-ji-dian-zhu-yi/","link":"","permalink":"http://zivblog.top/passages/python-han-shu-de-ji-dian-zhu-yi/","excerpt":"函数定义及传参的几点注意《Python编程从入门到精通》笔记","text":"函数定义及传参的几点注意《Python编程从入门到精通》笔记 函数的定义12345# 使用关键字'def'标识,函数体内的语句都要至少比函数名一个缩进def greet(): print(\"hello world\")greet() 实参和形参12345678# 调用时传入的参数时实参，定义时的参数时形参# 下面的username是形参，而tom是实参def greet(username): print(\"hello\" + username)greet(\"tom\") 几种传参方式1234567891011121314151617181920212223242526#位置实参： 即基于顺序的参数传递，传递参数时实参的顺序必须与形参的顺序完全一致def greet(username, age): print(username + \" is \"+ str(age) + \"years old\")greet(\"tom\", 17)# 关键字实参： 即传递时传递的是名称-值对（不同于键值对，键值对的键必须时字符串），直接在传参时将名称和值关联起来了，也就不需要顺序完全一致了def greet(username, age): print(username + \" is \" + str(age) + \"years old\")greet(username=\"tom\", age=12)#默认值： 即在形参处设置默认值，当调用时未传入该形参对应的参数时使用默认值def greet(username=\"tom\", age): print(username + \" is \" + str(age) + \"years old\") greet(age=12) 返回值 返回值可以是字符串，数字，字典，列表等 传递列表和字典123456789101112131415161718# 传入列表def greet(*username, age): for name in username: print(name + \" is \" + str(age) + \"years old\")username = ['bob', 'cindy', 'flank']greet(username, 12)# 传入字典def greet(**message): for name,age in message.items(): print(name + \" is \"+ str(age) + \"years old\")message = &#123;'bob':12, 'cindy':13, 'flank':14&#125;greet(message) 形参设置成列表可以实现传入任意数量的参数的功能 形参设置成字典可以实现传入任意数量的名称-值对的功能 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://zivblog.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://zivblog.top/tags/Python/"}]},{"title":"Python用户输入及while","slug":"Python用户输入及while","date":"2019-03-03T13:39:36.000Z","updated":"2019-04-01T13:15:42.000Z","comments":true,"path":"passages/python-yong-hu-shu-ru-ji-while/","link":"","permalink":"http://zivblog.top/passages/python-yong-hu-shu-ru-ji-while/","excerpt":"while及编程语言 《Python编程从入门到精通》笔记","text":"while及编程语言 《Python编程从入门到精通》笔记 用户输入1234# 获取用户输入message = input(\"Please input something:\")print(message) while循环的使用123456789101112131415161718192021222324252627# while循环num = 0sum = 0while num &lt; 5: sum = sum + num num = num + 1print(sum)# 用户选择何时退出mess = \"\" #必须事先定义while mess != \"quit\": mess = input(\"Please input something1:\\n\") if mess != \"quit\": print(mess)# 使用标志active = Truewhile active: mess = input(\"Please input something2:\\n\") if mess == \"quit\": active = False else: print(mess) break &amp; continue12345678910111213141516171819202122# 循环中使用break跳出循环mess = \"\"while True: mess = input() if mess == \"quit\": break else: print(mess)# 循环中使用continue直接跳到下一次循环num = 0while num &lt; 10: num = num + 1 # 跳过偶数 if num % 2 == 0: continue print(num) while循环的一些应用12345678910111213141516171819202122232425262728293031323334353637383940# 列表间元素的移动unfirmed_name = ['alice','amy','lili']firmed_name = []while unfirmed_name: username = unfirmed_name.pop() print(\"Verifying name :\" + username.title()) firmed_name.append(username)print(\"\\nThe following name is confirmed:\")while firmed_name: print(firmed_name.pop())# 删除列表中的多个相同的元素animals = ['dog','cat','pig','chicken','cat']while 'cat' in animals: animals.remove('cat') #remove()只能每次删除第一个符合要求的元素 print('Removed a cat')# 用输入填充字典responses = &#123;&#125;name = input(\"What's your name ?\\n\")responses['name'] = nameage = input(\"what's your age ?\\n\")responses['age'] = ageprint(responses['name'].title() + \"'s age is \" + responses['age']) 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://zivblog.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://zivblog.top/tags/Python/"}]},{"title":"Python字典操作","slug":"Python字典操作","date":"2019-03-03T13:31:10.000Z","updated":"2019-04-01T13:15:26.000Z","comments":true,"path":"passages/python-zi-dian-cao-zuo/","link":"","permalink":"http://zivblog.top/passages/python-zi-dian-cao-zuo/","excerpt":"Python字典操作 《Python编程从入门到精通》笔记","text":"Python字典操作 《Python编程从入门到精通》笔记 创建字典1234#字典由'&#123;&#125;'标识，其中的元素是键值对# 键必须是字符串，值可以是任何类型dic = &#123;\"name\":\"ziv\", \"age\":22&#125; 字典的操作1234567891011# 访问字典的值print(dic['name'])# 修改值dic[\"age\"] = 21# 添加键值对dic[\"sex\"] = \"male\"# 删除键值对del dic[\"sex\"] 遍历字典1234567891011121314151617# 键值同时遍历for key, value in dic.items(): print(key+\":\"+value)# 仅遍历字典的键for key in dic.keys(): print(key) # 仅遍历字典的值for value in dic.values(): print(value)# 按排序顺序遍历字典的键for value in sorted(dic.values()): print(value) 嵌套123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# 创建30个外星人字典：列表中嵌套字典aliens = []for alien_num in range(1,31): alien = &#123;'color':'green', 'age':'14', 'point':'5', 'number':alien_num&#125;aliens.append(alien)# 修改前3个，用到切片for alien in aliens[:3]: if alien['color'] == 'green': alien['color'] = 'blue' alien['age'] = '20' alien['point'] = '10'for alien in aliens: print(alien)# 披萨店的点餐：字典中嵌套列表pizza = &#123; 'crust':'thick', 'toppings':['mushrooms', 'extra cheese']&#125;# 仅访问其中的列表for topping in pizza['toppings']: print(topping)# 网站用户登记：字典中嵌套字典users = &#123; 'aeinstein': &#123; 'first': 'albert', 'last': 'einstein', 'location': 'princeton', &#125;, 'mcurie': &#123; 'first': 'marie', 'last': 'curie', 'location': 'paris', &#125;,&#125;for username, user_info in users.items(): print(\"\\nUsername: \" + username) full_name = user_info['first'] + \" \" + user_info['last'] location = user_info['location'] print(\"\\tFull name: \" + full_name.title()) print(\"\\tLocation: \" + location.title()) 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://zivblog.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://zivblog.top/tags/Python/"}]},{"title":"Python条件语句","slug":"Python条件语句","date":"2019-03-03T13:21:06.000Z","updated":"2019-04-01T13:15:36.000Z","comments":true,"path":"passages/python-tiao-jian-yu-ju/","link":"","permalink":"http://zivblog.top/passages/python-tiao-jian-yu-ju/","excerpt":"Python条件语句 《Python编程从入门到精通》笔记","text":"Python条件语句 《Python编程从入门到精通》笔记 if判断相等12345678910111213# 数字if 1 == 2 print(\"1==2\")else: print(\"1!=2\")# 字符串if \"asd\" == \"zxc\": print(True)else: print(False)# 若要忽略大小写判断字符串是否相等，可以通过将两个字符串同时转换为小写之后再判断：lower()函数 if判不等123456# 判不等使用!=，格式与判等相同if 1 != 2: print(\"1 != 2\")else: print(\"1 == 2\") if-elif-else结构12345678cars = (\"audi\", \"bwm\", \"loslis\")if car[1] == \"audi\": print(\"1\")elif car[2] == \"bwm\": print(\"2\")else: print(\"3\") 检查元素是否在列表中123456789cars = [\"audi\", \"bwm\", \"loslis\"]if \"audi\" in cars: print(\"audi is in cars\")if \"audi\" not in cars: print(\"audi is not in cars\") 布尔表达式12345# 布尔表达是只有两个值：True和False，且两者首字母必须要大写bool_ = Truebool__ = False 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://zivblog.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://zivblog.top/tags/Python/"}]},{"title":"Python列表（List）操作","slug":"Python列表（List）操作","date":"2019-03-03T12:44:53.000Z","updated":"2019-04-01T13:15:18.000Z","comments":true,"path":"passages/python-lie-biao-list-cao-zuo/","link":"","permalink":"http://zivblog.top/passages/python-lie-biao-list-cao-zuo/","excerpt":"python、List 《Python编程从入门到精通》笔记","text":"python、List 《Python编程从入门到精通》笔记 列表的定义1message = [\"hello\",\"this\",\"is\",\"a\",\"demo\"] 访问及修改列表12345# 直接通过索引访问print(message[0])# 直接对要修改位置的元素赋值message[2] = \"change\" 列表的插入123456789# 在列表末尾插入message.append(\"append\")# 按指定索引插入message.insert(0,\"insert\")# 指定索引位置若有元素，则该元素及其后续元素顺序后移# 指定缩影位置若超过原有索引的范围，则一律添加到列表末尾 删除元素12345678910# 用del 删除指定位置的元素del message[2]# 用pop()弹出末尾元素并使用pop = message.pop()print(pop)# 用remove()删除指定值的元素message.remove(\"this\") 排序列表1234567891011#用sort()对列表进行永久性排序message.sort()# 用sorted()对列表进行临时性排序print(message.sorted())# 用reverse()将列表倒置message.reserve()# 用len()获取列表长度print(len(message)) 列表切片12345678910111213message = [\"hello\", \"this\", \"is\", \"a\", \"demo\"]# 指定起始和结束位置mess1 = message[1:2]# 不指定起始位置，默认从列表头开始mess2 = message[:3]# 不指定结束位置，默认从到列表尾mess3 = message[1:]# 指定倒数几个mess4 = message[-2:] 复制列表1234567# 复制列表看似有两种方式，实则真正复制了列表的只有一种。下面第一种方式是创建了两个相同的列表，列表之间的操作相互独立，不会影响到另一方；第二种方式只是将两个变量指向同一个列表，其实质还是一个列表，两者的操作都会体现在同一个列表上# 通过切片复制列表(一个包含所有元素的切片)copy_message = message[:]# 通过赋值复制列表message1 = message 元组12345678910111213# 元组实际上可以理解为布允许改变的列表；列表通过'[]'标识，元组通过'()'标识；虽然元组不允许修改，但允许赋值：可以理解为元组不允许改变单个元素，但是可以整体赋值# 元组的定义cars = (\"bwm\", \"audi\", \"toyota\", \"loslis\")# 元组的遍历for car in cars: print(car)# 元组不允许切片# 元组的赋值（必须一次修改所有的值）cars = (\"1\", \"2\", \"3\", \"4\") 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://zivblog.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://zivblog.top/tags/Python/"}]},{"title":"Python字符串操作","slug":"Python字符串操作","date":"2019-03-03T12:39:13.000Z","updated":"2019-04-01T13:15:32.000Z","comments":true,"path":"passages/python-zi-fu-chuan-cao-zuo/","link":"","permalink":"http://zivblog.top/passages/python-zi-fu-chuan-cao-zuo/","excerpt":"Python字符串操作 《Python编程从入门到精通》笔记","text":"Python字符串操作 《Python编程从入门到精通》笔记 格式化输出1print(\"this is a &#123;&#125;\".format(\"demo\")) 大小写转换12345title() 将字符串中每个单词的首字母改为大写upper() 将字符串全部字母改为大写lower() 将字符串所有字母改为小写 空格删除12345strip() 同时删除字符串首部和尾部的空格lstrip() 删除字符串首部的空格rstrip() 删除字符串尾部的空格 转化为字符串1str()将传入的数据转化为对应的字符串 注释 单行注释 注释跟在‘#’后 多行注释 前后各三个‘“’将要注释部分包起来 中文注释 在文件首部加 #coding=utf-8 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://zivblog.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://zivblog.top/tags/Python/"}]},{"title":"Python程序运行时间计算","slug":"Python程序运行时间计算","date":"2019-03-03T12:31:38.000Z","updated":"2019-04-01T13:15:48.000Z","comments":true,"path":"passages/python-cheng-xu-yun-xing-shi-jian-ji-suan/","link":"","permalink":"http://zivblog.top/passages/python-cheng-xu-yun-xing-shi-jian-ji-suan/","excerpt":"Python程序运行时间计算","text":"Python程序运行时间计算 方法1123456789import datetimestarttime = datetime.datetime.now()# long runningendtime = datetime.datetime.now()print (endtime - starttime).seconds 方法 21234567start = time.time()run_fun()end = time.time()print end-start 方法31234567start = time.clock()run_fun()end = time.clock()print end-start 方法1和方法2都包含了其他程序使用CPU的时间，是程序开始到程序结束的运行时间。 方法3算只计算了程序运行的CPU时间 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://zivblog.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://zivblog.top/tags/Python/"}]},{"title":"苏州大学2009年复试编程题","slug":"苏州大学2009年复试编程题","date":"2019-03-03T11:47:29.000Z","updated":"2020-03-04T07:02:05.082Z","comments":true,"path":"passages/su-zhou-da-xue-2009-nian-fu-shi-bian-cheng-ti/","link":"","permalink":"http://zivblog.top/passages/su-zhou-da-xue-2009-nian-fu-shi-bian-cheng-ti/","excerpt":"字符串转数字 排序 分词","text":"字符串转数字 排序 分词 题目描述 用IE浏览器从ftp上下载org.dat，并保存在D盘目录下 此文件中存放了一段文章，其中由若干长度小于15的十进制或八进制的数字，数字之间用“,”隔开，数字内部存在且仅存在空格。 八进制以起始位0作为标识与十进制数区分。 顺序读取这些数字并将它们转变为十进制，排序后输出到文件new.txt，每个数字占一行。 例：_235_,34_2,_043_1,1_3，分别是十进制235，十进制342，八进制342，十进制13，_代表空格。 题目分析 根据分隔符（逗号），将文章分割成单个的字符串（c中的字符串即字符数组） 根据标识将八进制、十进制的字符串转化成十进制的数字 将十进制的数组使用选择排序按升序排序 将数组写入文件中，每个数字一行 解法一代码结构123456789101112131415161. void swap(int *a, int *b): 交换传入的两个数字2. int compare(int a, int b): 比较传入的两个数字的大小3. void selection_sort(int *ptr, int count): 选择排序4. bool is_num(char c): 判断传入的字符是否是数字5. bool valid(char c): 判断传入字符是否合法，数字或空格6. int main(): 打开文件 按分隔符读取数字（按字符串存） 将数字转化成十进制 排序 将排序结果存入文件 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;stdbool.h&gt;void swap(int *a, int *b)&#123; /* 交换传入的两个数字 */ int temp = *a; *a = *b; *b = temp;&#125;int compare(int a, int b)&#123; /* 比较传入的两个数字的大小 前者小返回-1 相等返回0 前者大返回1 */ if(a &lt; b) return -1; else if(a == b) return 0; else&#123; return 1; &#125;&#125;void selection_sort(int *ptr, int count)&#123; /* ptr为数组 count为数组元素个数 使用选择排序对数组中的元素进行升序排序 */ int i, j; for(i = 0; i &lt; count; i++)&#123; for(j = i + 1; j &lt; count; j++)&#123; // 前者比后者大 if(compare(&amp;ptr[i], &amp;ptr[j]) &gt; 0) swap(&amp;ptr[i], &amp;ptr[j]); &#125; &#125;&#125;// 判断传入字符 是否是数字bool is_num(char c)&#123; return c &gt;= '0' &amp;&amp; c &lt;= '9';&#125;// 判断传入的字符是否合法：数字或空格bool valid(char c)&#123; return is_num(c) || c == ' ';&#125;int main()&#123; FILE *fprog = fopen(\"org_2009.dat\", \"r\"); FILE *fpnew = fopen(\"new_2009.txt\", \"w\"); int i; int count = 0; int arr[128]; char c; char num[15]; printf(\"org_2009.dat:\\n\"); while((c = fgetc(fprog)) != EOF)&#123; if(is_num(c))&#123; i = 0; num[i++] = c; /* 读取一个数字 按字符读：空格或数字 只将数字存入num，用'\\0'结束 */ while((c = fgetc(fprog)) != EOF &amp;&amp; valid(c)) if(is_num(c)) num[i++] = c; num[i] = '\\0'; printf(\"%s\\n\", num); /* long int strtol(const char *nptr, char **endptr, int base) 将传入的字符串按base指示转化成long int 可以被转换的合法字符依据base而定，举例来说，当base为2时，合法字符为‘0’，‘1’； base为8时，合法字符为‘0’，‘1’，……‘7’；base为10时，合法字符为‘0’，‘1’，……‘9’； 事实上base指定的是传入字符串的进制，函数会自动转化乘10进制 */ arr[count++] = num[0] == '0' ? strtol(num, NULL, 8) : strtol(num, NULL, 10); &#125; &#125; // 排序 selection_sort(arr, count); // 将排序后的数组写入文件 for(i = 0; i &lt; count; i++) fprintf(fpnew, \"%d\\n\", arr[i]); // 关闭文件 fclose(fprog); fclose(fpnew); // 读取结果文件并输出 fpnew = fopen(\"new_2009.txt\", \"r\"); printf(\"new_2009.txt:\\n\"); while(fgets(num, sizeof(num), fpnew)) printf(\"%s\", num); fclose(fpnew);&#125; 解法二代码结构123456789101112131415void divide(char *a, char digit[][15], int *p) 将传入的字符串（包含整个文章内容）分成单词void sort(char digit[][15], int n) 冒泡排序，升序排序 int convert(char *a) 将字符串单词转化成10进制或八进制，这里可以选择使用strtol方法 int main() 读入文件内容 分词 转化成十进制数字 排序 学如文件 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;math.h&gt;#include&lt;string.h&gt;void divide(char *a, char digit[][15], int *p)&#123; /* 对传入的字符串形式的数组按分隔符进行分词 按逗号分词 去除数字中间的空格 */ int i = 0, j = 0, k = 0; while(a[i] != '\\0')&#123; // 字符非法，跳过 while(a[i] &lt; '0' || a[i] &gt; '9')&#123; if(a[i] == '\\0') break; i++; &#125; if(a[i] == '\\0') break; k = 0; // 读取单词，存到二维数组中 while((a[i] &gt;= '0' &amp;&amp; a[i] &lt;= '9') || (a[i] == ' '))&#123; if(a[i] == ' ')&#123; i++; continue; &#125;else&#123; digit[j][k++] = '\\0'; j++; &#125; &#125; // 单词个数 *p = j; &#125;&#125;void sort(char digit[][15], int n)&#123; /* 冒泡排序 外层控制趟数，内层控制比较次数 升序排列 */ int i, j; char temp[15]; for(i = 0; i &lt; n - 1; i++)&#123; for(j = 0; j &lt; n - i - 1; j++)&#123; if(convert(digit[j]) &gt; convert(digit[j+1]))&#123; strcpy(temp, digit[j]); strcpy(digit[j], digit[j+1]); strcpy(digit[j+1], temp); &#125; &#125; &#125;&#125;int convert(char *a)&#123; /* 讲字符串中的单词转化成十进制整数 */ int number = 0, i = 0; if(a[0] == '0')&#123; // 八进制 i++; while(a[i] != '\\0')&#123; number = 8 * number + a[i++] - '0'; &#125; &#125;else&#123; // 十进制 while(a[i] != '\\0')&#123; number = 10 * number +a[i++] - '0'; &#125; &#125; return number;&#125;int main()&#123; FILE *fp; int i = 0, j = 0; char a[30]; char digit[10][15]; // 打开待处理文件 if((fp = fopen(\"org_2009.dat\", \"r\")) == NULL)&#123; printf(\"cannot open the file\"); exit(0); &#125; // 读取文件，存储到一个字符串中 while(!feof(fp))&#123; a[i++] = fgetc(fp); &#125; a[i - 1] = '\\0'; // 分词 divide(a, digit, &amp;j); printf(\"#%s#\\n\", a); printf(\"%d\\n\", j); fclose(fp); // 输出分词结果 for(i = 0; i &lt; j; i++)&#123; printf(\"#%s#\\n\", digit[i]); &#125; // 排序 sort(digit, j); if((fp = fopen(\"new_200.txt\", \"w\")) == NULL)&#123; printf(\"cannot open the file\"); exit(0); &#125; //输出排序结果并写入文件 for(i = 0; i &lt; j; i++)&#123; printf(\"#%s#\\n\", digit[i]); fprintf(fp, \"%s\\n\", digit[i]); &#125; fclose(fp);&#125; 欢迎来信交流||指教。","categories":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"}],"tags":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"},{"name":"c语言","slug":"c语言","permalink":"http://zivblog.top/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"windows下搭建基于hexo的个人博客","slug":"windows下搭建基于hexo的个人博客","date":"2019-03-03T06:31:29.000Z","updated":"2020-03-04T06:44:16.996Z","comments":true,"path":"passages/windows-xia-da-jian-ji-yu-hexo-de-ge-ren-bo-ke/","link":"","permalink":"http://zivblog.top/passages/windows-xia-da-jian-ji-yu-hexo-de-ge-ren-bo-ke/","excerpt":"Hexo搭建步骤 安装Git 安装Node.js 安装Hexo及项目搭建 Github创建个人仓库 生成ssh添加到Github 将hexo部署到github 个人域名绑定 发布文章 踩坑","text":"Hexo搭建步骤 安装Git 安装Node.js 安装Hexo及项目搭建 Github创建个人仓库 生成ssh添加到Github 将hexo部署到github 个人域名绑定 发布文章 踩坑 1. 安装Git windows用户到这里下载Git并安装 验证Git安装成功 1$ git --version 2. 安装Nodejs windows用户到这里下载并安装 验证Nodejs安装成功 12$ node -v$ npm -v 3. 安装Hexo及项目搭建 输入以下命令安装Hexo并测试是否安装成功： 12345# 安装$ npm install -g hexo-cli# 测试$ hexo -v 创建项目 123$ hexo init ziv_blog$ cd ziv_blog$ npm install 在初始化的时候可能会比较慢，或者有时候会出现连接超时的情况，这时候切换为npm国内源就好了（2019.10.09更新） 1234$ npm install -g cnpm --registry=https://registry.npm.taobao.org# 还可以使用以下命令验证是否切换成功$ npm info express 本地目录 12345678910111213# 查看目录结构$ tree -L 1.├── _config.yml # 网站配置文件├── db.json├── node_modules # 依赖包├── package-lock.json├── package.json # 应用程序信息├── public # 静态站点存放于此├── scaffolds # 模板文件夹，新建文章时会使用此文件夹下的文件作为模板├── source # 存放用户资源的地方├── themes # 主题└── yarn.lock Github搭建个人仓库 注册Github账户，这里 创建仓库（new repository） 仓库名要与你的用户名相同，后面加.github.io。例如：myname.github.io 生成ssh添加到Github 123456789$ git config --global user.name \"your name\"$ git config --global user.email \"your email\"# 核对$ git config user.name$ git config user.email# 创建SSH$ ssh-keygen -t rsa -C \"your email\" 生成的ssh在你的用户目录下的.ssh文件夹中（该文件夹默认隐藏） 其中id_rsa是你的私人密钥，id_rsa.pub是公钥，将公钥上传到Github Github的setting -&gt; SSH key -&gt; new SSH key -&gt; 添加你的公钥（title随便起） 测试Github是否连接成功 1$ ssh -T git@github.com 将hexo部署到github上 将Hexo和Github关联起来，打开config.yml，添加以下内容： 1234deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master 安装deploy-git，便于以后用命令部署 1npm install hexo-deployer-git --save hexo基本操作 123456789$ hexo g # 生成静态站点放在public文件夹中$ hexo s # 本地启动服务，预览，访问localhost:4000$ hexo clean # 清除之前生成的东西$ hexo d # 部署文章$ hexo new 文件名 # 创建新.md文件 文章的标准格式 123456789101112131415---title: 文章标题date: 文章创建日期categories: 文章分类tags: - 文章标签1 - 文章标签2 - ...---在`&lt;!-- more --&gt;`之前编写文章的摘要内容！！！&lt;!-- more --&gt;在`&lt;!-- more --&gt;`之后编写文章的正式内容！！！ 域名绑定与解析 请见另一篇博文。 截断文章，显示摘要123在文章中合适 位置添加&lt;!--more--&gt;注意&lt;!--more--&gt;前的内容为摘要，不会显示在正文中 文章模版 可以修改在博客根目录下的scafflods的post.md文件。 文件中添加图片 请见另一篇博文。 踩坑 npm install 时，长时间停留在fetchMetadata 原因：网络不好 解决方法：更换源： 1npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org&#x2F; 验证： 1npm config get registry yml文件中 每行的初始不能有空格 冒号之后必须有空格 在不同的电脑上管理博客 这里提供一个思路，在github上令创建一个仓库，用于存放源文件，或者在码云上存放 本博客使用的是ad主题，欢迎来信交流。 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"博客相关","slug":"博客相关","permalink":"http://zivblog.top/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://zivblog.top/tags/Tools/"}]},{"title":"ubuntu下搭建spark单机环境","slug":"ubuntu下搭建spark单机环境","date":"2019-03-03T06:17:36.000Z","updated":"2020-03-04T06:42:15.097Z","comments":true,"path":"passages/ubuntu-xia-da-jian-spark-dan-ji-huan-jing/","link":"","permalink":"http://zivblog.top/passages/ubuntu-xia-da-jian-spark-dan-ji-huan-jing/","excerpt":"Java SE Scala spark sbt","text":"Java SE Scala spark sbt 安装配置Java SE 下载Java SE Linux版本，这里。 注意要选择Linux版本，并且根据实际情况选择64 or 32位。 下载jdk-XXXX-linux-XXX.tar.gz，解压到自己制定目录。 1$ tar -zxvf jdk-XXXX-linux-XXX.tar.gz -C /usr/lib/java 配置java环境变量 打开.bashrc并在其尾部添加如下内容： 123456$ nano ~&#x2F;.bashrcexport JAVA_HOME&#x3D;&#x2F;usr&#x2F;lib&#x2F;java&#x2F;jdk1.8.0_131 export JRE_HOME&#x3D;$&#123;JAVA_HOME&#125;&#x2F;jre export CLASSPATH&#x3D;.:$&#123;JAVA_HOME&#125;&#x2F;lib:$&#123;JRE_HOME&#125;&#x2F;lib export PATH&#x3D;$&#123;JAVA_HOME&#125;&#x2F;bin:$&#123;JRE_HOME&#125;&#x2F;bin:$PATH 执行下列命令使环境变量生效，并测试： 1234$ source ~/.bashrc$ java -versionjava version \"XXXX\" 安装配置Scala 下载Scala的压缩文件，这里。 下载scala-2.12.2.tgz后,解压到制定目录： 1$ tar -zxvf scala-2.12.2.tgz -C /opt/scala/ 配置scala环境变量 打开.bashrc，并在其尾部添加如下内容 1234$ nano ~/.bashrcexport SCALA_HOME=/opt/scala/scala-2.12.2 export PATH=$&#123;SCALA_HOME&#125;/bin:$PATH 执行下列命令使环境变量生效，并测试： 1234$ source ~/.bashrc$ scala -versionScala code runner version 2.12.2 安装配置spark 下载spark压缩文件，这里。 下载spark-2.1.1-bin-hadoop2.7.tgz后，解压到指定的目录。 1$ tar -zxvf spark-2.1.1-bin-hadoop2.7.tgz -C /opt/spark/ 配置spark环境变量 打开.bashrc，并在其尾部添加如下内容： 1234$ nano ~/.bashrcexport SPARK_HOME=/opt/spark/spark-2.1.1-bin-hadoop2.7export PATH=$&#123;SPARK_HOME&#125;/bin:$PATH 执行下列命令时环境变量生效并测试： 123$ source ~/.bashrc$ spark-shell 安装配置sbt 下载sbt的压缩文件，这里。 下载sbt-0.13.15.tgz后，解压到指定的目录。 1$ tar -zxvf sbt-0.13.15.tgz -C /opt/scala/sbt/ 配置sbt环境变量 打开.bashrc文件，并在其尾部添加： 1234$ nano ~/.bashrcexport SBT_HOME=/opt/scala/sbtexport PATH=$&#123;SBT_HOME&#125;/bin:$PATH 执行下列命令使环境变量生效： 1$ source ~/.bashrc 创建启动sbt的脚本 1234567$ mkdir /opt/scala/sbt/ $ cd /opt/scala/sbt/ $ touch sbt # 脚本内容如下，注意sbt-launch.jar的位置SBT_OPTS=\"-Xms512M -Xmx1536M -Xss1M -XX:+CMSClassUnloadingEnabled -XX:MaxPermSize=256M\" java $SBT_OPTS -jar /opt/scala/sbt/bin/sbt-launch.jar \"$@\" 检测sbt是否正确安装 1234567$ chmod u+x sbt $ sbt sbt-version[info] 0.13.15# 若报错，使用如下命令查看$ sbt sbtVersion 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"工具配置","slug":"工具配置","permalink":"http://zivblog.top/categories/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://zivblog.top/tags/Tools/"}]},{"title":"静态连接数据数据库实例","slug":"静态连接数据数据库实例","date":"2019-03-02T14:37:03.000Z","updated":"2020-07-06T05:46:14.387Z","comments":true,"path":"passages/jing-tai-lian-jie-shu-ju-shu-ju-ku-shi-li/","link":"","permalink":"http://zivblog.top/passages/jing-tai-lian-jie-shu-ju-shu-ju-ku-shi-li/","excerpt":"数据库静态连接","text":"数据库静态连接 12345678910111213141516171819202122232425262728293031323334import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class DBUtil &#123; private static final String url = \"jdbc:mysql://127.0.0.1:3306/jdbc_db\"; private static final String NAME = \"root\"; private static final String PASS = \"123456\"; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; //加载驱动程序 Class.forName(\"com.mysql.jdbc.Driver\"); //获得数据库连接 Connection conn = DriverManager.getConnection(url, NAME, PASS); //通过数据库的连接操作数据库 Statement stat = conn.createStatement(); ResultSet rs = stat.executeQuery(\"select user_name from jdbc_db_goddess\"); while(rs.next())&#123; System.out.println(rs.getString(\"user_name\")); &#125; &#125;&#125; 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://zivblog.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://zivblog.top/tags/Java/"}]},{"title":"C语言文件操作","slug":"c语言之文件操作","date":"2019-03-02T12:55:49.000Z","updated":"2020-03-04T12:20:39.853Z","comments":true,"path":"passages/c-yu-yan-zhi-wen-jian-cao-zuo/","link":"","permalink":"http://zivblog.top/passages/c-yu-yan-zhi-wen-jian-cao-zuo/","excerpt":"文件分类 文件缓冲区 文件指针 文件的打开与关闭 文件的读写 注意事项","text":"文件分类 文件缓冲区 文件指针 文件的打开与关闭 文件的读写 注意事项 文件分类 ASCII文件：文本文件，每一个字节存放一个字符的ASCII代码 二进制文件：映像文件，相当于存放在内存中数据的映像（内存中数据是以二进制形式存放的） 文件缓冲区 从内存中输出数据必须先送到内存中的换中去，装满缓冲区之后才一起送到磁盘中去 文件指针 由系统声明，取名FILE 12FILE f1;&#96;&#96;&#96; &#x2F;&#x2F;定义结构体变量f1，用于存放一个问价的有关信息 FILE *f1;&#96;&#96;&#96; &#x2F;&#x2F;指向文件类型数据的指针变量，通过文件指针变量能够找到与它关联的文件 文件的打开与关闭 在读写之前必须先打开文件，使用结束后必须手动关闭文件 打开文件使用fopen函数，fopen(文件名, 使用方式); “r”; //读，打开一个已存在的文本文件 “w”; //写，打开一个文本文件 “a”; //向文本文件尾部追加数据 “rb”; //读，打开一个二进制文件 “wb”; //写，打开一个二进制文件 “ab”; //向二进制文件尾部追加数据 “r+”; //读写，打开文本文件 “w+”; //读写，新建文本文件 “a+”; //读写，打开文本文件 “rb+”; //读写，打开二进制文件 “wb+”; //读写，新建二进制文件 “ab+”; //读写，打开二进制文件 // 常规文件打开方式 if(fp=fopen(filename,\"w\") == NULL) { printf(\"cannot ipen this file\"); exit(0); } &lt;!--￼1--&gt; fclose(文件指针); &lt;!--￼2--&gt; fgetc(文件指针); fputc(字符, 文件指针); &lt;!--￼3--&gt; fgets(字符数组, 长度, 文件指针); fputs(字符数组, 文件指针); &lt;!--￼4--&gt; fprintf(文件指针，格式字符串，输出列表); fscanf(文件指针，格式字符串，输入列表); &lt;!--￼5--&gt; fread(buffer, size, count, fp); fwrite(buffer, size, count, fp); &lt;!--￼6--&gt; 随机读写数据文件 文件位置标记：指示接下来要读写的下一个字符的位置 文件位置标记的定位 12345678rewind() # 使文件位置标记重新返回文件头部fseek(fp, 位移量, 起始点) # 改变文件位置标记# 起始点SEEK_SET # 文件开始位置SEEK_CUR # 文件当前位置SEEK_END # 文件末尾位置 文件读写的出错检测 123ferror(fp); # 检测调用输入输出函数是是否出现错误clearerr(); #使文件出错标志和文件结束标志置为0 注意事项 null在c语言中没有预定义，必须使用大写NULL 双引号中的内容是const char，单引号中的内容是char 从控制台读字符串使用%s占位，读字符使用%c占位，读整形数字使用%d占位，读浮点数使用%f占位 使用vs2010编译c语言文件：创建项目，不勾选预编译，源文件文件夹上右键新建项，c++文件；先编译（ctrl+f7），再执行 打开文件后一定要手动关闭 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"}],"tags":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"},{"name":"c语言","slug":"c语言","permalink":"http://zivblog.top/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"苏州大学2005年复试编程题","slug":"苏州大学2005年复试编程题","date":"2019-03-02T12:55:49.000Z","updated":"2020-07-06T05:47:34.828Z","comments":true,"path":"passages/su-zhou-da-xue-2005-nian-fu-shi-bian-cheng-ti/","link":"","permalink":"http://zivblog.top/passages/su-zhou-da-xue-2005-nian-fu-shi-bian-cheng-ti/","excerpt":"将给定数字拆分成若干素数的和","text":"将给定数字拆分成若干素数的和 2005-1题目描述 将给定数字拆分成若干素数的和 问题分析 素数：本身大于1，且除了1和其本身之外没有其他的素数因子。 C99之前的c语言没有bool类型，之后的标准中使用bool类型需要添加头文件stdbool.h。 代码结构12345678910111. int is_prime(int num)： 判断输入的数字是否小于二 循环判断2~$\\sqrt&#123;n&#125;$是否有输入数字的因子2. void splite(int num)： 判断数字是否小于2 判断数字本身是否为素数：输出本身 递归循环判断从n~1开始依次递减判断是否为素数：输出并递归，减去输出的数字3. int main() ： 输入并调用切分函数 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdbool.h&gt;bool is_prime(int num)&#123; /* 判断输入的数字是否为素数 */ // 小于2的不是素数 int i; if(num &lt; 2)&#123; return false; &#125; // 是否有除1和其本身之外的因子 for(i = 2; i*i &lt; num; i++)&#123; if(num % i == 0)&#123; return false; &#125; &#125; return true;&#125;void split(int num)&#123; int i; // 小于2的不是素数 if(num &lt; 2)&#123; return; &#125; // 本身是否为素数 if(is_prime(num))&#123; printf(\"%d\", num); return; &#125; // 递归判断 for(i = num; i &gt; 1; --i)&#123; if(is_prime(i) &amp;&amp; num-i &gt; 1)&#123; printf(\"%d \", i); splite(num - i); return; &#125; &#125;&#125;int main()&#123; int i; while(scanf(\"%d\", &amp;i))&#123; split(i); putchar(10); //输出换行符 &#125; getchar(); return 0;&#125; 2005-2题目描述 从指定文件中读取文件内容 统计文件中各个字母的出现次数 字母顺序按照出现次数升序排列 问题分析 从文件中读取内容 定义结构体Letter，包含两部分：字母，次数 定义长度为26的Letter数组 判断字母大小写，同一个字母的大小写按同一个计数 使用选择排序对按出现次数对Letter数组排序 代码结构123456789101112131415161718192021222324251. Letter结构体： char； n； 2. swap(Letter *a, Letter *b)： 交换传入的两个数据 3. compare(Letter *a, Letter *b)： 比较传入的两个数据 4. selection_sort(Letter *ptr, int count)： 选择排序（升序） 5. is_upper(char c)： 判断字母是否为大写 6. is_lower(char c)： 判断字母是否为小写 7. int main()： 读入文件 初始化Letter数组 统计各个字母次数 选择排序 输出 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdbool.h&gt;typedef struct&#123; char c; //字母 int n; //出现次数&#125;Letter;void swap(Letter *a, Letter *b)&#123; /* 交换传入的两个数据 */ Letter temp = *a; *a = *b; *b = temp;&#125;int compare(Letter *a, Letter *b)&#123; /* 比较两个传入字母出现次数的大小 */ if(a-&gt;n &lt; b-&gt;n) return -1; else if(a-&gt;n &gt; b-&gt;n) return 1; else return 0;&#125;void selection_sort(Letter *ptr, int count)&#123; /* 使用选择排序对传入的数组按升序排序 选择排序：第i趟选择第i小的与第i个位置的元素交换位置 第一层循环控制趟数，第二层循环控制比较 */ int i, j; for(i = 0;i &lt; count; i++)&#123; // 从第i+1个位置与第i个位置的元素比较 for(j = i+1; j &lt; count; j++) // 若前者大于后者 if(compare(&amp;ptr[i], &amp;ptr[j]) &gt; 0) swap(&amp;ptr[i], &amp;ptr[j]); &#125;&#125;// 判断是否为大写字母bool is_upper(char c)&#123;return c&gt;='A' &amp;&amp; c&lt;='Z';&#125;// 判断是否为小写字母bool is_lower(char c)&#123;return c&gt;='a' &amp;&amp; c&lt;='z';&#125;int main()&#123; FILE *fp = fopen(\"2005_2.txt\", \"r\"); Letter letter[26]; char c; int i; // 文件打开失败 if(!fp)&#123; printf(\"file opening failed\"); return EXIT_FAILURE; &#125; // 初试化letter数组 for(i = 0; i &lt; 26; i++)&#123; letter[i].c = i+'a'; letter[i].n = 0; &#125; // 统计字母个数 while((c = fgetc(fp)) != EOF)&#123; if(is_upper(c)) letter[c - 'A'].n ++; if(is_lower(c)) letter[c - 'a'].n++; &#125; // 选择排序 selection_sort(letter, 26); // 输出letter数组 for(i = 0; i &lt; 26; i++)&#123; printf(\"%c: %d\\n\", letter[i].c, letter[i].n); &#125; fclose(fp);&#125; 欢迎来信交流||指教。","categories":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"}],"tags":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"},{"name":"c语言","slug":"c语言","permalink":"http://zivblog.top/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"苏州大学2007年复试编程题","slug":"苏州大学2007年复试编程题","date":"2019-03-02T12:55:49.000Z","updated":"2020-03-04T07:00:56.253Z","comments":true,"path":"passages/su-zhou-da-xue-2007-nian-fu-shi-bian-cheng-ti/","link":"","permalink":"http://zivblog.top/passages/su-zhou-da-xue-2007-nian-fu-shi-bian-cheng-ti/","excerpt":"找出指定范围内符合描述条件的数字并写入文件","text":"找出指定范围内符合描述条件的数字并写入文件 问题描述 找出10~1000之间： 本身是素数 其反数也是素数，例如123的反数是321 将结果写入result文件中 问题分析 判断数字是否为素数 求其反数并判断是否为素数 符合条件的数字写入文件中 代码结构1234567891. bool is_prime(int num)： 判断传入的数字是否为素数2. int reverse(int num)： 求传入数字的反转3. int mian()： 创建文件指针 循环判断数字是否符合条件 格式化输出到文件中 关闭文件 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdbool.h&gt;bool is_prime(int num)&#123; /* 判断传入的数字是否为素数 */ int i; if(num &lt; 2) return false; for(i = 2; i*i &lt; num; i++)&#123; if(num % i == 0) return false; &#125; return true;&#125;int reverse(int num)&#123; /* 将传入的数字反转 */ int rev = 0; while(num &gt; 0)&#123; rev = rev * 10 + num % 10; num /= 10; &#125; return rev;&#125;int main()&#123; FILE *fp = fopen(\"result_2007.txt\", \"w\"); int i; for(i = 10; i &lt;= 1000; i++)&#123; if(is_prime(i) &amp;&amp; is_prime(reverse(i)))&#123; fprintf(fp, \"%d\\n\", i); &#125; &#125; fclose(fp);&#125; 欢迎来信交流||指教。","categories":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"}],"tags":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"},{"name":"c语言","slug":"c语言","permalink":"http://zivblog.top/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"苏州大学2006年复试编程题","slug":"苏州大学2006年复试编程题","date":"2019-03-02T12:55:49.000Z","updated":"2020-03-04T07:00:29.654Z","comments":true,"path":"passages/su-zhou-da-xue-2006-nian-fu-shi-bian-cheng-ti/","link":"","permalink":"http://zivblog.top/passages/su-zhou-da-xue-2006-nian-fu-shi-bian-cheng-ti/","excerpt":"找出100~1000中不含9的素数，将结果输入到result文件中","text":"找出100~1000中不含9的素数，将结果输入到result文件中 问题描述 找出100~1000中不含9的素数，将结果输入到result文件中 问题分析 判断数字是否为素数 在是素数的基础上判断是否含9 写入文件 代码结构123456789101. bool is_prime(int num)： 判断传入的数字是否为素数2. bool is_has9(int num)： 判断传入的数字是否含93. int mian()： 创建文件指针 循环判断100~1000之间的数字是否为素数 是素数的数字是否含9 符合条件的数字写入文件 关闭文件 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdbool.h&gt;bool is_prime(int num)&#123; /* 判断传入的数字是否为素数 */ int i; if(num &lt; 2) return false; for(i = 2; i*i &lt; num; i++)&#123; if(num % i == 0) return false; &#125; return true;&#125;bool is_has9(int num)&#123; /* 判断传入的数字是否含9 */ if(num &lt; 9) return false; while(num &gt;= 9)&#123; if(num % 10 == 9)&#123; return true; &#125; num /= 10; &#125; return false;&#125;int main()&#123; FILE *fp = fopen(\"result.txt\", \"w\");; int i; // 循环判断 for(i = 100; i &lt; 1000; i++)&#123; if(is_prime(i) &amp;&amp; !is_has9(i)) fprintf(fp, \"%d\\n\", i); &#125; fclose(fp); return 0;&#125; 欢迎来信交流||指教。","categories":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"}],"tags":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"},{"name":"c语言","slug":"c语言","permalink":"http://zivblog.top/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"苏州大学2008年复试编程题","slug":"苏州大学2008年复试编程题","date":"2019-03-02T12:55:49.000Z","updated":"2020-03-04T07:01:39.694Z","comments":true,"path":"passages/su-zhou-da-xue-2008-nian-fu-shi-bian-cheng-ti/","link":"","permalink":"http://zivblog.top/passages/su-zhou-da-xue-2008-nian-fu-shi-bian-cheng-ti/","excerpt":"排除指定单词，转换单词格式，输入到文件中","text":"排除指定单词，转换单词格式，输入到文件中 问题描述 用IE从FTP上下载org.dat，并保存到D盘根目录 顺序读取文件内的文章内容，读取过程中排除“the”及其变形 将读取的所有单词首字母转大写后，输出到D盘根目录下new.txt，每个单词一行 问题分析 从ftp上下载文件 读取文件内容 过滤掉“the”及其变形，相同单词读写一次 将每个单词首字母大写，格式化输出到文件中 解法一代码结构12345671. bool is_the(char word[15])： 判断传入的单词是否为the，或其变形 2. int main()： 创建文件指针 读取文件org.dat，输出并过滤the及其变形并写入new.txt中 输出new.txt中的内容 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdbool.h&gt;#include&lt;string.h&gt;bool is_the(char word[15])&#123; /* 判断传入的长度不超过15的单词是否为the及其变形 */ int i; char the[] = \"the\"; if(strlen(word) != strlen(the)) return false; for(i = 0; i &lt; strlen(word); i++) word[i] |= 0x20; // 按字典顺序比较两个字符串的大小 return strcmp(word, the) == 0;&#125;int main()&#123; FILE *fporg = fopen(\"org.dat\", \"r\"); FILE *fpnew = fopen(\"new.txt\", \"w\"); char word[15]; // 保证两个文件均正常打开 if(!fporg || !fpnew)&#123; printf(\"File opening failed\"); return EXIT_FAILURE; &#125; printf(\"org.dat:\\n\"); // 按单词读取org.dat的内容并输出，同时过滤the并写入new.txt中 while(fscanf(fporg, \"%s\", word) != EOF)&#123; printf(\"%s \", word); // 'a'-'A' = 32 = 0x20 if(!is_the(word))&#123; // 首字母大写 word[0] = (word[0] | 0x20) - 0x20; fprintf(fpnew, \"%s\\n\", word); &#125; &#125; printf(\"\\n\"); fclose(fporg); fclose(fpnew); // 输出new.txt的内容 fpnew = fopen(\"new.txt\", \"r\"); printf(\"new.txt:\\n\"); while(fscanf(fporg, \"%s\", word) != EOF) printf(\"%s \", word); printf(\"\\n\"); fclose(fpnew); return 0;&#125; 解法二代码结构1234567891011121. void divide(char *a, char words[][15], int *p)```： 将读取的整个文件（含空格，含‘\\0’），划分为单词，这里可以改进为用格式化按单词读取文件。2. void printResult(char words[][15], int n)： 重复单词只往文件中读写一次 过滤THE及其变形 首字母大写并写入文件中3. int isThe(char *p)： 判断传入的单词是否是THE及其变形 将传入长度为3的单词转换成全部大写，再与THE比较4. int main： 读取文件 输出划分好的文章 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdbool.h&gt;#include&lt;ctype.h&gt;#include&lt;string.h&gt;void divide(char *a, char words[][15], int *p)&#123; /* 将直接读取整个文件（包含空格）划分成单词 */ int i = 0, j = 0, k = 0; while(a[i] != '\\0')&#123; while(!isalpha(a[i]))&#123; if(a[i] == '\\0') break; i++; &#125; if(a[i] == '\\0') break; k = 0; while(isalpha(a[i])) words[j][k++] = a[i++]; words[j][k] = '\\0'; j++; &#125; // 单词个数 *p = j;&#125;void printResult(char words[][15], int n)&#123; /* 过滤the及其变形，重复单词只写一遍，写入文件中 */ FILE *fp; int i, j, signal; char temp[15]; // 确认文件正常打开 if((fp = fopen(\"new.txt\",\"w\")) == NULL)&#123; printf(\"cannot opening file\"); exit(0); &#125; // 相同单词只读写一次 for(i = 0; i &lt; n; i++)&#123; signal = 0; for(j = 0; j &lt; i; j++)&#123; if(j == i) continue; else&#123; // 比较两个单词是否相同 if(strcmp(words[i], words[j]) == 0)&#123; signal = 1; break; &#125; &#125; &#125; // 非the及其变形的单词首字母大写并写入文件中 if((signal == 0) &amp;&amp; !isThe(words[i]))&#123; strcpy(temp, words[i]); if(islower(temp[0]))&#123; temp[0] -= 32; &#125; fprintf(fp, \"%s \", temp); &#125; &#125; fclose(fp);&#125;int isThe(char *p)&#123; /* 判断传入的单词是否为THE及其变形 */ int i, k; // 长度不为3 if(strlen(p) != 3) return 0; else&#123; // 转化成全部大写，再与THE比较 for(i = 0; i &lt; 3; i++)&#123; if(islower(p[i]))&#123; p[i] -= 32; &#125; &#125; if(strcmp(p, \"THE\") == 0) return 1; else return 0; &#125;&#125;int main()&#123; FILE *fp; int i = 0,j = 0; char a[500]; char words[100][15]; if((fp = fopen(\"org.dat\", \"r\")) == NULL)&#123; printf(\"cannot open the file\"); exit(0); &#125; // 读取文件 while(!feof(fp))&#123; a[i++] = fgetc(fp); &#125; a[i-1] = '\\0'; divide(a, words, &amp;j); // 输出划分好的文章 for(i = 0; i &lt; j; i++)&#123; printf(\"%s \", words[i]); &#125; printResult(words, j);&#125; 欢迎来信交流||指教。","categories":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"}],"tags":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"},{"name":"c语言","slug":"c语言","permalink":"http://zivblog.top/tags/c%E8%AF%AD%E8%A8%80/"}]}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"},{"name":"自然语言处理","slug":"自然语言处理","permalink":"http://zivblog.top/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"},{"name":"Lintcode","slug":"Lintcode","permalink":"http://zivblog.top/categories/Lintcode/"},{"name":"算法","slug":"算法","permalink":"http://zivblog.top/categories/%E7%AE%97%E6%B3%95/"},{"name":"Sword Offer","slug":"Sword-Offer","permalink":"http://zivblog.top/categories/Sword-Offer/"},{"name":"工具配置","slug":"工具配置","permalink":"http://zivblog.top/categories/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/"},{"name":"周知识总结","slug":"周知识总结","permalink":"http://zivblog.top/categories/%E5%91%A8%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"},{"name":"读书&电影","slug":"读书-电影","permalink":"http://zivblog.top/categories/%E8%AF%BB%E4%B9%A6-%E7%94%B5%E5%BD%B1/"},{"name":"博客相关","slug":"博客相关","permalink":"http://zivblog.top/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"},{"name":"置顶","slug":"置顶","permalink":"http://zivblog.top/categories/%E7%BD%AE%E9%A1%B6/"},{"name":"深度学习","slug":"深度学习","permalink":"http://zivblog.top/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"机器学习","slug":"机器学习","permalink":"http://zivblog.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"编程语言","slug":"编程语言","permalink":"http://zivblog.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"},{"name":"NLP","slug":"NLP","permalink":"http://zivblog.top/tags/NLP/"},{"name":"lintcode","slug":"lintcode","permalink":"http://zivblog.top/tags/lintcode/"},{"name":"算法","slug":"算法","permalink":"http://zivblog.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"Tools","slug":"Tools","permalink":"http://zivblog.top/tags/Tools/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","permalink":"http://zivblog.top/tags/Artificial-Intelligence/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://zivblog.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"论文笔记","slug":"论文笔记","permalink":"http://zivblog.top/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"},{"name":"Python","slug":"Python","permalink":"http://zivblog.top/tags/Python/"},{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"},{"name":"c语言","slug":"c语言","permalink":"http://zivblog.top/tags/c%E8%AF%AD%E8%A8%80/"},{"name":"Java","slug":"Java","permalink":"http://zivblog.top/tags/Java/"}]}