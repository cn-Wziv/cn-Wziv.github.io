{"meta":{"title":"Ziv（瓶子）","subtitle":null,"description":null,"author":"Wang Jinfeng","url":"http://zivblog.top","root":"/"},"pages":[{"title":"关于","date":"2019-03-02T12:20:11.000Z","updated":"2020-12-14T08:48:28.408Z","comments":true,"path":"about/index.html","permalink":"http://zivblog.top/about/index.html","excerpt":"","text":"个人简介 计算机研一在读 方向：RST Discourse Parsing, Dialogue Discourse Parsing 兴趣包括但不限于: 检索式对话, 命名实体识别, 情感分析, 机器阅读理解 长期寻找竞赛队友, 最好NLP相关, 数据挖掘略坑 联系方式 邮箱 : jfwang9@stu.suda.edu.cn QQ : 850300210 欢迎交流，无事勿扰 如发现文章内排版或理论问题，欢迎交流 请指明文章名及位置 请配截图 谢谢"},{"title":"所有分类","date":"2019-03-02T12:18:35.000Z","updated":"2020-07-06T04:12:46.000Z","comments":true,"path":"categories/index.html","permalink":"http://zivblog.top/categories/index.html","excerpt":"","text":""},{"title":"友链","date":"2020-11-28T06:01:19.212Z","updated":"2020-07-07T01:33:01.000Z","comments":true,"path":"friends/index.html","permalink":"http://zivblog.top/friends/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-11-28T06:01:19.216Z","updated":"2020-07-06T06:13:01.000Z","comments":true,"path":"tags/index.html","permalink":"http://zivblog.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"BDCI2020房产行业问答匹配","slug":"BDCI2020房产行业问答匹配","date":"2020-12-14T07:12:44.000Z","updated":"2020-12-15T11:42:50.860Z","comments":true,"path":"passages/bdci2020-fang-chan-xing-ye-wen-da-pi-pei/","link":"","permalink":"http://zivblog.top/passages/bdci2020-fang-chan-xing-ye-wen-da-pi-pei/","excerpt":"CCF BDCI2020, 房产行业聊天问答匹配","text":"CCF BDCI2020, 房产行业聊天问答匹配 前言 本人计算机专业研二在读, 研究方向为自然语言处理, 具体来讲是篇章分析 (手写文本和对话都有研究) 作为即将踏入实习和求职大军的NLPer, 决心做几个比赛充实一下简历 本次CCF系列赛选择了其中的房产行业聊天问答匹配赛道, 最终成绩初赛21/2985, 复赛成绩12/2985 很荣幸在参赛过程中认识了一位队友, 最终的成绩也是我们两人共同努力的成果 参赛经历 正式的参赛经历从本学期开始的, 最先参加的是天池的中药文献问题生成比赛. 由于对于生成式任务并没有接触过, 最终也只是看了一篇问题生成的综述, 找来开源的baseline简单学习了一下, 由于参加的人数比较少, 虽然侥幸进入了复赛, 但并没有继续做下去 第二个比赛是天池的中药说明书实体识别, 第一次从数据处理开始搭建模型, 对bert的使用有了一定的认识 第三个就是CCF的这个比赛了, 花了很多心思来研究数据和模型, 最终成绩也算对得起自己的努力了(没错, 就这么咸鱼) 另外, 打个广告: 长期寻找比赛队友, 有大佬不嫌弃可以联系我一起苟分 上分过程 以下所有成绩都基于bert, bert的版本会在后面标出, 我们将该任务作为句对匹配任务处理, 将query和reply拼接经过bert得到句对的编码, 对最终的向量进行回归or分类任务 10月13日晚数据发布, 当即下载了数据 10月14日进行了简单的EDA, 在此过程中发现了一个比较有效的特征, 后面会进行详述 10月17日提交了第一份结果, 使用bert-base的pool_out作为句对的编码进行回归预测,prob&gt;0.5预测为1, 成绩0.7255 10月21日, 拼接bert-base的pool_out和last_hidden_state经过一层lstm之后的hidden作为句对的编码, 成绩0.7461 10月22日, 调整学习率的句子的maxlen等参数, 成绩0.7522 10月24日, 使用focal loss作为损失函数, 同时使用对抗训练(pgd, k=3)的策略, 成绩0.7592 10月26日, 为了更充分的使用训练集数据, 采用交叉验证的策略训练模型k=5, 投票, 沿用上面的参数, 成绩0.7659 10月29日, 使用二分类代替回归, 成绩0.7669, 后续成绩均使用二分类 11月4日, 使用概率平均代替投票, 成绩0.7685 11月6日, 使用哈工大的bert-base-wwm, robert-wwn-ext-large, 成绩分别为0.7724, 0.7703, 后面单模均使用bert-base-wwm 11月8日, 尝试在bert后加textcnn, dpcnn, 成绩分别为0.7709, 0.7694 11月10日, 请教了群里的大佬, 使用groupKFlod代替之前的StratifiedKFold划分策略, 模型的线上线下更加稳定, 并且效果有微弱提升, 成绩为0.7753. 因为原始数据中是一个query对应多个reply, 而我们的做法是将其拆分组合成了多个q-r pair, 如果使用分层取样的方式进行数据集的划分, 可能产生数据泄露, 即对应同一个query的reply被分别划分到了训练集和验证集中, 导致模型线下效果过好 11月12日, 认识了最终组队的队友 11月13日, 受CCF BDCI 2019互联网情感分析代码的启发, 不再使用lstm, 而是拼接bert的后n层输出中的CLS向量和pool_out,经过测试, 最好的选择为后三层, 成绩为0.7790 11月17日, 在一通魔改之后 (替换adam为adamw, 使用transformer中的warmup学习率策略, 加入梯度裁剪), 成绩0.7801 11月20日, 早停的策略由验证集上f1下降即停止变为训练两轮后停止, 成绩为0.7844 11月23日, 使用macbert-large替换bert-base-wwm, 成绩略有提升, 但耗时翻了好几倍, 我们的实验结果表明主要的耗时在对抗训练部分, 并且对抗训练对large模型提升有限, 可能会起反作用 (此处仅为个人观点) 11月26日, 加入位置特征, 即当前reply在当前query答案集中的相对位置, 提升明显, 成绩79.12 这验证了我们在EDA阶段的猜想, 通过统计数据的分布, 我们发现, 第一个reply为正确的比率高达76%(可能是数据构造的时候并没有进行shuffle) 同时这也与包大人在赛后文章中提到的数据敏感性不谋而合 不过我们的做法更加暴力且原始, 由于每个问题之多五个被选答案, 所以我们训练了5个向量分别表示不同的位置, 将该向量拼接到句子表征之后送入分类器 11月28日, 去掉了macbert的对抗训练策略, 成绩有所提升, 成绩为0.7945 这可能是我们最终参与融合的模型中最好的单模成绩 11月29日, 按照加权的方式对之前的结果进行投票, 成绩0.7966 11月29日, 使用等权重投票, 成绩0.7984 12月3日, 重新跑了这些模型, 使用概率平均的方式进行融合, 成绩0.7986 12月5日切榜, 我们的成绩从23到了15, b榜自动评测的成绩为0.8142 说明我们模型的健壮性还是经得起检验的, 哈哈 12月6日, 由于时间问题, 我们重新训练预测了10个模型, 分别为bert-base-wwm, roberta-chinese-large, macbert-large, roberta-large-pairs, nezha-large, 后接last3 CLS, lstm, textcnn, dpcnn, capsule, 最终b榜成绩0.8176 其他尝试 尝试了简单的数据预处理, 包括替换文本中的特殊字符, 网址, 替换网址影响不大(该现象本身就比较少), 替换特殊字符还导致了效果下降 我们认为bert在训练的时候的文本并不是十分pure的文本, 在训练过程中已经对特殊字符进行了比较好的表征; 另外, 闲聊对话中特殊字符提供的信息比带来的噪音更多 尝试了伪标签, 我们的做法是使用多个训练好的模型对训练集进行预测, 将多个模型判定一致的样本加入训练集, 对上述模型进行继续训练. 但效果并不理想, 可能是操作上存在问题, 由于伪标签的尝试已经是比赛后期, 并未进行进一步的尝试 尝试对bert和后接的结构使用不同的学习率, 提升微弱 在比赛最后几天得知roberta-pairs在句对分类问题上效果很好, 但是时间问题, 并没有进行线上的测试, 最终之取了其中一个线下较好的结果参与了最终的模型融合 炼丹技巧 该部分为多处博客or知乎答案的综合, 包括在此比赛中的实践结论 超参数的重要程度: 学习率 &gt; batch_size &gt; l2_weight &gt; 损失函数 &gt; 其他 一般来说, 越大的batch_size可以使用越大的学习率 batch_size大可以提高梯度下降的置信度, 所以可以”大步走” batch_size一般有一个临界值, 大于该值之后就不会再有明显的提升了, 但是仍可以通过增大batch_size加快训练速度 初始化权重可以加快收敛速度, 常用的权重初始化算法: kaiming_normal_, xavier_normal dropout通常在全连接层附近使用 梯度裁剪: 当梯度超过了设定的阈值之后, 将梯度设置为该阈值 如果模型包含n-&gt;n的全连接层, 可以使用highway network代替, 但highway比较难调 GPU上报错时可以将数据先放到cpu上跑, 可以更精确的定位错误的位置 使用rnn时可以尝试batch_size=1(没有验证过该结论) 数据归一化 神经网络学习的本质是学习数据分布, 当训练集和测试集分布不同时, 网络泛化能力将大大下降 另外, 当不同batch的分布各不相同时, 网络的每次迭代都要对适应不同的分布, 这回降低训练速度 原则上使用batch normalization可以替代dropout, l1,l2正则 warmup学习率自适应: 先用比较小的学习率探索, 再用较大的学习率学习, 最后再使用较小的学习率做最后的拟合 交叉验证的过程中注意数据泄漏(见上面groupKFold使用的动机) 在交叉验证挑选好模型之后, 可以使用全数据集在挑选的模型上以较小的学习率继续进行训练几个epoch 模型融合 要增加参与融合的模型之间的差异性, 主要从以下几个方面: 结构 &gt; 参数 &gt; … 更详细的部分可以看这里 融合方式 投票, 每个模型得到结果之后进行投票, 得票多的为最终结果 概率平均(加权平均), 每个模型预测的概率进行平均(加权) 实践结果证明, 最简单的等权重概率平均效果提升最稳定 另外stacking等方式可以试试, 要保证足够多的模型参与 结束语 先写到这里, 如果有疑问或者要讨论的可以留言 or 联系我 祝大家炼丹愉快 再罗嗦一句 : 长期寻找比赛队友","categories":[{"name":"数据竞赛","slug":"数据竞赛","permalink":"http://zivblog.top/categories/%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"炼丹手册","slug":"炼丹手册","permalink":"http://zivblog.top/tags/%E7%82%BC%E4%B8%B9%E6%89%8B%E5%86%8C/"},{"name":"深度学习","slug":"深度学习","permalink":"http://zivblog.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}]},{"title":"胶囊Capsule网络","slug":"胶囊Capsule网络","date":"2020-11-29T10:20:05.000Z","updated":"2020-11-29T12:54:49.177Z","comments":true,"path":"passages/xiao-nang-capsule-wang-luo/","link":"","permalink":"http://zivblog.top/passages/xiao-nang-capsule-wang-luo/","excerpt":"Capsule Network","text":"Capsule Network 胶囊是什么? 有别与神经网络的”Scaler in Scaler out”, 胶囊网络的特色是”Vector in vector out”. 更确切的说, 胶囊网络给出了一种全新的”Vector in Vector out”的传递方案, 并且具有很强的解释性 有人会问神经网络的输入不就是向量吗? 请注意, 具体到每个神经元, 它所处理的就是一个标量(只有大小, 没有方向) 重点在这, 胶囊就是向量. 使用向量表示一个特征不仅能够表示它的”有无”, 还能表示它的”模样”. 简单来说就是单个特征的表达更加丰富了 感觉有点”类比”NLP中的词向量, 不仅能够表示一个词的有无, 还能表示一个词的”含义”, 可以用来衡量与其他词的”远近” 动态路由 动态路由(Dynamic Rounting)的概念可谓将囊网络中最大的特色了, 我们来看一下它究竟是什么 看上面的例子, 我们将当前特征用蓝色表示, 更上曾的特征用绿色表示. 这时后要对当前特征进行更上层的抽象该如何做呢? 当然是基于当前的特征, 进行”再组合”. 既然进行再组合, 就需要明确下层特征对应上层特征的”贡献”(权重). 至此, 任务确定了”如何确定每个下层特征到上层特征的权重?“ 另外, 如果考虑所有下层特征与上层特征的连接, 每个上层特征实际上就是各个下层特征的聚类中心. 是的, 胶囊网络的核心就是”输出是输入的某种聚类结果“ 计算两个对象之间的权重(或者分类任务), 我们常规的套路就是内积后接softmax函数$$p_i = \\frac{e^{&lt;u_i, v1&gt;}}{4} ,u_1对应四个上层特征的权重$$ 但问题在于, v_i是我们所要求解的结果, 而求解该结果需要它自身的参与…, 死循环了? 这里给出的方案是: 利用迭代的策略(聚类算法也大都基于迭代) 初始将vi等于各个ui的均值 得到的vi参与权重的计算 利用得到的权重再次计算vi 重复(2)(3)两步, 直到收敛 这种网络层对叠几层就相当于对特征进行了多少层的抽象 那么, 胶囊网络还和其他神经网络一下需要通过”反向传播”进行训练吗? 答案是肯定的, 动态路由只是通过迭代得到了两层特征之间的权重,这部分权重将作为权重参与整个网络的训练 值得一提的是: 将聚类的过程添加到神经网络的训练中, 明显增加了神经网络训练所需要的时间, 一个字”慢” Squash是什么? 胶囊拥有的一个性质是: 通过胶囊(向量)的模长代表当前胶囊(向量)对应的特征的概率(显著程度) 想要表示显著程度需要确定一个指标范围, 从而就需要一个映射方案将其映射到该范围内进行对比, 论文中给出的解决方案为$$squash(x) = \\frac{||x||^2}{1+||x||^2}\\frac{x}{||x||}$$ 这个方案在进行压缩的同时引入了”非线性” 参考资料 https://arxiv.org/pdf/1710.09829.pdf https://kexue.fm/archives/4819","categories":[{"name":"自然语言处理","slug":"自然语言处理","permalink":"http://zivblog.top/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"http://zivblog.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}]},{"title":"模型融合","slug":"模型融合","date":"2020-11-28T07:12:33.000Z","updated":"2020-11-29T10:22:00.285Z","comments":true,"path":"passages/mo-xing-rong-he/","link":"","permalink":"http://zivblog.top/passages/mo-xing-rong-he/","excerpt":"模型融合","text":"模型融合 前言为什么要进行模型融合? 试想一下生活中的某个场景, 在你想买一个比较贵重的物品时, 你一般会询问周围的许多朋友, 听听他们的意见, 或许还会百度一下, 知乎查一下, 最后综合上述的所有信息来决定要买哪种 模型融合正是基于这种思想和假设—-“多个模型的组合决策可以提高决策的质量” 模型融合是数据竞赛后期比较重要的一种上分手段, 大体来说会有以下几种方式: 加权融合 stacking or blending boosting or bagging 加权融合平均法 对于回归问题, 最暴力的思路就是对多个模型的结果进行平均, 又分为简单平均和加权平均$$y = \\frac{1}{n}\\sum w_i y_i$$ 其中简单平均可以是做加权平均的一种特殊情况 (权重相同) 权重的设置基本按照单个模型的性能进行设置, 单模型效果越好, 话语权(权重)越高 对于分类问题也可以使用在转化为label之前的概率进行加和求平均 投票法 对于分类问题, 将多个模型的结果进行投票, 将投票结果根据一定规则得到最终的预测结果. 又根据不同的规则分为: 绝对多数投票, 相对多数投票, 加权投票, 硬投票 绝对多数投票: 当某个结果的票数超过总票数的一半以上时, 以该结果作为最终结果 相对多数投票: 取投票结果中票数最多的作为最终结果 加权投票: 对不同的模型的结果赋予一定的权重, 取投票结果中得票数最高的 根据是否可对参与投票的模型赋予权重, 还可分为硬投票和软投票 硬投票: 多个模型的重要性相同, 将最终票数最多的类作为最终结果 软投票: 可以对不同的模型赋予不同的权重 集成学习 集成学习分为多种: stacking, boosting, bagging, blending Stacking 用初始训练数据学习出若干基学习器, 将这些基学习器的预测结果作为特征再训练一个分类器, 作为最终的预测结果 保留基学习器在训练集上的预测结果, 这部分结果作为特征进行新模型的训练, 还要保留基学习器在测试集上的预测结果作为特征来进行最终的预测. 如果是k折的话, 对于每个基学习器, 需要保留所有dev上的预测结果并拼接才是在训练集上的预测结果 至于多少个基学习器, 当然是越多越好 并且对于构造出来的特征也要进行降维, 或者简单的保留相关性较高的特征列中的一列即可 Blending 与stacking相思, 也是两层的架构, 不同之处在于 将训练集划分为train和dev, 仅用train训练多个分类器, 分别预测dev和test 将dev的预测结果作为特征进行第二层分类器的训练数据, 预测test作为最终结果 这种方式笔者并未尝试过, 在这里仅作简单介绍 Bagging 采用有放回的采样方式(自采样, bootstrap), 训练子集的大小与原始数据相同, 但是存在重复样本 基于这些训练子集相互独立并行的训练不同的模型, 最终的预测结果由多个模型共同决策得到 random forest就是一种典型的使用bagging思想的集成学习模型 Boosting 不同于bagging的并行, boosting是一种串行的工作机制. 各个学习器之间的训练存在依赖关系, 后续模型会纠正前面模型的错误 通过增加前一个学习器在训练过程中预测错误的样本的权重, 后续学习器可以更加关注这些样本, 从而在一定程度上进行纠错 然后再对串行的多个基学习器进行加权投票 构造模型差异性 使用模型融合的关键在于两点 较好的投票参与者 (基础模型的效果不能太差) 投票参与者之间的差异 (模型之间的差异性要足够显著), 毕竟结合不同的人的意见才能得到更合理的决定 下面主要说一下模型的差异性体现在那些方面 相同的模型结构, 不同的随机数种子 相同的参数, 不同的网络初始化方式 不同的参数, 通过交叉验证选取最好的模型 相同的参数, 模型的不同训练阶段 不同的模型结构 最后, 根据笔者的经验来看, 简单的平均效果提升比较稳定, 可能多次尝试之后该方法上分最明显 加权平均受权重的影响比较大 集成学习的方法受不同基学习器产生的结果影响较大 一定要做相关性分析, 集成相关性低的模型可以增加纠错能力 参考资料 https://mp.weixin.qq.com/s/fsT6rzpL5cuzh2usNjzzbA https://zhuanlan.zhihu.com/p/26890738","categories":[{"name":"数据竞赛","slug":"数据竞赛","permalink":"http://zivblog.top/categories/%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"炼丹手册","slug":"炼丹手册","permalink":"http://zivblog.top/tags/%E7%82%BC%E4%B8%B9%E6%89%8B%E5%86%8C/"}]},{"title":"Leetcode之数组与字符串","slug":"Leetcode之数组与字符串","date":"2020-08-18T00:58:45.000Z","updated":"2020-08-19T02:02:51.000Z","comments":true,"path":"passages/leetcode-zhi-shu-zu-yu-zi-fu-chuan/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-shu-zu-yu-zi-fu-chuan/","excerpt":"数组与字符串（2020.8.4~2020.8.18）","text":"数组与字符串（2020.8.4~2020.8.18） 2020.8.4 更新 数组简介集合、列表和数组 集合：由一个或多个确定的元素所构成的整体 集合里的元素类型不一定相同 集合里的元素没有顺序 列表（线性列表）：按照一定的线性顺序，排列而成的数据项的集合 包括数组和链表 Python中的List不是数组，包含的元素的数据类型不一定相同 寻找数组的中心索引 对应Leetcode第724题 给定一个整数类型的数组，返回中心索引 中心索引：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和 123456789101112131415161718192021def pivotIndex(self, nums: List[int]) -&gt; int: ''' 先计算出数组所有元素之和 遍历数组，计算当前位置左边的元素之和 当左边元素之和*2+当前元素=数组之和时，返回当前位置 特殊处理： 数组长度为0时，返回-1 数组长度为1时，返回nums[0] ''' if len(nums) == 0: return -1 if len(nums) == 1: return nums[0] sum_ = sum(nums) left_sum = 0 for idx, num in enumerate(nums): if left_sum*2+num == sum_: return idx left_sum += num return -1 搜索插入位置 对应leetcode第35题 给定一个排序数组（无重复元素）和一个目标值 在数组中找到目标值，并返回其索引 如果目标值不存在于数组中，返回它将被插入的位置 12345678910111213def searchInsert(self, nums: List, target: int) -&gt; int: ''' 遍历有序数组，若当前位置的元素大于或等于目标值，则返回当前位置的下标 特殊处理： 当数组为空时，返回0 当数组中无插入位置，返回len(nums)，即数组最后一个位置的下一个位置 ''' if len(nums) == 0: return 0 for idx, num in enumerate(nums): if num &gt;= target: return idx return len(nums) 合并区间 对应leetcode第56题 解析见合并区间 二维数组简介 二维数组是一种结构比较特殊的数组，将数组中的每个元素变成了一维数组 旋转矩阵 对应leetcode第48题 给定一幅由N*N矩阵表示的图像，其中的像素大小为4字节 将图像旋转90度 能够不使用额外的内存空间（原地）解决吗？ 解析见旋转图像 1234567891011121314151617181920212223class Solution: def rotate(self, matrix: List[List[int]]) -&gt; None: \"\"\" 通过数据观察可以发现，旋转90度相当于将第i行转化为第len(matrix)-i-1列 这里我们通过两次反转实现 根据左上到右下的对角线反转 再根据水平对称轴反转 原理在于 进行对角线反转时，相当于一次270度的旋转 进行水平对称轴反转，相当与进行一次-189度的旋转 最终两次效果叠加，相当于一次90度的旋转 \"\"\" # 方阵 n = len(matrix) # 沿左上到右下反转 for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] print() # 竖直对称轴反转 for i in range(n): matrix[i].reverse() 12345678910111213141516class Solution: def rotate(self, matrix: List[List[int]]) -&gt; None: # 方阵 n = len(matrix) ''' 或者沿右上到左下的对角线反转 再沿竖直对称线反转 ''' # # 沿右上到左下反转 # for i in range(n): # for j in range(n-i): # matrix[i][j], matrix[n-j-1][n-i-1] = matrix[n-j-1][n-i-1], matrix[i][j] # # 水平对称线反转 # for i in range(n//2): # matrix[i], matrix[n-i-1] = matrix[n-i-1], matrix[i] 零矩阵 对应leetcode第91题 编写算法，若M*N的矩阵中某个元素为0，则将其所在的行与列清零 解析见矩阵置零 1234567891011121314151617181920212223class Solution: def setZeroes(self, matrix: List[List[int]]) -&gt; None: \"\"\" 使用一个字典记录 \"\"\" r_c = &#123;'row':[], 'col':[]&#125; for i in range(len(matrix)): for j in range(len(matrix[0])): if matrix[i][j] == 0: r_c['row'].append(i) r_c['col'].append(j) row, col = set(r_c['row']), set(r_c['col']) for i in range(len(matrix)): if i in row: for j in range(len(matrix[0])): matrix[i][j] = 0 else: for j in range(len(matrix[0])): if j in col: matrix[i][j] = 0 12345678910111213141516171819202122232425262728293031323334353637class Solution: def setZeroes(self, matrix: List[List[int]]) -&gt; None: \"\"\" 不使用额外的空间，使用第一行第一列记录的元素记录该行或该列是否需要置零 注意点： matrix[0][0]只能表示列或行中的一种情况，所以需要一个额外的标识来记录其中一个 以代码为例，用一个标识记录第一列是否需要置零，这时对第一列的置零要在第一行之后（对第一列置零后会影响行的置零） \"\"\" # 第一列是否需要置零 is_col = False for i in range(len(matrix)): # 只要第一列有0 if matrix[i][0] == 0: is_col = True for j in range(1, len(matrix[0])): if matrix[i][j] == 0: # 记录该行 matrix[i][0] = 0 # 记录该列 matrix[0][j] = 0 # 除去第一列和第一行 for i in range(1, len(matrix)): for j in range(1, len(matrix[0])): if not matrix[i][0] or not matrix[0][j]: matrix[i][j] = 0 # 注意顺序 # 第一行 if matrix[0][0] == 0: for i in range(len(matrix[0])): matrix[0][i] = 0 # 处理第一列 if is_col: for i in range(len(matrix)): matrix[i][0] = 0 2020.8.6 更新 对角线遍历 对应leetcode第498题 给定一个包含M*N个元素的矩阵（M行，N列），请以对角线遍历的顺序返回这个矩阵中的所有元素，对角线遍历如下图所示 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution: def findDiagonalOrder(self, matrix: List[List[int]]) -&gt; List[int]: ''' 对于这种比较奇怪的遍历，找规律 按遍历的顺序，每层存在一个规律 当前层的元素的横纵坐标之和为一个定值 刚好为当前所在的层的索引[0, m+n-1], 共m+n+1层 另外，遍历的顺序有两种 当层数的索引为偶数时，遍历从左下向右上进行（横坐标减小，纵坐标增大） 当层数的索引为奇数时，遍历从右上向左下进行（横坐标增大，从坐标减小） ''' if len(matrix) == 0: return [] n, m = len(matrix), len(matrix[0]) f_num = n + m - 1 res = [] # 按层遍历 for f in range(f_num): # 左下到右上 if f % 2 == 0: # 横坐标减小 for i in range(f, -1, -1): # 横纵坐标之和为一定值，即f j = f - i if i &lt; n and j &lt; m: res.append(matrix[i][j]) elif j &gt;= m: break else: continue # 右上到左下 else: # 纵坐标减小 for j in range(f, -1, -1): i = f - j if i &lt; n and j &lt; m: res.append(matrix[i][j]) elif i &gt;= n: break else: continue return res 字符串简介 字符串由一个或多个字符组成的有限序列 字符串的基本操作对象通常是字符串整体或字符串的子串 最长公共前缀 对应leetcode的第14题 编写函数查找字符串数组中的最长公共前缀 123456789101112131415161718192021222324252627282930class Solution: def longestCommonPrefix(self, strs: List[str]) -&gt; str: ''' 依次遍历每个字符串的每个字符 若相等，则添加到结果中 若不相等，则退出 剪枝： 按照最短的字符串的长度进行遍历 特殊情况： 当数组为空时，返回空串 ''' if len(strs) == 0: return \"\" str_len = [len(str) for str in strs] max_pre = \"\" i = 0 while i &lt; min(str_len): is_equal = True s = strs[0][i] # 遍历所有字符串的第i个字符 for str_ in strs[1:]: if s != str_[i]: is_equal = False break if is_equal: max_pre += strs[0][i] else: break i += 1 return max_pre 1234567891011121314151617class Solution: def longestCommonPrefix(self, strs: List[str]) -&gt; str: ''' 利用字符串排序的原理 按字符的ASCII码进行排序 只需对排序后字符串数组的第一个字符串和最后一个字符串求公共前缀即可 ''' if len(strs) == 0: return \"\" strs.sort() min_, max_ = strs[0], strs[len(strs)-1] for i in range(len(min_)): if min_[i] != max_[i]: return min_[:i] return min_ 最长回文子串 对应leetcode中第5题 给定一个字符串s，找到s中最长的回文子串 12345678910111213141516171819202122232425262728293031323334353637383940class Solution: def longestPalindrome(self, s: str) -&gt; str: ''' 动态规划 N*N的数组，记录第i个元素到第j个元素组成的子串是否为回文串 单个元素必为回文串 当i和j对应的元素相等时 若两者之差小于等于2，必为回文串 当两个之差大于2时，与第i+1到j-1个元素组成的子串有关 记录i的位置和回文串的长度 特殊情况 当字符串长度小于等于2的时候，必为回文串 注意 子串和子序列的区别 ''' if len(s) &lt; 2: return s len_ = len(s) dp = [[False]*len_ for _ in range(len_)] # 初始化 for i in range(len_): dp[i][i] = True max_len, start = 1, 0 for j in range(1, len_): for i in range(j): if s[i] == s[j]: if j - i &lt;= 2: dp[i][j] = True else: dp[i][j] = dp[i+1][j-1] else: dp[i][j] = False if dp[i][j]: cur_len = j - i + 1 if cur_len &gt; max_len: max_len = cur_len start = i return s[start: start+max_len] 2020.8.8更新 翻转字符串里的单词 对应leetcode中第151题 给定一个字符串，逐个翻转字符串中的每个单词 无空格字符构成一个单词 输入字符串可以在前面或后面包含多余的空格，但是反转后的字符串不能包括 如果两个单词之间有多个空格，将反转后单词间的空格减少到只含一个 123456789101112131415161718192021222324252627class Solution: def reverseWords(self, s: str) -&gt; str: ''' 遍历，使用列表存储当前字符串，添加到结果中 在字符串后添加一个空格分割 缺点： 使用几乎等长的额外空间 ''' res = list() sub_s = '' is_end = False for i in range(len(s)): if s[i] != ' ': sub_s += s[i] else: if is_end == False: is_end = True # 连续空格跳过 else: continue if is_end or i == len(s)-1: if sub_s != \"\": res.append(sub_s) sub_s = '' is_end = False # 反向添加到结果中 return \" \".join(reversed(res)) 123456789class Solution: def reverseWords(self, s: str) -&gt; str: ''' Python的内置函数 使用split按空格分割，因为可能是多个空格分割，不能指定为单空格分割 使用reversed反转列表 使用join中间添加空格拼接 ''' return \" \".join(reversed(s.split())) 实现strStr 对应leetcode第28题 KMP算法 使用next数组保存模式串和主串之间元素不匹配时，下一步应该重新开始的位置 next数组中，p[i]对应模式串p[0,i+1]中最长公共前后缀（前缀和后缀中的公共部分，前后缀不能有重叠）的长度 net[0]=1表示不懂 next数组只与模式串本身的性质有关 KMP参考代码 12345678910111213141516171819202122232425262728293031# next数组的构造def build_next(P): n = len(P) Next = [0]*n Next[0]= -1 j, t = 0, -1 while j &lt; n-1: if t &lt; 0 or P[j]==P[t]: j += 1 t += 1 Next[j] = t else: t = Next[t] return Nextdef match(P, S): ''' P: 模式串 S: 主串 ''' next = build_next(P) m, n = len(S), len(P) i, j = 0, 0 while j &lt; n and i &lt; m: if j &lt; 0 or S[i]==P[j]: i += 1 j == 1 else: # 有限回溯 j = next[j] return i - j 给定一个字符串和一个模式串，找到在主串中模式串第一次出现的位置 如果不存在，则返回-1 12345678910111213141516class Solution: def strStr(self, haystack: str, needle: str) -&gt; int: ''' 暴力匹配 ''' if len(needle) == 0: return 0 for i in range(len(haystack)-len(needle)+1): j = 0 while j &lt; len(needle): if haystack[i+j] != needle[j]: break j += 1 if j == len(needle): return i return -1 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution: def strStr(self, haystack: str, needle: str) -&gt; int: ''' KMP 构建next数组 匹配 ''' def build_next(P): n = len(P) Next = [0]*n Next[0] = -1 j, t = 0, -1 while j &lt; n-1: if t &lt; 0 or P[j]==P[t]: j += 1 t += 1 Next[j] = t else: t = Next[t] return Next def match(P, S): Next = build_next(P) m, n = len(S), len(P) i, j = 0, 0 while j &lt; n and i &lt; m: if j &lt; 0 or S[i]==P[j]: i += 1 j += 1 else: # 有限回溯 j = Next[j] print(i, j) return i, j if len(needle) == 0: return 0 i, j = match(needle, haystack) # 匹配成功 if j == len(needle): return i-j else: return -1 2020.8.9 更新 双指针技巧 双指针的经典场景 从两段向中间迭代数组，指针的运动方向相反 两个不同步的指针，即快慢指针，指针的运动方向相同 反转字符串 对应leetcode第344题 将输入的字符串反转过来，字符串以字符数组的形式给出 需要原地修改数组 详细解释见反转字符串 123456789101112131415class Solution: def reverseString(self, s: List[str]) -&gt; None: \"\"\" 双指针分别指向数组的头部和尾部 交换指针指向的元素 两指针分别向中间移动 直到两指针相遇 \"\"\" left, right = 0, len(s)-1 while left &lt; right: s[left], s[right] = s[right], s[left] left += 1 right -= 1 return s 数组拆分 对应leetcode第561题 给定长度为2n的数组, 你的任务是将这些数分成n对, 例如(a1, b1), (a2, b2), ..., (an, bn)，使得从1到n的min(ai, bi)总和最大 1234567891011121314class Solution: def arrayPairSum(self, nums: List[int]) -&gt; int: ''' 可以发现，如果想要使n对数中较小值的和最大 可以将数组进行排序，每相邻两个组成一对，这样每对中的较小值之和即为最大 所以，可以先对数组进行排序，从第一个开始，隔一个取一个即可 ''' nums.sort() sum_, i = 0, 0 while i &lt;= len(nums)-2: sum_ += nums[i] i += 2 return sum_ 好像和双指针没什么联系啊，难道是排序算法？ 两数之和 Ⅱ 对应leetcode第167题 给定一个按照升序排列的有序数组，找到两个数使他们相加之和等于目标数 返回两个下标值index1和index2，要求index1必须小于index2 下标值是从1开始的，并且不能使用两个相同的数 详细分析请看两数之和Ⅱ 12345678910111213141516171819class Solution: def twoSum(self, numbers: List[int], target: int) -&gt; List[int]: ''' 双指针分别指向数组的头和尾部 计算指针指向的两个元素的值 若两者之和大于目标值，则尾指针向前移动 若两者之和小于目标值，则头指针向后移动 由于排过序，相同的数字都在一起 两指针不能指向同一个元素 ''' head, tail = 0, len(numbers)-1 while head &lt; tail: sum_ = numbers[head]+numbers[tail] if sum_ == target: return [head+1, tail+1] elif sum_ &gt; target: tail -= 1 else: head += 1 移除元素 对应leetcode第27题 给定一个数组nums和一个val，你需要原地移出所有数值等于val的元素，并返回一处后数组的新长度 不要使用额外的数组空间，请原地修改数组 123456789101112131415class Solution: def removeElement(self, nums: List[int], val: int) -&gt; int: ''' 由于对元素的顺序没有要求，且返回的是长度 可以将与val相同的元素依次用后面的元素替换 最后返回新的长度即可 ''' p, end = 0, len(nums)-1 while p &lt;= end: if nums[p] == val: nums[p] = nums[end] end -= 1 else: p += 1 return p 123456789101112131415class Solution: def removeElement(self, nums: List[int], val: int) -&gt; int: &#39;&#39;&#39; 快慢指针 快指针每次移动一步 慢指针仅在元素不为val的时候移动 当慢指针指向val时，与快指针交换 &#39;&#39;&#39; slow, fast &#x3D; 0, 0 while fast &lt; len(nums): if nums[fast] !&#x3D; val: nums[slow] &#x3D; nums[fast] slow +&#x3D; 1 fast +&#x3D; 1 return slow 最大连续1的个数 给定一个二进制数组，计算其中最大连续1的个数 1234567891011121314151617181920212223class Solution: def findMaxConsecutiveOnes(self, nums: List[int]) -&gt; int: ''' 快慢指针 快指针每次都移动 慢指针在指向0的时候移动，或在快指针指向0的时候计算完连续1的长度后移动 特殊情况 当快指针指向最后一个元素且为1时，长度+1 ''' if len(nums) == 1: return 1 if nums[0]==1 else 0 res = 0 slow = 0 for fast in range(len(nums)): if nums[slow] == 0: slow += 1 continue if nums[fast] != 1: res = max(res, fast-slow) slow = fast if fast == len(nums)-1: res = max(res, fast-slow+1) return res 长度最小的子数组 对应leetcode第209题 给定一个含有n个正整数的数组和一个正整数s，找出该数组中满足和&gt;=s的长度最小的连续子数组，返回长度；如果不存在，则返回0 详细分析见长度最小的子数组 12345678910111213141516171819class Solution: def minSubArrayLen(self, s: int, nums: List[int]) -&gt; int: ''' 双指针 快指针一直移动，不断累加，直到大于给定值时 和不断减去慢指针指向的位置的元素，慢指针移动 直到快指针遍历结束 ''' res = float('inf') slow = 0 sum_ = 0 for fast in range(len(nums)): sum_ += nums[fast] while sum_ &gt;= s: res = min(res, fast-slow+1) sum_ -= nums[slow] slow += 1 return 0 if res == float('inf') else res 2020.8.10 更新 小结杨辉三角 给定一个非负整数numRows，生成杨辉三角的前numRows行 在杨辉三角中，每个数是它左上方和右上方的数的和 12345678910111213141516171819202122232425262728293031323334class Solution: def generate(self, numRows: int) -&gt; List[List[int]]: ''' 观察发现： 第n行的元素的个数为n 由于下一行的元素与上一个位置有关，所以选择使用动态规划 动态规划： 当前位置元素的值为与当前元素下标相同的元素及其之前元素的和 特殊处理 当为第一列时，直接为上一行的元素 当为写边上的元素时，为其左上角的元素 特殊情况： 当n为0时，返回空列表 ''' if numRows == 0: return [] if numRows == 1: return [[1]] dp = [[0]*i for i in range(1, numRows+1)] dp[0][0] = 1 # 第一列 for i in range(1, numRows): for j in range(i+1): print(i, j) if j == 0: dp[i][j] = dp[i-1][j] elif j == i: dp[i][j] = dp[i-1][j-1] else: dp[i][j] = dp[i-1][j] + dp[i-1][j-1] return dp 杨辉三角Ⅱ 给定一个非负索引k，其中k&lt;=33，返回杨辉三角的第k行 在杨辉三角中每个数是其左上方和右上方的数的和 123456789101112131415161718192021222324class Solution: def getRow(self, rowIndex: int) -&gt; List[int]: ''' 可直接使用杨辉三角中的代码 需要注意的是，这里的第k行是编号为k的行，并且编号是从0开始的 ''' if rowIndex == 0: return [1] dp = [[0]*i for i in range(1, rowIndex+2)] dp[0][0] = 1 # 第一列 for i in range(1, rowIndex+1): for j in range(i+1): print(i, j) if j == 0: dp[i][j] = dp[i-1][j] elif j == i: dp[i][j] = dp[i-1][j-1] else: dp[i][j] = dp[i-1][j] + dp[i-1][j-1] return dp[-1] 1234567891011121314class Solution: def getRow(self, rowIndex: int) -&gt; List[int]: ''' 后一行的元素是直接由前一行的元素计算得到的， 经过观察发现，后一行的元素可以由前一行的元素在头部添加0后与原来行相加 注意每行的最后一个数字一定是1，不用特别处理 ''' row = [1] for i in range(1, rowIndex+1): row.insert(0, 0) for j in range(i): row[j] = row[j] + row[j+1] return row 2020.8.17 反转字符串中的单词Ⅲ 给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序 12345678910class Solution: def reverseWords(self, s: str) -&gt; str: ''' 使用Python自带的split和reverse函数 按照空格分割，对每个子串反转 拼接 ''' s_split = s.split(' ') return ' '.join([temp[::-1] for temp in s_split]) 1234567891011121314151617181920class Solution: def reverseWords(self, s: str) -&gt; str: ''' 手动实现了分割 空格分割 最后一个单词单独处理 ''' s = list(s) sub_s = [] s_temp = '' for idx, item in enumerate(s): if item == ' ': s_temp += ''.join(sub_s[::-1]) + ' ' sub_s = [] elif idx == len(s)-1: sub_s.append(item) s_temp += ''.join(sub_s[::-1]) else: sub_s.append(item) return s_temp 123456789class Solution: def reverseWords(self, s: str) -&gt; str: ''' 先将字符串进行反转：相当于把所有的单词都进行了反转 分词，对分词结果进行反转：把单词顺序调整回来 ''' s = s[::-1] return \" \".join(s.split(' ')[::-1]) 2020.8.18 寻找旋转排序数组中的最小值 假设按照升序排序的数组在预先未知的某个点上进行了旋转 找出其中最小的元素 数组中不存在重复元素 123456789101112131415161718192021class Solution: def findMin(self, nums: List[int]) -&gt; int: ''' 设原来的数组为S，原数组以旋转点分割后[S1, S2] 旋转之后为[S2, S1]， 并且S1中的任意元素均小于S2 二分法查找指定元素： left、right两指针，计算mid 如果S[mid]&gt;S[right]，则表示mid在S2中，左指针移动到mid下一个位置 如果S[mid]&lt;S[right]，则表示mid在S1中，右指针移动到mid的位置 直到left和right相遇 ''' left, right = 0, len(nums)-1 while left &lt; right: mid = (left + right) // 2 if nums[mid] &gt; nums[right]: left = mid+1 if nums[mid] &lt; nums[right]: right = mid return nums[right] 删除排序数组中的重复项 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次 返回删除后数组的新长度 1234567891011121314151617181920class Solution: def removeDuplicates(self, nums: List[int]) -&gt; int: ''' 双指针 一个指针用于遍历数组 另一个指针用于指示不重复部分的最终位置 ''' p1, p2 = 0, 0 # 遍历数组 while p1 &lt; len(nums): if nums[p1] == nums[p2]: p1 += 1 continue else: p2 += 1 nums[p2] = nums[p1] p1 += 1 return p2+1 移动零 给定一个数组nums，编写一个函数将所有的0移动到数组的末尾，同时保持非零元素的相对顺序 12345678910111213141516class Solution: def moveZeroes(self, nums: List[int]) -&gt; None: \"\"\" 双指针 一个指针用于遍历数组 当该指针发现一个0元素时，由另一个指针从其后方查找一个非零元素与其交换 \"\"\" p1 = 0 while p1 &lt; len(nums): if nums[p1] == 0: for i in range(p1, len(nums)): if nums[i] != 0: nums[p1], nums[i] = nums[i], nums[p1] break p1 += 1","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"多标签任务中的Macro-F1和Micro-F1","slug":"多标签任务中的Macro-F1和Micro-F1","date":"2020-08-03T02:42:31.000Z","updated":"2020-08-12T02:48:28.000Z","comments":true,"path":"passages/duo-biao-qian-ren-wu-zhong-de-macro-f1-he-micro-f1/","link":"","permalink":"http://zivblog.top/passages/duo-biao-qian-ren-wu-zhong-de-macro-f1-he-micro-f1/","excerpt":"多标签任务中的宏平均和微平均","text":"多标签任务中的宏平均和微平均 多标签任务中的Macro-F1和Micro-F1本文分为三部分 混淆矩阵中TP、FP、TN、FN四个值 Precision、Recall和F1-Score的计算 Macro-F1和Micro-F1的区别 混淆矩阵 实际标签 实际标签 P N 预测输出 P’ TP，实际为正预测为正（真阳性） FP，实际为负，预测为正（假阳性） 预测输出 N’ FN，实际为正，预测为负（假阴性） TN，实际为负，预测为负（真阴性） 精确度和召回率 精确率，表示的是正确预测为正的样本占全部预测为正的样本的比例$$Precision=\\frac{TP}{TP+FP}$$ 召回率，表示的是正确预测为正的样本占全部实际为正的样本的比例$$Recall=\\frac{TP}{TP+FN}$$ F1值，表示的是精确率和召回率的加权$$F1-Score=\\frac{2*Precision*Recall}{Precision+Recall}$$ 感性认识 召回率：真正的正样本有多少被你猜出来了 精确率：你认为的正样本有多少猜对了 Macro-F1和Micro-F1 举例说明 预测值 实际值 A A A A B A C A B B B B C B B C C C 类别A的混淆矩阵为 A Other Pre_A 2 0 Pre_Other 2 ~ $$Precison_A = \\frac{TP}{TP+FP}=\\frac{2}{2+0}=100%$$ $$Recall_A = \\frac{TP}{TP+FN} = \\frac{2}{2+2} = 50%$$ $$F1-Score_A = \\frac{2PrecisionRecall}{Precision+Recall} = \\frac{210.5}{1+0.5}=67%$$ 类别B的混淆矩阵为 B Other Pre_B 2 2 Pre_Other 1 ~ $$Precison_B = \\frac{TP}{TP+FP}=\\frac{2}{2+2}=50%$$ $$Recall_B = \\frac{TP}{TP+FN} = \\frac{2}{2+1} = 67%$$ $$F1-Score_B = \\frac{2PrecisionRecall}{Precision+Recall} = \\frac{20.50.67}{0.5+0.67}=57%$$ 类别C的混淆据真伪 C Other Pre_C 1 2 Pre_Other 1 ~ $$Precison_C = \\frac{TP}{TP+FP}=\\frac{1}{1+2}=33%$$ $$Recall_C = \\frac{TP}{TP+FN} = \\frac{1}{1+1} = 50%$$ $$F1-Score_C = \\frac{2PrecisionRecall}{Precision+Recall} = \\frac{20.330.5}{0.33+0.5}=40%$$ Micro-F1不需要去分类别，直接统计总样本的准确率和召回率进行计算整个样本上的F1-Score 5（TP，预测正确） 4（FP，预测错误） 4（TN，预测错误） ~ $$Precision=\\frac{TP}{TP+FN} = \\frac{5}{5+4} = 56%$$ $$Recall = \\frac{TP}{TP+FN} = \\frac{5}{5+4}=56%$$ $$Micro-F1 =\\frac{2PrecisionRecall}{Precision+Recall} = \\frac{20.560.56}{0.56+0.56}=56%$$ Macro-F需要先计算出每个类别的准确率和召回率，通过求平均值计算整个样本上的F1-Score$$Macro-F1 = \\frac{F1_A+F1_B+F1_C}{3} = \\frac{0.67+0.57+0.40}{3}=0.546$$ 从上面的例子中可以发现 Micro-Score考虑到了每个类别中样本的数量，适用于数据分布不均衡的情况；但是在数据分布极度不平衡的情况下，数量多的类别会对最终的成绩影响较大 Macro-Score没有考虑不同类别中的样本数量，平等地看待每一个类别，会有较高的Precision和Recall的影响","categories":[{"name":"自然语言处理","slug":"自然语言处理","permalink":"http://zivblog.top/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"}],"tags":[{"name":"NLP","slug":"NLP","permalink":"http://zivblog.top/tags/NLP/"}]},{"title":"Leetcode之删除二叉搜索树中的节点","slug":"Leetcode之删除二叉搜索树中的节点","date":"2020-07-30T02:18:57.000Z","updated":"2020-07-30T02:50:21.000Z","comments":true,"path":"passages/leetcode-zhi-shan-chu-er-cha-sou-suo-shu-zhong-de-jie-dian/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-shan-chu-er-cha-sou-suo-shu-zhong-de-jie-dian/","excerpt":"Delete Node in BST","text":"Delete Node in BST Delete Node in BST code with Python title number：450 读题 给定一个二叉搜索树的根节点root和一个值key，删除二叉搜索树中的key对应的节点，保证二叉搜索树的性质不变 返回根节点 一般来说，删除节点可分为两个步骤： 找到需要删除的节点 找到之后，删除 调整树结构使之符合二叉搜索树的性质 示例 1234567891011121314151617181920212223242526root &#x3D; [5,3,6,2,4,null,7]key &#x3D; 3 5 &#x2F; \\ 3 6 &#x2F; \\ \\2 4 7给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。 5 &#x2F; \\ 4 6 &#x2F; \\2 7另一个正确答案是 [5,2,6,null,4,null,7]。 5 &#x2F; \\ 2 6 \\ \\ 4 7 思路一 首先，待删除的节点有三种情况 如果该节点是叶子节点，则直接删除 如果该节点的左右孩子只存在一个，则将其孩子节点与该节点交换位置，并删除叶子节点即可 如果该节点的左右孩子都存在，则选择左子树中的最小值或右子树中的最大值与其交换，删除叶子节点即可 整体思路是将待删除节点交换到叶子节点处执行删除操作 123456789101112131415161718def deleteNode(self, root: TreeNode, key: int) -&gt; TreeNode: def delete(root, key, l): # 树为空 if not root: return l # 删除根节点 if root.val == key: return delete(root.right, key, root.left) # 节点在右子树中 elif root.val &lt; key: root.right = delete(root.right, key, l) return root # 节点在左子树中 else: root.left = delete(root.left, key, l) return root return delete(root, key, None) 另一种写法 12345678910111213141516171819202122232425262728293031def deleteNode(self, root: TreeNode, key: int) -&gt; TreeNode: if not root: return Nonde # 去左子树中找 if root.val &gt; key: root.left = self.deleteNode(root.left, key) return root # 去右子树中找 elif root.val &lt; key: root.right = self.deleteNode(root.right, key) return root # 找到待删除节点 else: left = root.left right = root.right # 左子树为空，直接返回右子树 if not left: return root.right # 右子树为空，直接返回左子树 elif not right: return root.left # 左右子树都不为空，与右子树的最左节点（第一个比跟大的节点） # 删除，并将根节点的左子树代替其位置 # 返回该节点右子树的根节点 else: r = right while right.left: right = right.left right.left = left return r","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之找到字符串中所有字母异位词","slug":"Leetcode之找到字符串中所有字母异位词","date":"2020-07-29T01:16:07.000Z","updated":"2020-07-29T01:32:19.000Z","comments":true,"path":"passages/leetcode-zhi-zhao-dao-zi-fu-chuan-zhong-suo-you-zi-mu-yi-wei-ci/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zhao-dao-zi-fu-chuan-zhong-suo-you-zi-mu-yi-wei-ci/","excerpt":"Find All Anagrams in a String","text":"Find All Anagrams in a String Find All Anagrams in a String code with Python title number：438 读题 给定一个字符串s和一个非空字符串p，找到s中所有是p的字母异位词的子串，返回这些子串的起始索引 字符串只包含小写英文字母，并且字符串s和p的长度都不超过20100 示例 12345输入：s: \"cbaebabacd\" p: \"abc\"输出：[0, 6]解释：起始索引等于 0 的子串是 \"cba\", 它是 \"abc\" 的字母异位词起始索引等于 6 的子串是 \"bac\", 它是 \"abc\" 的字母异位词 思路一 所谓字母异位词，实际与567中的字符串的排列是相同的概念 子串中的字母没有顺序，因此我们可以使用字典来保存每个字母出现的次数 使用滑动窗口读取s中与p等长的子串，如果子串对应的字母出现的次数和p相同，那么子串就是p的字母异位词 注意，通过这种方式判断s的子串为p的异位词时，指针q所在的位置时子串的结束索引，可以通过q-l1+1计算得到子串的起始位置，也可以直接读取p所在的位置 123456789101112131415161718def findAnagrams(selfm s: str, p: str) -&gt; List[int]: res = [] l1, l2 = len(p), len(q) c1, c2 = collections.Counter(p), collections.Counter() p, q = 0, 0 while q &lt; l2: c2[s[q]] += 1 if c2 == c1: res.append(p) q += 1 if q - p + 1 &gt; l1: c2[s[p]] -= 1 if c2[s[q]] == 0: del c2[s[p]] p += 1 return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之字符串的排列","slug":"Leetcode之字符串的排列","date":"2020-07-28T00:55:35.000Z","updated":"2020-07-28T01:33:32.000Z","comments":true,"path":"passages/leetcode-zhi-zi-fu-chuan-de-pai-lie/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zi-fu-chuan-de-pai-lie/","excerpt":"Permutation in String","text":"Permutation in String Permutation in String code with Python title number：567 读题 给定两个字符串s1和s2，判断s2是否包含s1的排列 即：s1的排列之一是否是第二个字符串的子串 思路一 滑动窗口+哈希表 由于判断的是s1的排列是否为s2的子串，可以等价于s1中的元素是无序的，我们可以只统计字母出现的频次 使用滑动窗口遍历s2，并统计其中字母出现的频次 当子串长度不够时，向右移动滑动窗口的右边界，将最右边的字母的频次+1 当子串长度超过s1时，向右移动滑动窗口的左边界，并将左边的字母的频次-1 当子串与s1的哈希表相同时，则说明s2包含s1的排列 1234567891011121314151617181920def checkInclusion(self, s1: str, s2: str) -&gt; bool: l1, l2 = len(s1), len(s2) c1, c2 = collections.Counter(s1), collections.Counter() p, q = 0, 0 while q &lt; l2: c2[s2[q]] += 1 if c2 == c1: return True q += 1 # 当子串长度超过s1的长度 if q - p + 1 &gt; l1: c2[s2[p]] -= 1 if c2[s2[p]] == 0: del c2[s2[p]] p += 1 return False 思路二 字符哈希 + 滑动窗口 整体思路同思路一，优化哈希表结构 由于字母的数量是有限的，使用数组来存储字母出现的频次 使用s[i]-&#39;a&#39;的值作为数组下标 1234567891011121314151617181920def checkInclusion(self, s1: str, s2: str) -&gt; bool: l1, l2 = len(s1), len(s2) c1, c2 = [0]*26, [0]*26 p, q = 0, 0 # 统计s1 for i in s1: c1[ord(i)-ord('a')] += 1 while q &lt; l2: c2[ord(s2[q])-ord('a')] += 1 if c2 == c1: return True q += 1 if q - p + 1 &gt; l1: c2[ord(s2[p])-ord('a')] -= 1 p += 1 return False 思路三 其实在做比较时，我们无需每次都比较两个哈希表 维护一个变量，用来统计滑动窗口中频次与s1中相同的字母的个数 当滑动窗口中符合条件的字母的个数与s1中字母的个数相同，则返回True 123456789101112131415161718192021222324252627def countInclusion(self, s1: str, s2: str) -&gt; bool: l1, l2 = len(s1), len(s2) c1, c2 = collections.Counter(s1), collections.Counter() # 统计变量，全26个字母，频率相同的个数 cnt = 0 # 滑动窗口的左右边界 p, q = 0, 0 while q &lt; l2: c2[s2[q]] += 1 if c2[s2[q]] == c1[s2[q]]: cnt += 1 if cnt == len(c1): return True q += 1 if q - p + 1 &gt; l1: if c1[s2[p]] == c2[s2[p]]: cnt -= 1 c2[s2[p]] -= 1 if c2[s2[p]] == 0: del c2[s2[p]] p += 1 return False","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之斐波那契数","slug":"Leetcode之斐波那契数","date":"2020-07-27T00:38:17.000Z","updated":"2020-07-27T06:55:55.000Z","comments":true,"path":"passages/leetcode-zhi-fei-bo-na-qi-shu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-fei-bo-na-qi-shu/","excerpt":"Fibonacci Number","text":"Fibonacci Number Fibonacci Number code with Python title number：509 读题 斐波那契数，通常使用F(n)表示，形成的序列成为斐波那契数。 该数列有0和1开始，后面的每一项数字都是前面两项数字的和 即 12F(0) &#x3D; 0, F(1) &#x3D; 1F(N) &#x3D; F(N-1) + F(N-2), N &gt; 1 思路 递归 当N=0或N=1时，返回设定值 其他情况下的N返回F(N-1)和F(N-2)的和 1234567def fib(self, N: int) -&gt; int: if N == 0: return 0 if N == 1: return 1 return fib(N-1) + fib(N-2) 思路二 递归的时间复杂度太高了 采取记忆化的方式，存储前面已经计算过的值，减少递归带来的重复计算 首先是自底向上的方法 当N &lt;= 1时，返回N 否则迭代计算N，并存储在数组中 直接从记忆数组中读取N对应的值 1234567891011def fib(self, N: int) -&gt; int: if N &lt;= 1: return N return self.memorize(N)def memorize(self, N): cache = &#123;0:0, 1:1&#125; for i in range(2, N+1): cache[i] = cache[i-1] + cache[i-2] return cache[N] 思路三 仍然是记忆化的思路，这次是自顶向下的方法 如果N &lt;= 1，返回N 调用和返回memorize(N) 如果N对应的值存在，则直接返回 否则通过公式memorize(N-1) + memorize(N-2)，计算N对应的值 1234567891011def fib(self, N: int) -&gt; int: if N &lt;= 1: return N self.cache = &#123;0:0, 1:1&#125; return self.memorize(N)def memorize(self, N): if N in self.cache: return self.cache[N] self.cache[N] = self.memorize(N-1) + self.memorize(N-2) return self.memorize(N)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode周赛（199）","slug":"Leetcode周赛（199）","date":"2020-07-26T06:36:42.000Z","updated":"2020-07-27T00:29:25.000Z","comments":true,"path":"passages/leetcode-zhou-sai-199/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhou-sai-199/","excerpt":"Leetcode第199场周赛","text":"Leetcode第199场周赛 重新排列字符串 给定一个字符串s和一个长度相同的整数数组indices 重新排列字符串s，其中第i个字符需要移动到indices[i]指示的位置 返回重新排列后的字符串 思路一 翻译题目要求即可 创建一个空字符 使用index()定位i在indices中的位置 按顺序添加到字符串中即可 123456def restoreString(self, s: str, indeices: List[int]) -&gt; str: res = '' for i in range(len(s)): res += s[indices.index(i)] return res 顺便说一句，第一题太简单了不是什么好兆头，后面会让你怀疑人生 灯泡开关 房间中有n个灯泡，编号从0到n-1，自左向右排成一行。最开始的时候，所有的灯泡都是关着的 请你设法使得灯泡的开关状态和target描述的状态一致，其中target[i]等于1第i个灯泡是开着的，等于0意味着第i个灯是关着的 有一个开关可以用于翻转灯泡的状态，翻转操作定义如下： 选择当前配置下的任意一个灯泡（下标为 i ） 翻转下标从i到n-1的每个灯泡 翻转时，如果灯泡的状态为0就变为1，为1就变为0 返回达成target描述的状态所需的 最少 翻转次数 思路一 由于一次操作会反转后面的所有开关，即后一状态与前一状态相关，我们使用动态规划 使用dp数组存储中间信息 每个位置有两个状态：与目标相同，与目标相反；以第i个位置的 dp[i][0]表示从第i个灯泡到末尾转化为和目标状态相同需要的次数，且第i个灯泡当前状态为0 当target[i]==&#39;0&#39;时，无需改变，dp[i][0] = dp[i+1][0] 当target[i]==&#39;1&#39;，对第i个位置进行反转操作，dp[i][0] = dp[i+1][0] + 1 dp[i][1]表示从第i个灯泡到末尾转化为和目标状态相反需要的次数，且第i个灯泡当前状态为1 当target[i]==&#39;0&#39;时，对第i个位置进行反转操作，dp[i][1] = dp[i+1][0] + 1 当target[i]==&#39;1&#39;，无需改变，dp[i][0] = dp[i+1][1] 初始状态：dp[n][0] = dp[n][1] = 0 注意：因为开关影响的是后面的灯泡，所以需要从后往前遍历 123456789101112def minFlips(self, target: str) -&gt; int: dp = [[0]*2 for _ in range(len(target)+1)] # 从后向前 for i in range(len(target)-1, -1, -1): if target[i] == '0': dp[i][0] = dp[i+1][0] dp[i][1] = dp[i+1][0] + 1 if target[i] == '1': dp[i][0] = dp[i+1][1] + 1 dp[i][1] = dp[i+1][1] return dp[0][0] 好叶子节点对的数量 给定一棵二叉树和一个整数distance 如果二叉树中两个叶子节点之间的最短路径长度小于或等于distance，则这两个叶子节点就可以组成一组好叶子节点 路径长度指的是两个叶子节点相互到达需要经过的边的数量 返回好叶子节点对的数量 思路一 left保存左子树根节点到叶子节点的距离列表 right保存右子树根节点到叶子节点的距离列表 ans保存当前节点到叶子节点的距离列表，当left、right都为空时，说明该节点是叶子节点 当left和right都不为空时，寻找和小于等于distance的叶子对 由于left、right是左右子树的举例列表，因此需要+2 123456789101112131415161718192021222324252627282930313233def countPairs(self, root: TreeNode, distance: int) -&gt; int: self.cnt = 0 def dfs(node) -&gt; List[int]: if not node: return [] left = dfs(node.left) right = dfs(node.right) ans = [] if not left and not right: ans.append(0) elif left and not right: for num in left: ans.append(num+1) elif right and not left: for num in right: ans.append(num+1) else: for num in left: ans.append(num+1) for num in right: ans.append(num+1) for i in left: for j in right: if i+j+2 &lt;= distance: self.cnt += 1 retrun ans dfs(root) return self.cnt 压缩字符串Ⅱ 形成长度编码是一种常用的字符串压缩方法，它将连续的相同字符（重复2次或更多次）替换为字符和表示字符计数的数字（行程长度） 例如：用此方法压缩字符串aabccc，将aa替换为a2，ccc替换为c3，因此压缩之后的字符串变为a2bc3 注意，在单个字符之后不附加计数1 给定一个字符串s和一个整数k，你需要从字符串s中删除最多k个字符，以使s的形成长度编码长度最小 返回删除最多k个字符后，s行程长度编码的最小长度 示例： 123输入：s &#x3D; &quot;aaabccd&quot;, k &#x3D; 2输出：4解释：在不删除任何内容的情况下，压缩后的字符串是 &quot;a3bc3d&quot; ，长度为 6 。最优的方案是删除 &#39;b&#39; 和 &#39;d&#39;，这样一来，压缩后的字符串为 &quot;a3c3&quot; ，长度是 4 。 思路一 从示例中可以发现，优先删除重复次数少的字符可使总编码长度最小 因此，在可删除的字符个数k范围内，删除k个必定会导致最终编码长度最小 当我们删除了重复次数少的字符造成了编码长度的减小后，即使剩余的删除并不会完全删掉较多重复的字符，也不会影响最终编码长度最小 故，问题可转化为从字符串中选取n-k个字符，使编码长度最小 动态规划 定义dp[p][cnt] p表示从字符串的第p位开始 cnt表示当前已经选取了cnt个字符 状态转移 从当前的位置p开始向后遍历，只要发现后面又自负和s[p]相同，则选取 例如：当s = aabaaca, p=0，则我们可以从0位置开始选择5个a，再从之后的字符串中选取字符 状态转移方程为：dp[p][cnt] = min(calc(same) = dp[j+1][cnt+same]) same表示s[p:j]中和s[p]相同的字符的数量 calc(same)表示长度为same的连续字符的编码长度 转化一下，比较可操作的状态转移方程为 dp[p][cnt] = min(dp[p][cnt], dp[p+1][cnt]) 初始条件下，dp[p][T]=0 引用自题解，转移方程还不是很理解，代码后面补充","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之反转字符串","slug":"Leetcode之反转字符串","date":"2020-07-25T01:45:09.000Z","updated":"2020-07-25T01:57:26.000Z","comments":true,"path":"passages/leetcode-zhi-fan-zhuan-zi-fu-chuan/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-fan-zhuan-zi-fu-chuan/","excerpt":"Reverse String","text":"Reverse String Reverse String code with Python title number：344 读题 编写函数，将给定的字符串反转 不能额外为数组分配空间，必须原地修改数组，可使用O(1)的额外空间 思路一 递归 如果left &lt; right，则交换两指针指向的元素 再次调用函数本身，传入的left和right要分别右移和左移 递归的好处在于代码比较简单，但是由于函数需要不断调用自身，所需要的堆栈空间比较多（O(n)），并且花费的时间比较多 12345678def reverseString(self, s: List[int]) -&gt; None: def helper(left, right): if left &lt; right: s[left], s[right] = s[right], s[left] helper(left+1, right-1) helper(0, len(s)-1) 思路二 双指针 设置两个指针分别指向字符串的首部的尾部 在两指针相遇之前，交换两指针指向的元素，同时指针想内侧移动 使用双指针替代递归，空间复杂度达到了O(1) 1234567def reverseString(self, s: List[int]) -&gt; None: left, right = 0, len(s)-1 while left &lt; right: s[left], s[right] = s[right], s[left] left += 1 right -= 1","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Lintcode之背包问题（ⅠandⅡ）","slug":"Lintcode之背包问题（ⅠandⅡ）","date":"2020-07-24T02:34:59.000Z","updated":"2020-07-24T04:03:43.000Z","comments":true,"path":"passages/lintcode-zhi-bei-bao-wen-ti-iandii/","link":"","permalink":"http://zivblog.top/passages/lintcode-zhi-bei-bao-wen-ti-iandii/","excerpt":"背包问题，标准的01背包和完全背包问题，动态规划中有详细思路，此处仅做记录","text":"背包问题，标准的01背包和完全背包问题，动态规划中有详细思路，此处仅做记录 Backpack code with Python title number：92 题目 在n个物品中挑选若干物品装入背包，最多能装多满？ 假设背包大小为m，每个物品的大小为A[i] 思路 使用dp数组记录中间值 问题转化为前i个物品总体积不超过j的选法的集合，选对应的最大的价值 将每次第i个物品能不能选则作为集合划分标准 若选择第i个物品，则当前体积上限变为j-V_i，问题转化为前i-1个物品总体积不超过j-V_i的选法的集合 若不选择第i个物品，则当前体积上限仍为j，问题转化为前i-1个物品总体积不超过j的选法的集合 状态转移方程为dp[i][j] = dp[i-1][j-1]+A[i] or dp[i-1][j] 数组的每个位置使用布尔值来进行表示 1234567891011121314151617181920def backPcak(self, m, A): if len(A) == 0: return 0 dp = [[False]*(m+1) for _ in range(len(A)+1)] for i in range(len(A)+1): dp[i][0] = True for i in range(1, len(A)+1): for j in range(m+1): dp[i][j] = dp[i-1][j] if j &gt;= A[i-1]: dp[i][j] = dp[i-1][j-A[i-1]] or dp[i][j] res = 0 for z in range(m+1): if dp[len(A)][z] == True: res = z return res Backpack Ⅱ题目 有n个物品和一个大小为m的背包，给定数组A表示每个物品的大小和数组V表示每个物品的价值 问最多能装入背包的总价值有多大 思路 仍然是01背包问题（即一个物品只能选择拿或不拿） 使用dp数组表是前i个物品中可以放到容量为j的背包中的最大价值和 以第i个物品是否选择作为划分标准 如果选择第i个物品，则dp[i][j]=dp[i-1][j-A[i-1]]+V[i-1] 如果不选择第i个物品，则dp[i][j]=dp[i-1][j] 状态转移方程 dp[i][j] = max(dp[i][j], dp[i-1][j-A[i-1]]+V[i-1]) 1234567891011121314def backPackII(self, m, A, V): if len(A) == 0: return 0 dp = [[0]*(m+1) for _ in range(len(A)+1)] for i in range(1, len(A)+1): for j in range(1, m+1): dp[i][j] = dp[i-1][j] if j &gt;= A[i-1]: dp[i][j] = max(dp[i][j], dp[i-1][j-A[i-1]]+V[i-1]) return dp[-1][-1]","categories":[{"name":"Lintcode","slug":"Lintcode","permalink":"http://zivblog.top/categories/Lintcode/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"},{"name":"lintcode","slug":"lintcode","permalink":"http://zivblog.top/tags/lintcode/"}]},{"title":"Leetcode之编辑距离","slug":"Leetcode之编辑距离","date":"2020-07-23T01:08:57.000Z","updated":"2020-07-23T02:12:35.000Z","comments":true,"path":"passages/leetcode-zhi-bian-ji-ju-chi/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-bian-ji-ju-chi/","excerpt":"Edit Distance","text":"Edit Distance Edit Distance code with Python title number：72 读题 给定两个单词word1和word2，请你计算出将word1转化成word2所使用的最少操作数 你可以对一个单词进行如下三种操作 插入一个字符 删除一个字符 替换一个字符 示例 123456输入：word1 &#x3D; &quot;horse&quot;, word2 &#x3D; &quot;ros&quot;输出：3解释：horse -&gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)rorse -&gt; rose (删除 &#39;r&#39;)rose -&gt; ros (删除 &#39;e&#39;) 思路一 动态规划 对于双序列的动态规划我们都使用一个二维的矩阵来做状态表示 使用dp[i][j]表示word1前i个字符转化为word2前j个字符需要的最少步数 特殊的，我们要考虑word1和word2为空的情况，即另一个字符串全增加或全删除 定义dp[0][j]和dp[i][0]分别表示word1和word2为空的情况 对三种转移状态进行表示 插入字符，dp[i][j] = dp[i][j-1] + 1，表示把word1的前i-1个字符转化为word2的前j-1个字符，再将word2的第j个字符插入到尾部 删除字符，dp[i][j] = dp[i-1][j] + 1，表示删除掉word1的第i个字符，再将前i-1个字符转化为word2的前j个字符 替换字符，dp[i][j] = dp[i-1][j-1] + 1，表示把word1的前i-1个字符转化为word2的前j-1个字符，再将word1的第i个字符替换为word2的第j个字符 双循环进行遍历，每进行一次遍历，比较三种操作所需要的操作次数，取最小值，再+1 当word1[i] != word2[j]，dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1 当word1[i-1] == word2[j-1]是，可直接参考dp[i-1][j-1]，无需进行比较 12345678910111213141516171819def minDistance(self, word1: str, word2: str) -&gt; int: n1, n2 = len(word1), len(word2) dp = [[0]*(n2+1) for i in range(n1+1)] # 第一列 for j in range(1, n2+1): dp[0][j] = dp[0][j-1] + 1 # 第一行 for i in range(1, n1+1): dp[i][0] = dp[i-1][0] + 1 for i in range(1, n1+1): for j in range(1, n2+1): if word1[i-1] == word2[j-1]: dp[i][j] = dp[i-1][j-1] else: dp[i][j] = min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1]) + 1 return dp[-1][-1]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之分割回文串Ⅱ","slug":"Leetcode之分割回文串Ⅱ","date":"2020-07-22T01:08:20.000Z","updated":"2020-07-22T01:33:34.000Z","comments":true,"path":"passages/leetcode-zhi-fen-ge-hui-wen-chuan-ii/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-fen-ge-hui-wen-chuan-ii/","excerpt":"palindrome partitioning Ⅱ","text":"palindrome partitioning Ⅱ palindrome partitioning Ⅱ code with Python title number：132 读题 给定一个字符串S，将S分割成一些子串，使每个子串都是回文串 返回符合要求的最少分割次数 思路一 动态规划 使用min_cnt数组维护长度不同的字符串的最小分割次数 min_cnt[i]表示s[0:i]分割回文串的最小分割次数 min_cnt[i]默认为i，例如：s[0:0]只有一个字符，最少分割次数为0 使用dp数组维护任意子串是否为回文串 dp[i][j]表示s[i][j]是否为回文串 dp数组中值默认为False 穷举所有子串的边界情况，更新dp数组 当end - start &lt; 2时，必为回文数组 当s[start] == s[end]时，若dp[start+1][end-1]==True，则dp[start][end]=True（左右两段字符相同并且内部为回文串） 在子串为回文串的情况下 若start == 0，则说明当前回文串从下标0开始，无需切割，即min_cnt[end]=0 若start != 0，说明开始位置不是0，需要更新，取min_cnt[j]和上一回文串分割次数+1的较小值，即min_cnt[j] = min(min_cnt[j], min_cnt[i-1]+1) 12345678910111213141516171819def minCut(self, s: str) -&gt; int: min_cnt = list(range(len(s))) dp = [[False]*len(s) for _ in range(len(s))] for end in range(len(s)): for start in range(end + 1): # 当前情况为回文串 if s[start] == s[end] and (end - start &lt; 2 or dp[start+1][end-1]==True): dp[start][end] = True # 更新min_cnt if start == 0: min_cnt[end] = 0 else: min_cnt[end] = min(min_cnt[end], min_cnt[start-1]+1) return min_cnt[-1]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之最长上升子序列","slug":"Leetcode之最长上升子序列","date":"2020-07-21T01:30:47.000Z","updated":"2020-07-21T01:50:29.000Z","comments":true,"path":"passages/leetcode-zhi-zui-chang-shang-sheng-zi-xu-lie/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zui-chang-shang-sheng-zi-xu-lie/","excerpt":"Longest Increasing Subsequence","text":"Longest Increasing Subsequence Longest Increasing Subsequence code with Python title number：300 读题 给定一个无需的整数数组，找到其中最长上升子序列的长度 思路一 注意子序列与子串之间的区别 子序列中的元素在原字符串中不必相邻 子串是原字符串中的连续元素的组合 动态规划： 使用dp数组保存当前位置及之前的字符串中的最长上升子序列的长度 对于每一个位置，遍历其前方的所有dp元素 如果nums[j]&lt;nums[i]，则取dp[i]和dp[j]+1的较大值（前面的最长子序列的长度+当前元素） 最后取dp数组的最大值返回 1234567891011def lengthOfLIS(self, nums: List[int]) -&gt; int: if len(nums) == 0: return 0 dp = [1 for _ in range(len(nums))] for i in range(len(nums)): for j in range(i): if nums[j] &lt; nums[i]: dp[i] = max(dp[j]+1, dp[i]) return max(dp)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之爬楼梯","slug":"Leetcode之爬楼梯","date":"2020-07-20T01:44:26.000Z","updated":"2020-07-21T01:51:03.000Z","comments":true,"path":"passages/leetcode-zhi-pa-lou-ti/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-pa-lou-ti/","excerpt":"Climbing Stairs","text":"Climbing Stairs Climbing Stairs code with Python title number：70 读题 假设你需要爬n阶楼梯才能到达楼顶 每次你可以爬1或2个台阶，试计算可以有多少中方式爬到楼顶 n总不为0，是一个正整数 思路一 动态规划 使用dp数组记录到达当前位置的方法数 通过题目描述可以发现，到达任意位置的方法数仅与其前面的两个台阶有关（每次只能选择爬一个或两个台阶） 需要特殊处理前两个台阶（如果存在两个）：dp[0], dp[1] = 1, 2 返回数组中最后一个台阶对应的值即可 12345678910def climbStairs(self, n: int) -&gt; int: if n == 1: return 1 dp = [0] * n dp[0], dp[1] = 1, 2 for i in range(2, n): dp[i] = dp[i-1] + dp[i-2] return dp[-1] 因为当前位置的值至于前面两个位置的值有关，所以可以减少对空间的使用——仅使用两个变量存储前两个位置的值即可 整体思路同上，仅做代码复杂度优化 12345678910111213def climbStairs(self, n: int) -&gt; int: ''' r表示当前位置的值 p是前两位的值 q是前一位的值 ''' p, q, r = 0, 0, 1 for i in range(1, n+1): p = q q = r r = p + q return r 思路二 这是一道动态规划的简单题，尝试使用数学的方法解答 该问题的递推方程为$f(n) = f(n-1) + f(n-2)$ 写出其特征方程：$x^2 = x + 1$ 求得：$x_1 = \\frac{1+\\sqrt{5}}{2}, x_2 = \\frac{1 - \\sqrt{5}}{2}$ 设通解为：$f(n) = c_1x_1 + c_2x_2$ 将初始值f(1) = 1, f(2)=2带入通解中，解得：$c_1 = \\frac{1}{\\sqrt{5}}, c_2 = -\\frac{1}{\\sqrt{5}}$ 最终的通解为：$$f(n) = \\frac{1}{\\sqrt{5}}[(\\frac{1+\\sqrt{5}}{2})^2 - (\\frac{1-\\sqrt{5}}{2})^2]$$ 12345def climbStairs(self, n: int) -&gt; int: sqrt_5 = sqrt(5) fib_n = ((1+sqrt_5)/2)** (n+1) - ((1-sqrt_5)/2)**(n+1) return int(fib_n / sqrt_5)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode周赛（198）","slug":"Leetcode周赛（198）","date":"2020-07-19T05:15:48.000Z","updated":"2020-07-19T07:41:52.000Z","comments":true,"path":"passages/leetcode-zhou-sai-198/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhou-sai-198/","excerpt":"Leetcode第198场周赛","text":"Leetcode第198场周赛 换酒问题 小区便利店正在促销，用numExchange个空酒瓶可以兑换一瓶新酒 你购入了numBottles瓶酒 请问你最多可以喝到多少瓶酒 思路一 递归 每次传入现有的空瓶数量，交换规则，以及当前一共喝过多少瓶酒 递归求解，最终返回喝过的酒的总数 1234567891011121314151617181920class Solution: def change(self, k, exchange, sum_): ''' k：当前的空瓶数 exchange：交换规则 sum_：喝过的酒的瓶数 ''' if k &lt; exchange: return sum_ else: num = k // exchange remain = k % exchange sum_ += num return self.exchange(num+remain, exchange, sum_) def numWaterBottles(self, numBottles: int, numExchange: int) -&gt; int: return self.exchange(numBottles, numExchange, numBottles) 注意else分支中要有返回值，否则最后可能为None 思路二 数学解法 将每瓶内酒的价值视为2，将空瓶的价值视为1（整体价值为3） 注意至少最后有一个空瓶在手里什么也换不了 当倒数第二次换完一瓶后没有空瓶，则最后剩一个空瓶 当倒数第二次换完剩下一个空瓶，则最后剩两个空瓶 123def numWaterBottles(self, numBottles: int, numExchange: int) -&gt; int: return (numBottles * numExchange - 1) // (numExchange-1) 子树中标签相同的节点数 给定一棵树，树由编号0 ~ n-1的n个节点组成，且有n-1条边 树的根节点为节点0，树上的每个节点都有一个标签，也就是字符串labels中的一个小写字符（编号为i的节点对的标签就是labels[i]） 边数组edges以edges[i] = [ai, bi]的形式给出，该格式表示节点ai和bi之间存在一条边 返回一个大小为n的数组，其中ans[i]表示第一i个节点的子树中与节点i标签相同的节点数 示例 12输入：n &#x3D; 7, edges &#x3D; [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], labels &#x3D; &quot;abaedcd&quot;输出：[2,1,1,1,1,1,1] 思路一 因为子树是嵌套的，所以采取自底至顶的方式进行比较合适 edges的顺序是随机的，唯一能确定的就是edges[0]是包含0 首先遍历edges，记录下每个节点的父节点 按从底至顶的方式遍历节点 将每个节点的子树中的labels数组及其数量传递给父节点 123456789101112131415161718192021222324252627282930313233def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -&gt; List[int]: # father[i]为节点i的父节点 father = [-1 for i in eange(n)] # 顺序，在列表中越靠前的在树中越靠上 order = [0] # 若order中有i则saved[i]=True saved = [False] * n saved[0] = True # 遍历整个树，得到每个节点的父节点 for [head, tail] in edges: if saved[head]: father[tail] = head order.append(tail) saved[tail] = True else: father[head] = tail order.append(head) saved[i] = True # 为每个标签创建一个字典 counters = [Counter(labels[i]) for i in range(n)] order.reverse() for i in order: if i == 0: break for key in counters[i].keys(): # 将子节点的统计传给其父节点 counters[father[i]][key] += counters[i][key] # 依次得到每个编号对应的节点中对应标签的次数 return [counters[i][labels[i]] for i in range(n)] if saved[head]比if head in order快，不过需要占额外空间 思路二 树形DP 深度优先遍历，同时记录以当前节点为根的子树中每种字符的累计数值 根据节点编号读取以当前节点为根节点的子树中根节点label出现的次数 1234567891011121314151617181920212223242526272829def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -&gt; List[int]: link = &#123;&#125; # 遍历所有的边，建立映射字典 for a, b in edges: if a not in link: link[a] = [] if b not in link: link[b] = [] link[a].append(b) link[b].append(a) # key是节点的坐标值，value是以该节点为根的子树上所有节点的字符个数累计 char_cnt = &#123;&#125; def dfs(root, prev): root_counter = Counter() root_counter[labels[root]] = 1 # 当前节点信息的存储结构 char_cnt[root] = root_counter for child in link[root]: if child != prev: dfs(child, root) c = char_cnt[child] for ch in 'abcdefghijklmnopqrstuvwxyz': root_counter[ch] += c[ch] dfs(0, None) return [char_cnt[node][label[node]] for node in range(n)] 由于dp的时候需要记录当前节点子树中所有可能的字母的出现次数（26个字母），使用的额外空间比较多 补充 collections.Counter函数可用作计数 是实现dict的一个子类，得到的结果是一个字典 例如，统计一个字符串中每个单词出现的次数 123c = Counter('abcasdf')输出为：Counter(&#123;'a': 2, 'b': 1, 'c': 1, 's': 1, 'd': 1, 'f': 1&#125;) 最多的不重叠子字符串 给定一个只包含小写字母的子字符串s，要求找到s中最多数目的非空子字符串，满足以下条件： 子字符串之间互不重叠 如果一个子字符串包含字符c，则s中所有的字符c都要包含在该子字符串中 示例 1234567891011121314输入：s &#x3D; &quot;adefaddaccc&quot;输出：[&quot;e&quot;,&quot;f&quot;,&quot;ccc&quot;]解释：下面为所有满足第二个条件的子字符串：[ &quot;adefaddaccc&quot; &quot;adefadda&quot;, &quot;ef&quot;, &quot;e&quot;, &quot;f&quot;, &quot;ccc&quot;,]如果我们选择第一个字符串，那么我们无法再选择其他任何字符串，所以答案为 1 。如果我们选择 &quot;adefadda&quot; ，剩下子字符串中我们只可以选择 &quot;ccc&quot; ，它是唯一不重叠的子字符串，所以答案为 2 。同时我们可以发现，选择 &quot;ef&quot; 不是最优的，因为它可以被拆分成 2 个子字符串。所以最优解是选择 [&quot;e&quot;,&quot;f&quot;,&quot;ccc&quot;] ，答案为 3 。不存在别的相同数目子字符串解。 思路一 对字符串进行一次遍历，记录每个字符最早和最晚出现的位置 组合两个数组，最终得到一个长度之多为26的数组，例：[(s, e)]记录的是a出现的区间 进行去重操作 使用动态规划进行求解 问题为区间的不相交问题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253def maxNumOfSubstrings(self, s: str) -&gt; List[str]: start = [-1] * 26 end = [-1] * 26 for i in range(len(s)): c = s[i] tmp = ord(c) - ord('a') # 当前字母第一次出现的位置 if start[tmp] == -1: start[tmp] = i # 当前字母最后又一次出现的位置 end[tmp] = i pos = [(-1, -1)] * 26 for i in range(26): l, r = start[i], end[i] if r == -1: continue cur = set(s[start[i]: r+1]) seen = set() while cur: seen |= cur for nxt in cur: r = max(r, end[ord(nxt)-ord('a')]) l = min(l, start[ord(nxt)-ord('a')]) cur = set(s[l: r+1]) - seen pos[i] = (l, r) pos = set(pos) pos = sorted(list(pos)) n = len(pos) def dp(i, e): if i &gt;= n: return [] res = dp(i+1,e) if pos[i][0] &gt; e: tmp = [i] + dp(i+1,pos[i][1]) else: return res if not res: return tmp if len(tmp) &gt; len(res): return tmp elif len(tmp) == len(res): if sum([pos[j][1]-pos[j][0] for j in tmp]) &lt; sum([pos[j][1]-pos[j][0] for j in res]): return tmp return res return [s[pos[i][0]:pos[i][1]+1] for i in dp(0,-1)] 还有几个点不是很通透，后面补充 找到最接近目标值的函数值 Winston构造了一个如下所示的函数 12345678def func(arr, l, r): if r &lt; l: return -1000000000 ans = arr[l] for i in range(l, r+1): ans = ans &amp; arr[i] return ans 现有一个整数数组arr，和一个整数target 找到让|func(arr, l, r) - target|最小的l和r 返回|func(arr, l, r) - target|的最小值 思路一 最暴力的思路是： 穷举所有的区间情况，计算该区间内元素对应的func值 与target作差取绝对值 比较得到最小值 这种情况是肯定会超时的（要对得起hard的难度），我们要对其进行优化 将数组中相邻且相同的元素进行合并（对&amp;操作的结果没有影响） 当函数求&amp;的值小于target时，则无需继续进行操作（&amp;之后得到的值只会更小） 函数得到的值越小，与target作差再取绝对值的结果只会更大 即要求满足条件的最小值，只能从func计算得到的比target更大的值中选择 123456789101112131415161718192021def closestToTarget(self, arr: List[int], target: int) -&gt; int: # 相邻且相同的值去重 new_arr = [] for i in range(len(arr)): if not new_arr or new_arr[-1] != arr[i]: new_arr.append(arr[i]) arr = new_arr ans = abs(-10**9 - target) for l in range(len(arr)): cur = ~0 for r in range(l, len(arr)): cur &amp;= arr[r] ans = min(ans, abs(cur - target)) # 如果ans小于target，跳出 if cur &lt;= target: break if ans == 0: break return ans 思路二 数位DP 对当前二进制从高位到低位枚举，目前为止选择区间[l, r]的与结果f(index, l, r)，target只取从高位32到index的值g(index) 如果f(index, l, r) &gt; g(index)，取所有[l, r]的数字，因为从index到0的bit位能取到的最小值就是[l, r]中所有的数字与的结果 如果f(index, l, r) &lt; g(index)，当前位如果能取1到1，否则才取0 如果f(index, l, r) = g(index)，当前位取0或1都可以 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364def closestToTarget(self, A: list[int], target: int) -&gt; int: def bitset(val, index): return val &amp; (1 &lt;&lt; index) &gt; 0 def setbit(val, index): return val | (1 &lt;&lt; index) def getones(index, start, end): l, r = start, start ones = [] while r &lt;= end: if not bitset(A[i], index): if r &gt; l: ones.append((l, r - 1)) l = r + 1 r += 1 if r &gt; 1: ones.append((l, r - 1)) return ones INF = 10**9 + 7 def dfs(index, state, start, end, op): if start &gt; end: return INF if index &lt; 0: return abs(state - target) if start == end: return abs(A[start] - target) if op &gt; 0: rest = (1 &lt;&lt; (index + 1)) - 1 for i in range(start, end+1): rest &amp;= A[i] state |= rest return abs(state - target) ans = INF cv = bitset(target, index) ones = getones(index, start, end) nstate = setbit(state, index) if op == 0: # set current bit to one ans = min(ans, min([dfs(index - 1, nstate, l, r, 0 if cv else 1) for l, r in ones] or [INF])) # if current bit of some value is 0 if any([not bitset(A[i], index) for i in range(start, end + 1)]): # bitwise and of all value in A == 0 ans = min(ans, dfs(index - 1, state, start, end, -1 if cv else 0)) elif op &lt; 0: # always choose 1 for current bit ans = min(ans, min([dfs(index - 1, nstate, l, r, -1) for l, r in ones] or [INF])) if not ones: ans = min(ans, dfs(index - 1, state, start, end, -1)) return ans ans = dfs(31, 0, 0, len(A) - 1, 0) return ans","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之不同路径Ⅱ","slug":"Leetcode之不同路径Ⅱ","date":"2020-07-18T05:07:32.000Z","updated":"2020-07-18T05:49:34.000Z","comments":true,"path":"passages/leetcode-zhi-bu-tong-lu-jing-ii/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-bu-tong-lu-jing-ii/","excerpt":"Unique Paths Ⅱ","text":"Unique Paths Ⅱ Unique Paths Ⅱ code with Python title number：63 读题 一个机器人位于一个m * n的网格的左上角，试图到达网格的右下角 机器人每次只能向下或向左移动一步 网格之中存在障碍物，计算从左上角到右下角将会有多少条不同的路径 思路一 使用dp数组记录从左上角到达该位置的路径数 dp[i][j] = dp[i-1][j] + dp[i][j-1] 有两个特殊的位置，即第一行和第一列（它们只有来自一个方向的路径） 第一行：dp[i][0] = dp[i-1][0] 第一列：dp[0][i] = dp[0][i-1] 若当前位置是障碍物，则能到达当前位置的路径数为0 12345678910111213141516171819202122232425def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -&gt; int: height, width = len(obstacleGrid), len(obstacleFrid[0]) if obstacleFrid[0][0] == 1: return 0 dp = [[0 for _ in range(width)] for _ in range(height)] dp[0][0] = 1 # 第一列 for i in range(1, height): if obstacleGrid[i][0] == 0: dp[i][0] = dp[i-1][0] # 第一行 for i in range(1, width): if obstacleGrid[0][i] == 0: dp[0][i] = dp[0][i-1] for i in range(1, height): for j in range(1, width): if obstacleGrid[i][j] == 1: dp[i][j] = 0 else: dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[-1][-1]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之最小路径和","slug":"Leetcode之最小路径和","date":"2020-07-17T01:45:38.000Z","updated":"2020-07-18T05:17:12.000Z","comments":true,"path":"passages/leetcode-zhi-zui-xiao-lu-jing-he/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zui-xiao-lu-jing-he/","excerpt":"Minimum Path Sum","text":"Minimum Path Sum Minimum Path Sum code with Python title number：64 读题 给定一个包含非负整数的m * n的网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小 每次只能向下或向右移动一步 思路一 使用dp数组保存由左上角到当前位置的最小值 由于当前位置只能由左侧和上方的位置到达，只需要比较两者所保存的dp值的大小，加上grid当前位置的大小 dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] 最终结果保存在dp[m-1][n-1]中 由于需要通过访问每个位置的前一行和前一列的元素，有两个位置需要单独处理 第一行中的元素只能由左侧位置到达，dp[i][j] = dp[i][j-1] + grid[i][j] 第一列中的元素只能由上方位置到达，dp[i][j] = dp[i-1][j] + grid[i][j] 123456789101112131415161718192021def minPathSum(self, grid: List[List[int]]) -&gt; int: m, n = len(grid), len(grid[0]) dp[[0 for _ in range(n)] for _ in range(m)] dp[0][0] = grid[0][0] for i in range(m): # 第一行 if i == 0: for j in range(1, n): dp[i][j] = dp[i][j-1] + grid[i][j] else: for j in range(n): # 第一列 if j == 0: dp[i][j] = dp[i-1][j] + grid[i][j] else: dp[i][j] = min(dp[i][j-1], dp[i-1][j]) + grid[i][j] return dp[m-1][n-1] 优化一下代码结构 与思路一的主体思路相同，改变一下数据结构 直接在grid上进行修改，不使用额外的数据结构保存中间结果 通过grid[-1][-1]访问最终结果 12345678910111213def minPathSum(self, grid: List[List[int]]) -&gt; int: for i in range(grid): for j in range(len(grid[0])): if i == j == 0: continue elif i == 0: grid[i][j] = grid[i][j-1] + grid[i][j] elif j == 0: grid[i][j] = grid[i-1][j] + grid[i][j] else: grid[i][j] = min(grid[i-1][j], grid[i][j-1]) + grid[i][j] return grid[-1][-1]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之三角形最小路径和","slug":"Leetcode之三角形最小路径和","date":"2020-07-16T01:59:50.000Z","updated":"2020-07-16T02:53:11.000Z","comments":true,"path":"passages/leetcode-zhi-san-jiao-xing-zui-xiao-lu-jing-he/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-san-jiao-xing-zui-xiao-lu-jing-he/","excerpt":"Triangle","text":"Triangle Triangle code with Python title number：120 读题 给定一个三角形，找出自顶向下的最小路径和 规定每一步只能移动到下一行中相邻的结点上 相邻结点指：下标与上层节点的下标相同或上层节点下标+1的两个节点 示例： 1234567[ [2], [3,4], [6,5,7], [4,1,8,3]]自顶向下的最小路径和为11，即 2-&gt;3-&gt;5-&gt;1 其实，将给定的示例转化一下更容易理解 123456[ [2], [3,4], [6,5,7], [4,1,8,3]] 思路一 使用dp数组保存每次移动的最小值，自顶向下 按照上面的示例，在dp数组中保存的结果2 -&gt; 5 -&gt; 10 -&gt; 11 对于在三角形的任意一层中的某个位置，只有两个位置可以移动 反过来说，三角形中的每个位置，有至多两个位置可以到达该位置 我们只需比较这两个位置的dp值大小，即可选择经过当前位置的最小路径 dp[i][j] = min(dp[i-1][j-1], dp[i-1][j]) + triangle[i][j] 此外，三角形中的两个特殊路径需要单独处理 第一列列，即每行只有一个元素，这种需要单独计算 在使用dp[i-1][j-1]取斜上方的dp值时会越界 dp[i][0] = dp[i-1][0] + triangle[i][0] 斜边，也只有一条路径，下一层的横坐标在上一层的基础上右移一格i+1, j+1 在使用dp[i-1][j]取上方的dp值时会越界 dp[i][j] = dp[i-1][j-1] + triangle[i][j] 最终获取dp数组最后一行的最小值即可 1234567891011121314151617181920def minimumTotal(self, triangle : List[List[int]]) -&gt; int: if not triangle: return 0 dp = [[0 for _ in range(len(triangle[-1]))] for _ in range(len(triangle))] dp[0][0] = triangle[0][0] # 第一列单独处理 for i in xrange(1, n): dp[i][0] = dp[i-1][0] + triagnle[i][0] # 自顶向下 for i in xrange(1, n): j = 1 while j &lt; len(triangle[i])-1: dp[i][j] = min(dp[i-1][j-1], dp[i-1][j]) + triagle[i][j] j += 1 # 斜边单独计算 dp[i][j] = dp[i-1][j-1] + triangle[i][j] # 返回最后一行的最小值 return min(dp[-1]) 思路二 使用dp数组保存每次移动的最小值，自底向上 按照上面的示例，在dp数组中显式的路径为1 -&gt; 6 -&gt; 9 -&gt; 11 同自顶向下的想法 每个位置都有两个下层的位置可以到达，需要比较两个的大小，取其中一个 dp[i][j] = min(dp[i+1][j+1], dp[i+1][j]) + triangle[i][j] 不同之处在于 自底向上的方式将结果保存在了dp[0][0]中，不需要遍历最后一行取最小值 为了处理边界（最底层一行），需要在dp数组中添加一行 无需处理第一列和斜边这两种特殊情况 1234567891011def minimumTotal(self, triangle: List[List[int]]) -&gt; int: if not triangle: return 0 dp = [[0 for _ in range(len(triangle[-1])+1)] for _ in range(len(triangle)+1)] # 自底向上 for i in range(len(triangle)-1, -1, -1): for j in range(len(triangle[i])-1, -1, -1): dp[i][j] = min(dp[i+1][j+1], dp[i+1][j]) + triangle[i][j] return dp[0][0]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"快速排序","slug":"快速排序","date":"2020-07-15T12:13:26.000Z","updated":"2020-07-15T12:24:38.000Z","comments":true,"path":"passages/kuai-su-pai-xu/","link":"","permalink":"http://zivblog.top/passages/kuai-su-pai-xu/","excerpt":"快速排序","text":"快速排序 快速排序 从数列中挑出一个元素作为”基准“（通常会选择数列的第一个元素） 重新排序数列，将比基准小的放到基准的前面，比基准大的元素放到基准的后面，此时”基准“位于数组的中间（即完成了对基准的排序） 递归进行，将基准左侧和右侧的子数列按上述方式操作 知道子数列的长度为0或1的时候，跳出递归，此时数组已排列完毕 12345678910def quick_sort(self, nums: List[int]) -&gt; List[int]: if len(nums) &lt; 2: return nums else: # 选择基准 pivot = nums[0] less = [i for i in nums[1:] if i &lt;= pivot] greater = [i for i in nums[1:] if i &gt; pivot] return quick_sort(less) + [pivot] + quick_sort(greater)","categories":[{"name":"算法","slug":"算法","permalink":"http://zivblog.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"基数排序","slug":"基数排序","date":"2020-07-15T12:02:33.000Z","updated":"2020-07-19T05:17:26.000Z","comments":true,"path":"passages/ji-shu-pai-xu/","link":"","permalink":"http://zivblog.top/passages/ji-shu-pai-xu/","excerpt":"基数排序","text":"基数排序 基数排序 基数排序是一种非比较排序算法 将所有待排序元素（必须是非负整数）统一为位数相同的整数，位数较少的前面补零 从最低位开始，依次进行依次稳定排序；后面更高位的排序是在前面排序结果的基础上进行的 直到最高位排序完成之后，整个序列就变成了一个有序序列 时间复杂度：O(n) 空间复杂度：O(n+k) 1234567891011def RadixSort(self, nums: List[int], d: int) -&gt; List[int]: # 数字的位数，即排序轮数 for k in range(d): # 0~9，共10个桶 s = [[] for _ in range(10)] # 将第K位放到桶中 for i in nums: s[i // (10**k) % 10].append(i) # 按当前桶的顺序重新排列数组 nums = [j for i in s for j in i] return nums 与桶排序相比： 桶排序是在max-min之间划分出多个区间，将元素先划分到不同的区间中，对区间中的元素进行排序，再将其结合 基数排序可以看作是多轮桶排序，每个位数上都进行一轮桶排序","categories":[{"name":"算法","slug":"算法","permalink":"http://zivblog.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"归并排序","slug":"归并排序","date":"2020-07-15T08:40:44.000Z","updated":"2020-07-15T08:50:27.000Z","comments":true,"path":"passages/gui-bing-pai-xu/","link":"","permalink":"http://zivblog.top/passages/gui-bing-pai-xu/","excerpt":"归并排序","text":"归并排序 归并排序 采用分治的思想，将原问题划分为多个规模较小而结构相似的子问题，最终合并结果，得到原问题的解 使用递归将原数组转化为多个子列 申请空间将两个子列排序合并 将所有子列一步步合并，最终完成排序 常见的即二路归并（每次排序合并相邻的两个子序列） 时间复杂度： 最好时间复杂度：O(nlog2n) 最坏时间复杂度：O(nlog2n) 平均时间复杂度：O(nlog2n) 空间复杂度，O(1) 123456789101112131415161718192021222324def merge_sort(self, nums: List[int]) -&gt; List[int]: if len(nums) == 1: return nums mid = len(nums) // 2 left = nums[:mid] right = nums[mid:] # 递归分割 &amp; 合并 return merge(merge_sort(left), merge_sort(right)) def merge(left, right): '''合并传入的两个子数组并排序''' result = [] while len(left) &gt; 0 and len(right) &gt; 0: if left[0] &lt;= right[0]: result.append(left.pop(0)) else: result.append(right.pop(0)) # 某个子数组中可能还有元素 result += left resule += right return result","categories":[{"name":"算法","slug":"算法","permalink":"http://zivblog.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"冒泡排序","slug":"冒泡排序","date":"2020-07-15T08:26:32.000Z","updated":"2020-07-15T08:40:17.000Z","comments":true,"path":"passages/mou-pao-pai-xu/","link":"","permalink":"http://zivblog.top/passages/mou-pao-pai-xu/","excerpt":"冒泡排序","text":"冒泡排序 冒泡排序 从第一个开始和第二个比较，如果第一个比第二个大（小），则将其交换位置 然后比较第二个和第三个，…… 经过一轮后可以将最大（小）的元素排到最后 重复上述过程，可在第i趟的时候将第i大（小）的元素排在倒数第i个位置上，从而使整个数组有序 时间复杂度 最好时间复杂度，O(n) 最坏时间复杂度，O(n^2) 平均时间复杂度，O(n^2) 空间复杂度，O(1) 12345678def bubble_sort(self, nums: List[int]) -&gt; List[int]: # 控制循环的次数 for i in range(len(nums)-1): # 控制相邻元素的比较和交换 for j in range(len(nums) - 1 - i): if nums[j] &gt; nums[j + 1]: nums[j], nums[j+1] = nums[j+1], nums[j] return nums","categories":[{"name":"算法","slug":"算法","permalink":"http://zivblog.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"希尔排序","slug":"希尔排序","date":"2020-07-15T08:10:03.000Z","updated":"2020-07-15T08:24:58.000Z","comments":true,"path":"passages/xi-er-pai-xu/","link":"","permalink":"http://zivblog.top/passages/xi-er-pai-xu/","excerpt":"希尔排序","text":"希尔排序 希尔排序 希尔排序的思想是将固定间隔的几个元素之间排序，不断缩小这个间隔，最后数列就成为了有序数列 计算一个增量值（间隔） 按照增量对元素进行分组并组内排序 当前增量下的所有分组内元素排序完毕后，对增量进行调整（一般为缩小到原来的一半） 进行完增量为1的分组排序后，结果即为最终结果 时间复杂度 时间复杂度与步长的选择有关 通常认为希尔排序的时间复杂度为O(n^1.5) 空间复杂度 O(1) 不稳定的排序算法 两个相同的数可能因为分组的不同而发生相对位置的改变 1234567891011121314151617181920def shell_sort(self, nums: list[int]) -&gt; List[int]: # 计算增量 gap = len(nums) // 2 while gap &gt; 0: # 按增量值开始遍历比较 # 分组内元素的排序使用直接插入排序 for i in range(gap, len(nums)): j = i current = nums[i] while j - gap &gt;= 0 and current &lt; nums[j - gap]: # 将不合适的向后移 nums[j] = nums[j - gap] # 往前比较下一个元素 j -= gap # 插入合适的位置 nums[j] = current # 缩小增量值 gap //= 2 return nums","categories":[{"name":"算法","slug":"算法","permalink":"http://zivblog.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"直接插入排序","slug":"直接插入排序","date":"2020-07-15T07:57:05.000Z","updated":"2020-07-15T08:09:52.000Z","comments":true,"path":"passages/zhi-jie-cha-ru-pai-xu/","link":"","permalink":"http://zivblog.top/passages/zhi-jie-cha-ru-pai-xu/","excerpt":"直接插入排序","text":"直接插入排序 直接插入排序 初始状态，将第一个元素是做已经被排序的元素 取出下一个元素，在已经排序的元素序列中从前向后扫描 如果该元素大于新元素，则将该元素移到下一位置 知道找到已排序的元素小于或等于新元素的位置，将新元素插入到该位置的后面 时间复杂度 最好时间复杂度：O(n) 最差时间复杂度：O(n^2) 平均时间复杂度：O(n^2) 空间复杂度 O(1) 稳定的排序算法 1234567891011121314def insertion_sort(self, nums: List[int]) -&gt; List[int]: # 控制循环插入的次数 for i in range(1, len(nums)): # 需要插入的元素 current = nums[i] # 有序区的最后一个元素 pre_index = i - 1 # 逆向遍历比较 while pre_index &gt;= 0 and nums[pre_index] &gt; current: nums[pre_index + 1] = nums[pre_index] pre_index -= 1 # 插入元素到合适的位置 nums[pre_index + 1] = current return nums","categories":[{"name":"算法","slug":"算法","permalink":"http://zivblog.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"堆排序","slug":"堆排序","date":"2020-07-14T04:06:32.000Z","updated":"2020-07-15T08:05:09.000Z","comments":true,"path":"passages/dui-pai-xu/","link":"","permalink":"http://zivblog.top/passages/dui-pai-xu/","excerpt":"堆排序","text":"堆排序 堆排序 对排序是指利用堆这种数据结构进行排序算法 堆类似于一个完全二叉树的结构，并且满足子节点的值总小于或大于它的父节点的值 这样，堆顶的值一定是当前堆中最大的或最小的，我们也正是将此性质用作排序 堆排序算法如下（结果为升序排列）： 初始无序区为R1……Rn，初始有序区为空 将无序区调整为大顶堆，将堆顶元素与最后一个元素交换 这样有序区为R_max，无序区还剩n-1个元素 再次将无序区调整为大顶堆，将堆顶元素与倒数第二个元素交换 …… 直到无序区为空，排序完成 注意： 要得到升序序列，使用大顶堆 要得到降序序列，使用小顶堆 堆排序的时间复杂度为O(nlogn) 每次进行堆调整需要的时间为O(logn) 空间复杂度为O(1) 交换时需要一个暂存空间 不稳定的排序算法 12345678910111213141516171819202122232425262728293031323334353637def HeapSort(self, nums: List[int]) -&gt; List[int]: def heapAdjust(arr, start, end): temp = arr[start] son = 2 * start + 1 while son &lt; end: # 找到左右孩子中较大的节点 if son &lt; end and arr[son] &lt; arr[son + 1]: son += 1 # 判断是否符合大顶堆 if temp &gt;= arr[son]: break # 子节点上移 arr[start] = arr[son] # 继续向下比较 start = son son = 2 * son + 1 # 将原堆顶插入正确位置 arr[start] = temp n = len(nums) if n &lt;= 1: return nums # 完全二叉树中的最后一个非叶子节点 root = n // 2 -1 while root &gt;= 0: heapAdjust(nums, root, n-1) root -= 1 i = n -1 while i &gt;= 0: # 交换堆顶与第i个元素 nums[0], nums[i] = nums[i], nums[0] heapAdjust(nums, 0, i-1) i -= 1 return nums","categories":[{"name":"算法","slug":"算法","permalink":"http://zivblog.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"简单选择排序","slug":"简单选择排序","date":"2020-07-14T03:19:19.000Z","updated":"2020-07-15T08:04:39.000Z","comments":true,"path":"passages/jian-dan-xuan-ze-pai-xu/","link":"","permalink":"http://zivblog.top/passages/jian-dan-xuan-ze-pai-xu/","excerpt":"简单选择排序","text":"简单选择排序 简单选择排序 第i次遍历 从待排序的数据元素中选择最小（最大）的元素 将其与数组中第i个位置进行交换 直到待排序部分为空 时间复杂度： 最好的情况下O(n)（数组有序） 最坏的情况为O(n^2)（数组降序，要求升序排列） 平均的情况为O(n^2) 空间复杂度为O(1)，即进行数据交换时的过渡空间 不稳定的排序算法 12345678910111213def SelectSort(self, nums: List[int]) -&gt; List[int]: n = len(nums) if n &lt;= 1: return nums for i in range(n - 1): minIndex = i for j in range(i+1, n): if nums[j] &lt; nums[minIndex]: minIndex = j if minIndex != i: nums[minIndex], nums[i] = nums[i], nums[minIndex] return nums 需要注意的是，与简单插入排序相比 简单插入排序初始将第一个元素视为有序部分，每一趟将一个元素插入有序部分（不是第i大） 简单选择排序是每次将第i大的元素与第i个位置进行交换","categories":[{"name":"算法","slug":"算法","permalink":"http://zivblog.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之搜索旋转排序数组Ⅱ","slug":"Leetcode之搜索旋转排序数组Ⅱ","date":"2020-07-13T11:37:50.000Z","updated":"2020-07-13T12:24:06.000Z","comments":true,"path":"passages/leetcode-zhi-sou-suo-xuan-zhuan-pai-xu-shu-zu-ii/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-sou-suo-xuan-zhuan-pai-xu-shu-zu-ii/","excerpt":"Search in Rotated Sorted Array Ⅱ","text":"Search in Rotated Sorted Array Ⅱ Search in Rotated Sorted Array Ⅱ code with Python title number：81 读题 假设按照升序排序的数组在预先位置的某个点上进行了旋转 编写函数来判断给定的目标值是否存在于数组中 若存在则返回True，若不存在则返回False 数组中可能存在重复数字 思路一 延续上一题的思路 使用二分搜索，减少对数组中元素的判断次数，从而降低时间复杂度 我们知道旋转后的排序数组是由两个升序子数组组成的，并且两个子数组的长度必定有一个小于len(nums) / 2 通过比较nums[mid]和nums[start]的大小可以确定nums[mid]所在的位置，从而选择mid左边或者右边舍弃 如果nums[mid]&gt;=nums[start]，则nums[mid]位于左边的有序子数组中 如果nums[mid]&lt;nums[start]，则nums[mid]位于右边的有序子数组中 target位置的确定只需比较target和有序部分边界的大小关系即可 若nums[mid] == nums[start] == nums[end]，将左右指针分别向内移动一个位置 若nums[mid] &gt; nums[start]，说明mid在做边的子序列中 若此时nums[start] &lt;= target &lt; nums[mid]，则说明target在[start, mid]中，令end = mid -1 否则，令start = mid + 1 若nums[mid] &lt; target &lt;= nums[end], 说明target在右子序列中 若此时nums[mid] &lt; target &lt; nums[end]，则说明target在[mid, end]之间，令start = mid + 1 否则，令end = mid - 1 12345678910111213141516171819202122def search(self, nums: List[int], target: int) -&gt; bool: l, r = 0, len(nums) - 1 while l &lt;= r: mid = (l + r) // 2 if nums[mid] == target: return True if nums[mid] == nums[l] == nums[r]: l += 1 r -= 1 elif nums[mid] &gt;= nums[l]: if nums[l] &lt;= target &lt; nums[mid]: r = mid - 1 else: l = mid + 1 else: if nums[mid] &lt; target &lt;= nums[r]: l = mid + 1 else: r = mid - 1 return False","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode周赛（197）","slug":"Leetcode周赛（197）","date":"2020-07-12T03:49:49.000Z","updated":"2020-07-14T03:18:41.000Z","comments":true,"path":"passages/leetcode-zhou-sai-197/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhou-sai-197/","excerpt":"第197周周赛","text":"第197周周赛 前言 第一次参加周赛，AC了两道（easy+medium）,另外一道medium超时了，hard直接没思路……，我太菜了 大神们都20min+全部AC，哭liao~ 向前排大佬学习一下，对比自己和他们思路上的差别（我还是太喜欢暴力了） 题目好数对的数目（Easy）题目 给你一个整数数组 nums 如果一组数字 (i,j) 满足 nums[i] == nums[j] 且 i &lt; j ，就可以认为这是一组 好数对 。 返回好数对的数目 思路 这道题的思路很简单，使用双指针进行数组的遍历即可 当两个指针指向的元素值相等时，则为一对好数对 注意两指针不能指向同一个元素 1234567891011class Solution: def numIdenticalPairs(self, nums: List[int]) -&gt; int: res = 0 for i in range(len(nums)): for j in range(i, len(nums)): if nums[i] == nums[j] and i != j: print(i, j) res += 1 return res 仅含1的子串数（Medium）题目 给定一个二进制字符串s（仅由0和1组成的字符串） 返回所有字符都为1的子字符串的个数 由于答案可能很大，请将其对10 ^ 9 + 7取模后返回 我的思路 连续的n个1可以组成的关于1的子字符串的个数为 123451个长为n的子字符串2个长为n-1的子字符串...n-1个长为2的子字符串n个长为1的子字符串 故，只需要统计有多少个连续为1的子字符串的长度即可 由连续1产生的子字符串是可以通过计算1~n的累加和得到 123456789101112131415161718192021222324252627class Solution: def numSub(self, s: str) -&gt; int: res = 0 one_array = [] cnt = 0 def count_(num): sum_ = 0 for i in range(1, num+1): sum_ += i return sum_ for i in range(len(s)): if s[i] == '1': cnt += 1 else: if cnt != 0: one_array.append(cnt) cnt = 0 if cnt != '0': one_array.append(cnt) sum_ = 0 for num in one_array: sum_ += count_(num) return sum_ % (10**9 + 7) 哦……，要记得做最后的取模运算 概率最大的路径（Medium）题目 给你一个由 n 个节点（下标从 0 开始）组成的无向加权图，该图由一个描述边的列表组成，其中 edges[i] = [a, b] 表示连接节点 a 和 b 的一条无向边，且该边遍历成功的概率为 succProb[i] 。 指定两个节点分别作为起点 start 和终点 end ，请你找出从起点到终点成功概率最大的路径，并返回其成功概率。 如果不存在从 start 到 end 的路径，请 返回 0 。只要答案与标准答案的误差不超过 1e-5 ，就会被视作正确答案。 我的思路（超时） 将用边表示的图转化为以节点表示的图（原谅我只会以节点表示的图的深度优先搜索……） 进行深度优先搜索，得到所有start和end之间的路径 遍历路径，拿到边对应的权值，计算路径的概率 比较得到最终概率最大的路径 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class Solution: def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -&gt; float: def build_graph(edges): graph = &#123;&#125; for edge in edges: left, right = edge[0], edge[1] if left not in graph: graph[left] = [right] else: graph[left].append(right) if right not in graph: graph[right] = [left] else: graph[right].append(left) return graph def find_all_path(graph, start, end, path = []): if start not in graph: return [] path = path + [start] if start == end: return [path] paths = [] for node in graph[start]: if node not in path: newpaths = find_all_path(graph, node, end, path) for newpath in newpaths: paths.append(newpath) return paths def cal_max_prob(paths, edges, succProb): max_prob = float(0) if paths == []: return max_prob for path in paths: prob = float(1) for i in range(len(path)-1): if [path[i], path[i+1]] in edges: index = edges.index([path[i], path[i+1]]) else: index = edges.index([path[i+1], path[i]]) prob *= succProb[index] if max_prob &lt; prob: max_prob = prob return max_prob # 构建图 graph = build_graph(edges) # 所有路径 paths = find_all_path(graph, start, end) max_prob = cal_max_prob(paths, edges, succProb) return max_prob 前排围观 BFS + 剪枝 使用广度优先搜索进行图的遍历 使用一个数组记录已经访问过的节点（提前剪枝） 使用字典记录每个节点被访问到的最大概率（防止再次访问到时概率小的进队） 1234567891011121314151617181920212223242526class Solution: def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -&gt; float: # adjlist存储从边的一端到另一端的概率（双向） # 队列用于实现bfs adjlist, queue, record, visited = defaultdict(list), deque([(start, 1), ]), defaultdict(int), set() # 从一个节点到其他节点的概率 for (x, y), p in zip(edges, succProb): adjlist[x].append((y, p)) adjlist[y].append((x, p)) ans = 0 # bfs while queue: node, prob = queue.popleft() if node == end: ans = max(ans, prob) continue for next_node, next_prob in adjlist[node]: val = next_prob * prob if val &gt; record[next_node]: record[next_node] = val queue.append((next_node, val)) return ans 题目要求求概率最大的路径，整体思路与Dijkstra相同 需要将其中边的权值相加替换为边的权值相乘 Dijkstra使用来计算单源最短路径的算法，是一种贪心算法 1234567891011121314151617181920212223242526272829303132class Solution: def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -&gt; float: # 构造图 mem = collections.defaultdict(list) for (u, v), p in zip(edges, succProb): mem[u].append((v, p)) mem[v].append((p, u)) dist = [0 for _ in range(n)] visited = [False for _ in range(n)] # 构造一个优先队列辅助实现 queue = [] heapq.heappush(queue, (-1, start)) dist[start] = 1 # 为了每次返回最大概率，对概率取反 while queue: maxprob, u = heapq.headppop(queue) # 已访问过的跳过 if visited[u]: continue visited[u] = True for v, p in mem[u]: new_prob = - (p * maxprob) if dist[v] &lt; new_prob: dist[v] = new_prob heapq.heappush(queue, (-dist[v], v)) return dist[end] 服务中心的最佳位置（Hard）题目 一家快递公司希望在新城市建立新的服务中心。公司统计了该城市所有客户在二维地图上的坐标，并希望能够以此为依据为新的服务中心选址：使服务中心 到所有客户的欧几里得距离的总和最小 。 给你一个数组 positions ，其中 positions[i] = [xi, yi] 表示第 i 个客户在二维地图上的位置，返回到所有客户的 欧几里得距离的最小总和 。 换句话说，请你为服务中心选址，该位置的坐标 [xcentre, ycentre] 需要使下面的公式取到最小值： $$\\sum_{i=0}^{n-1} \\sqrt{(x_{centre} - x_i)^2 + (y_{centre} - y_i)^2}$$ 前排围观 梯度下降算法 首先选择x0, y0，作为迭代的初始值 求当前节点的梯度，即dx, dy 学习率的调节：固定x0, y0不变的情况下，成倍数的缩减步长，直到找到距离小于当前点的转移点 进行下一步的迭代 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution: def dist(self, x, y, positions): \"\"\"计算欧式距离\"\"\" return sum([((x - xi) ** 2 + (y - yi) ** 2) ** 0.5 for xi, yi in positions]) def deri(self, x, y, positions): \"\"\"计算导数（偏微分）\"\"\" dx, dy = 0, 0 for xi, yi in positions: div = ((x - xi) ** 2 + (y - yi) ** 2) ** 0.5 if div == 0: continue dx += (x - xi) / div dy += (y - yi) / div return dx, dy def getMinDistSum(self, positions: List[List[int]]) -&gt; float: if len(set([tuple(v) for v in positions])) &lt;= 1: return 0 # 初始迭代位置 x0 = sum([p[0] for p in positions]) / len(positions) y0 = sum([p[1] for p in positions]) / len(positions) # 初始步长 step = 16 while True: dx, dy = self.deri(x0, y0, positions) # 导数都为0, 说明当前是极值点, 退出循环。凹函数的证明可以参考其他文章 if (dx, dy) == (0, 0): break while True: x1 = x0 - step * dx y1 = y0 - step * dy # 保持x0、y0不变，一直寻找下一个下降点，并在此期间改变步长 if self.dist(x1, y1, positions) &lt; self.dist(x0, y0, positions): break # 减少步长 step /= 4 if abs(self.dist(x1, y1, positions) - self.dist(x0, y0, positions)) &lt; 10 ** -6: break # 转移到下一个位置点 x0, y0 = x1, y1 return self.dist(x0, y0, positions) 任重道远呀，要开始记解题模板了🎈🎈🎈🎈","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之寻找旋转排序数组中的最小值Ⅱ","slug":"Leetcode之寻找旋转排序数组中的最小值Ⅱ","date":"2020-07-12T01:17:10.000Z","updated":"2020-07-12T01:49:46.000Z","comments":true,"path":"passages/leetcode-zhi-xun-zhao-xuan-zhuan-pai-xu-shu-zu-zhong-de-zui-xiao-zhi-ii/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-xun-zhao-xuan-zhuan-pai-xu-shu-zu-zhong-de-zui-xiao-zhi-ii/","excerpt":"Find Minimum in Rotated Sorted Array Ⅱ","text":"Find Minimum in Rotated Sorted Array Ⅱ Find Minimum in Rotated Sorted Array Ⅱ code with Python title number：154 读题 假设按照升序排序的数组在预先未知的点上进行了旋转 请找出其中最小的元素 数组中可能存在重复元素 思路一 延续上一题的思路： 旋转排序数组nums可以被拆分为两个单独的升序数组nums1, nums2，并且前者中任意元素均大于等于后者中的元素 使用二分法查找两个子排序数组的分界点（nums2的首个元素），即为当前数组中的最小值 同样的，mid位置元素的值要与end位置的值进行比较 不同之处在于，本题给出的数组中可能存在重复的元素： 设置left, right分别位于数组的两端 当nums[mid] &gt; nums[right]时，mid一定在nums1中，接下来需要去mid右边查找，即left = mid=1 当nums[mid] &lt; nums[right]时，mid一定在nums2中，且分割点一定在mid的左侧，即right = mid 当nums[mid] == nums[right]时，由于重复元素的存在，并不能准确判断出mid所在的位置： 我们采用right = right - 1的方式解决此问题 当nums[right]是最小值且是唯一最小值时，nums[mid]==nums[right]不可能成立（``mid必小于right`） 当nums[right]是最小值且不唯一时，由于mid &lt; right，则有其他最小值存在于[left, right-1]之间 12345678910111213def findMin(self, nums: List[int]) -&gt; int: left, right = 0, len(nums) - 1 while left &lt; right: mid = left + int((right - left) / 2) if nums[mid] &gt; nums[right]: left = mid + 1 elif nums[mid] &lt; nums[right]: right = mid else: right = right - 1 return nums[left]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之寻找旋转排序数组中的最小值","slug":"Leetcode之寻找旋转排序数组中的最小值","date":"2020-07-11T05:21:18.000Z","updated":"2020-07-12T02:02:46.000Z","comments":true,"path":"passages/leetcode-zhi-xun-zhao-xuan-zhuan-pai-xu-shu-zu-zhong-de-zui-xiao-zhi/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-xun-zhao-xuan-zhuan-pai-xu-shu-zu-zhong-de-zui-xiao-zhi/","excerpt":"Find Minimum in Rotated Sorted Array","text":"Find Minimum in Rotated Sorted Array Find Minimum in Rotated Sorted Array code with Python title number：153 读题 假设按照升序排序的数组，在预先未知的某个点上进行了旋转 例如，数组[0, 1, 2, 3, 4, 5, 6, 7]可能变为[4, 5, 6, 7, 0, 1, 2, 3] 找出其中的最小元素 假设数组中不存在重复元素 思路一 首先想到的思路是，对于进行过旋转的数组上，出最小值之外，数组中任意相邻两个元素，后者减去前者一定是正数，只要便利找到第一个为负数的组合即可 但是这样的问题在于，如果未进行过旋转（最坏情况），那么时间复杂度为O(n) 使用二分查找能明显减少查找的次数，从而降低时间复杂度 根据旋转后数组的特征：最右边的值是旋转部分中的最大值 当mid位置的值大于right时，最小值在右半部分（旋转的部分在mid右边） 当mid位置的值小于right时，最小值在左半部分（即mid在旋转的部分中） 123456789101112def findMin(self, nums: List[int]) -&gt; int: l, r = 0, len(nums) - 1 while l &lt; r: mid = int(l + (r - l) / 2) if nums[mid] &lt; nums[len(nums)-1]: r = mid else: l = mid + 1 return nums[r] 深入讨论 使用二分法查找的主要思路是什么？ 使用二分法的目的是通过不断收缩走右边界，将目标值始终包含在[left, right]区间内 当左右边界重合之后，就完成了目标的查找 旋转后的数组有什么特性？ 特性很明显，旋转之后，左半部分的数组始终大于右半部分数组中的值 为什么通过比较nums[mid]与nums[right]之间的大小关系而不是比较nums[mid]与nums[left]之间的关系来确定区间的收缩方式呢？ 我们可以穷举所有可能的情况 在前面三种情况中，情况1、2同属一类，第三种属于第二类 如果中值 &lt; 右值，则最小值在左半边，可以收缩右边界。 如果中值 &gt; 右值，则最小值在右半边，可以收缩左边界。 通过比较中值与右值，可以确定最小值的位置范围，从而决定边界收缩的方向 而如果进行中值与左值的比较： 在第三种情况中，均为左值小于中值，但是最小值的范围却不相同 即不能确定区间边界的收缩 ​","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之第一个错误的版本","slug":"Leetcode之第一个错误的版本","date":"2020-07-10T03:48:35.000Z","updated":"2020-07-10T04:54:46.000Z","comments":true,"path":"passages/leetcode-zhi-di-yi-ge-cuo-wu-de-ban-ben/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-di-yi-ge-cuo-wu-de-ban-ben/","excerpt":"First Bad Version","text":"First Bad Version First Bad Version code with Python title number：278 读题 给定一个长为n的序列，对应一个产品编号为1~n的n个版本 其中有一个版本出错，会导致后续版本都有错误 请找出第一个出现错误的版本，并尽量减少判断的次数 思路一 请原谅我第一反应竟然是顺序遍历，并依次判断当前版本是否为错误版本（很明显会超时） 通过二分搜索来减少一半的搜索空间，以此来减少时间复杂度 对于情况一： 1234561 2 3 4 5 6 7 8 9G G G G G G B B B| | |l mid r对mid位置的判断为true，因此我们知道mid左边的一定全是未出现错误的版本，只需去右半部分进行搜索即可。即l = mid + 1 对于情况二： 123451 2 3 4 5 6 7 8 9G G B B B B B B B| | |l mid r对mid位置的判断为false，因此我们知道右边的一定全是出现错误的版本，只需去左半部分进行搜索即可。即r = mid 需要注意的是，在初始时需要将l=0, r=n，当两个相等时，所指方向即为第一个错误的版本号 12345678910def firstBadVersion(self, n: int) -&gt; int: left, right = 0, n while left != right: mid = int(left + (right - left) / 2) if isBadVersion(mid): right = mid else: left = mid + 1 return left","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之搜索二维矩阵","slug":"Leetcode之搜索二维矩阵","date":"2020-07-09T02:43:33.000Z","updated":"2020-07-09T02:55:44.000Z","comments":true,"path":"passages/leetcode-zhi-sou-suo-er-wei-ju-zhen/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-sou-suo-er-wei-ju-zhen/","excerpt":"Search a 2D Matrix","text":"Search a 2D Matrix Search a 2D Matrix code with Python title number：74 读题 编写算法，在二维矩阵中，判断是否存在目标值，矩阵特点如下： 每行中的整数从左到右按升序排列 每行的第一个整数大于前一行的最后一个整数 思路一 根据矩阵的特点，可以将矩阵转化为一维的升序列表 查找 &amp; 有序列表 ——&gt; 使用二分查找进行目标值的查找 12345678910111213141516171819202122232425def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool: # 矩阵中不包含元素 if len(matrix) == 0 or len(matrix[0]) == 0: return False # 矩阵转化为列表 L = [] for m in matrix: L.extend(m) # 进行二分查找 l, r = 0, len(L) - 1 while l + 1 &lt; r: mid = int(l + (r - l) / 2) if L[mid] == target: return True if L[mid] &lt; target: l = mid if L[mid] &gt; target: r = mid # 当矩阵中只包含一个元素时 if L[l] == target or L[r] == target: return True return False","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Lintcode之搜索区间","slug":"Lintcode之搜索区间","date":"2020-07-08T00:54:23.000Z","updated":"2020-07-10T04:55:04.000Z","comments":true,"path":"passages/lintcode-zhi-sou-suo-qu-jian/","link":"","permalink":"http://zivblog.top/passages/lintcode-zhi-sou-suo-qu-jian/","excerpt":"Search For Range","text":"Search For Range Search For Range code with Python titile number： 60 读题 给定一个包含n个整数的排序数组，找出给定目标值target的起始和结束位置 如果目标值不再数组中，则返回[-1, -1] 示例： 123输入：[5, 7, 7, 8, 8, 10], 8输出：[3, 4]解释：返回的是数组中目标值出现的起始位置的下标 思路一 有序数组中的查找，最先想到的是二分查找 通过两次二分查找分别得到target的两个边界 值得注意的是，两个边界要么都存在，要么都不存在 12345678910111213141516171819202122232425262728293031323334353637383940414243444546def searchRange(self, A: List[int], target: int) -&gt; List[int]: if len(A) == 0: return [-1, -1] result = [] start, end = 0, len(A) - 1 while start + 1 &lt; end: mid = int(start + (end - start) / 2) if A[mid] &gt; target: end = mid elif A[mid] &lt; target: start = mid else: end = mid # 查找左边界 if A[start] == target: result.append(start) elif A[end] == target: result.append(end) else: result.append(-1) result.append(-1) return result start, end = 0, len(A) - 1 while start + 1 &lt; end: mid = int(start + (end - start) / 2) if A[mid] &gt; target: end = mid elif A[mid] &lt; target: start = mid else: start = mid # 查找右边界 if A[end] == target: result.append(end) elif A[start] == target: result.append(start) else: result.append(-1) result.append(-1) return result return result","categories":[{"name":"Lintcode","slug":"Lintcode","permalink":"http://zivblog.top/categories/Lintcode/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"},{"name":"lintcode","slug":"lintcode","permalink":"http://zivblog.top/tags/lintcode/"}]},{"title":"Leetcode之比特位计数","slug":"Leetcode之比特位计数","date":"2020-07-07T00:37:25.000Z","updated":"2020-07-07T01:43:20.000Z","comments":true,"path":"passages/leetcode-zhi-bi-te-wei-ji-shu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-bi-te-wei-ji-shu/","excerpt":"Counting Bits","text":"Counting Bits Counting Bits code with Python title number：338 读题 给定一个非负整数num，对于0 &lt;= n &lt;= num范围中的每个数字i，计算器二进制数中的1的数目并将他们作为数组返回 示例： 123输入：2输出：[0, 1, 1]解释：0: 00, 1: 01, 2: 10, 包含的1的个数分别为0, 1, 1 思路一 遍历整个范围，对范围中的每个数统计其包含的1的个数，将统计结果添加到结果集中 将数字和1进行与操作，判断当前最低位是否为1 将数字进行左移操作，删除掉低位被统计过的1 12345678910def countBits(self, num: int) -&gt; List[int]: res = [] for i in range(num + 1): count = 0 while i: count += i &amp; 1 res.append(count) return res 时间复杂度为O(n*sizeof(integer)) 思路二 题目要求使用线性时间复杂度的算法，并且算法的空间复杂度为O(n) 要想实现时间复杂度是O(n)的算法，必然不能一边遍历一遍统计；需要在遍历的同时，利用之前的结果计算当前数字中1的个数 如果当前数字是偶数，则f(i)=f(i//2) 如果当前数字是奇数，则f(i)=f(i-1)+1 具体解释一下 如果当前数字是偶数，说明数字的最低位一定是0，所以将数字左移一位（除2），数字中所包含的1的个数是不变的 如果当前数字是奇数，则其前一位必定是偶数，当前奇数只是在前一个数字的最低位加了一个1，所以其1的个数是前一个数字的1的个数+1 其实这就是动态规划 12345678910def countBits(self, num: int) -&gt; List[int]: res = [0] for i in range(1, num+1): if i % 2 == 0: res.append(res[i // 2]) else: res.append(res[i - 1] + 1) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之只出现一次的数字Ⅲ","slug":"Leetcode之只出现一次的数字Ⅲ","date":"2020-07-06T02:01:26.000Z","updated":"2020-07-06T05:04:53.000Z","comments":true,"path":"passages/leetcode-zhi-zhi-chu-xian-yi-ci-de-shu-zi-iii/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zhi-chu-xian-yi-ci-de-shu-zi-iii/","excerpt":"Single Number Ⅲ","text":"Single Number Ⅲ Single Number Ⅲ code with Python title number：260 读题 给定一个整数数组，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素 思路一 沿用之前的思路，数学方法、字典、位运算 由于这里是要求两个元素，故前面用过的数学方法不适用 这里先用字典解决： 遍历数组，统计每个元素出现的次数 返回出现次数为1的元素 123456789101112131415def SingleNumber(self, nums: List[int]) -&gt; List[int]: map_ = dict() for num in nums: if num in map_: map_[num] += 1 else: map_[num] = 1 res = [] for key in map_keys(): if map_[key] == 1: res.append(key) return res 思路二 位运算背景知识： 0和所有数异或得到数字本身 相同的数字进行异或得到的结果为0 补码等于原码的反码加1，负数用补码表示 一个数和它的相反数异或得到该数二进制表示最左边的1 例如 1234原码：0000 0101反码：1111 1010补码：1111 11115 &amp; (-5) &#x3D; 1 思路： 所有数进行异或操作，得到只出现一次的两个数的异或 将这个异或与自己的相反数进行与操作，得到两个数最左边出现的1，记为2 分别用a与每个数进行与操作，将数组分为两部分 每部分分别进行异或操作，即可得到这两个只出现一次的数 12345678910111213141516def singleNumber(self, nums； List[int]) -&gt; List[int]: a = 0 # 遍历，进行异或操作 for num in nums: a ^= num x, y = 0, 0 # 得到两个数的异或的最左边的1 a &amp;= -a for num in nums: if a &amp; num: x ^= num else: y ^= num return [x, y]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之只出现一次的数字Ⅱ","slug":"Leetcode之只出现一次的数字Ⅱ","date":"2020-07-05T09:39:46.000Z","updated":"2020-07-06T05:31:44.000Z","comments":true,"path":"passages/leetcode-zhi-zhi-chu-xian-yi-ci-de-shu-zi-ii/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zhi-chu-xian-yi-ci-de-shu-zi-ii/","excerpt":"Single Number Ⅱ","text":"Single Number Ⅱ Single Number Ⅱ code with Python title number：137 读题 给定一个非空整数数组，除了某个元素只出现一次之外，其余的元素均出现了三次，找出那个只出现了一次的元素 说明 算法应具有线性时间复杂度，尽量不要使用额外空间 思路一 数学方法 利用集合的特性，求整个数组的不重复元素，乘3求和 对所有数组元素求和 两者相减除以2即为只出现了一次的元素 例如: 123输入：[2, 2, 3, 2]输出：3解释：[2*3 * 3*3 - (2+2+3+2)] &#x2F; 2 &#x3D; 3 123456789def singleNumber(self, nums: List[int]) -&gt; int: single = set(nums) sum_3 = 0 for i in single: sum_3 += 3*i for num in nums: sum_3 -= num return sum_3 / 2 思路二 利用字典 遍历整个数组，统计每个元素出现的次数 返回出现次数为1的元素 1234567891011def singleNumber(self, nums: List[int]) -&gt; int: map_ = dict() for num in nums: if num in map_: map_[num] += 1 else: map_[num] = 1 for key in map_.keys(): if map_[key] == 1: return key 思路三 先进行排序（将相同的数字放到一起） 遍历，如果nums[i]==nums[i+2]，则说明该数字出现了三次 否则返回当前数字 如果遍历完也没有找到，则最后一个数字为出现一次的 123456789def singleNumber(self, List[int]) -&gt; int: nums.sort() i = 0 while i + 2 &lt; len(nums): if nums[i] == nums[i+2]: i += 3 else: return nums[i] return nums[-1] 思路三 上述方法都使用了额外的空间 使用位运算进行，先介绍三种位运算： and，且运算，使用&amp;表示 not，非运算，使用~表示 xor，异或运算，使用^表示 使用异或运算可以检测出现奇数次的数字 0异或所有数字都为该数字本身 两个相同的数进行异或操作，结果为0 对于出现两次的相同数，我们可以通过异或置0 对于出现三次的相同数，我们要构造一种方法，将同一个位置上的三个1清零，这样就可以发现出现三次的数字了 在异或运算中，1^1=0, 1^0=0, 0^1=1，可以将其理解为不进位的二进制加法，而不进位可以理解为进位为对2取模 这样，我们可以定义二进制加法，且进位为对3取模的做法为三个相同位的清零运算，即可实现a?a?a=0 所谓清零 12321: 1010121: 10101异或: 00000 1234567891011def singleNumber(self, nums: List[int]) -&gt; int: res = 0 for i in range(64): # 初始化每一位1的个数为0 sum = 0 for j in range(len(nums)): # 通过右移的方式，统计每一位1的个数 sum += nums[j] &gt;&gt; i &amp; 1 # 最终将抵消后剩余的1放到对应的位数上 res ^= (sum % 3) &lt;&lt; i return res 推而广之，如果是定义一个a?a?a?a?a=0的运算，只需要进行二进制加法，进位对5取模","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之01矩阵","slug":"Leetcode之01矩阵","date":"2020-07-04T05:08:08.000Z","updated":"2020-07-06T05:08:18.000Z","comments":true,"path":"passages/leetcode-zhi-01-ju-zhen/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-01-ju-zhen/","excerpt":"01 Matrix","text":"01 Matrix 01 Matrix code with Python title number：542 读题 给定一个由0, 1组成的矩阵，找出每个元素到最近的0的距离 两个相邻元素间的距离为1 例如： 矩阵元素只能在四个方向上相邻：上、下、左、右 思路一 由题意可知，所求距离为曼哈顿距离，即方向上只能沿这横、竖到达下一个位置 在一个图中，从一个点出发求最短距离，首先想到的是广度优先遍历 广度优先遍历会优先将最近的一圈搜索完之后，再去搜索下一圈 所以在本题中，第i圈对应的就是距离为i 题目给出了多个1，要求找到每个1到0的最近曼哈顿距离。而0到1的距离和1到0的距离是相同的 故我们可以将问题转化为:每个0到1距离 问题抽象为:多个起始点的广度优先搜索 接下来是广度优先搜索： 将每个还未搜索到的点依次放入队列，再弹出队列的头部元素作为当前的遍历点 要确定遍历到哪一层，需要加一个level记录遍历的层数 访问完每层的元素之后，level+1 具体算法细节，请结合代码和注释理解 12345678910111213141516171819202122232425262728293031323334353637383940def updateMatrix(self, matrix: List[List[int]]) -&gt; List[List[int]]: M, N = len(matrix), len(matrix[0]) queue = collections.deque() # 记录已访问过的位置 visited = [[0] * N for _ in range(M)] # 结果 res = [[0] * N for _ in range(M)] # 将所有的0添加到队列中 for i in range(M): for j in range(N): if matrix[i][j] == 0: queue.append((i, j)) visited[i][j] = 1 # 四个方向 dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)] # 距离 = 层数 step = 0 # 出队所有元素 while queue: size = len(queue) # 当前元素所有邻居 for i in range(size): x, y = queue.popleft() if matrix[x][y] == 1: res[x][y] = step # 广度优先遍历，四个方向 for dx, dy in dirs: newx, newy = x + dx, y + dy if newx &lt; 0 or newx &gt;= M or newy &lt; 0 or newy &gt;= N or visited[newx][newy] == 1: continue # 新节点入队 queue.append((newx, newy)) visited[newx][newy] = 1 # 下一层 step += 1 return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之柱状图中最大的矩形","slug":"Leetcode之柱状图中最大的矩形","date":"2020-07-03T01:02:29.000Z","updated":"2020-07-06T05:32:02.000Z","comments":true,"path":"passages/leetcode-zhi-zhu-zhuang-tu-zhong-zui-da-de-ju-xing/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zhu-zhuang-tu-zhong-zui-da-de-ju-xing/","excerpt":"Largest Rectangle in Histogram","text":"Largest Rectangle in Histogram Largest Rectangle in Histogram code with Python title number：84 读题 给定n个非负数，用来表示柱状图中每个柱子的高度。 每个柱子彼此相邻，且宽度为1 求在该柱状图中，能够勾勒出来的矩形的最大面积 先验知识 单调栈适合处理两端元素的大小决定中间元素大小的问题 单调栈有一下性质： 如果是单调递增栈，则从栈顶到栈底的元素是严格递增的；如果是单调递减栈，则从栈顶到栈底的元素是严格递减的 只能在栈顶操作 进栈过程（以单调递增栈为例）： 如过当前进栈元素为e，从栈顶开始遍历元素，把小于e或等于e的元素弹出 直到遇到一个大于e的元素或栈空为止，然后再把e压入栈中 思路一 当前位置的高度能决定的最大阴影面积由其左右第一个小于该元素的元素决定 以第i根柱子为最矮柱子所能延伸的最大面积：当前高度 * 左右第一个小于该元素之间的距离 使用单调栈用以找到当前元素左右第一个小于它的元素 上述思路体现在单调栈上的操作，即： 从左到右遍历每一根柱子，我们要找到第一个小于当前高度的柱子 如果柱子高度大于栈顶的柱子高度（不是我们要找的），则入栈 如果柱子高度小于栈顶的柱子高度（所求）， 对于栈顶元素，其右边的第一个小于它的就是当前遍历到的柱子，左边第一个小于它的柱子就是栈中下一个要被弹出的元素 因此，当前栈顶元素决定的最大阴影面积为：当前栈顶的柱子高度 * (当前遍历到的柱子索引 - 栈中下一个要被弹出的元素的索引 + 1) 为了方便操作，在heights的左右两边各添加一个哨兵元素，保证所有的柱子都会出栈 1234567891011def largestRectangleArea(self, heights: List[int]) -&gt; int: n, heights, stack, ans = len(heights), [0]+heights+[0], [], 0 for i in range(n + 2): # 当前元素是栈顶元素右边第一小于它的元素 # 栈顶第二元素是栈顶元素左边第一个小于它的元素 while st and heights[stack[-1]] &gt; heights[i]: ans = max(ans, heights[stack.pop(-1)] * (i - stack[-1] - 1)) stack.append(i) return ans 不愧是hard的题目啊，🤦‍♂️🤦‍♂️🤦‍♂️","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之克隆图","slug":"Leetcode之克隆图","date":"2020-07-02T01:09:58.000Z","updated":"2020-07-06T05:20:05.000Z","comments":true,"path":"passages/leetcode-zhi-ke-long-tu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-ke-long-tu/","excerpt":"Clone Graph","text":"Clone Graph Clone Graph code with Python title number：133 读题 给定一个无向连通图中一个节点的引用，请返回该图的深拷贝（克隆） 图中每个节点包含它的值和它的邻居列表 思路一 由于图是连通图，可以通过一次遍历访问到所有节点（深度优先搜索 or 广度优先搜索） 深拷贝，即所有节点的空间要重新申请，而不是只创建索引 图中可能存在环，因此需要存储已经访问过的节点，防止陷入死循环 这里我们使用深度优先搜索遍历图 用于存储已访问过（且拷贝过）节点的数据结构为字典{原节点:复制节点} 12345678910111213141516171819202122232425class Solution: def __init__(self): self.visited = &#123;&#125; def cloneGraph(self, node: 'Node') -&gt; 'Node': # 深度优先遍历并克隆 def dfs(node): if not node: return None # 已访问过，直接返回已创建的克隆对象 if node in self.visited: return self.visited[node] # 未访问过，创建克隆对象 ans = Node(node.val) self.visited[node] = ans # 深度优先搜索其邻居节点 for neighbor in node,neighbors: ans.neighbors.append(dfs(neighbor)) return ans return dfs(node)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之字符串解码","slug":"Leetcode之字符串解码","date":"2020-07-01T01:22:07.000Z","updated":"2020-07-06T05:32:44.000Z","comments":true,"path":"passages/leetcode-zhi-zi-fu-chuan-jie-ma/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zi-fu-chuan-jie-ma/","excerpt":"Decode String","text":"Decode String Decode String code with Python title number：394 读题 给定一个经过编码的字符串，返回它解码后的字符串。 编码规则为: k[encoded_string]，表示其中方括号内部的encoded_string正好重复k次。注意k保证为正整数。 输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像3a或 2[4]的输入。 思路一 本题的难点在于解码过程存在嵌套现象，即需要先对内部进行解码拼接，再依次对外部进行解码 这与栈的先入后出十分吻合，这里我们使用辅助栈进行解码操作： 遇到数字（’[‘之前的元素，转化为数字）压入栈中 遇到’[‘之后，将左右括号之间的元素压入栈中 遇到’]’之后，取出栈中元素进行拼接，将结果放入栈中 栈中唯一元素即为拼接后的结果 12345678910111213141516def decodeString(self, s: str) -&gt; str: stack, res, multi = [], '', 0 for c in s: if c == '[': stack.append([multi, res]) res, multi = '', 0 elif c == ']': cur_multi, last_res = stack.pop() res = last_res + cur_multi * res elif '0' &lt;= c &lt;= '9': multi = multi * 10 + int(c) else: res += c return res 思路二 这种嵌套结构也会令人自然想到递归 左右括号间的内容是需要递归的主体： 遇到’[‘，开启一层新的递归 遇到’]’，返回当前括号内的字符串和索引i 遍历完返回结果 1234567891011121314151617def decodeString(self, s: str) -&gt; str: def dfs(s, i): res, multi = \"\", 0 while i &lt; len(s): if '0' &lt;= s[i] &lt;= '9': multi = multi *10 + int(s[i]) elif s[i] == '[': i, temp = dfs(s, i + 1) res += multi * temp multi = 0 elif s[i] == ']': return i, res else: res += s[i] i += 1 return res return dfs(s, 0)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之复制带随机指针的链表","slug":"Leetcode之复制带随机指针的链表","date":"2020-06-30T01:05:43.000Z","updated":"2020-07-06T05:16:16.000Z","comments":true,"path":"passages/leetcode-zhi-fu-zhi-dai-sui-ji-zhi-zhen-de-lian-biao/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-fu-zhi-dai-sui-ji-zhi-zhen-de-lian-biao/","excerpt":"Copy List with Random Pointer","text":"Copy List with Random Pointer Copy List with Random Pointer code with Python title number：138 读题 给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点 要求返回该链表的深拷贝 用一个有n个节点组成的链表来表示输入/输出的链表。每个节点用一个[val, random_index]表示： val：节点值 random_index：随机指针 示例 12输入：head &#x3D; [[7,null],[13,0],[11,4],[10,2],[1,0]]输出：[[7,null],[13,0],[11,4],[10,2],[1,0]] 思路一 深拷贝与浅拷贝的区别： 深拷贝在于创建新的指针和空间，即深拷贝得到的对象与原对象之间相互独立，互不影响 浅拷贝只创建新的指针指向原对象的空间，原对象上的修改都会浅拷贝对象的改变 本题的关键在于存在随机指针，所以链表中可能存在环，如果直接遍历复制可能导致死循环，故有以下考虑： 使用hash表存储已访问过的节点 对next和random两个指针同时进行递归复制 123456789101112131415161718192021class Solution: def __init__(self): self.visited = &#123;&#125; def copyRandomList(self, head: 'Node') -&gt; 'Node': if head == None: return None if head in self.visited: return self.visited[head] node = Node(head.val, None, None) self.visited[head] = node # 递归 node.next = self.copyRandomList(head.next) node.random = self.copyRandomList(node.random) return node 思路二 本题的难点在于随机指针的复制，我们通过一下三步实现： 根据遍历到的原节点创建对应的新节点，每个新创建的节点添加到原节点的后面（为了方便的复制随机指针） 对所有新创建节点组成的链表添加随机指针（若node1.random=node3，则node1_new.random=node3_new） 将两个链表分离 另外，我们是沿着next链进行的遍历，无需使用额外的空间来记录访问过的节点 12345678910111213141516171819202122232425262728293031class Solution: def __init__(self, head): if not head: return Node p = head # 第一步：在每个节点后创建新节点 while p: new_node = Node(p.val, None, None) new_node.next = p.next p.next = new_node p = new_node.next p = head # 第二步：复制随机指针 while p: if p.random: p.next.random = p.random.next p = p.next.next p = head dummy = Node(-1, None, None) cur = dummy # 将两个链表分离 while p: cur.next = p.next cur = cur.next p.next = cur.next p = p.next return dummy.next","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之回文链表","slug":"Leetcode之回文链表","date":"2020-06-29T02:32:37.000Z","updated":"2020-07-06T05:17:13.000Z","comments":true,"path":"passages/leetcode-zhi-hui-wen-lian-biao/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-hui-wen-lian-biao/","excerpt":"Palindrome Linked List","text":"Palindrome Linked List Palindrome Linked List code with Python title number：234 读题 给定一个单链表，判断其是否为回文链表 思路一 快慢指针找到中间节点 反转后半部分链表 两子链表从头比较是否完全相同 具体细节参看代码注释 123456789101112131415161718192021222324252627282930313233343536def isPalindrome(self, head: ListNode) -&gt; bool: # 链表为空或链表长度为1，为回文链 if head is None or head.next is None: return True # 反转链表 def reverse(head): pre, cur = None, head while cur: temp = cur.next cur.next = pre pre = cur cur = temp return pre fast, slow = head.next, head # 查找中间节点 while fast and fast.next: fast, slow = fast.next.next, slow.next if fast == slow: break # 指向两子链表头节点 p, q = head, slow.next # 断开链表 slow.next = None # 反转后半部分链表 q = reverse(q) while p and q: # 中间存在不相等节点 if p.val != q.val: return Fasle p, q = p.next, q.next return True","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之环形链表Ⅱ","slug":"Leetcode之环形链表Ⅱ","date":"2020-06-29T01:21:25.000Z","updated":"2020-07-06T05:16:47.000Z","comments":true,"path":"passages/leetcode-zhi-huan-xing-lian-biao-ii/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-huan-xing-lian-biao-ii/","excerpt":"Linked List Cycle Ⅱ","text":"Linked List Cycle Ⅱ Linked List Cycle Ⅱ code with Python title number：142 读题 给定一个链表，返回链表开始入环的第一个节点。 如果链表中不存在环， 返回None 链表不允许修改 思路一 首先要判断链表中是否存在环，使用快慢指针即可 其次查找链表中入环的第一个节点（有点绕，自己画个示意图） 假设，头结点到链表入环的第一个节点的长度为a（a的值即为所求） 假设，环的长度为b 分析 两节点相遇时，慢指针走过的长度必小于a+b（假设为a+x） 快指针必定已经走完至少一圈环（假设为m圈） 此时有：快指针走过的长度为a + mb + x，慢指针走过的长度为a + x 快指针走过的长度是慢指针的两倍，故a + mb + x = 2*(a + x)，可得a = mb - x 方法 在两指针相遇时，在头结点出设置一指针，令其与快指针同步移动（每次一个位置） 两指针相遇的位置即为环的入口 证明如下： 新指针到达入口需要走的长度为a 快指针再走a总长度为a + mb + x + mb - x = a + 2*mb，即刚好走完两个环，到达环的入口位置 123456789101112131415161718def detectCycle(self, head: ListNode) -&gt; ListNode: fast, slow = head, head while fast and fast.next: fast = fast.next.next slow = slow.next # 有环 if fast == slow: meetNode = slow start = head while meetNode != start: meetNode, start = meetNode.next, start.next return meetNode return None","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之环形链表","slug":"Leetcode之环形链表","date":"2020-06-29T01:13:19.000Z","updated":"2020-07-06T05:16:38.000Z","comments":true,"path":"passages/leetcode-zhi-huan-xing-lian-biao/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-huan-xing-lian-biao/","excerpt":"Linked List Cycle","text":"Linked List Cycle Linked List Cycle code with Python title number：141 读题 给定一个链表，判断链表中是否存在环 思路一 快慢指针 如果链表中存在环，则两指针必会相遇 12345678910111213141516def hasCycle(self, head: ListNode) -&gt; bool: if head == None: return False fast, slow = head.next, head while fast and fast.next: fast = fast.next.nxt slow = slow.next # 如果有环，则跳不出循环 if fast == slow: return True # 跳出循环则无环 return False","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之重排列表","slug":"Leetcode之重排列表","date":"2020-06-28T02:07:35.000Z","updated":"2020-07-06T05:31:55.000Z","comments":true,"path":"passages/leetcode-zhi-chong-pai-lie-biao/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-chong-pai-lie-biao/","excerpt":"Reorder List","text":"Reorder List Reorder List code with Python title number：143 读题 给定一个链表，形如： L : L0 -&gt; L1 -&gt; L2 -&gt; … -&gt; Ln-1 -&gt; Ln 将其重新排序为： L : L0 -&gt; Ln -&gt; L1 -&gt; Ln-1 -&gt; … 不能仅交换节点内部的值，需要进行实际的节点交换 思路一 实名反对所有使用栈和列表等外部结构的解法 算法分为三部分： 查找前后两部分的分割点 —— 快慢指针查找中点 反转后半部分的链表 将两部分链表进行拼接 —— 两个指针遍历两个链表 1234567891011121314151617181920212223242526272829303132333435def reorderList(self, head: ListNode) -&gt; None: # 反转链表 def reverse(head): pre, cur = None, head while cur: temp = cur.next cur.next = pre pre = cur cur = temp return cur # 快慢指针查找中间节点 fast, slow = head.next, head while fast and fast.next: fast = fast.next.next slow = slow.next # 获取后半部分的头节点，截断两部分链表 last_part, slow.next = slow.next, None last_part = reverse(last_part) # 两个指针用于遍历两个子链表 p, q = head, last_part while p and q: p_temp, q_temp = p.next, q.next # 链接 p.next = q q.next = p_temp # 指针后移 p, q = p_temp, q_temp","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之排序链表","slug":"Leetcode之排序链表","date":"2020-06-27T03:27:41.000Z","updated":"2020-07-06T05:23:40.000Z","comments":true,"path":"passages/leetcode-zhi-pai-xu-lian-biao/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-pai-xu-lian-biao/","excerpt":"Sort List","text":"Sort List Sort List code with Python title number：148 读题 在O(nlogn)的时间复杂度和常数级空间复杂度下，对链表进行排序 思路一 常见的排序算法都可以在链表上应用，只不过为了追求操作上的简便，一些方法我们一般不用，例如： 快速排序：需要使用首尾指针，对于单链表来说不容易实现 通常我们只考虑只需要比较相邻元素的排序算法 链表结构不同与顺序结构： 不支持随机访问，只能单向遍历 节点交换涉及至少三个节点（单链表），操作繁琐 这里要求常数级空间复杂度和O(nlogn)的时间复杂度，所以我们选择归并排序 归并排序采用分治法的思想，将已有序的子序列合并，得到完全有序的子序列 可以很方便的使用递归的方式实现 递归实现链表的归并排序有两个环节： 分割环节 找到链表的中点（使用快慢指针，快指针每次移动两个位置，慢指针每次移动一个位置），将链表切断 递归分割链表 合并环节 双指针法进行合并 使用辅助节点作为头部，比较两个待合并的链表中元素的大小，将合适的加到辅助节点的后面 盗张图，演示一下😜😜😜 1234567891011121314151617181920212223242526def sortList(self, head: ListNode) -&gt; ListNode: # 链表为空 or 只包含一个节点 if not head or not head.next: return head # 快慢指针查找中间位置 slow, fast = head, head.next while fast and fast.next: fast, slow = fast.next.next, slow.next mid, slow.next = slow.next, None # 递归分割 left, right = self.sortList(head), self.sortList(mid) # 双指针进行合并 h = res = ListNode(0) while left and right: # 左子链中当前节点更小 if left.val &lt; right.val: h.next, left = left, left.next else: h.next, right = right, right.next h = h.next h.next = left if left else right return res.next 思路二 这是一种比较讨巧的方法 通过一次遍历，将链表中的元素全部读取到数组中 对数组中的元素进行排序（选择符合复杂度要求的排序算法） 最后将有序数组依次写入链表节点中 123456789101112131415def sortList(self, head: ListNode) -&gt; ListNode: p = head arr = [] while p: arr.append(p.val) p = p.next arr.sort() p, i = head, 0 while p: p.val = arr[i] i += 1 p = p.next return head","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之删除排序链表中的重复元素Ⅱ","slug":"Leetcode之删除排序链表中的重复元素Ⅱ","date":"2020-06-26T06:19:07.000Z","updated":"2020-07-06T05:25:46.000Z","comments":true,"path":"passages/leetcode-zhi-shan-chu-pai-xu-lian-biao-zhong-de-chong-fu-yuan-su-ii/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-shan-chu-pai-xu-lian-biao-zhong-de-chong-fu-yuan-su-ii/","excerpt":"Remove Duplicates from Sorted List Ⅱ","text":"Remove Duplicates from Sorted List Ⅱ Remove Duplicates from Sorted List Ⅱ code with Python title number：82 读题 给定一个排序链表，删除所有含有重复数字的节点 最终链表中只保留原始链表中没有重复出现的数字 思路一 本题的特殊之处在于：删除所有重复的节点，即头结点也有可能被删除 故这里需要使用dummpy头结点 具体思路结合代码注释理解 12345678910111213141516171819def deleteDuplicates(self, head: ListNode) -&gt; ListNode: # 创建虚拟节点 dummp_node = TreeNode(0) # 添加到头结点之前 dummp_node.next = head # 将头指针指向虚拟节点 head = dummpy_node while head.next and head.next.next: # 出现连续相同的元素 if head.next.val == head.next.next.val: # 依次删除 val = head.next.val while head.next and head.next.val == val: head.next = head.next.next # 头指针向后移 else: head = head.next return dummp_node.next","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之删除排序链表中的重复元素","slug":"Leetcode之删除排序链表中的重复元素","date":"2020-06-26T06:04:00.000Z","updated":"2020-07-06T05:25:37.000Z","comments":true,"path":"passages/leetcode-zhi-shan-chu-pai-xu-lian-biao-zhong-de-chong-fu-yuan-su/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-shan-chu-pai-xu-lian-biao-zhong-de-chong-fu-yuan-su/","excerpt":"Remove Duplicates from Sorted List","text":"Remove Duplicates from Sorted List Remove Duplicates from Sorted List code with Python title number：83 读题 给定一个排序数组，删除所有重复的元素，使得每个元素只出现一次 思路一 由于是排序数组，所以相同的元素是连续的 单指针 遇到重复项就使用指针指向其下一项，以此来完成删除操作 12345678def deleteDuplicate(self, head: ListNode) -&gt; ListNode: temp = head while temp: while temp.next and temp.val == temp.next.val: temp.next = temp.next.next temp = temp.next return head","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之二叉搜索树中的插入操作","slug":"Leetcode之二叉搜索树中的插入操作","date":"2020-06-25T03:01:23.000Z","updated":"2020-07-06T05:12:57.000Z","comments":true,"path":"passages/leetcode-zhi-er-cha-sou-suo-shu-zhong-de-cha-ru-cao-zuo/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-er-cha-sou-suo-shu-zhong-de-cha-ru-cao-zuo/","excerpt":"Insert into a Binary Search Tree","text":"Insert into a Binary Search Tree Insert into a Binary Search Tree code with Python title number：701 读题 给定一棵二叉搜索树的根节点以及要插入树总的值，将值插入二叉搜索树 返回插入后二叉搜索树的根节点 思路一 二叉搜索树的新插入节点比定位叶子节点 二叉搜索树是一种递归结构，即左孩子小于根节点的值，右孩子大于根节点的值 使用递归的方式查找待插入的位置，在合适的位置穿件新节点并连接到树中即可 返回根节点 12345678910111213def insertIntoBST(self, root: TreeNode, val: int) -&gt; TreeNode: # 插入位置 if root is None: root = TreeNode(val) return root # 递归在右子树中查找插入位置 if root.val &lt; val: root.right = self.insertIntoBST(root.right, val) # 递归在左子树中查找插入位置 if root.val &gt; val: root.left = self.insertIntoBST(root.left, val) return root 思路二 还是上面的思路，使用迭代的方式进行 沿着树结构不断查找合适的插入位置，到达根节点后穿件新节点插入 单独处理树为空的情况 123456789101112131415161718def insertIntoBST(self, root: TreeNode, val: int) -&gt; TreeNode: node = root # 迭代查找插入位置，并插入 while node: if val &gt; node.val: if not node.right: node.right = TreeNode(val) return root else: node = node.right if val &lt; node.val: if not node.left: node.left = TreeNode(val) return root else: node = node.left # 处理根节点为空的情况 return TreeNode(val)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之二叉树的层序遍历Ⅱ","slug":"Leetcode之二叉树的层序遍历Ⅱ","date":"2020-06-24T08:00:48.000Z","updated":"2020-07-06T05:11:38.000Z","comments":true,"path":"passages/leetcode-zhi-er-cha-shu-de-ceng-xu-bian-li-ii/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-er-cha-shu-de-ceng-xu-bian-li-ii/","excerpt":"Binary Tree Level Order Traversal Ⅱ","text":"Binary Tree Level Order Traversal Ⅱ Binary Tree Level Order Traversal Ⅱ code with Python title number：107 读题 给定一棵二叉树，返回其节点值自底向上的层次遍历。 按叶子节点所在的层到根节点所在的层，逐层从左向右遍历 思路一 按照正常的自顶向下的方式进行层序遍历 对遍历结果的顺序进行翻转 1234567891011121314151617181920212223def levelOrderBottom(self, root: TreeNode) -&gt; List[List[int]]: if root is None: return [] queue = [root] res = [] while queue: len_ len(queue) res.append([]) for i in range(len_): node = queue.pop(0) res[-1].append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) res = res[::-1] return res 思路二 沿用上面的思路，调整添加当前层结果到结果集中的位置，省去最后翻转的过程 自顶向下进行层序遍历 每次都将当前层的遍历结果添加到结果集的头部 123456789101112131415161718192021def levelOrderBottom(self, root: TreeNode) -&gt; List[List[int]]: if root is None: return [] queue = [root] res = [] while queue: len_ len(queue) res.insert(0, []) for i in range(len_): node = queue.pop(0) res[0].append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之平衡二叉树","slug":"Leetcode之平衡二叉树","date":"2020-06-23T07:54:20.000Z","updated":"2020-07-06T05:24:07.000Z","comments":true,"path":"passages/leetcode-zhi-ping-heng-er-cha-shu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-ping-heng-er-cha-shu/","excerpt":"Balanced Binary Tree","text":"Balanced Binary Tree Balanced Binary Tree code with Python title number：110 读题 给定一棵二叉树，判断它是否为平衡二叉树 平衡二叉树的定义为： 二叉树中，每个节点的左右两棵子树的高度差的绝对值不超过1 思路一 题目的关键在于：得到每个节点的高度 关于树形结构，最省心的方法就是递归 递归判断每个节点是否为平衡点 若是，返回True和当前节点高度 若否，返回False和当前节点高度（统一格式） 123456789101112131415161718192021def isBalanced(self, root: TreeNode) -&gt; bool: def is_Bala(root): if root is None: return True, 0 bool_left, left_height = is_Bala(root.left) bool_right, right_height = is_Bala(root.right) if bool_left and bool_right: if abs(left_height - right_height) &lt;= 1: return True, max(left_height, right_height) + 1 else: return False, max(left_height, right_height) + 1 else: return False, max(left_height, right_height) + 1 bool_, height = is_Bala(root) return bool_","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Sword-offer-03-数组中的重复元素","slug":"Sword-offer-03-数组中的重复元素","date":"2020-06-22T10:35:40.000Z","updated":"2020-11-28T07:43:51.366Z","comments":true,"path":"passages/sword-offer-03-shu-zu-zhong-de-chong-fu-yuan-su/","link":"","permalink":"http://zivblog.top/passages/sword-offer-03-shu-zu-zhong-de-chong-fu-yuan-su/","excerpt":"Sword Offer","text":"Sword Offer 数组中重复的数字 code with Python title number：03 读题 在一个长度为n的数组nums里的所有数字都在[0, n-1]的范围内 数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次 请找出数组中任意一个重复的数字 思路一（常规） 使用字典保存每个元素出现的次数 如果不在字典内，则添加 如果在字典内，直接返回该元素 12345678def findRepeatNumber(self, nums: List[int]) -&gt; int: count = dict() for num in nums: if num not in count: count[num] = 1 else: return num 思路二（时间优先） 使用字典保存每个元素出现的次数 使用排序，将相同元素聚集到一起，加快遇到重复元素的速度 123456789def findRepeatNumber(self, nums: List[int]) -&gt; int: count = dict() nums.sort() for num in nums: if num not in count: count[num] = 1 else: return num 思路三（空间优先） 原地哈希 不使用额外的空间来保存字典 由于数组中元素的值域为[0, len(nums)]，所以可以利用第i个位置存储元素i，如此“ 当前元素为i，需要与第``i`个位置的元素交换 如果第i个位置的元素不为i，则执行交换 如果第i个位置的元素为i，则说明该元素重复了，直接返回 12345678910def findRepeatNumber(self, nums: List[int]) -&gt; int: n = len(nums) for i in range(n): while i != nums[i]: if nums[i] == nums[nums[i]]: return nums[i] else: temp = nums[i] nums[i], nums[temp] = nums[temp], nums[i]","categories":[{"name":"Sword Offer","slug":"Sword-Offer","permalink":"http://zivblog.top/categories/Sword-Offer/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Python环境配置","slug":"Python环境配置","date":"2020-06-16T02:19:58.000Z","updated":"2020-07-11T05:36:38.000Z","comments":true,"path":"passages/python-huan-jing-pei-zhi/","link":"","permalink":"http://zivblog.top/passages/python-huan-jing-pei-zhi/","excerpt":"Python环境配置","text":"Python环境配置 Motivation 现在百度来的环境配置教程太繁琐~，且不友好，遂整理出这篇博文，希望对看到的你有所帮助 中间遇到问题或错误，欢迎交流指正 内容仅针对Window10，MaxOS可自行百度 你需要下载这些东西 Python3.x，在这里下载你顺眼的版本， 不要用最新的，推荐3.6或者3.7 下载带executable installer且x86-64字样的，省心 Pycharm 在这里下载，有两种可选 专业版，功能齐全，需要PJ 社区版，功能经过阉割，无需PJ，免费使用 社区版足够使用，如需进行网页开发，Python开发及远程连接功能，请下载专业版 PJ教程参考一份香甜的免费午餐 只需以下几步 对于下载好的Python3.x，双击 需要注意的来了（两点） 直接点击Install Now会安装到寸土寸金的C盘，所以我们选择下面的Customize installation 之后一路Next，直到： 勾选红色箭头所指的选项，其他的凭个人喜好 下面的Customize install location选择一个位置（尽量不要是C盘，最好是盘符下的根目录，该文件夹需自行创建），例如D:\\Python3.8 等待安装完成，打开cmd——组合键win+R，输入cmd 在命令行界面输入python，出现版本等信息证明安装成功，输入exit()即可退出Python环境 Pycharm 正常安装即可，没有需要注意的地方 安装之后打开（截图来自专业版，实际都大同小异） location处，取一个你喜欢的响当当的名字~，例如：’python_learn’。这个是工程的名字，即一个文件夹，下面可以有很多python文件 Project Interpreter处选择Existing interpreter，找到之前安装的python 不推荐使用虚拟环境，也就是上面的New environment，这个会创建一个基于本工程的Python环境。如果使用的话注意这个会下载python文件用于编译该工程的文件，需等待片刻才能使用 进入工程后，创建文件 输入内容并编译执行，即可得到代码执行后的内容 后续如果想要使用更多的Python包，可使用Anaconda——一款Python的集成环境，预装了很多常用工具包，使用清华源下载更快 ———— 2020.7.11 更新 推荐练习或者简单的小项目使用jupyter notebook 安装方法： 在cmd命令行中使用pip install jupyter等待安装完成即可 安装完成之后执行jupyter notebook命令即可启动该工具 如果安装的是Anaconda，会自带jupyter包，直接在命令行中执行jupyter notebook即可 在jupyter中创建文件的方式如下: 执行cell中代码的快捷键是Shift+Enter 完结，撒花🎈🎈🎈","categories":[{"name":"工具配置","slug":"工具配置","permalink":"http://zivblog.top/categories/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://zivblog.top/tags/Tools/"}]},{"title":"Leetcode之每个元音包含偶数次的最长子字符串","slug":"Leetcode之每个元音包含偶数次的最长子字符串","date":"2020-06-08T02:32:22.000Z","updated":"2020-07-06T05:23:08.000Z","comments":true,"path":"passages/leetcode-zhi-mei-ge-yuan-yin-bao-han-ou-shu-ci-de-zui-chang-zi-zi-fu-chuan/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-mei-ge-yuan-yin-bao-han-ou-shu-ci-de-zui-chang-zi-zi-fu-chuan/","excerpt":"Find the Longest Substring Containing Vowels in Even Counts","text":"Find the Longest Substring Containing Vowels in Even Counts Find the Longest Substring Containing Vowels in Even Counts code with Python title numbers：1371 读题 给定一个字符串s，返回满足下列条件的最长字符串的长度 每个出现在子串中的元音字母（a, e, i, o, u）都恰好出现了偶数次 示例： 123输入：s &#x3D; &quot;eleetminicoworoep&quot;输出：13解释：最长子字符串是 &quot;leetminicowor&quot; ，它包含 e，i，o 各 2 个，以及 0 个 a，u 思路一 暴力+剪枝 双层循环找到所有的子串，对每个子串统计元音字母的个数，如果满足条件，则更新最长字符串的长度 可以反向枚举，即从最长的子串开始枚举，这样就可以更快的接近答案 1234567891011def findTheLongestSubstring(self, s: str) -&gt; int: for i in range(len(s), 0, -1): for j in range(len(s) - i + 1): sub = s[j:j + i] has_odd_vowel = False for vowel in ['a', 'e', 'i', 'o', 'u']: if sub.count(vowel) % 2 != 0: has_odd_vowel = True break if not has_odd_vowel: return i return 0 思路二 我们知道枚举所有子串是会有很多重复统计的 简化这部分操作会使时间复杂度显著降低 对每个字母维护一个前缀和，p[i][k]表示字符串前i个字符中，第k个原因字母出现的次数 此时如果要判断子串[l:r]是否满足条件，就可以使用p[r][k]-p[l-1][k]来直接得到该子串中第k个元音字母是否满足条件 123456789101112131415161718192021222324252627282930i_mapper = &#123; \"a\": 0, \"e\": 1, \"i\": 2, \"o\": 3, \"u\": 4&#125;def check(self, s, pre, l, r): for i in range(5): if s[l] in self.i_mapper and i == self.i_mapper[s[l]]: cnt = 1 else: cnt = 0 if (pre[r][i] - pre[l][i] + cnt) % 2 != 0: return False return Truedef findTheLongestSubstring(self, s: str) -&gt; int: n = len(s) pre = [[0] * 5 for _ in range(n)] # pre for i in range(n): for j in range(5): if s[i] in self.i_mapper and self.i_mapper[s[i]] == j: pre[i][j] = pre[i - 1][j] + 1 else: pre[i][j] = pre[i - 1][j] for i in range(n - 1, -1, -1): for j in range(n - i): if self.check(s, pre, j, i + j): return i + 1 return 0","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之阈值距离内邻居最少的城市","slug":"Leetcode之阈值距离内邻居最少的城市","date":"2020-06-07T02:30:47.000Z","updated":"2020-07-06T05:30:43.000Z","comments":true,"path":"passages/leetcode-zhi-yu-zhi-ju-chi-nei-lin-ju-zui-shao-de-cheng-shi/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-yu-zhi-ju-chi-nei-lin-ju-zui-shao-de-cheng-shi/","excerpt":"Find the City With the Smallest Number of Neighbors at a Threshold Distance","text":"Find the City With the Smallest Number of Neighbors at a Threshold Distance Find the City With the Smallest Number of Neighbors at a Threshold Distance code with Python title number：1334 读题 有n个城市，按0到n-1编号 给你一个边数组edges，其中edges[i]=[from_i, to_i, weight_i]，代表的是从from_i到to_i两个城市之间的双向加权边 距离阈值是一个整数distanceThreshold 返回能通过某些路径到达其他城市数目最多，且路径距离最大为distanceThreshold的城市 如果有多个这样的城市，则返回编号最大的 示例： 在上图中，设距离阈值为4 每个城市阈值距离范围内的邻居城市如下 城市0：城市1，城市2 城市1：城市0，城市2，城市3 城市2：城市0，城市1，城市3 城市3：城市1，城市2 返回3（编号最大，邻居最少） 思路一 问题的本质是查找两个城市之间的最短路径 对于多源最短路径，我们使用Floyd-Warshall算法 得到各个城市之间的最短路径 对每个城市筛选距离不大于阈值的邻居城市 最后统计每个城市满足条件的城市 返回邻居城市最少且编号最大的城市 123456789101112131415161718192021222324252627def findTheCity(self, n: int, edges: List[List[int]], distanceThreshold: int) -&gt; int: # distance矩阵，二维矩阵 dist = [[float('inf')] * n for _ in range(n)] # 初始化 for i, j, w in edges: dist[i][j] = w dist[j][i] = w for i in range(n): dist[i][i] = 0 # 求最短 for k in range(n): for i in range(n): for j in range(n): dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j]) # 过滤 res = 0 minCnt = float('inf') for i in range(n): cnt = 0 for d in dist[i]: if d &lt;= distanceThreshold: cnt += 1 if cnt &lt;= minCnt: minCnt = cnt res = i return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之子数组异或查询","slug":"Leetcode之子数组异或查询","date":"2020-06-06T11:09:13.000Z","updated":"2020-07-06T05:32:34.000Z","comments":true,"path":"passages/leetcode-zhi-zi-shu-zu-yi-huo-cha-xun/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zi-shu-zu-yi-huo-cha-xun/","excerpt":"XOR Queries of a Subarray","text":"XOR Queries of a Subarray XOR Queries of a Subarray code with Python title number：1310 读题 有一个正整数数组arr，现给定一个对应的查询数组queries，其中queries[i]= $[L_i, R_i]$ 对于每个查询i，请计算从Li到Ri的XOR值（即arr[i] xor arr[Li+1] xor .. xor arr[Ri]​）作为本次查询的结果 并返回一个包含给定查询queries所有结果的数组 示例： 12345678910111213输入：arr &#x3D; [1,3,4,8], queries &#x3D; [[0,1],[1,2],[0,3],[3,3]]输出：[2,7,14,8] 解释：数组中元素的二进制表示形式是：1 &#x3D; 0001 3 &#x3D; 0011 4 &#x3D; 0100 8 &#x3D; 1000 查询的 XOR 值为：[0,1] &#x3D; 1 xor 3 &#x3D; 2 [1,2] &#x3D; 3 xor 4 &#x3D; 7 [0,3] &#x3D; 1 xor 3 xor 4 xor 8 &#x3D; 14 [3,3] &#x3D; 8 思路一 直接线上暴力解法 双层循环 12345678910def xorQueries(self, arr: List[int], queriesL List[List[int]]) -&gt; List[int]: res = [] for (L, R) in queries: i = L xor = 0 while i &lt; R: xor ^= arr[i] i += 1 res.append(xor) return res 毫无悬念的超时了 思路二 前缀表达式 我们使用一个数组pre来表示数组arr的前缀异或和 12pre[0] &#x3D; 0pre[i] &#x3D; arr[0] ^ arr[1] ... ^ arr[i-1] 这样以来，我们要计算arr[Li]到arr[Ri]的异或值时，我们可以通过 12345pre[Li] ^ pre[Ri+1] &#x3D; (arr[0] ^ ... ^ arr[Li-1])^(arr[0] ^ ... ^ arr[Ri])&#x3D; (arr[0] ^ ... ^ arr[Li - 1]) ^ (arr[0] ^ ... ^ arr[Li - 1]) ^ (arr[Li] ^ ... ^ arr[Ri]) （异或运算的结合律）&#x3D; 0 ^ (arr[Li] ^ ... ^ arr[Ri]) （异或运算的逆运算，即 a ^ a &#x3D; 0）&#x3D; arr[Li] ^ ... ^ arr[Ri] 总的来说，需要知道异或运算的一个规律，即x ^ y ^ x = y 123456789def xorQueries(self, arr: List[int], queriesL List[List[int]]) -&gt; List[int]: pre = [0] res = [] for i in range(len(arr)): pre.append(pre[i] ^ arr[i]) for (L, R) in queries: res.append(pre[L] ^ pre[R + 1]) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之子串出现的最大次数","slug":"Leetcode之子串出现的最大次数","date":"2020-06-05T01:44:16.000Z","updated":"2020-07-06T05:32:15.000Z","comments":true,"path":"passages/leetcode-zhi-zi-chuan-chu-xian-de-zui-da-ci-shu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zi-chuan-chu-xian-de-zui-da-ci-shu/","excerpt":"Maximum Number of Occurrences of a Substring","text":"Maximum Number of Occurrences of a Substring Maximum Number of Occurrences of a Substring code with Python title number：1297 读题 给定一个字符串S，返回满足下列条件且出现次数最大的任意子串的出现次数： 子串中不同字母的数目必须小于等于maxLetters 子串的长度必须大于等于minSize且小于等于maxSize 示例： 1234输入：s &#x3D; &quot;aababcaab&quot;, maxLetters &#x3D; 2, minSize &#x3D; 3, maxSize &#x3D; 4输出：2解释：子串 &quot;aab&quot; 在原字符串中出现了 2 次。它满足所有的要求：2 个不同的字母，长度为 3 （在 minSize 和 maxSize 范围内）。 思路一 尝试暴力解法： 找出所有满足长度要求（[minSize, maxSize]）的子串 对于maxLetter满足题意的子串，统计其出现次数 返回最大的出现次数 1234567891011121314151617181920def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -&gt; int: n = len(s) letters = set() cnts = dict() res = 0 for i in range(n - minSize + 1): length = minSize while i + length &lt;= n and length &lt;= maxSize: t = s[i:i+length] for c in t: if len(letters) &gt; maxLetters: break letters.add(c) if len(letters) &lt;= maxLetters: cnts[t] = cnts.get(t, 0) + 1 res = max(res, cnts[t]) letters.clear() length += 1 return res 代码超时 思路二 我们尝试在上述思路的基础上进行优化 从题目要求中可以分析出——maxSize属于无用信息，不需要考虑，而是只需要统计长度等于minSize的子串即可 原因是，如果一个长度大于minSize的子串满足条件，那么该子串其中必定至少一个长度为minSize的子串满足条件 所以如果一个长度大于minSize的子串出现了n次，必定有一个长度为minSize的子串出现了n次 于是题目转化为了一个滑动窗口的问题，我们只需要通过滑动窗口来判断所有长度为minSize的子串中有多少满足条件即可 123456789def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -&gt; int: counter, res = &#123;&#125;, 0 for i in range(0, len(s) - minSize + 1): sub = s[i: i + minSize] if len(set(sub)) &lt;= maxLetters: counter[sub] = counter.get(sub, 0) + 1 res = max(res, counter[sub]) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之可被三整除的最大和","slug":"Leetcode之可被三整除的最大和","date":"2020-06-04T08:39:33.000Z","updated":"2020-07-06T05:19:58.000Z","comments":true,"path":"passages/leetcode-zhi-ke-bei-san-zheng-chu-de-zui-da-he/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-ke-bei-san-zheng-chu-de-zui-da-he/","excerpt":"Greatest Sum Divisible by Three","text":"Greatest Sum Divisible by Three Greatest Sum Divisible by Three code with Python title number：1262 读题 给定一个数组，找出并返回可被三整除的元素最大和 示例： 123输入：nums &#x3D; [3,6,5,1,8]输出：18解释：选出数字 3, 6, 1 和 8，它们的和是 18（可被 3 整除的最大和） 思路一 比较暴力的想法是穷举所有可能的组合，然后判断是否可被三整除 由于nums的长度为[1, 4*10^4]，这种方法必定会超时 思路二 排序+减法 我们首先计算出所有元素的总和并判断是否能被三整除 如果能整除，即余数为0，则直接返回结果 如果不能整除，可能的情况有两种：余数为1或余数为2 针对这两种情况，我们分别建立数组one和two，数组内元素被排序 两个数组分别存储余数为1和余数为2的元素 如果余数为1，我们减去one数组中最小的元素，或者减去two数组中最小的两个元素。取决于两者谁更小 如果余数为1，我们减去two数组中最小的元素，或者减去one数组中最小的两个元素。取决于两者谁更小 1234567891011121314151617181920212223def maxSumDivThree(self, nums: List[int]) -&gt; int: one, two = [], [] total = 0 for num in nums: total += num if num % 3 == 1: one.append(num) if num % 3 == 2: two.append(num) one.sort(), two.sort() if total % 3 == 0: return total elif total %3 == 1 and one: if len(two) &gt;= 2 and one[0] &gt; two[0]+two[1]: return total - two[0] - two[1] return total - one[0] elif total % 3 == 2 and two: if len(one) &gt;= 2 and two[0] &gt; one[0]+one[1]: return total - one[0] - one[1] return total - two[0] return 0 思路二 我们发现上述的算法中，我们只用到了one数组和two数组中最小的两个数 所以我们只需要使用4个存储空间来存储两个数组即可 1234567891011121314151617181920212223242526272829303132def maxSumDivThree(self, nums: List[int]) -&gt; int: one, two = [float('inf')]*2, [float('inf')]*2 total = 0 for num in nums: total += num if num % 3 == 1: if num &lt; one[0]: t = one[0] one[0] = num one[1] = t elif num &lt; one[1]: one[1] = num if num % 3 == 2: if num &lt; two[0]: t = two[0] two[0] = num two[1] = t elif num &lt; two[1]: two[1] = num if total % 3 == 0: return total elif total %3 == 1 and one: if len(two) &gt;= 2 and one[0] &gt; two[0]+two[1]: return total - two[0] - two[1] return total - one[0] elif total % 3 == 2 and two: if len(one) &gt;= 2 and two[0] &gt; one[0]+one[1]: return total - one[0] - one[1] return total - two[0] return 0","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之在受污染的二叉树中查找元素","slug":"Leetcode之在受污染的二叉树中查找元素","date":"2020-06-03T01:05:49.000Z","updated":"2020-07-06T05:30:58.000Z","comments":true,"path":"passages/leetcode-zhi-zai-shou-wu-ran-de-er-cha-shu-zhong-cha-zhao-yuan-su/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zai-shou-wu-ran-de-er-cha-shu-zhong-cha-zhao-yuan-su/","excerpt":"Find Elements in a Contaminated Binary Tree","text":"Find Elements in a Contaminated Binary Tree Find Elements in a Contaminated Binary Tree code with Python title number：1261 读题 给定一个满足下述规则的二叉树 root.val == 0 如果treeNode.val == x且treeNode.left != null，那么treeNode.left.val == 2*x + 1 如果treeNode.val == x且treeNode.right != null，那么treeNode.right.val == 2*x +2 现在，二叉树受到了污染，所有的treeNode.val都变成了-1 需要先还原二叉树，然后实现FindElements类 FindElements(TreeNode* root)用受污染的二叉树初始化对象，需要先将其还原 bool find(int target)判断目标值target是否存在于还原后的二叉树中并返回结果 思路一 根据题目描述，我们可以递归的由根结点得到所有结点的值，这样，就可以通过一次遍历，还原所有的结点的值 所以，比较朴素的想法就是全上递归 递归建树 递归查找 123456789101112131415161718192021222324class FindElements: def __init__(self, root: TreeNode): node = None def recover(node): if not node: return node if node.left: node.left.val = 2 * node.val + 1 if node.right: node.right.val = 2 * node.val + 2 recover(node.left) recoder(node.right) return node root.val = 0 self.node = recover(root) def find(self, target: int) -&gt; bool: def findTree(node, target): if not node: return False if node.val == target: return True return findTree(node.left, target) or findTree(node.right, target) return findTree(self.node, target) 不出意外的超时了😂😂😂 思路二 延续上一题的思路，使用空间换时间 123456789101112131415161718192021class FindElements: def __init__(self, root: TreeNode): self.seen = set() def recover(node): if not node: return node if node.left: node.left.val = 2 * node.val + 1 self.seen.add(node.left.val) if node.right: node.right.val = 2 * node.val + 2 self.seen.add(node.right.val) recover(node.left) recover(node.right) return node root.val = 0 self.seen.add(0) self.node = recover(root) def find(self, target: int) -&gt; bool: return target in self.seen","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之飞机座位分配概率","slug":"Leetcode之飞机座位分配概率","date":"2020-06-02T02:24:38.000Z","updated":"2020-07-06T05:15:31.000Z","comments":true,"path":"passages/leetcode-zhi-fei-ji-zuo-wei-fen-pei-gai-lu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-fei-ji-zuo-wei-fen-pei-gai-lu/","excerpt":"Airplane Seat Assignment Probability","text":"Airplane Seat Assignment Probability Airplane Seat Assignment Probability code with Python title number：1227 读题 有n位乘客即将登机，飞机正好有n个作为，第一位乘客的票丢了，它随便选了一个作为坐下 剩下的乘客将会 如果他们的座位还空着，就做到自己的座位上 如果它们的座位被占用时，随机选择其他座位 第n位乘客坐在自己作为上的概率是多少 思路一 按照题意，暴力递归 原问题定义为f(n)，对于第一个人来说，有n种选择，选择每个位置的概率都是$\\frac{1}{n}$ 如果第一个人选择了自己的位置，则剩下的人只需按自己票上的座位坐好即可，即最后一个人必会坐到自己的座位上 如果第一个人选择了最后一个人的位置，则最后一个人必不能坐到自己的位置上 如果第一个人选择了第i个位置（ 1 &lt; i &lt; n），那么第i个人就成为了新的“丢票的人”，问题转化为f(n-i+1) 123456789def nthPersonGetNthSeat(self, n: int) -&gt; float: if n == 1: return 1 if n == 2: return 0.5 res = 1 / n for i in range(2, n): res += self.nthPersonGetNthSeat(n-i+1) * 1 / n return res 栈溢出 思路二 数学思想 首先，将上述的递归表达式写出来 1234f(n) &#x3D; 1&#x2F;n + 0 + 1&#x2F;n*(f(n-1)+f(n-2)...f(2))&#x3D; 1&#x2F;n * (f(n-1)+f(n-2)...f(2)+1)&#x3D; 1&#x2F;n * (f(n-1)+f(n-2)...f(2)+f(1)) 下面对其进行化简 首先，写出f(n-1) 1f(n-1) &#x3D; 1&#x2F;(n-1) * (f(n-2)+f(n-3)...f(1)) 将上述两式两遍分别乘以n和n-1，即消除右侧分母 12n * f(n) &#x3D; f(n-1) + f(n-2) + ... + f(1)(n-1) * f(n-1) &#x3D; f(n-2) + f(n-3) + ... + f(1) 将两者相减 1n*f(n) - (n-1)*f(n-1) &#x3D; f(n-1) 将(n-1)*f(n-1)移到右边 1n * f(n) &#x3D; n * f(n-1) 即f(n) == f(n-1)（n &gt; 2） 这是一个重要的结论，以此，我们可以得到 12345f(1) &#x3D; 1f(2) &#x3D; 0.5f(3) &#x3D; f(2) &#x3D; 0.5...f(n) &#x3D; f(n-1) &#x3D; 0.5 12def nthPersonGetNthSeat(self, n: int) -&gt; float: return 1 if n == 1 else 0.5","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之最长定差子序列","slug":"Leetcode之最长定差子序列","date":"2020-06-01T05:41:55.000Z","updated":"2020-07-06T05:34:41.000Z","comments":true,"path":"passages/leetcode-zhi-zui-chang-ding-chai-zi-xu-lie/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zui-chang-ding-chai-zi-xu-lie/","excerpt":"Longest Arithmetic SubSequence of Fiven Difference","text":"Longest Arithmetic SubSequence of Fiven Difference Longest Arithmetic SubSequence of Fiven Difference code with Python title number：1218 读题 给定一个整数数组arr和一个整数difference，请你找出arr中所有相邻元素之间等于给定difference的等差子序列，并返回其中最长的等差子序列的长度 示例 123输入：arr &#x3D; [1, 2, 3, 4], difference &#x3D; 1输出：4解释：最长的等差子序列是 [1, 2, 3, 4] 思路一 最直观的思路就是使用双循环，我们暴力枚举出以每一个元素为开始元素，以最后元素结尾的所有情况 1234567891011def longestSubsequence(self, arr: List[int], difference: int) -&gt; int: n = len(arr) res = 1 for in range(n): count = 1 for j in range(i+1, n): if arr[i] + difference * count == arr[j]: count += 1 if count &gt; res: res = count return res 超时，时间复杂度为$O(n^2)$ 思路二 动态规划 将每一个元素结尾的最长等差子序列的长度保存起来，这样在遍历新的元素的时候，只需从之前的存储中找是否有符合的，如果有，则更新当前的值，否则就不进行操作 具体而言 使用dp[num]中每个位置记录以当前元素为结尾的最长等差子序列的长度 当遍历到一个新的元素的时候，就去之前的存储中找dp[num-difference] 如果找到了，则更新当前值为dp[num] = dp[num-difference]+1； 否则，更新当前值为dp[num] = 1 12345678910def longestSubsequence(self, arr: List[int], difference: int) -&gt; int: n = len(arr) res = 1 dp = &#123;&#125; for num in arr: dp[num] = 1 if num - difference in dp: dp[num] = dp[num - difference] + 1 return max(dp.values())","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之删除一次得到子数组最大和","slug":"Leetcode之删除一次得到子数组最大和","date":"2020-05-31T02:37:33.000Z","updated":"2020-07-06T05:26:09.000Z","comments":true,"path":"passages/leetcode-zhi-shan-chu-yi-ci-de-dao-zi-shu-zu-zui-da-he/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-shan-chu-yi-ci-de-dao-zi-shu-zu-zui-da-he/","excerpt":"Maximum Subarray Sum with One Deletion","text":"Maximum Subarray Sum with One Deletion Maximum Subarray Sum with One Deletion code with Python title number：1186 读题 给定一个整数数组，返回其某个非空子数组（连续元素）在执行一次可选的删除操作后，所能得到的最大元素总和 换句话说，你可以从原数组中选出一个子数组，并可以决定要不要从中删除一个元素，（删除后）子数组中至少应当有一个元素，然后该子数组（剩下）的元素总和是所有子数组中最大的 示例 1234567输入：arr &#x3D; [1, -2, 0, 3]输出：4解释：我们可以选择[1, -2, 0, 3]，然后删掉-2，这样得到的[1, 0, 3]和最大输入：arr &#x3D; [-1, -1, -1, -1]输出：-1解释：最后得到的子数组不能为空，所以可以选择[-1, -1]删掉其中一个；或者选择[-1],不删除任何元素 思路一 暴力的做法是 计算所有可能的情况，取出最大的即可 使用双层循环，外循环用于确定我们丢弃的元素，内循环用于计算 12345678910111213141516def maximumSum(self, arr: List[int]) -&gt; int: res = arr[0] def maxSubSum(arr, skip): res = maxSub = float(\"-inf\") for i in range(len(arr)): if i == skip: continue maxSub = max(arr[i], maxSub+arr[i]) res = max(res, maxSub) return res for i in range(len(arr)+1): res = max(res, maxSubSum(arr, i)) return res 超时 思路一 基于上述方法会超时，我们考虑能否用空间换时间 从头尾分别遍历，建立两个子数组集合L, R 第一次从左向右遍历，建立数组L，L[i]表示从左向右以arr[i]结尾的子数组的最大值 第二次从右向左遍历，建立数组R，R[i]表示从右向左以arr[i]结尾的子数组的最大值 第三次遍历，计算L[i-1]+R[i+1]的最大值 这样，我们就可以在空间扩大一倍的情况下，将时间由O(n^2)降低到了O(n) 1234567891011121314151617181920def maximumSum(self, arr: List[int]) -&gt; int: n = len(arr) L = [arr[0]] * n R = [arr[n - 1]] * n if n == 1: return arr[0] res = arr[0] for i in range(1, n): L[i] = max(L[i-1] + arr[i], arr[i]) res = max(res, L[i]) for i in range(n-2, -1, -1): R[i] = max(R[i+1]+arr[i], arr[i]) res = max(res, R[i]) for i in range(1, n-1): res = max(res, L[i-1]+R[i+1]) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之绝对值表达式的最大值","slug":"Leetcode之绝对值表达式的最大值","date":"2020-05-30T02:39:50.000Z","updated":"2020-07-06T05:19:19.000Z","comments":true,"path":"passages/leetcode-zhi-jue-dui-zhi-biao-da-shi-de-zui-da-zhi/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-jue-dui-zhi-biao-da-shi-de-zui-da-zhi/","excerpt":"Maximum of Absolute Value Expression","text":"Maximum of Absolute Value Expression Maximum of Absolute Value Expression code with Python title number：1131 读题 给定两个长度相等的整数数组，返回下面表达式的最大值： |arr1[i] - arr1[j]| + |arr2[i] - arr2[j]| + |i - j| 其中i, j，满足0 &lt;= i, j &lt; arr1.length 示例： 1234输入：arr1 &#x3D; [1, 2, 3, 4], arr2 &#x3D; [-1, 3, 5, 6]输出：13解释：|1 - 4| + |-1 - 6| + |1 - 4| &#x3D; 13 思路一 数学分析，即去绝对值运算 表达式分为三部分，每一个部分绝对值内的计算结果会有两种情况（大于等于0 or小于0），故共有2 * 2 * 2 = 8种情况 我们尝试去掉绝对值，可以得到八个可能的表达式 arr1[i]-arr1[j]+arr2[i]-arr2[j]+i-j arr1[i]-arr1[j]-(arr2[i]-arr2[j])+i-j -(arr1[i]-arr1[j])+arr2[i]-arr2[j]+i-j -(arr1[i]-arr1[j])-(arr2[i]-arr2[j])+i-j arr1[i]-arr1[j]+arr2[i]-arr2[j]-(i-j) arr1[i]-arr1[j]-(arr2[i]-arr2[j])-(i-j) -(arr1[i]-arr1[j])+arr2[i]-arr2[j]-(i-j) -(arr1[i]-arr1[j])-(arr2[i]-arr2[j])-(i-j) 由于i, j之间没有大小关系，所以上述表达式可以缩减为4个 arr1[i]-arr1[j]+arr2[i]-arr2[j]+i-j arr1[i]-arr1[j]-(arr2[i]-arr2[j])+i-j -(arr1[i]-arr1[j])+arr2[i]-arr2[j]+i-j -(arr1[i]-arr1[j])-(arr2[i]-arr2[j])+i-j 我们只需计算上述四个表达式的最大值即可 再次进行变换，我们分别将与i, j相关的聚合到一起 arr1[i] + arr2[i] + i - (arr1[j] + arr2[j] + j) arr1[i] - arr2[i] + i - (arr1[j] - arr2[j] + j) arr2[i] - arr1[i] + i - (arr2[j] - arr1[j] + j) -arr2[i] - arr1[i] + i - (-arr1[j] - arr2[j] + j) 观察上式，可以发现，表达式的最大值即左半部分的最大值和右半部分的最小值之差 并且，由于i, j之间可以互换，前半部分和后半部分是等价的 故 遍历一遍数组，计算四个表达式的最大值和最小值 ``arr1[i] + arr2[i] + i` arr1[i] - arr2[i] + i arr2[i] - arr1[i] + i -arr2[i] - arr1[i] + i 分别取出四个表达式的最大值和最小值的差值 比较得到四个表达式中最大的差值即可 1234567891011121314def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -&gt; int: A, B, C, D = [], [], [], [] for i in range(len(arr1)): a = arr1[i] + arr2[i] + i b = arr1[i] - arr2[i] + i c = arr2[i] - arr1[i] + i d = -1 * arr2[i] - arr1[i] + i A.append(a) B.append(b) C.append(c) D.append(d) return max(max(A)-min(A), max(B)-min(B), max(C)-min(C), max(D)-min(D))","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之二叉树寻路","slug":"Leetcode之二叉树寻路","date":"2020-05-29T04:53:16.000Z","updated":"2020-07-06T05:12:46.000Z","comments":true,"path":"passages/leetcode-zhi-er-cha-shu-xun-lu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-er-cha-shu-xun-lu/","excerpt":"Path In Zigzag Labelled Binary Tree","text":"Path In Zigzag Labelled Binary Tree Path In Zigzag Labelled Binary Tree code with Python title number：1104 读题 在一棵无限的二叉树上，每个结点都有两个子节点，树中的结点逐行“之”字型进行标记 在奇数行从左向右标记 在偶数行按从右到左标记 给出树上的某个结点的标号label，返回从根节点到该标号为label的路径。路径由途径的结点标号组成 示例： 12输入：label &#x3D; 14输出：[1, 3, 4, 14] 思路一 随便说句：如果这道题是按层次遍历（一个方向）来标记，那么可以直接由子节点推算出父节点的标记 通过观察我们发现一个规律： 以上图最后一层为例： 12按“之”字形排列：15, 14, 13, 12, 11, 10, 9, 8按常规层次遍历： 8, 9, 10, 11, 12, 13,14,15 可以观察到，”之“字型排列和常规排列之和为一常数，并且等于该行的最大最小值之和 因此，问题转化为求每行行对应的常数，然后用其减去当前值就能得到标记的值 当前值可以通过二叉树子节点和父节点的关系得到 更进一步，由于满二叉树的性质：每一行的最小值为2^(level-1)，最大值为2^level - 1 那么，问题更简化为求每一行的level（直接用一个变量记录即可） 1234567891011121314def pathInZigZagTree(self, label: int) -&gt; List[int]: level = 0 res = [] while 2** level - 1 &lt; label: level += 1 while level &gt; 0: res.insert(0, label) label = 2 ** (level-1) + 2 ** level -1 - label label //= 2 level -= 1 return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之两个非重叠子数组的最大和","slug":"Leetcode之两个非重叠子数组的最大和","date":"2020-05-28T02:07:44.000Z","updated":"2020-07-06T05:20:20.000Z","comments":true,"path":"passages/leetcode-zhi-liang-ge-fei-chong-die-zi-shu-zu-de-zui-da-he/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-liang-ge-fei-chong-die-zi-shu-zu-de-zui-da-he/","excerpt":"Maximum Sum of Two Non-Overlapping Subarrays","text":"Maximum Sum of Two Non-Overlapping Subarrays Maximum Sum of Two Non-Overlapping Subarrays code with Python title number：1031 读题 给出非负整数数组A，返回两个非重叠（连续）子数组中元素的最大和，子数组的长度分别为L和M 长为L的子数组可以出现在长为M的子数组之前或之后 从形式上看，返回最大的V，V = (A[i] + A[i+1] + ... + A[i+L-1]) + (A[j] + A[j+1] + ... + A[j+M-1]) 示例： 123输入: [0, 6, 5, 2, 2, 5, 1, 9, 4], L &#x3D; 1, M &#x3D; 2输出: 20解释: 长度为1的子数组为[9]，长度为2的子数组为[6, 5] 思路一 一个简单的想法是穷举所有符合长度为L的子数组，再对剩余的数组元素列举所有长度为M的子数组，返回最大值即可 时间复杂度太高，必会超时 这里尝试用动态规划进行求解 根据题意，数组必定会被分为两部分（左边包含长为L的子数组，右边包含长为M的子数组，或者反过来） 这样就有四种状态，我们分别使用一次动态规划来得到相应的结果 dp[i][0]：从A[0]~A[i]中长为L的最大连续子数组 dp[i][1]：从A[0]~A[i]中长为M的最大连续子数组 dp[i][2]：从A[i+1]~A[len(A)-1]中长为L的最大连续子数组 dp[i][3]：从A[i+1]~A[len(A)-1]中长为M的最大连续子数组 这里使用滑动窗口分别对每个动态规划任务进行计算 最终，取其中的最大组合即可（dp[i][0]+dp[i][2]或dp[i][1]+dp[i][3]） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -&gt; int: dp = [[0, 0, 0, 0] for _ in range(len(A))] # L在左边 presum = 0 for i in range(L): presum += A[i] maxsum = presum dp[L-1][0] = maxsum # 华东窗口 for i in range(L, len(A)): presum -= A[i-L] presum += A[i] maxsum = max(maxsum, presum) dp[i][0] = maxsum # M在左边 presum = 0 for i in range(M): presum += A[i] maxsum = presum dp[M-1][1] = maxsum for i in range(M, len(A)): presum -= A[i-M] presum += A[i] maxsum = max(maxsum, presum) dp[i][1] = maxsum # L在右边 presum = 0 for i in range(len(A)-1, len(A)-L-1, -1): presum += A[i] maxsum = presum dp[len(A)-L][2] = maxsum for i in range(len(A)-L-1, -1, -1): presum -= A[i+L] presum += A[i] maxsum = max(maxsum, presum) dp[i][2] = maxsum # M在右边 presum = 0 for i in range(len(A)-1, len(A)-M-1, -1): presum += A[i] maxsum = presum dp[len(A)-M][3] = maxsum for i in range(len(A)-M-1, -1, -1): presum -= A[i+M] presum += A[i] maxsum = max(maxsum, presum) dp[i][3] = maxsum res = 0 # 取最大组合 for i in range(L, len(A)-M+1): res = max(res, dp[i-1][0] + dp[i][3]) for i in range(M, len(A)-L+1): res = max(res, dp[i-1][1] + dp[i][2]) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之驼峰式匹配","slug":"Leetcode之驼峰式匹配","date":"2020-05-27T01:37:01.000Z","updated":"2020-07-06T05:28:29.000Z","comments":true,"path":"passages/leetcode-zhi-tuo-feng-shi-pi-pei/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-tuo-feng-shi-pi-pei/","excerpt":"Camelcase Matching","text":"Camelcase Matching Camelcase Matching code with Python title number：1023 读题 如果可以将小写字母插入模式串pattern中得到带查询项query，则称待查询项与给定模式串匹配 给定待查询列表queries和模式串pattern，返回由布尔值组成的答案列表。 answer[i]=True表示匹配成功，否则为匹配失败 示例： 123456输入：queries &#x3D; [&quot;FooBar&quot;,&quot;FooBarTest&quot;,&quot;FootBall&quot;,&quot;FrameBuffer&quot;,&quot;ForceFeedBack&quot;], pattern &#x3D; &quot;FB&quot;输出：[true,false,true,true,false]解释：&quot;FooBar&quot; 可以这样生成：&quot;F&quot; + &quot;oo&quot; + &quot;B&quot; + &quot;ar&quot;。&quot;FootBall&quot; 可以这样生成：&quot;F&quot; + &quot;oot&quot; + &quot;B&quot; + &quot;all&quot;.&quot;FrameBuffer&quot; 可以这样生成：&quot;F&quot; + &quot;rame&quot; + &quot;B&quot; + &quot;uffer&quot;. 需要注意的是最后一个，由于只能插入小写字母，所以无法通过在FB上插入字母得到ForceFeedBack 思路一 双指针 我们将两个指针i, j分别指向模式串和待查询串的第一个字母 当指针指向的两个字母相同时，同时将两个指针向后移动一个位置 当指针指向的两个字母不相同时，移动指向查询串的j 直到j超出了查询串的范围，此时判断模式串是否遍历完毕（True） 当模式串提前遍历完时可提前退出 123456789101112131415161718192021def camelMatch(self, queries: List[str], pattern: str) -&gt; List[bool]: def isValid(pattern, query): i, j = 0, 0 while j &lt; len(query): if i &lt; len(pattern) and pattern[i] == query[j]: i += 1 j += 1 else: if query[j] &gt;='a' and query[j] &lt;= 'z': j += 1 else: return False return i == len(pattern) ans = [] for query in queries: ans.append(isValid(pattern, query)) return ans","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之飞地的数量","slug":"Leetcode之飞地的数量","date":"2020-05-26T02:24:16.000Z","updated":"2020-07-06T05:14:07.000Z","comments":true,"path":"passages/leetcode-zhi-fei-di-de-shu-liang/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-fei-di-de-shu-liang/","excerpt":"Number of Enclaves","text":"Number of Enclaves Number of Enclaves code with Python title number：1020 读题 给定一个二维数组，每个单元格为0（海）或1（陆地） 移动是指在陆地上从一个地方走到另一个地方（四个方向）或者离开网格的边界 返回网格中无法在任意次数的移动中离开网络边界的陆地单元格的数量 示例： 1234567[[0, 0, 0, 0], [1, 0, 1, 0], [0, 1, 1, 0], [0, 0, 0, 0]]输出：3解释： 有三个1被0包围，另外在边界上的1并没有被包围 思路一 典型的连通区域问题，可以使用DFS进行解决 具体而言： 遍历整个矩阵 如果遍历到0，不予理会 如果遍历到1，将其加到temp 不断拓展边界（上下左右四个方向） 在深度优先搜索的过程中碰到了边界，则证明可以逃脱，将累计的temp清空 如果深度优先搜索后无法到达边界，则证明无法逃脱，将temp加到cnt中 最终返回cnt即可 123456789101112131415161718192021222324252627282930313233343536class Solution: def __init__(self): self.temp = 0 self.meetEdge = False def numEnclaves(self, A: List[List[int]]) -&gt; int: cnt = 0 m, n = len(A), len(A[0]) visited =set() def dfs(i, j): # 到达边界或已访问过 if i &lt; 0 or i &gt;= m or j &lt; 0 or j &gt;= n or (i, j) in visited: return visited.add((i, j)) if A[i][j] == 1: self.temp += 1 else: return if i == 0 or i == m-1 or j == 0 or j == n-1: self.meetEdge = True dfs(i + 1, j) dfs(i - 1, j) dfs(i, j - 1) dfs(i, j + 1) for i in range(m): for j in range(n): dfs(i, j) if not self.meetEdge: cnt += self.temp # 重置 self.meetEdge = False self.temp = 0 return cnt 思路二 消除法，对上面方法的优化 具体而言 从矩阵边界开始进行深度优先搜索（搜索到的只能是非飞地） 如果碰到1就将其变为0 如果遇到0则跳过 最后遍历整个矩阵，统计剩下的1的个数即可 1234567891011121314151617181920212223242526272829def numEnclaves(self, A: List[List[int]]) -&gt; int: cnt = 0 m, n = len(A), len(A[0]) def dfs(i, j): if i &lt; 0 or i &gt;= m or j &lt; 0 or j &gt;= n or A[i][j] == 0: return A[i][j] = 0 dfs(i + 1, j) dfs(i - 1, j) dfs(i, j + 1) dfs(i, j - 1) # 从边界开始进行dfs for i in range(m): dfs(i, 0) dfs(i, n - 1) for j in range(n): dfs(0, j) dfs(m - 1, j) # 统计最终数组中1的个数 for i in range(m): for j in range(n): if A[i][j] == 1: cnt += 1 return cnt","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之链表中的下一个更大节点","slug":"Leetcode之链表中的下一个更大节点","date":"2020-05-25T00:43:36.000Z","updated":"2020-07-06T05:20:12.000Z","comments":true,"path":"passages/leetcode-zhi-lian-biao-zhong-de-xia-yi-ge-geng-da-jie-dian/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-lian-biao-zhong-de-xia-yi-ge-geng-da-jie-dian/","excerpt":"Next Greater Node In Linked List","text":"Next Greater Node In Linked List Next Greater Node In Linked List code with Python title number：1019 读题 给出一个以头结点head为第一个节点的链表。链表中的节点编号依次为node_1, node_2, node_3, ... 每个节点都可能有下一个更大值： 对于node_i，如果其next_latger(node_i)是node_j.val，则j &gt; i且node_j.val &gt; node_i.val，而且j是可能的选项中最小的那个。 若j不存在，则next_larger(node_i)返回0 返回整个数组的每个元素对应的下一个最大值 示例： 123456输入：[2, 1, 5]输出：[5, 5, 0]解释： 2的next_larger是5 1的next_larger是5 5的next_larger不存在，返回0 思路一 最开始的想法是，对于结点i将其后面的结点排序，取第一个大于结点i的值的结点值，这样的时间复杂度为O(n^2)，并且因为是链表，不容易进行排序操作 这里介绍一种数据结构，单调栈 栈中的元素满足单调性 在插入新元素时，出栈最少的元素以保持栈中元素的单调性 例如： 栈中元素自栈顶到栈底依次为[1, 2, 4, 5]，现插入元素3 为了保持栈中元素的单调性需出栈1, 2，最后将3插入栈中，得到[3, 4, 5]的单调栈 在这里如何使用呢 遍历链表，维护一个单调栈，单调栈的每个元素为(结点下标, 对应链表节点值) 按单调递减栈的入栈顺序，如果出现当前遍历到的结点值比栈顶值大，则将栈中元素出栈，并更新res值 12345678910111213def nextLargerNodes(self, head): res, st = [], [] # 遍历链表 while head: # 插入当前头指针指向的结点的值，并通过出栈操作维护单调性 while len(st) &gt; 0 and head.val &gt; st[-1][1]: res[st.pop()[0]] = head.val st.append((len(res), head.val)) # 没有符合条件的元素 res.append(0) head = head.next return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之可被K整除的最小整数","slug":"Leetcode之可被K整除的最小整数","date":"2020-05-24T04:17:05.000Z","updated":"2020-07-06T05:19:28.000Z","comments":true,"path":"passages/leetcode-zhi-ke-bei-k-zheng-chu-de-zui-xiao-zheng-shu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-ke-bei-k-zheng-chu-de-zui-xiao-zheng-shu/","excerpt":"Smallest Integer Divisible by K","text":"Smallest Integer Divisible by K Smallest Integer Divisible by K code with Python title number：1015 读题 给定正整数K，你需要找出可被K整除的、仅包含数字1的最小正整数N 返回N的长度，如果不存在这样的N，就返回-1 示例： 1234567891011输入：1输出：1解释：最小的答案是 N &#x3D; 1，其长度为1输入：2输出：-1解释：不存可被2乘除的正整数N输入：3输出：3解释：最小的答案是111，长度为3 思路一 最直接的想法就是从小到达遍历，判断是否能整除 根据题目给出的信息，可以从1, 11, 111, 1111...中不断尝试。但是该何时跳出循环呢 举几个例子： 123输入2， 1 % 2 &#x3D; 1， 11 % 2 &#x3D; 1， 好像没有什么特点输入6， 1 % 6 &#x3D; 1， 11 % 6 &#x3D; 5， 111 % 6 &#x3D; 3， 1111 % 6 &#x3D; 1， 11111 % 6 &#x3D; 5，陷入了循环153 总得来说 我们从1, 11, 111, ...中依次尝试 当余数出现之前出现过的数，则陷入了循环，则跳出循环返回-1 1234567891011121314def smallestRepunitDivByK(self, K: int) -&gt; int: if L % 10 in [2, 4, 5, 6]: return -1 seen = set() mode = 0 for i in range(1, K+1): mod = (mod*10 + 1) % K if mod in seen: return -1 if mod == 0: return i seed.add(mod)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之最佳观光组合","slug":"Leetcode之最佳观光组合","date":"2020-05-23T04:19:52.000Z","updated":"2020-07-06T05:33:34.000Z","comments":true,"path":"passages/leetcode-zhi-zui-jia-guan-guang-zu-he/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zui-jia-guan-guang-zu-he/","excerpt":"Best Sightseeing Pair","text":"Best Sightseeing Pair Best Sightseeing Pair code with Python title number：1014 读题 给定正整数数组A，A[i]表示第i个观光景点的评分，并且两个景点i和j之间的距离为j-i 一对景点组成的观光组合的得分为(A[i] + A[j] + i + j)：景点的评分之和减去两者之间的距离 返回一对观光经典能取得的最高分 示例： 123输入：[8,1,5,2,6]输出：11解释：i &#x3D; 0, j &#x3D; 2, A[i] + A[j] + i - j &#x3D; 8 + 5 + 0 - 2 &#x3D; 11 思路一 最直接的思路就是穷举所有的组合，计算其相应得分，最后返回最高得分 必然超时 1234567def maxScoreSightseeingPair(self, A: List[int]) -&gt; int: n = len(A) res = 0 for i in range(n - 1): for j in range(i+1, n): res = max(res, A[i] + A[j] + i - j) return res 思路二 对于得分的计算，我们可以分为两组，即A[i]+i和A[j]-j 对于每个A[j]-j，我们都去选取前面最大的A[i]+i即可实现结果最大 对于第二个子任务（选取数组A前i项的最大值）可以使用动态规划实现 状态表示：dp[] 集合：前i项所有的A[i]+i的值 属性：最大值 状态计算 比较前i-1个中的最大值与当前A[i]+i的大小，取较大值即可 常规的，我们使用长为i+1的数组简化操作 同时我们发现，dp[i]只与dp[i-1]有关，所以可以仅使用一个变量来存储dp[i-1]即可 1234567891011def maxScoreSightseeingPair(self, A: List[int]) -&gt; int: n = len(A) pre = A[0] + 0 res = 0 for i in range(1, n): res = max(res, pre + A[i] - i) pre = max(pre, A[i] + i) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之在D天内送达包裹的能力","slug":"Leetcode之在D天内送达包裹的能力","date":"2020-05-22T05:56:23.000Z","updated":"2020-07-06T05:30:50.000Z","comments":true,"path":"passages/leetcode-zhi-zai-d-tian-nei-song-da-bao-guo-de-neng-li/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zai-d-tian-nei-song-da-bao-guo-de-neng-li/","excerpt":"Capacity To Ship Packages Within D Days","text":"Capacity To Ship Packages Within D Days Capacity To Ship Packages Within D Days code with Python title number：1011 读题 传送带上的包裹必须在D天内从一个港口运送到另一个港口 传送带上的第i个包裹的重量为weights[i]。 每天，我们都会按给出的重量往传送带上装载包裹。装载的重量不会超过船的最大运载重量 返回能在D天内将传送带上的所有包裹送达的船的最低运载能力 思路一 货物必须按照给定的顺序装运 看一个示例： 123456789输入：weights &#x3D; [1,2,3,4,5,6,7,8,9,10], D &#x3D; 5输出：15解释：船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：第 1 天：1, 2, 3, 4, 5第 2 天：6, 7第 3 天：8第 4 天：9第 5 天：10 给定的列表并没有很特殊的地方，我们可以进行一下列表的转化 将列表中的元素进行合并，直至列表中元素与给定天数相同 这时，新构建的列表中元素的最大值即为所求最小运载能力 上面的例子，初始列表中最大值为10，这样我们可以选择将前面的4个元素进行合并，这样可以得到一个7个元素的列表（因为只能按顺序装货，此时仅能将前4个合并以得到更少的元素） 既然如此，就要提高每天搬运的上限。 我们意识到每天的搬运上限是有取值范围的，即[一天搬一袋时的上限, 一天全部搬完的上限]，对应到上述例子中就是[10, 50] 这样就转化为在指定范围内查找合适的数值的问题，面对查找问题，就可以用二分查找来解决了 只需要通过二分查找不断缩小查找的范围，然后找到恰好能D天搬运完的每日半圆上限（即为我们的最小每日搬运上限）即可 123456789101112131415161718192021222324252627282930313233def shipWithinDays(self, weights: List[int], D: int) -&gt; int: def get_days(weights, limit): # 根据上限判断能搬完的天数 r = 0 record = [] for w in weights: # 合并元素 if r+w &lt;= limit: r += w else: record.append(r) r = w record.append(r) return len(record) # 左右边界 left = max(weights) right = sum(weights) if left == right: return left while left &lt; right: mid = (left+right)//2 result = get_days(weights, mid) if result &gt; D: left = mid + 1 else: right = mid return left","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之骑士拨号器","slug":"Leetcode之骑士拨号器","date":"2020-05-21T04:40:23.000Z","updated":"2020-07-06T05:24:22.000Z","comments":true,"path":"passages/leetcode-zhi-qi-shi-bo-hao-qi/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-qi-shi-bo-hao-qi/","excerpt":"Knight Dialer","text":"Knight Dialer Knight Dialer code with Python title number：935 读题 国际象棋中的骑士可以按下图的方式移动 这一次，我们将其实放在电话拨号盘上，接下来骑士将会跳N-1步，每一步必须从一个数字跳到另一个数字 骑士每次落到一个键上都会拨出对应的数字，总共按下N位数字。 求一共可以拨出多少种不同的号码（因为答案很大，所以输出需要模10^9+7） 思路一 深度优先遍历 对于每一个号码，可以转移的状态是确定的，做以下处理 使用数组jump记录每个数字的转移状态，jump[i]即数字i可以转移的状态 这样问题就编程，从0开始的所有路径···从9开始的所有路径 但是这种暴力遍历必然存在很多重复的计算，超时 动态规划 状态表示：f(start, n) 集合：从start开始跳n-1步可以得到的数字的个数 属性：个数之和 状态计算 f(start, n)只与上一个可直接跳到start的数字有关 $$f(start, n) = \\sum f(x, n-1), x是可直接跳到start的数字$$ 所以要先进行处理，使用数组move保存转移关系 例如，当start=0时，可以由6或8直接跳到，所以move[0]=[6, 8] 所求即为f(0, n) + ... f(9, n) 12345678910111213141516def knightDialer(self, N): MOD = 10**9 + 7 moves = [[4, 6], [6, 8], [7, 9], [4, 8], [3, 9, 0], [], [1, 7, 0], [2, 6], [1, 3], [2, 4]] dp = [1] * 10 for hops in xrange(N-1): dp2 = [0]*10 for node, count in enumerate(dp): for nei in moves[node]: dp2[nei] += count dp2[nei] %= MOD dp = dp2 return sum(dp) % MOD","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之排序数组","slug":"Leetcode之排序数组","date":"2020-05-20T07:36:09.000Z","updated":"2020-07-06T05:23:49.000Z","comments":true,"path":"passages/leetcode-zhi-pai-xu-shu-zu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-pai-xu-shu-zu/","excerpt":"Sort an Array","text":"Sort an Array Sort an Array code with Python title number：912 读题 给定一个整数数组nums，将该数组升序排序 思路一 考察最基本的排序算法 排序算法可以分为多类，有不同的划分标准：稳定性、内外排序、时空复杂度等 下面依次实现常见的多种排序算法 选择排序 1234567def sortArray(self, nums: List[int]) -&gt; List[int]: n = len(nums) for i in range(n): for j in range(i, n): if nums[i] &gt; nums[j]: nums[i], nums[j] = nums[j], nums[i] return nums 冒泡排序 12345678def sortArray(self, nums: List[int]) -&gt; List[int]: n = len(nums) for c in range(n): for i in range(1, n-c): if nums[i-1] &gt; nums[i]: nums[i-1], nums[i] = nums[i], nums[i-1] return nums 插入排序 12345678def sortArray(self, nums: List[int]) -&gt; List[int]: n = len(nums) for i in range(1, n): while i &gt; 0 and nums[i-1] &gt; nums[i]: nums[i-1], nums[i] = nums[i], nums[i-1] i -= 1 return nums 希尔排序 1234567891011def sortArray(self, nums: List[int]) -&gt; List[int]: n = len(nums) gap = n // 2 while gap: for i in range(gap, n): while i - gap &gt;= 0 and nums[i-gap] &gt; nums[i]: nums[i - gap], nums[i] = nums[i], nums[i - gap] i -= gap gap //= 2 return nums 归并排序 123456789101112131415161718192021222324def merge(left, right): res = [] i = 0 j = 0 while i &lt; len(left) and j &lt; len(right): if left[i] &lt;= right[j]: res.append(left[i]) i += 1 else: res.append(right[j]) j += 1 res += left[i:] res += right[j:] return resdef sortArray(self, nums: List[int]) -&gt; List[int]: if len(nums) &lt;= 1: return nums mid = len(nums) // 2 # 分 left = merge_sort(nums[:mid]) right = merge_sort(nums[mid:]) # 合并 return merge(left, right) 快速排序 123456789101112131415161718192021def sortArray(self, nums: List[int]) -&gt; List[int]: n = len(nums) def quick(left, right): if left &gt;= right: return nums pivot = left i = left j = right while i &lt; j: while i &lt; j and nums[j] &gt; nums[pivot]: j -= 1 while i &lt; j and nums[i] &lt;= nums[pivot]: i += 1 nums[i], nums[j] = nums[j], nums[i] nums[pivot], nums[j] = nums[j], nums[pivot] quick(left, j - 1) quick(j + 1, right) return nums return quick(0, n - 1) 堆排序 123456789101112131415161718192021222324252627def sortArray(self, nums: List[int]) -&gt; List[int]: # 调整堆 # 迭代写法 def adjust_heap(nums, startpos, endpos): newitem = nums[startpos] pos = startpos childpos = pos * 2 + 1 while childpos &lt; endpos: rightpos = childpos + 1 if rightpos &lt; endpos and nums[rightpos] &gt;= nums[childpos]: childpos = rightpos if newitem &lt; nums[childpos]: nums[pos] = nums[childpos] pos = childpos childpos = pos * 2 + 1 else: break nums[pos] = newitem n = len(nums) # 建堆 for i in reversed(range(n // 2)): adjust_heap(nums, i, n) # 调整堆 for i in range(n - 1, -1, -1): nums[0], nums[i] = nums[i], nums[0] adjust_heap(nums, 0, i) return nums 基数排序 1234567891011121314151617181920def sortArray(self, nums: List[int]) -&gt; List[int]: if not nums: return [] _max = max(nums) # 最大位数 maxDigit = len(str(_max)) bucketList = [[] for _ in range(10)] # 从低位开始排序 div, mod = 1, 10 for i in range(maxDigit): for num in nums: bucketList[num % mod // div].append(num) div *= 10 mod *= 10 idx = 0 for j in range(10): for item in bucketList[j]: nums[idx] = item idx += 1 bucketList[j] = [] return nums 桶排序 1234567891011121314151617181920212223def sortArray(self, nums: List[int]) -&gt; List[int]: if len(nums) &lt; 2: return nums _min = min(nums) _max = max(nums) # 需要桶个数 bucketNum = (_max - _min) // bucketSize + 1 buckets = [[] for _ in range(bucketNum)] for num in nums: # 放入相应的桶中 buckets[(num - _min) // bucketSize].append(num) res = [] for bucket in buckets: if not bucket: continue if bucketSize == 1: res.extend(bucket) else: # 当都装在一个桶里,说明桶容量大了 if bucketNum == 1: bucketSize -= 1 res.extend(bucket_sort(bucket, bucketSize)) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之RLE迭代器","slug":"Leetcode之RLE迭代器","date":"2020-05-19T06:55:29.000Z","updated":"2020-07-06T05:08:36.000Z","comments":true,"path":"passages/leetcode-zhi-rle-die-dai-qi/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-rle-die-dai-qi/","excerpt":"RLE Iterator","text":"RLE Iterator RLE Iterator code with Python title number：900 读题 编写一个遍历游程编码序列的迭代器 迭代器由RLEIterator(int[] A)初始化，其中A是某个序列的游程编码 对于所有偶数i，A[i]告诉我们在序列中重复非负整数值A[i+1]的次数 迭代其支持一个函数next(int n)，它耗尽接下来的n个元素(n&gt;=1)，并返回以这种方式耗去的最后一个元素。如果没有剩余的元素可供耗尽，则next返回-1 例如，我们以 A = [3,8,0,9,2,5] 开始，这是序列 [8,8,8,5,5] 的游程编码。这是因为该序列可以读作 “三个八，零个九，两个五”。 示例： 1234567891011输入：[&quot;RLEIterator&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;], [[[3,8,0,9,2,5]],[2],[1],[1],[2]]输出：[null,8,8,5,-1]解释：RLEIterator 由 RLEIterator([3,8,0,9,2,5]) 初始化。这映射到序列 [8,8,8,5,5]。然后调用 RLEIterator.next 4次。.next(2) 耗去序列的 2 个项，返回 8。现在剩下的序列是 [8, 5, 5]。.next(1) 耗去序列的 1 个项，返回 8。现在剩下的序列是 [5, 5]。.next(1) 耗去序列的 1 个项，返回 5。现在剩下的序列是 [5]。.next(2) 耗去序列的 2 个项，返回 -1。 这是由于第一个被耗去的项是 5，但第二个项并不存在。由于最后一个要耗去的项不存在，我们返回 -1。 思路一 编码中两个数表示一种状态，例如3, 8 -&gt; 三个八，第一个是元素个数，第二个是元素值 在调用next()时，不改变数组的值，而是维护两个变量i, q，i表示迭代器当前指向的元素是A[i+1]，q表示它已经被删除的次数，q的值不会大于A[i] 调用next(n)时，即删除n个元素，相对与当前的元素A[i+1]，我们还可以删除的次数为D=A[i]-q 如果n &gt; D，那么我们会删除所有的A[i+1]，并迭代下一个元素，即n-=D, i+=2, q=0 如果n &lt;= D，那么我们删除的最后一个元素为A[i+1]，即q+=D, return A[i+1] 1234567891011121314151617class RLEIterator: def __init__(self, A: List[int]): self.A = A self.i = 0 self.q = 0 def next(self, n: int) -&gt; int: while self.i &lt; len(self.A): if self.q + n &gt; self.A[self.i]: n -= self.A[self.i] - self.q self.q = 0 self.i += 2 else: self.q += n return self.A[self.i+1] return -1","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之鸡蛋掉落","slug":"Leetcode之鸡蛋掉落","date":"2020-05-18T06:23:57.000Z","updated":"2020-07-06T05:18:24.000Z","comments":true,"path":"passages/leetcode-zhi-ji-dan-diao-luo/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-ji-dan-diao-luo/","excerpt":"Super Egg Drop","text":"Super Egg Drop Super Egg Drop code with Python title number：887 读题 你有K个鸡蛋，可以使用移动从1到N的N层楼的建筑 每个鸡蛋功能相同，且摔碎之后不能再用 存在楼层F，满足0 &lt;= F &lt;= N任何从高于F的楼层落下的鸡蛋会碎，低于F的楼层落下的鸡蛋不会碎 每次移动，可以取一个鸡蛋从任一楼层扔下，来测试确切的F的值 无论F的值如何，请计算确定F的值的最小移动次数为多少 示例： 123456输入：K &#x3D; 1, N &#x3D; 2输出：2解释：鸡蛋从1楼掉落，如果碎了，则F &#x3D; 0否则，鸡蛋从二楼掉落，如果碎了，则F &#x3D; 1；如果没碎，则F &#x3D; 2因此最坏的情况下需要移动两次才能确定 思路一 动态规划 最直接的想法 状态表示 集合：有i个鸡蛋，j层楼，测试出F的需要的次数的集合 属性：最小值 状态计算 状态转移方程为：dp[i][j] = min(dp[i-1][j-1], dp[i][N-j]+1) 前者表示在第j层楼扔下去，碎了，下次只有i-1个鸡蛋，测试j层之下的j-1层楼即可 后者表示在第j层楼扔下去，没碎，下次只有i-1个鸡蛋，测试j层之上的N-j层楼即可 这种方式的时间复杂度太高，相当于穷举 1def superEggDrop(self, K: int, N: int) -&gt; int: 思路二 还是动态规划，转化一下想法 状态表示 有i个鸡蛋，扔j次 集合：测试出F需要的次数的集合 属性：最小值 状态计算 dp[i][j] = dp[i-1][j-1] + dp[i][j-1]+1 前者表示扔了一次之后，碎了，还剩j-1次机会 后者表示扔了一次之后，没碎，还剩j-1次机会 因为dp[i][j]只与dp[][j-1]有关，所以可以简化为一维数组，遍历时倒序遍历即可 dp[i] = dp[i-1] + dp[i]+1 12345678910def superEggDrop(self, k: int, N: int) -&gt; int: dp = [0]*(K+1) cnt = 0 while dp[-1] &lt; N: for i in range(K, 0, -1): dp[i] = dp[i] + dp[i-1]+1 cnt += 1 return cnt","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之石子游戏","slug":"Leetcode之石子游戏","date":"2020-05-17T06:52:28.000Z","updated":"2020-07-06T05:26:34.000Z","comments":true,"path":"passages/leetcode-zhi-shi-zi-you-xi/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-shi-zi-you-xi/","excerpt":"Stone Game","text":"Stone Game Stone Game code with Python title number：877 读题 A和B用几堆石子做游戏。石子的堆数是偶数，石子堆排成一行，每堆有正整数颗石子piles[i] 以谁手中的石子最多来决定胜负。石子总数为奇数，没有平局 两人轮流进行，每回合玩家从行的开始或结束处取走整堆石头，直到取完 假设两个都采取最佳方案，当A获胜时返回True，当B获胜时返回False 示例： 12345678输入：[5,3,4,5]输出：true解释： 亚历克斯先开始，只能拿前 5 颗或后 5 颗石子 。 假设他取了前 5 颗，这一行就变成了 [3,4,5] 。 如果李拿走前 3 颗，那么剩下的是 [4,5]，亚历克斯拿走后 5 颗赢得 10 分。 如果李拿走后 5 颗，那么剩下的是 [3,4]，亚历克斯拿走后 4 颗赢得 9 分。 这表明，取前 5 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 true 。 思路一 博弈问题，因为这道题的限制比较多，可以通过分析得出结论 因为石子堆是偶数堆，而A是先手，所以他可以做到取所有序号为偶数的堆（第一次取最后一堆），也可以做到取所有序号为奇数的堆（第一次取第一堆） 既然如此，B是没有选择权的，只能被动的选择 只需要计算所有奇数堆和所有偶数堆哪个大选择哪个即可 所以，在本题的情境中，A立于不败之地 123def stoneGame(self, piles: List[int]) -&gt; bool: return True 思路二 博弈问题，两者都会选择最有利于自己的方案，不过这道题的限制太多（先手必胜），我们将其推广到更通用的情况来分析 A和B面前有一排石头堆，用一个数组piles表示，piles[i]表示第i堆石子有多少个。 轮流拿石头，一次拿一堆，但是只能拿走最左边或者最右边的石头堆。所有石头被拿完后，谁拥有的石头多，谁获胜 状态表示：dp[i][j] 想要使用动态规划，首先要抽象出总问题与子问题之间的关系 [i, ..., j]之间先手和后手能获得的最高分数 每个状态要存储两个值，我们使用对象来存储 集合：第i到第j个石堆先手和后手的可能的得分的集合 属性：先手和后手得分的最大值 状态计算 对于每一个状态，只有两个选择：选择最左边的石堆，选择最右边的石堆。我们可以穷举出所有状态 故：以先手选择取左边还是右边的石堆作为集合划分标准 如果先手选择左边的石堆，则： dp[i][j].first = piles[i] + dp[i+1][j].second 在[i, ... j]是先手，则在下一步[i+1, ..., j]就变成了后手 dp[i][j].second = dp[i+1][j].first 在[i, ... j]是后手，则在[i+1, ..., j]就变成了先手 如果先手选择右边的石堆，则： dp[i][j].first = piles[j] + dp[i][j-1].second 在[i, ... j]是先手，则在下一步[i, ..., j-1]就变成了后手 dp[i][j].first = dp[i][j-1].first 在[i, ... j]是后手，则在[i, ..., j]就变成了先手 初始化 如果只有一堆石头，即i==j时，先手得到该堆石头，后手什么都没有 dp[i][j].first = piles[i] dp[i][j].second = 0 所求 dp[0][n-1]中first与second的大小关系 12345678910111213141516171819202122232425262728293031class Pair: def __init __(self, first, second): self.first = first self.second = second def stoneGame(self, piles: List[int]) -&gt; bool: len_ = len(piles) dp = [[0 for _ in range(len_)] for _ in range(len_)] for i in range(len_): dp[i][i].first = piles[i] dp[i][i].second = 0 # 斜着遍历数组 for i in range(len_-2, -1, -1): # (len-2, 0) for j in range(i+1, len_): # (i+1, len-1) left = piles[i] + dp[i+1][j].second right = piles[j] + dp[i][j-1].second if left &gt; right: dp[i][j].first = left dp[i][j].second = dp[i+1][j].first else: dp[i][j].first = right dp[i][j].second = dp[i][j-1].first res = dp[0][n-1] if res.first &gt; res.second: return True else: return False","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之爱吃香蕉的珂珂","slug":"Leetcode之爱吃香蕉的珂珂","date":"2020-05-16T13:24:21.000Z","updated":"2020-07-06T05:08:43.000Z","comments":true,"path":"passages/leetcode-zhi-ai-chi-xiang-jiao-de-ke-ke/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-ai-chi-xiang-jiao-de-ke-ke/","excerpt":"Koko Eating Bananas","text":"Koko Eating Bananas Koko Eating Bananas code with Python title number：875 读题 珂珂喜欢吃香蕉，这里有N堆香蕉，第i堆中有piles[i]根香蕉。警卫已经离开，将在H小时候返回 珂珂可以决定自己的吃香蕉速度K（每小时K根） 每小时选择一堆香蕉，吃掉其中的K根香蕉。如果该堆少于K根则吃掉整堆的香蕉，并且在该小时内不能吃其他堆的香蕉 返回珂珂可以在H小时内吃掉所有香蕉的最小速度K 示例： 12输入：piles &#x3D; [3, 6, 7, 11], H &#x3D; 8输出：4 思路一 直觉上，不断进行尝试，从令K = 最大堆的香蕉数开始尝试，如果可行，则减小1，如果不行则返回上一次的结果。一次类推，计算出刚好不行的临界值即可 或者假设珂珂吃的特别慢，从K = 1开始，不断提高速度，直到刚刚可以在规定时间内吃完 但是使用二分查找能有效减小时间复杂度（题目的相关标签中也有提示使用二分查找） 由于只能每个小时选择其中一堆吃，所以速度的最大值就是最大堆的香蕉数，最小值为1 每堆香蕉吃完的耗时 = 这对香蕉的数量 / 速度（不能整除时取上界） 123456789101112131415161718def minEatingSpeed(self, piles: List[int], H: int) -&gt; int: def cal_sum(self, piles, speed): res = 0 for pile in piles: res += (pile + speed - 1) // speed return res left = 1 right = max(piles) while left &lt; right: mid = (left + right) &gt;&gt; 1 if cal_sum(piles, mid) &gt; H: left = mid + 1 else: right = mid return left 绝大多数在递增递减区间中搜索目标值的问题都可以转化为二分查找问题","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之单词的压缩编码","slug":"Leetcode之单词的压缩编码","date":"2020-05-15T02:32:26.000Z","updated":"2020-07-06T05:10:38.000Z","comments":true,"path":"passages/leetcode-zhi-dan-ci-de-ya-suo-bian-ma/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-dan-ci-de-ya-suo-bian-ma/","excerpt":"Short Encoding of Words","text":"Short Encoding of Words Short Encoding of Words code with Python title number：820 读题 给定一个单词列表，讲这个列表编码称一个索引字符串S与索引列表A 通过每个索引，我们可以通过从字符串S中索引的位置开始读取字符串，直到#结束，以此来恢复我们的单词列表 返回给单词列表进行编码的最小字符串长度 示例： 123输入：words &#x3D; [&#39;time&#39;, &#39;me&#39;, &#39;bell&#39;]输出：10说明：S &#x3D; &#39;time#bell#&#39;, indexes &#x3D; [0, 2, 5] 思路一 解读一下上面给出的例子，对于time和me拥有相同的后缀，所以可以不用重复存储，而只需要记录起始位置为[0, 2]就可以恢复原来的字符序列 由于这种共享后缀的特性我们联想到了后缀树，而之前我们做过关于前缀树（字典树）的题目实现Trie 而只需要将字符串逆序存储，原来的共同后缀就变为了共同前缀，也就可以使用前缀树解决了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Trie: def __init__(self): \"\"\" Initialize your data structure here. \"\"\" self.lookup = &#123;&#125; def insert(self, word: str) -&gt; None: \"\"\" Inserts a word into the trie. \"\"\" tree = self.lookup for a in word: if a not in tree: # 新节点 tree[a] = &#123;&#125; tree = tree[a] # 设置单词的结束标志 tree[\"#\"] = \"#\" def search(self, word: str) -&gt; bool: \"\"\" Returns if the word is in the trie. \"\"\" tree = self.lookup for a in word: if a not in tree: return False tree = tree[a] if \"#\" in tree: return True return False def startsWith(self, prefix: str) -&gt; bool: \"\"\" Returns if there is any word in the trie that starts with the given prefix. \"\"\" tree = self.lookup for a in prefix: if a not in tree: return False tree = tree[a] return Truedef minimumLengthEncoding(self, word: List[str]) -&gt; int: len_ = 0 trie = Trie() words = set(words) for word in words: # 插入的是字符串逆序 trie.insert(word[::-1]) for word in words: if trie.startsWith(word[::-1]): len_ += len(word) + 1 return cnt","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之在系统中查找重复文件","slug":"Leetcode之在系统中查找重复文件","date":"2020-05-14T02:08:29.000Z","updated":"2020-07-06T05:31:12.000Z","comments":true,"path":"passages/leetcode-zhi-zai-xi-tong-zhong-cha-zhao-chong-fu-wen-jian/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zai-xi-tong-zhong-cha-zhao-chong-fu-wen-jian/","excerpt":"Find Duplicate File in System","text":"Find Duplicate File in System Find Duplicate File in System code with Python title number：609 读题 给定一个目录信息列表，包括目录路径以及目录中的所有包含内容的文件 找到文件系统中的所有重复文件组的路径 一组重复的文件至少包含两个完全相同内容的文件 示例： 12345输入列表格式为：&quot;root&#x2F;d1&#x2F;d2&#x2F;...&#x2F;dm f1.txt(f1_content) f2.txt(f2_content) ... fn.txt(fn_content)&quot;表示有n个文件：f1.txt, f2.txt ... fn.txt 内容分别为：f1_content, f2_content ... fn_content输出为一个列表，包含文件路径及文件名 对输出顺序无要求 同意目录中没有没有同名文件或目录 思路一 使用字典存储 key为文件内容，value为文件路径列表，遍历一遍列表 输出时要输出value列表长度大于2的 1234567891011121314def findDuplicate(self, paths: List[str]) -&gt; List[List[str]]: dict_ = collections.defaultdict(list) for path in paths: splits = path.split(\" \") folder, files = splits[0], splits[1:] for file in files: # 以左括号划分 name, content = file.split('(') dict[content] += [folder+'/'+name] result = [] for value in dict_.values(): if len(value) &gt;= 2: result.append(value) return result","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之朋友圈","slug":"Leetcode之朋友圈","date":"2020-05-13T03:07:47.000Z","updated":"2020-07-06T05:23:58.000Z","comments":true,"path":"passages/leetcode-zhi-peng-you-quan/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-peng-you-quan/","excerpt":"Friend Circles","text":"Friend Circles Friend Circles code with Python title number：547 读题 班上有N名学生，其中有一些人是朋友，有一些不是 他们的友谊具有传递性，即A与B是朋友，B与C是朋友，则A与C也是朋友 给定一个N*N的矩阵，表示班级中学生之间的朋友关系。如果M[i][j]=1，则表示第i个学生与第j个学生互为朋友 输出所有一直的朋友圈总数 示例： 1234567输入：[[1, 1, 0], [1, 1, 0], [0, 0, 1]]输出：2解释：第1个和第2个学生互为朋友，是一个朋友圈第3个学生自己在一个朋友圈 思路一 可以当作连通区域问题解决，具体可参考岛屿数量和被围绕的区域 使用深度搜索查找矩阵中的连通区域 123456789101112131415def findCircleNum(self, M: List[List[int]]) -&gt; int: def dfs(M, visited, i): for j in range(len(M)): if M[i][j] == 1 and visited[j] == 0: visited[j] = 1 dfs(M, visited, j) visited = [0 for _ in range(len(M))] count = 0 for i in range(len(M)): if visited[i] == 0: dfs(M, visited, i) count += 1 return count 思路二 使用并查集统计连通块数量 使用一个大小为N的parent数组，遍历整个图，每个结点都遍历所有相邻点，并将相邻点指向该节点，设置成一个parent数组结点决定的单独组，即union过程 对于新节点，寻找其父亲，如果父亲结点一样，则在同一个组内 如果父亲节点不同，则仍需要合并，故将其父亲节点合并 123456789101112131415161718192021222324def findCircleNum(self, M: List[List[int]]) -&gt; int: def find(parent, i): if parent[i] == -1: return i return find(parent, parent[i]) def union(parent, x, y): x_set = find(parent, x) y_set = find(parent, y) if x_set != y_set: parent[x_set] = y_set parent = [-1 for i in range(len(M))] for i in range(len(M)): for j in range(len(M)): if M[i][j] == 1 and i != j: union(parent, i, j) count = 0 for i in range(len(parent)): if parent[i] == -1: count += 1 return count 实际尝试中，并查集的时间复杂度更高","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之零钱兑换Ⅱ","slug":"Leetcode之零钱兑换Ⅱ","date":"2020-05-12T08:22:06.000Z","updated":"2020-07-06T05:22:09.000Z","comments":true,"path":"passages/leetcode-zhi-ling-qian-dui-huan-ii/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-ling-qian-dui-huan-ii/","excerpt":"Coin Change Ⅱ","text":"Coin Change Ⅱ Coin Change Ⅱ code with Python title number：518 读题 给定不同面额的硬币和一个总金额，计算有多少中凑成总金额的硬币组合数 每种面额的硬币都有无限个 示例 1234567输入：amount &#x3D; 5，coins &#x3D; [1, 2, 5]输出：4解释：5 &#x3D; 55 &#x3D; 2 + 2 + 15 &#x3D; 2 + 1 + 1 + 15 &#x3D; 1 + 1 + 1 + 1 + 1 思路一 很明显的完全背包问题的变体，使用动态规划解决 状态表示：$f(i, j)$ 集合：使用前i种硬币凑出金额j的方法数 属性：总数（求和） 状态计算 以前i种硬币中第i个硬币是否使用作为集合分割标准 第i种硬币不用，$f(i, j) = f(i-1, j)$ 第i中硬币选用，k是满足j &gt;= k*coin[i]的最大值 $f(i, j) = f(i-1, j-1coin[i]) + f(i-1, j-2coin[i])+…f(i-1, j-k*coin[i])$ 综上：$$f(i, j) = f(i-1,j) + f(i-1, j-1coin[i]) + f(i-1, j-2coin[i])+…f(i-1, j-k*coin[i])$$ 令j = j-coin[i]，则 $$f(i, j-coin[i]) = f(i-1,j-coin[i]) + f(i-1, j-2coin[i])+…f(i-1, j-kcoin[i])$$ - 结合两式，可得到 $$ f(i, j) = f(i, j-coin[i]) + f(i-1, j) $$ 所求即为，$f(len(coins), amount)$ 123456789101112def change(self, amount: int, coins: List[int]) -&gt; int: n = len(coins) dp = [[0]*(amount+1) for _ in range(n+1)] for i in range(n+1): dp[i][0] = 1 for i in range(1, n+1): for j in range(1, amount+1): dp[i][j] = dp[i-1][j] if j &gt;= coins[i-1]: dp[i][j] = dp[i][j] + dp[i][j-coins[i-1]] return dp[-1][-1] 优化 使用dp[i]表示组成金额i的总组合数 对于小于最小硬币面值的金额，跳过 每个金额遍历一遍硬币，进行更新 12345678def change(self, amount: int, coins: List[int]) -&gt; int: n = len(coins) dp = [0]*(amount+1) dp[0] = 1 for coin in coins: for j in range(coin, amount): dp[j] = dp[j] + dp[j-coin] return dp[-1]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之最长回文子序列","slug":"Leetcode之最长回文子序列","date":"2020-05-11T01:50:43.000Z","updated":"2020-07-06T05:35:18.000Z","comments":true,"path":"passages/leetcode-zhi-zui-chang-hui-wen-zi-xu-lie/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zui-chang-hui-wen-zi-xu-lie/","excerpt":"Longest Palindromic Subsequence","text":"Longest Palindromic Subsequence Longest Palindromic Subsequence code with Python title number：516 读题 给定一个字符串s找到其中最长的回文子序列 假设s的最大长度为1000 示例： 123输入：&quot;bbbab&quot;输出：4解释：可能的最长子序列为&quot;bbbb&quot; 思路一 注意”子序列“与”子串“的区别，子序列并不要求序列中的元素在原字符串中相邻 对于找子序列问题，关键词在于”延伸“ 如果一个子序列是回文子序列，那么在其左右分别加上一个相同的字符，它还是一个回文子序列。此时回文子序列长度要+2 如果 一个子序列不是回文子序列，或者在其左右加上不同的字符，则得到的不是回文子序列，此时回文子序列长度不变，取[i][j-1]和[i+1][j]的较大值 根据上述分析，我们得到了整体问题与子问题之间的关系，可以用动态规划来解决了 按照惯例，下面进行动态规划式的分析 状态表示：$f(i, j)$表示子串s[i:j]之间所有回文子序列的集合 集合：在子串s[i:j]的所有回文子序列的集合 属性：最长的回文子序列 状态计算 以子串的第一个字符s[i]和最后一个字符s[j]是否相同作为分割标准 如果两者相同，则为子串s[i+1, j-1]中的最长回文子串长度加2，即$f(i, j) = f(i+1, j-1) + 2$ 如果两者不相同，则为子串s[i+1, j-1]分别加上其中一个字符所产生的最长子序列中的较大值，即$f(i, j) = max[f(i+1, j), f(i, j-1)]$ 综上，$$f(i, j) = \\begin{cases}f(i+1, j-1), s[i]==s[j]\\max[f(i+1, j), f(i, j-1)], s[i!=s[j]\\end{cases}$$ 所求即为，$f(0, len(str))$ 123456789101112131415def longestPalindromeSubseq(self, s: str) -&gt; int: n = len(s) dp = [[0]*(n) for _ in range(n)] if s == s[::-1]: return n for i in range(n): dp[i][i] = 1 for i in range(n, -1, -1): for j in range(i+1, n): if s[i] == s[j]: dp[i][j] = dp[i+1][j-1] + 2 else: dp[i][j] = max(dp[i+1][j], dp[i][j-1]) return dp[0][-1]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之一和零","slug":"Leetcode之一和零","date":"2020-05-10T01:13:53.000Z","updated":"2020-07-06T05:30:00.000Z","comments":true,"path":"passages/leetcode-zhi-yi-he-ling/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-yi-he-ling/","excerpt":"Ones and Zeroes","text":"Ones and Zeroes Ones and Zeroes code with Python title number：474 读题 假设你分别支配着m个0和n个1，另外还有一个仅包含0和1字符串的数组 现在的任务是，使用给定的m个0和n个1，找到能拼接出存在于数组中的字符串的最大数量 每个0和1至多被使用一次 示例： 1234567输入：Array &#x3D; &#123;&quot;10&quot;, &quot;0001&quot;, &quot;111001&quot;, &quot;1&quot;, &quot;0&quot;&#125;, m &#x3D; 5, n &#x3D; 3输出：4解释：总共有4个字符串可以通过5个0和3个1拼出输入：Array &#x3D; &#123;&quot;10&quot;, &quot;1&quot;, &quot;0&quot;&#125;, m &#x3D; 1, n &#x3D; 1输出：2解释：只能拼出“10”，之后0,1就被使用完了 思路一 本题可以转化为01背包问题，经典的01背包问题介绍见这里 转化后的问题 把0和1的个数视为背包的容量，将每个字符串视为装进背包的物品 不同之处，这里的背包分为两部分，分别用来装0或1 状态表示，$f(i, j , k)$ 集合：输入字符串在自区间[0, i]能够使用j个0和k个1表示字符串数 属性：可被表示的字符串的最大数量 状态计算 以第i个字符串是否使用01表示为分割标准 若第i个字符串被表示，$f(i-1, j-第i个字符串0的个数, k-当前字符串1的个数) + 1$ 若第i个自负串不被表示，$f(i-1, j, k)$ 综上$$f(i , j , k) = max[f(i-1, j, k), f(i-1, j-当前字符串使用0的个数, k-当前字符串使用1的个数)]$$ 最终所求即为：$f(len, m, n)$ 另外，我们一般多设置一行，即用来处理第0个字符串为空串的情况，初始化为0 1234567891011121314151617181920212223242526272829def findMaxForm(self, strs: List[str], m: int, n: int) -&gt; int: len_ = len(strs) # 注意三维数组的初始化 def make_dp(len_, m, n): dp = [0]*(len_+1) for i in range(len_+1): dp[i] = [0]*(m+1) for i in range(len+1): for j in range(m+1): dp[i][j] = [0]*(n+1) def countZeroAndOne(str_): ones, zeroes = 0, 0 for i in range(len(str_)): if str_[i] == \"0\": zeroes += 1 if str_[i] == \"1\": ones += 1 return ones, zeroes dp = make_dp(len_, m, n) for i in range(1, len_+ 1): ones, zeroes = countZeroAndOne(strs[i-1]) for j in range(m+1): for k in range(n+1): dp[i][j][k] = dp[i-1][j][k] if j &gt;= zeroes and k &gt;= ones: dp[i][j][k] = max(dp[i-1][j][k], dp[i-1][j-zeroes][k-ones] + 1) return dp[len_][m][n] 我们知道，动态规划实质上是一种填表的过程，所谓状态压缩，就是根据状态之间的相关性，通过遍历顺序上的调整，节省掉一种到多重状态的表示，体现在dp数组上就是数组的维度下降 以下分析来自题解区 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152以给定的示例为例：Array &#x3D; &#123;&quot;10&quot;, &quot;0001&quot;, &quot;111001&quot;, &quot;1&quot;, &quot;0&quot;&#125;, m &#x3D; 5, n &#x3D; 3初始化背包：dp 0列 1列 2列 3列 0行 0 0 0 01行 0 0 0 02行 0 0 0 03行 0 0 0 04行 0 0 0 0 5行 0 0 0 0（行表示背包0的可容纳大小，列表示背包1的可容纳大小）对于第一个串“10”：可容纳的背包 （√表示可容纳 x表示不可容纳）dp 0列 1列 2列 3列 0行 × × × ×1行 × √ √ √2行 × √ √ √3行 × √ √ √4行 × √ √ √ 5行 × √ √ √对于可容纳的背包要依次遍历，不放，则查看原旧背包容量 放，则 1（当前01串）+ 变小的 旧背包容量 -&gt; 取最大值dp 0列 1列 2列 3列 0行 0 0 0 01行 0 1 1 12行 0 1 1 13行 0 1 1 14行 0 1 1 1 5行 0 1 1 1对于第二个串“0001”可容纳的背包 （√表示可容纳 x表示不可容纳）dp 0列 1列 2列 3列 0行 × × × × 1行 × × × × 2行 × × × × 3行 × √ √ √4行 × √ √ √ 5行 × √ √ √对于可容纳的背包要依次遍历， 不放，则查看原旧背包容量 放，则 1（当前01串）+ 变小的 旧背包容量 -&gt; 取最大值dp 0列 1列 2列 3列 0行 0 0 0 01行 0 1 1 12行 0 1 1 13行 0 1 1 1 4行 0 1 2 2 5行 0 1 2 2 &lt;-- max（原本背包价值1【不放】， 1+旧背包dp[5-3][3-1]【放】） 分析上述过程，我们发现，当前行的值只与上一行的值有关，所以，我们可以使用滚动数组，也可以从后向前赋值，此时dp数组只需要有两维即可 12345678910111213141516171819def findMaxForm(self, strs: List[str], m: int, n: int) -&gt; int: dp = [[0]*(n+1) for _ in range(m+1)] def countZeroAndOne(str_): ones, zeroes = 0, 0 for i in range(len(str_)): if str_[i] == \"0\": zeroes += 1 if str_[i] == \"1\": ones += 1 return ones, zeroes for str_ in strs: ones, zeroes = countZeroAndOne(str_) for i in range(m, zeroes-1, -1): for j in range(n, ones-1, -1): dp[i][j] = max(dp[i][j], dp[i-zeroes][j-ones] + 1) return dp[m][n]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之四数相加Ⅱ","slug":"Leetcode之四数相加Ⅱ","date":"2020-05-09T06:44:11.000Z","updated":"2020-07-06T05:27:37.000Z","comments":true,"path":"passages/leetcode-zhi-si-shu-xiang-jia-ii/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-si-shu-xiang-jia-ii/","excerpt":"4 Sum Ⅱ","text":"4 Sum Ⅱ 4 Sum Ⅱ code with Python title number：454 读题 给定四个列表A, B, C, D，计算有多少个元组(i, j, k, l)，使得A[i]+B[j]+C[k]+D[l]=0 所有的列表长度相同，且长度不超过500 示例： 12345678910111213输入：A = [1, 2]B = [-2, -1]C = [-1, 2]D = [0, 2]输出：2解释：两个元组如下:1. (0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 02. (1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0 思路一 按照常规的思路，遍历每种可能需要四层遍历，时间复杂度极高 核心思想是用空间换时间 将四个数组分为两组（例如：(A, B), (C, D)），先对求第一组中元素所有可能的和，使用字典存储，方面统计其出现的次数 再对第二组中元素所有可能的和，并得到的和是否与第一组中的和可以相加为0，若有，则取其出现的次数作为结果 123456789101112def fourSumCount(self, A: List[int], B: List[int], C: List[int], D: List[int]) -&gt; int: mapper = &#123;&#125; res = 0 for i in A: for j in B: mapper[i+j] = mapper.get(i+j, 0) + 1 for i in C: for j in D: res += mapper.get(-1*(i+j), 0) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之两数相加Ⅱ","slug":"Leetcode之两数相加Ⅱ","date":"2020-05-08T03:42:23.000Z","updated":"2020-07-06T05:21:29.000Z","comments":true,"path":"passages/leetcode-zhi-liang-shu-xiang-jia-ii/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-liang-shu-xiang-jia-ii/","excerpt":"Add Two Numbers Ⅱ","text":"Add Two Numbers Ⅱ Add Two Numbers Ⅱ code with Python title number：455 读题 给订两个非空链表来表示两个数。数字的最高位位于链表开始位置，每个节点只存储一位数字，将两数相加，返回一个新的链表 除了数字0之外，两个数组均不会以0开头 思路一 因为第一个结点表示的是最高位，而加法运算需要从低位开始，所以很容易想到借助栈来进行计算 另外要注意加法的进位即可 123456789101112131415161718192021222324252627282930313233343536373839def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode: # 将链表转化为列表 def L2S(l: ListNode) -&gt; List: stack , c = [], l while c: stack.append(c.val) c = c.next return stack stack1, stack2 = L2S(l1), L2S(l2) # 将两个列表补齐到相同长度，方便处理 diff = abs(len(stack1) - len(stack2)) stack1 = ([0]*diff + stack1 if len(stack1) &lt; len(stack2) else stack1) stack2 = ([0]*diff + stack2 if len(stack2) &lt; len(stack1) else stack2) # 对应相加 stack3 = [x+y for x, y in zip(stack1, stack2)] # 计算进位 up = 0 for i, val in enumerate(stack3[::-1]): index = len(stack3) - i - 1 up, stack3[index] = divmod(val + carry, 10) if carry and index == 0: # 最高位进位 stack3 = [1] + stack3 elif carry: # 进位 stack3[index - 1] += 1 # 转化为链表存储 result = ListNode(0) c = result for i in stack3: c.next = ListNode(i) c = c.next return result.next","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之分割等和子集","slug":"Leetcode之分割等和子集","date":"2020-05-07T04:26:44.000Z","updated":"2020-07-06T05:15:51.000Z","comments":true,"path":"passages/leetcode-zhi-fen-ge-deng-he-zi-ji/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-fen-ge-deng-he-zi-ji/","excerpt":"Partition Equal Subset Sum","text":"Partition Equal Subset Sum Partition Equal Subset Sum code with Python title number：416 读题 给定一个只包含正整数的非空数组，判断是否能够将这个数组分割成两个子集，使得两个子集的元素和相等 每个数组中的元素不会超过100，数组的大小不会超过200 思路一 可以看出，这是一道01背包问题的变种，为什么说这是一道01背包问题呢？我们来分析一下 先看一下01背包问题的描述： 一个可装载重量为 W 的背包和 N 个物品，每个物品有重量和价值两个属性。其中第 i 个物品的重量为 wt[i]，价值为 val[i]，现在让你用这个背包装物品，最多能装的价值是多少 再来看一下这个问题，我们可以转化为： 先对数组所有元素求和，得到sum 给一个可装载重量为 sum / 2 的背包和 N 个物品，每个物品的重量为 nums[i]。现在让你装物品，是否存在一种装法，能够恰好将背包装满？ 这样，我们直接使用之前的动态规划的分析框架进行分析 状态表示：$f(i, j)$ 集合：前i个物品，当前容量为j的情况下的所有选法 属性：能够恰好将背包装满 状态计算 以第i个元素是否选取作为分割标准，分割集合 若选取第i个元素，$f(i , j) = f(i-1, j-nums[i])$ 若不选取第i个元素，$f(i, j) = f(i-1, j)$ 即，$f(i, j) = f(i-1, j) | f(i-1, j-nums[i])$ 所求即为$f(n, sum/2)$，即前n个元素能够凑成sum/2，剩余的自然也是sum/2 123456789101112131415161718192021def canPartition(self, nums: List[int]) -&gt; bool: sum_ = sum(nums) if sum_ % 2 != 0: return False sum_ = sum_ // 2 # 多加一行一列，便于处理 dp = [[False]*(sum_+1) for _ in range(len(nums))] dp[0][0] = True for i in range(1, sum_+1): if nums[0] == i: dp[0][i] = True break for i in range(1, len(nums)): for j in range(sum_+1): if j &gt;= nums[i]: dp[i][j] = dp[i-1][j] or dp[i-1][j-nums[i]] else: dp[i][j] = dp[i-1][j] return dp[-1][-1]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之常数时间内插入删除和获取随机元素","slug":"Leetcode之常数时间内插入删除和获取随机元素","date":"2020-05-06T12:30:30.000Z","updated":"2020-07-06T05:09:39.000Z","comments":true,"path":"passages/leetcode-zhi-chang-shu-shi-jian-nei-cha-ru-shan-chu-he-huo-qu-sui-ji-yuan-su/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-chang-shu-shi-jian-nei-cha-ru-shan-chu-he-huo-qu-sui-ji-yuan-su/","excerpt":"Insert Delete GetRandom O(1)","text":"Insert Delete GetRandom O(1) Insert Delete GetRandom O(1) code with Python titile number：380 读题 设计以个支持在平均时间复杂度O(1)下，执行以下操作的数据结构： insert(val)：当元素val不存在时，向集合中插入该项 remove(val)：元素val存在时，从集合中移除该项 getRandom()：随机返回现有集合中的一项，每个元素应该有相同道德概率被返回 思路一 题目要求即思路，说一下几个要点 存储结构：组合使用哈希表和数组 插入操作：用哈希表判断元素是否存在，数组记录值（插入的元素添加到数组末尾），哈希表记录索引 删除操作：用哈希表来定位，把数组最后一个元素取下来顶替被删除元素位置 取随机数：随机从数组中挑选一个元素 123456789101112131415161718192021222324252627282930313233343536class RandomizedSet: def __init__(self): \"\"\" Initialize your data struct here \"\"\" self.d = &#123;&#125; self.l = [] def insert(self, val: int) -&gt; bool: \"\"\" Inserts a value to the set. Returns true if the set did not already contain the specified element. \"\"\" if val in self.d: return False else: self.d[val] = len(self.l) self.l.append(val) return True def remove(self, val: int) -&gt; bool: \"\"\" Removes a value from the set. Returns true if the set contained the specified element. \"\"\" if val in self.d: self.d[self.l[-1]] = self.d[val] self.l[self.d.pop(val)] = self.l[-1] self.pop() return True else: return False def getRandom(self) -&gt; int: \"\"\" Get a random element from the set. \"\"\" return self.l[random.randint(0, len(self.l)-1)]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之有序矩阵中第k小的元素","slug":"Leetcode之有序矩阵中第k小的元素","date":"2020-05-05T12:50:50.000Z","updated":"2020-07-06T05:30:34.000Z","comments":true,"path":"passages/leetcode-zhi-you-xu-ju-zhen-zhong-di-k-xiao-de-yuan-su/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-you-xu-ju-zhen-zhong-di-k-xiao-de-yuan-su/","excerpt":"Kth Smallest Element in a Sorted Matrix","text":"Kth Smallest Element in a Sorted Matrix Kth Smallest Element in a Sorted Matrix code with Python title number：378 读题 给定一个N*N的矩阵，其中每行和每列元素均按升序排序，找到矩阵中第K小的元素 注意是排序后的第k小元素，而不是第k个不同的元素 示例： 123456matrix &#x3D; [[1, 3, 5], [10, 11, 13], [12, 13, 15]]k &#x3D; 8返回 13 思路一 直觉上可以遍历读取整个矩阵，再进行排序，最后读取第k个元素即可 123456789def kthSmallest(self, matrix: List[List[int]], k: int) -&gt; int: arr = [] for i in range(matrix): arr.extend(matrix[i]) arr.sort() return arr[k-1] 思路二 既然使用了排序算法，那么可以更进一步 利用排序算法，大顶堆 但是使用排序算法显然没有利用有序矩阵这一信息 下面介绍一下值域二分法 首先，根据矩阵的性质，我们的矩阵元素的值域为[l, r]，其中l = matrxi[0][0], r = matrix[-1][1] 于是，我们就可以对该区间进行二分，mid = (l+r) / 2 统计矩阵中小于mid的元素个数，记为less_mid 如果less_mid &lt; k，那么[l , mid]之间包含的元素小于k，即第k个元素一定不在其中，而一定在[mid, r]中，此时将l = mid 如果less_mid &gt;= k，那么[l, mid]中的元素个数大于等于k，即第k小的元素一定在[l, mid]中，此时r = mid 只与如何统计小于等于mid的元素个数，利用矩阵本身的性质，从左下角开始枚举 12345678910111213141516171819202122232425def getLowCnt(self, matrix, row, col, mid): i, j = row-1, 0 cnt = 0 while i &gt;= 0 and j &lt; col: # 若当前值小于mid，则该列中，当前值上方的元素均小于mid if matrix[i][j] &lt;= mid: cnt = cnt + i + 1 j += 1 else: i -= 1 return cntdef kthSmallest(self, matrix: List[List[int]], k: int) -&gt; int: # k恒为有效值，无需判断 row, col = len(matrix), len(matrix[0]) l, r = matrix[0][0], matrix[-1][-1] while l &lt; r: mid = (l + r) &gt;&gt; 1 if self.getLowCnt(matrix, row, col, mid) &lt; k: l = mid + 1 else: r = mid return l 思路二应重点掌握 但从提交结果来看，第一种的时空复杂度更低","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之水壶问题","slug":"Leetcode之水壶问题","date":"2020-05-04T01:05:20.000Z","updated":"2020-07-06T05:27:29.000Z","comments":true,"path":"passages/leetcode-zhi-shui-hu-wen-ti/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-shui-hu-wen-ti/","excerpt":"Water and Jug Problem","text":"Water and Jug Problem Water and Jug Problem code with Python title number：365 读题 BFS 有两个容量分别为x升和y升的水壶以及无线多的水 判断是否能通过使用这两个水壶，得到恰好为z升的水 允许的操作： 装满任意一个水壶 清空任意一个水壶 从一个水壶向另一个水壶倒水，知道装满或倒空 思路一 将两个水壶视作两个状态，对水壶的操作视作改变状态 初始状态为(0, 0)，目标状态为(z, any)或(any, z) 每一时刻的状态由x和y决定 把X壶的水灌进Y壶，直至灌满或倒空 把Y壶的水灌进X壶，直至灌满或倒空 把X壶灌满 把Y壶灌满 把X壶倒空 把Y壶倒空 通过其中一个示例来模拟该过程 输入：x = 3, y= 5, z = 4输出：True (0, 0) -&gt; (0, 5) -&gt; (3, 2) -&gt; (0, 2) -&gt; (2, 0) -&gt; (2, 5) -&gt; (3, 4) -&gt; True 1234567891011121314151617181920212223242526def canMeasureWater(self, x: int, y : int, z: int) -&gt; bool: if x + y &lt; z: return False queue = [(0, 0)] seen = set((0, 0)) while len(queue) &gt; 0: a, b = queue.pop(0) if a == z or b == z or a + b == z: return True states = set() # 当前所有可能得到的的状态 states.add((x, b)) states.add((a, y)) states.add((0, b)) states.add((a, 0)) states.add((min(x, b+a), 0 if b &lt; x - a else b- (x-a))) states.add((0 if a + b &lt; y else a - (y - b), min(b+a, y))) for state in states: if state in seen: continue queue.append(state) seen.add(state) return False 思路二 数学方法：求最大公约数 先介绍一个定理，裴蜀定理 对任意两个整数a、b，设d是它们的最大公约数，那么关于x和y的线性方程ax+by=m，有整数解(x, y)当且仅当m是d的整数倍 用示例一演示该定理的使用： x = 3, y = 5, z= 4 3*3 - 1*5 = 4 -&gt; 3*x - 1*y = z 具体过程为： 倒满a（1）将a倒到b再次倒满a（2）再次将a倒到b（a这个时候还剩下1升）倒空b（-1）将剩下的1升倒到b将a倒满（3）将a倒到bb此时正好是4升 我们只需计算出x和y的最大公约数，再判断z是否是该最大公约数的整数倍即可 123456789101112131415161718def canMeasureWater(self, x: int, y: int, z: int) -&gt; bool: if x + y &lt; z: return False if z == 0: return True if x == 0: return y == z if y == 0: return x == z def getGCD(x, y): min_ = min(a, b) while min_: if a % min_ == 0 and b % min_ == 0: return min_ min_ -= 1 return z % getGCD(x, y) == 0","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之递增的三元子序列","slug":"Leetcode之递增的三元子序列","date":"2020-05-03T02:26:32.000Z","updated":"2020-07-06T05:11:02.000Z","comments":true,"path":"passages/leetcode-zhi-di-zeng-de-san-yuan-zi-xu-lie/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-di-zeng-de-san-yuan-zi-xu-lie/","excerpt":"Increasing Triplet Subsequence","text":"Increasing Triplet Subsequence Increasing Triplet Subsequence code with Python title number：334 读题 给定一个未排序的子数组，判断数组中是否存在长度为3的递增子序列 所谓递增子数组，定义如下： 如果存在这样的 i, j, k, 且满足 0 ≤ i &lt; j &lt; k ≤ n-1，使得 arr[i] &lt; arr[j] &lt; arr[k] ，返回 true ; 否则返回 false 。 要求算法复杂度为O(n)，空间复杂度为O(1) 思路一 由于时空复杂度的限制，暴力算法就不用考虑了 再者，结合之前的经验，子序列 != 子串。所以，满足条件的三个元素不一定连续，也不适合使用滑动窗口的思想 我们的目的是依次找到三个变量，这三个变量的大小是递增的，即可 所以，我们的做法是，遍历，维护三个变量min_one, min_two, min_thr,分别对应最小值，第二小值，第三小值。 只要我们能够在遍历的过程中将这三个变量填满，即认为可以找到满足条件的子序列 1234567891011121314def increaseTriplet(self, nums: List[int]) -&gt; bool: if len(nums) &lt; 3: return False min_one, min_two, min_thr = float(\"inf\"), float(\"inf\"), float(\"inf\") for i in range(len(nums)): if nums[i] &lt;= min_one: min_one = nums[i] elif nums[i] &lt;= min_two: min_two = nums[i] else: min_thr = nums[i] return min_one != float(\"inf\") and min_two != float(\"inf\") and min_thr != float(\"inf\")","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之奇偶链表","slug":"Leetcode之奇偶链表","date":"2020-05-02T00:38:58.000Z","updated":"2020-07-06T05:24:14.000Z","comments":true,"path":"passages/leetcode-zhi-qi-ou-lian-biao/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-qi-ou-lian-biao/","excerpt":"Odd Even Linked List","text":"Odd Even Linked List Odd Even Linked List code with Python title number：328 读题 给定一个单链表，把所有的奇数结点和偶数结点分别排在一起 这里的奇数偶数结点指的是结点编号的奇偶性 请使用原地算法完成 思路一 首先想到的是，遍历一遍链表 将奇数结点放到一起 将偶数结点放到一起 最后将两个子链表拼接起来 但题目要求的是原地算法，所以要转化思路 思路二 遍历一次，同时修改两个结点，具体而言： 设置三个指针，odd、even、evenhead，分别用于知识奇数子链的结尾、偶数子链的结尾、偶数子链的开头 具体实现见代码 1234567891011121314151617class ListNode: def __init__(self, x): self.val = x self.next = Nonedef oddEvenList(self, head: ListNode) -&gt; ListNode: if head == None: return head odd, evenhead, even = head, head.next, head.next while even != None and even.next != None: odd.next = even.next odd = odd.next even.next = odd.next even = even.next odd.next = evenhead return head","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之零钱兑换","slug":"Leetcode之零钱兑换","date":"2020-05-01T02:28:43.000Z","updated":"2020-07-06T05:22:00.000Z","comments":true,"path":"passages/leetcode-zhi-ling-qian-dui-huan/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-ling-qian-dui-huan/","excerpt":"Coin Change","text":"Coin Change Coin Change code with Python title number：322 读题 给定不同面额的硬币coins和一个总金额amount 计算可以凑成总金额所需的最少的硬币个数，每种硬币可以无限量使用 若没有凑成总金额的方案，则返回-1 思路一 本题十分类似于之前的完全平方数 贪心策略在这里是行不通的 思路二 动态规划 状态表示：$f(i)$ 集合：组成i块钱可行的硬币组合的集合 属性：集合中使用硬币数最少的方案 状态计算 类似于完全背包问题，每种面额的硬币可以无限使用 完全背包问题是在有限空间下求最大价值 本题是在给定金额下求最小硬币数 以第最后一种硬币取不取为集合分割标准 最后一种硬币不取，则f(i) 最后一种硬币取，则f(i-coni[j]) + 1 即，$f(i) = min(f(i), f(i-coins[j])+1)$ 最终答案为：$f(amount)$ 1234567891011def coinChange(self, coins: List[int], amount: int) -&gt; int: # 多申请一个空间，方便处理 dp = [amount+1]*(amount+1) dp[0] = 0 for i in range(1, amount+1): for j in range(len(coins)): if i &gt; coins[j]: dp[i] = min(dp[i], dp[i-coins[j]]+1) return -1 if dp[-1]==amount+1 else dp[-1]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之最佳买卖股票时机含冷冻期","slug":"Leetcode之最佳买卖股票时机含冷冻期","date":"2020-04-30T02:40:31.000Z","updated":"2020-07-06T05:33:44.000Z","comments":true,"path":"passages/leetcode-zhi-zui-jia-mai-mai-gu-piao-shi-ji-han-leng-dong-qi/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zui-jia-mai-mai-gu-piao-shi-ji-han-leng-dong-qi/","excerpt":"Best Time to Buy and Sell Stock with Cooldown","text":"Best Time to Buy and Sell Stock with Cooldown Best Time to Buy and Sell Stock with Cooldown code with Python title number：309 读题 给定一个整数数组，其中第i个元素代表了第i天的股票价格 设计一个算法计算出最大利润。 在满足约束条件下，你可以尽可能地完成更多的交易 注意： 不能多次参与多笔交易 卖出股票后，无法在第二天买入股票（冷冻期为1天） 例如： 输入：[1, 2, 3, 0, 2] 输出：3 解释：对应的交易状态为[买入, 卖出, 冷冻期, 买入, 卖出] 思路一 股票问题即动态规划问题 相比与最简单的股票问题，当前问题存在卖出股票后有一天的时间不允许买入股 因此当前状态变为了三种，即[卖出、不操作、买入]。所以使用三维的数组，dp[i][k][0]或dp[i][k][1]，其中i为第i天，k = [0:不操作, 1:卖出, 2:买入]，最后一维[0:当前不持有物品, 1:当前持有物品] 状态表示：$f(i, k, 0/1)$ 集合：第i天所有买卖股票方案的利润的集合 属性：所有方案下取得的最大利润 状态计算 有六种状态（其中有两种情况不可能存在） 当前不操作且无物品，$f(i, 0 ,0)$ 前一天不操作且无物品，$f(i-1, 0, 0)$ 前一天卖出物品，$f(i-1, 1, 0)$ 所以，$f(i, 0, 0) = max[f(i-1, 0, 0), f(i-1, 1, 0)]$ 当前不操作且有物品 前一天不操作且有物品，$f(i-1, 0, 1)$ 前一天买入后持有物品，$f(i-1, 2, 1)$ 所以，$f(i, 0, 1) = max[f(i-1, 0, 1), f(i-1, 2, 1)]$ 当前卖出后无物品 前一天买入物品，$f(i-1, 2, 1)+prices[i]$ 前一天持有物品，$f(i-1, 0, 1)+pries[i]$ 所以，$f(i, 1, 0) = max[f(i-1,2,1)+prices[i], f(i-1, 0, 1)+prices[i]]$ 当前买入后有物品 前一天不进行操作且不持有物品，$f(i-1, 0, 0)-prices[i]$ 所以，$f(i, 2, 1) = f(i-1, 0, 0) - prices[i]$ 当前卖出后持有物品 该状态不存在 当前买入后不持有物品 该状态不存在 最后一天一定为不操作无物品和卖出物品后无物品的最大值，即： $$max[f(len(prices)-1, 0, 0), f(len(prices)-1, 1, 0)]$$ 1234567891011121314151617181920212223242526272829303132def maxProfit(self, prices: List[int]) -&gt; int: def make_dp(n): dp = [0]*(n+1) for i in range(n+1): dp[i] = [0]*3 for i in range(n+1): for j in range(3): dp[i][j] = [0]*2 return dp if len(prices) == 0: return 0 dp = make_dp(len(prices)) # 初始化 dp[0][0][0] = 0 dp[0][2][1] = -prices[0] dp[0][0][1] = -float('inf') dp[0][1][0] = -float('inf') dp[0][1][1] = -float('inf') dp[0][2][0] = -float('inf') for i in range(1, len(prices)): dp[i][0][0] = max(dp[i-1][0][0], dp[i-1][1][0]) dp[i][0][1] = max(dp[i-1][0][1], dp[i-1][2][1]) dp[i][1][0] = max(dp[i-1][2][1], dp[i-1][0][1]) + prices[i] dp[i][2][1] = dp[i-1][0][0]-prices[i] return max(dp[len(prices)-1][0][0], dp[len(prices)-1][1][0]) 使用Python解决该题的时候，注意在创建多维数组时的方式 如果使用list comprehension会产生浅拷贝的问题，即dp = [[[0]*(len(prices)+1)]*3]*2的方式建数组","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之完全平方数","slug":"Leetcode之完全平方数","date":"2020-04-29T06:23:54.000Z","updated":"2020-07-06T05:28:39.000Z","comments":true,"path":"passages/leetcode-zhi-wan-quan-ping-fang-shu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-wan-quan-ping-fang-shu/","excerpt":"Perfect Squares","text":"Perfect Squares Perfect Squares code with Python title number：279 读题 给定一个正整数n，找到若干平方数，使这些完全平方数的和等于n，输出使用的完全平方数的个数 使组成和的完全平方数的个数最少，完全平方数可重复使用 思路一 首先说一下，一开始的想法是 生成一个完全平方数的列表，然后从中挑选尽可能大的数来用 但是这种想法是有问题的，虽然直觉上觉得每次取尽可能大的数会减少使用的数字的数量，这种想法的缺陷是会在后期使用多次的较小的数字，从而直接将使用的数字个数变多 例如： 对于n = 12，使用这种算法得到的序列为[9, 1, 1, 1] 而实际上[4, 4, 4]的序列才是最合适的 贴一下代码吧，但是不要用 12345678910111213141516171819def numSquares(self, n: int) -&gt; int: def gen_square_list(n): # 生成合适的完全平方素列表，返回降序列表 square, i = [], 1 while i*i &lt;= n: square.append(i*i) i += 1 return square[::-1] result, i = [], 0 square = gen_square_list(n) while n &gt; 0: if n &gt;= square[i]: result.append(square[i]) n -= square[i] else: i += 1 return result 思路二 暴力解法 完全平方数列表 + n 求出所有的组合，取其中最短的组合 1234567891011121314151617181920212223def numSquares(self, n: int) -&gt; int: def gen_square_list(n): # 生成合适的完全平方素列表，返回降序列表 square, i = [], 1 while i*i &lt;= n: square.append(i*i) i += 1 return square[::-1] square = gen_square_list(n) def minNumSquares(n): if n in square: return 1 min_num = float('inf') for s in square: if n &lt; s: break new_num = minNumSquare(n - s) + 1 min_num = min(min_num, new_num) return min_num return minNumSquares(n) 在题目没有给出范围时，使用暴力解法通常是会超时的 毫无意外，超时了 思路三 使用暴力枚举之所以会超时是因为我们在其中进行了多次的重复计算，所以动态规划登场 在使用动态规划之前，我们需要预先计算小于给定数字的完全平方数列表 状态表示（$f(i)$） 集合：数字i的平方数组合方案使用平方数的个数集合 属性：集合中使用平方数最少的方案 状态计算 以是否使用小于等于i的最大平方数作为集合的划分标准 假设符合条件的最后一个数字为k 若使用最后一个数字，则表达式为f(i) 若不使用最后一个数字，则表达式为f(i-k) 综上，状态计算表达式为：$f(i) = min(f(i), f(i-k)+1)$ 结果即$f(n)$，即数字n的平方数组合中使用平方数最少的个数 12345678910111213def numSquares(self, n: int) -&gt; int: square_nums = [i**2 for i in range(0, int(math.sqrt(n))+1)] # 这里多申请一个位置，用于处理n-k==0的情况 dp = [float('inf')] * (len(n)+1) dp[0] = 0 for i in range(1, n+1): for s in square_nums: if i &lt; s: break dp[i] = min(dp[i], dp[i-s] + 1) return dp[-1] 思路四 贴一个比较有趣的解法，是一个基于数学定理的解法，来自本题的题解区","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之搜索二维矩阵Ⅱ","slug":"Leetcode之搜索二维矩阵Ⅱ","date":"2020-04-28T02:07:54.000Z","updated":"2020-07-06T05:27:47.000Z","comments":true,"path":"passages/leetcode-zhi-sou-suo-er-wei-ju-zhen-ii/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-sou-suo-er-wei-ju-zhen-ii/","excerpt":"Search a 2D Matrix Ⅱ","text":"Search a 2D Matrix Ⅱ Search a 2D Matrix Ⅱ code with Python title number：240 读题 编写一个高效的算法来搜索一个m*n的矩阵中的一个目标值 矩阵具有以下的特性： 每行的元素从左到右升序排列 每列的元素从上到下升序排列 思路一 不巧，该题目在准备研究生初试的时候遇到过 说一下思路： 第一行中的每个位置的元素都是对应列中最小的元素 最后一行的元素从右向左遍历，如果target大于当前值，则行号+1；如果target小于当前值，则列号-1 直到找到target，返回True，或遍历完没发现对应元素，返回False 123456789101112131415161718192021def searchMatrix(self, matrix, target): \"\"\" :type matrix: List[List[int]] :type target: int :rtype: bool \"\"\" if len(matrix) == 0: return False i, j = len(matrix)-1, 0 while i &gt;= 0 and j &lt; len(matrix[0]): if matrix[i][j] == target: return True # target大于当前元素，列号+1 if matrix[i][j] &lt; target: j += 1 # target小于当前元素，行号-1 if matrix[i][j] &gt; target: i -= 1","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之除自身以外数组的乘积","slug":"Leetcode之除自身以外数组的乘积","date":"2020-04-27T05:31:32.000Z","updated":"2020-07-06T05:10:15.000Z","comments":true,"path":"passages/leetcode-zhi-chu-zi-shen-yi-wai-shu-zu-de-cheng-ji/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-chu-zi-shen-yi-wai-shu-zu-de-cheng-ji/","excerpt":"Product of Array Except Self","text":"Product of Array Except Self Product of Array Except Self code with Python title number：238 读题 给定一个长度为n的整数数组nums，其中n &gt; 1，返回输出数组output，其中output[i]等于nums中除nums[i]之外其余个元素的乘积 不允许使用除法 请尝试在常数空间复杂度内完成这个题目 思路一 常规思路为双重遍历 第一轮遍历进行数组的遍历 第二轮遍历除当前元素以外的数组，并进行计算 12345678910def productExceptSelf(self, nums: List[int]) -&gt; List[int]: output = [] for i in range(len(nums)): temp = nums[:i]+nums[i+1:] temp_product = temp[0] for j in range(len(temp)): temp_product *= temp[j] output.append(temp_product) return output 意料之中，超时 思路二 由于输出数组中每个位置的值都要用到其他元素只对数组进行一次遍历完成该任务是不可能的，我们的工作是尽可能的减少遍历的次数 我们正向进行一次遍历，维护一个数组，第i项代表前i个元素的乘积 之后再反向遍历一次数组，同样维护一个数组，第i项代表前i个元素的乘积 之后再将两个数组相乘，即为结果 这种做法本质上就是分别计算了第i个元素前面和后面的乘积，最后再结合 事实上，并不需要使用第二个数组，在进行第二遍遍历的时候，只需要对第一个数组的对应位置进行修改即可 123456789101112131415def productExceptSelf(self, nums: List[int]) -&gt; List[int]: output = [0]*len(nums) temp = 1 # 正向遍历 for i in range(len(nums)): output[i] = temp temp *= nums[i] temp, n = 1, len(nums)-1 # 反向遍历 while n &gt;= 0: output[n] *= temp temp *= nums[n] n -= 1 return output","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之二叉树的最近公共祖先","slug":"Leetcode之二叉树的最近公共祖先","date":"2020-04-26T08:02:59.000Z","updated":"2020-07-06T05:12:33.000Z","comments":true,"path":"passages/leetcode-zhi-er-cha-shu-de-zui-jin-gong-gong-zu-xian/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-er-cha-shu-de-zui-jin-gong-gong-zu-xian/","excerpt":"Lowest Common Ancestor of a Binary Tree","text":"Lowest Common Ancestor of a Binary Tree Lowest Common Ancestor of a Binary Tree code with Python title number：236 读题 给定一棵二叉树，找到树中两个指定结点的最近公共祖先 结点p和q为不同结点，并且必定存在于给定的二叉树中 最近公共祖先 对于有根数T的两个结点p、q，最近公共祖先表示为一个结点x，满足x是p、q的祖先，并且x的深度尽可能大 一个节点可以是自己的祖先 思路一 二叉树树是一种递归的数据结构，所以解决二叉树问题递归应该是我们首先需要想到的解决方法 不错，这里介绍的是一种递归方法 在当前结点的左右子树中分别查找p和q，如果p没有在左子树中，那么它一定在右子树中，反之依然 分别查找左右子树，返回查找到的结点 这种方法的原理在于： 树是一种递归数据结构 p和q是不同的结点，并且必定存在于一个结点的左右子树中 12345678910111213141516def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -&gt; 'TreeNode': if not root or root == p or root == q: return root # 分别去左右子树中找 left = self.lowestCommonAncestor(root.left, p, q) right = self.lowestCommonAncestor(root.right, p, q) # 左子树中没找到，找右子树 if not left: return right # 右子树中没找到，找左子树 if not right: return left # 分别一个，返回当前子树的root else: return root 欢迎来信交流||指教。","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之二叉搜索树中第K小元素","slug":"Leetcode之二叉搜索树中第K小元素","date":"2020-04-25T02:41:24.000Z","updated":"2020-07-06T05:13:15.000Z","comments":true,"path":"passages/leetcode-zhi-er-cha-sou-suo-shu-zhong-di-k-xiao-yuan-su/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-er-cha-sou-suo-shu-zhong-di-k-xiao-yuan-su/","excerpt":"Kth Smallest Element in a BST","text":"Kth Smallest Element in a BST Kth Smallest Element in a BST code with Python title number：230 题目 给定一棵二叉搜索树，查找其中第k个最小的元素 k总是有效的 思路一 回顾一下，二叉搜索树的特点如下： 左子树若不空，则左子树中所有节点的值都小于根节点的值 右子树若不空，则右子树中所有结点的值都大于根节点的值 左右子树也符合该特点 根据二叉搜索树的特点，如果对二叉搜索树进行一次中序遍历可以得到一个升序数组，然后取数组的第k个元素即可 12345678910111213def kthSmallest(self, root: TreeNode, k: int) -&gt; int: def inorder(root): if root is None: return inorder(root.left) res.append(root.val) inorder(root.right) res = [] inorder(root) return res[k-1]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之求众数Ⅱ","slug":"Leetcode之求众数Ⅱ","date":"2020-04-24T07:18:59.000Z","updated":"2020-07-06T05:24:40.000Z","comments":true,"path":"passages/leetcode-zhi-qiu-zhong-shu-ii/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-qiu-zhong-shu-ii/","excerpt":"Majority Element Ⅱ","text":"Majority Element Ⅱ Majority Element Ⅱ code with Python title number：229 读题 给定一个大小为n的数组，找出其中所有出现次数超过$\\frac{1}{3}$次的元素 要求算法的时间复杂度为$O(n)$，空间复杂度为$O(1)$ 思路一 首先从分析一下从题目中得到的信息： 存在数组中没有没有符合条件的数的情况，即返回空集 最多存在两个满足条件的数（显然） 投票算法（摩尔投票，即对候选者与其他人对抗的过程） 本题特别之处在于，需要设置两个候选值（至多两个满足条件的元素） 对于候选者cand1和cand2： 如果投cand1，cand1加一票 如果投cand2，cand2加一票 如果投其他元素，cand1和cand2各减一票 1234567891011121314151617181920212223242526272829303132333435363738394041def majorityElement(self, nums: List[int]) -&gt; List[int]: cand1, vote1 = None, 0 cand2, vote2 = None, 0 res = [] for i in range(len(nums)): if cand1 is None and cand2 != nums[i]: cand1 = nums[i] vote1 = 1 elif cand2 is None and cand1 != nums[i]: cand2 = nums[i] vote2 = 1 else: if cand1 == nums[i]: vote1 += 1 elif cand2 == nums[i]: vote2 += 1 else: vote1 -= 1 vote2 -= 1 if vote1 == 0: cand1 = None if vote2 == 0: cand2 = None # 重新遍历判断 vote1 ， vote2 = 0， 0 if cand1 is not None: for i in range(len(nums)): if cand1 == nums[i]: vote1 += 1 if cand2 is not None: for i in range(len(nums)): if cand2 == nums[i]: vote2 += 1 if vote1 &gt; len(nums)//3: res.append(cand1) if vote2 &gt; len(nums)//3: res.append(cand2) return res 以下解释帮助理解 根据上面的信息，我们可以找出数组中出现次数最多的两个数，然后判断这两个数是否符合条件即可 如此一来，我们每次从数组中拿走三个不同的数，最后剩下的一定是出现次数最多的两个数，再判断这两个数是否合法即可。 分为三种情况：(将数组分为三组，A、B、其他，A、B为出现次数最多的两个数） 三个数中包含A和B。则三部分分别减去1，不影响最终结果 三个数中只包含A和B其中一个，假设是A。则A和其他分别减1减2，注意，即使这里A减去了1，但仍是出现次数最多的前两名 三个数中不包含A和B，则其他减去2，仍不改变最终的结果","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之最大正方形","slug":"Leetcode之最大正方形","date":"2020-04-23T03:17:19.000Z","updated":"2020-07-06T05:33:16.000Z","comments":true,"path":"passages/leetcode-zhi-zui-da-zheng-fang-xing/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zui-da-zheng-fang-xing/","excerpt":"Maximal Square","text":"Maximal Square Maximal Square code with Python title number：221 读题 给定一个由0和1组成的二维矩阵 在矩阵内找到之包含1的最大正方形，返回其面积 思路一 一开始想到了连通区域问题，但仔细一想并不可行，连通区域问题只需要进行DFS即可，而当前问题对连通区域的形状有要求，并不适合 暴力解法： 遍历每一个点，求以当前点为右下角点的正方形的最大面积 由于是正方形，所以我们只需要记录以当前点为右下角点的正方形的最大边长即可 12345678910111213141516171819202122232425262728293031def maximalSquare(self, matrix: List[List[str]]) -&gt; int: if len(matrix) == 0: return 0 # 存储以当前位置结尾的连续数字一的个数 width = [[0]*len(matrix[0]) for _ in range(len(matrix))] # 记录最大边长 int max_side = 0 for row in range(len(matrix)): for col in range(len(matrix[0])): if matrix[row][col] == '1': if col == 0: # 第一列，只能为1 width[row][col] = 1 else: width[row][col] = width[row][col-1] + 1 else: width[row][col] = 0 cur_width = width[row][col] #向上扩展行 up_row = row while up_row &gt;= 0: height = row - up_row + 1 if width[up_row][col] &lt;= max_side || height &gt; cur_width: break # 最大边长受高和长的限制， max_side = max(height, max_side) up_row -= 1 return max_side * max_side 思路二 动态规划 在思路一中，我们求每个点的最大边长时并没哟欧考虑之前的解，而事实上是可以用到的，所以动态规划他来了 状态表示：$f(i, j)$ 集合：以点matrix[i][j]为右下角点的正方形的边长的集合 属性：集合中边长的最大值 状态计算： 当前的点有三个方向可以到达：上方、左边、左上角（当前点是右下角。所以右边和下边对当前点没有影响）。以此作为标准划分集合，在当前点为1的时候: 当左上角的最大边长不为0时，当前点的最大边长可以表示为$f(i, j) = f(i-1, j-1)+1$ 当左边的最大边长不为0时，当前点的最大边长可以表示为$f(i ,j) = f(i-1, j) + 1$ 当上面的最大边长不为0时，当前点的最大边长可以表示为$f(i, j) = f(i , j-1) + 1$ 而当前点最终的最大边长受这三者中最短的最大边长的限制，于是：$$f(i, j) = min[f(i-1, j-1), f(i-1, j), f(i ,j-1)]+1$$ 代码方面，我们可以多申请一行和一列，这样第一行和第一列就不需要特殊处理了 1234567891011121314151617def maximalSquare(self, matrix: List[List[str]]) -&gt; int: if len(matrix) == 0: return 0 dp = [[0]*len(matrix[0])+1 for _ in range(len(matrix)+1)] max_side = 0 for row in range(1, len(matrix)+1): for col in range(1, len(matrix[0])+1): if matrix[row-1][col-1] == '0': dp[row][col] = 0 else: dp[row][col] = min(dp[row][col-1], min(dp[row-1][col], dp[row-1][col-1]))+1 max_side = max(dp[row][col], max_side) print(dp) return max_side * max_side","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之数组中第K个最大元素","slug":"Leetcode之数组中第K个最大元素","date":"2020-04-22T08:25:46.000Z","updated":"2020-07-06T05:27:21.000Z","comments":true,"path":"passages/leetcode-zhi-shu-zu-zhong-di-k-ge-zui-da-yuan-su/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-shu-zu-zhong-di-k-ge-zui-da-yuan-su/","excerpt":"Kth Largest Element in an Array","text":"Kth Largest Element in an Array Kth Largest Element in an Array code with Python title number：215 读题 在未排序的数组中找到第K个最大的元素。 注意，你要找到的是数组排序后的第K个最大的元素，而不是第K个不同的元素（即降序排序后的第K个元素） 示例： 12345输入：[3, 2, 1, 5, 6, 4] 和 k &#x3D; 2输出：5输入：[3, 2, 3, 1, 2, 4, 5, 5, 6] 和 k &#x3D; 4输出：4 思路一 直接调用sort()进行原地排序，返回排序后的降序序列的第K个元素 1234def findKthLargest(self, nums: List[int], k: int) -&gt; int: nums.sort(reverse=True) return nums[k-1] 思路二 联想到排序算法中的堆排序，我们可以使用小顶堆来优化该算法的时间复杂度 利用对存储前K个最大的数，最后返回堆顶的元素即可 当i &lt; k时，压数据进堆 当i &gt;= k时，比较nums[i]和堆顶元素的大小，如果大于，则使用heapreplace()进行替换，否则跳过 123456789101112from heapq import heappush, heapreplacedef findKthLargest(self, nums: List[int], k: int) -&gt; int: heap = [] for i in range(len(nums)): if i &lt; k: heappush(heap.nums[i]) if i &gt;= k: if nums[i] &gt; heap[0]: heapreplace(heap, nums[i]) return heap[0]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之添加与搜索单词","slug":"Leetcode之添加与搜索单词","date":"2020-04-21T04:46:01.000Z","updated":"2020-07-06T05:28:02.000Z","comments":true,"path":"passages/leetcode-zhi-tian-jia-yu-sou-suo-dan-ci/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-tian-jia-yu-sou-suo-dan-ci/","excerpt":"Add and Search Word","text":"Add and Search Word Add and Search Word code with Python title number：211 读题 又是一道数据结构的设计题 设计一个支持一下两种操作的数据结构 添加单词 搜索单词 所有单词仅由小写字母组成 示例 1234567addWord(&quot;bad&quot;)addWord(&quot;dad&quot;)addWord(&quot;mad&quot;)search(&quot;pad&quot;) -&gt; falsesearch(&quot;bad&quot;) -&gt; truesearch(&quot;.ad&quot;) -&gt; truesearch(&quot;b..&quot;) -&gt; true 思路一 观察上面的示例，如果没有正则符号.（匹配除换行符之外的任意单字符），我们可以使用数组直接存储单词，在查找的时候线性查找即可 不过加入.之后也比较好处理，因为在判断时只需要将.对应的字符认为时匹配到了即可 之前做过一道前缀树的设计题，我们这里可以使用前缀树进行优化 123456789101112131415161718192021222324252627282930313233343536373839404142class WordDictionary: from collections import defaultdict def __init__(self): \"\"\" Initialize your data structure here. \"\"\" self.lookup = &#123;&#125; def addWord(self, word: str) -&gt; None: \"\"\" Adds a word into the data structure. \"\"\" tree = self.lookup for a in word: tree = tree.setdefault(a, &#123;&#125;) tree[\"#\"] = &#123;&#125; def search(self, word: str) -&gt; bool: \"\"\" Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. \"\"\" def helper(word, tree): if not word: if \"#\" in tree: return True return False if word[0] == \".\": for t in tree: if helper(word[1:], tree[t]): return True elif word[0] in tree: if helper(word[1:], tree[word[0]]): return True return False return helper(word, self.lookup)# Your WordDictionary object will be instantiated and called as such:# obj = WordDictionary()# obj.addWord(word)# param_2 = obj.search(word)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之最长公共子序列","slug":"Leetcode之最长公共子序列","date":"2020-04-20T11:02:30.000Z","updated":"2020-07-06T05:35:01.000Z","comments":true,"path":"passages/leetcode-zhi-zui-chang-gong-gong-zi-xu-lie/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zui-chang-gong-gong-zi-xu-lie/","excerpt":"Longest Common Subsequence","text":"Longest Common Subsequence Longest Common Subsequence code with Python title numbber：1143 读题 给定两个字符串text1和text2，返回这两个字符串的最长公共子序列 若两个自负串没有公共子序列，则返回0 值得注意的是： 子序列与子串的最大区别在于：子序列并不要求序列中的元素相邻 思路一 动态规划 对于两个字符串text1，text2 状态表示：$f(i, j)$ 集合：所有两个字符串A[0, i]和B[0, j]的公共子序列的集合 属性：集合中的最长子序列 状态计算 我们以字符串的最后一个字符是否包含在公共子序列中作为集合的划分标准 可以划分为4种情况： 两个字符串的最后一个字符均包含在公共字序列中（即两个字符串的最后一个字符相同），即除去最后一个字符的最长公共子序列的长度加一，可以表示为$f(i-1, j-1)+1$ 两个字符串的最后一个字符都不再公共子序列中，即除去最后一个字符的最长公共子序列的长度，$f(i-1, j-1)$ 字符串A[0, i]的最后一个字符包含在公共字序列中，字符串B[0, j]的最后一个字符不包含在公共字序列中 字符串B[0, j]的最后一个字符包含在公共字序列中，字符串A[0, i]的最后一个字符不包含在公共字序列中 事实上最后两种比较难以精确表示 前面我们也说过，虽然状态表示要求不重不漏，但是在求最值时可以适当重复 我们可以使用f(i, j-1)和f(i-1, j)来近似的表示上面的两种情况（准确的说时包含上面的两种情况），而且f(i-1, j-1)包含在这两种情况中 故f(i,j) = max[f(i, j-1), f(i-1, j)]，并且第一种情况仅在A[i]==B[i]的时候才会存在 题目所求即为$f[len(text1), len(text2)]$， 1234567891011def longestCommonSubsequence(self, text1: str, text3: str) -&gt; int: # 在前面添加了全为0的一行和一列 dp = [0]*(len(text2)+1) for _ in range(len(text1)+1) for i in range(len(text1)): for j in range(len(text2)): if text1[i] != text2[j]: dp[i][j] = max(dp[i+1][j], dp[i][j+1]) else: dp[i+1][j+1] = dp[i][j] + 1 return dp[-1][-1]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之长度最小的子数组","slug":"Leetcode之长度最小的子数组","date":"2020-04-20T05:39:27.000Z","updated":"2020-07-06T05:31:20.000Z","comments":true,"path":"passages/leetcode-zhi-chang-du-zui-xiao-de-zi-shu-zu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-chang-du-zui-xiao-de-zi-shu-zu/","excerpt":"Minimum Size Subarray Sum","text":"Minimum Size Subarray Sum Minimum Size Subarray Sum code with Python title number：209 读题 给定一个含有n个正整数的数组和一个正整数s，找出该数组中满足其和大于等于s的长度最小的连续子数组 返回满足条件的子数组的长度 若不存在符合条件的连续子数组，返回0 思路一 暴力解法 穷举所有可能的子数组，在子数组和满足条件的情况下更新min_size 返回最终的min_size 1234567891011def minSubArrayLen(self, s: int, nums: List[int]) -&gt; int: min_size = len(nums) for i in range(len(nums)): for j in range(i, len(nums)): sum_ = 0 for k in range(i, j+1): sum_ += nums[k] if sum_ &gt;= s: min_size = min(min_size, j-i+1) return min_size 遍历所有的子数组的时间复杂度为$O(n^2)$，计算子数组的时间复杂度为$O(n)$ 整个算法的时间复杂度为$O(n^3)$，提交超时 思路二 优化后的暴力解法 可优化的部分为对子数组的求和： 使用一个与数组等长的数组sums来存储前i个元素的和 这样，求num[i:j]的和就是sums[j] - sums[i] + nums[j] 123456789101112131415161718def minSubArrayLen(self, s: int, nums: List[int]) -&gt; int: if len(nums) == 0: return 0 min_size = float('inf') sums = [0]*len(nums) sums[0] = nums[0] for i in range(1, len(nums)): sums[i] = sums[i-1] + nums[i] for i in range(len(nums)): for j in range(i, len(nums)): sum_ = sums[j] - sums[i] + nums[i] if sum_ &gt;= s: min_size = min(min_size, j-i+1) return 0 if min_size==float('inf') else min_size 仍是超时。。。。。 思路三 滑动窗口，所有查找连续子数组的都可以考虑滑动窗口 左指针从左向右遍历，若当前连续子数组满足条件后，尝试向右移动指针使当前连续子数组尽可能短 之后再加移动右指针，加上下一个值 重复上述过程 1234567891011def minSubArry(self, s: int, nums: List[int]) -&gt; int: l = total = 0 ans = float('inf') for r in range(len(nums)): total += nums[r] while total &gt;= s: ans = min(ans, r-l+1) total -= nums[l] l += 1 return 0 if ans == float('inf') else ans","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之实现Trie","slug":"Leetcode之实现Trie","date":"2020-04-19T04:56:36.000Z","updated":"2020-07-06T05:26:50.000Z","comments":true,"path":"passages/leetcode-zhi-shi-xian-trie/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-shi-xian-trie/","excerpt":"Implement Trie(Prefix Tree)","text":"Implement Trie(Prefix Tree) Implement Trie (Prefix Tree) code with Python title number：208 读题 实现前缀树，包含insert，search，startWith这三个操作 示例： 12345678Trie trie &#x3D; new Trie();trie.insert(&quot;apple&quot;);trie.search(&quot;apple&quot;); &#x2F;&#x2F; 返回 truetrie.search(&quot;app&quot;); &#x2F;&#x2F; 返回 falsetrie.startsWith(&quot;app&quot;); &#x2F;&#x2F; 返回 truetrie.insert(&quot;app&quot;); trie.search(&quot;app&quot;); &#x2F;&#x2F; 返回 true 前缀树，又称字典树： 是一种树形结构，是哈希树的变种，典型的应用是统计、排序和保存带昂的数据。 优点是可以利用字符串的公共前缀来减少查询时间 前缀树有三个基本特性： 根节点不包含字符，除根节点之外每个节点只包含一个字符 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串 每个结点的所有子节点包含的字符都不相同 思路一 题目很直接，实现前缀树的几个功能 初始化 前缀树又称字典树，所以存储结构初始化为字典 插入 每个结点是一个字典，不断迭代存入字符串中的元素 搜索 若有字母不再树中，则查找失败 遍历完当前字符串遇到结束标志才表示当前字符串存在（未遇到结束符则是前缀） 同时结束标志也用来区分是字符串存在于树中，还是当前字符串仅为前缀 判断是否有以给定字符串为前缀的字符串 迭代查找当前字符串，并且不是一个完整单词 即搜索完该前缀并未到达结束符 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Trie: def __init__(self): \"\"\" Initialize your data structure here. \"\"\" self.lookup = &#123;&#125; def insert(self, word: str) -&gt; None: \"\"\" Inserts a word into the trie. \"\"\" tree = self.lookup for a in word: if a not in tree: # 新节点 tree[a] = &#123;&#125; tree = tree[a] # 设置单词的结束标志 tree[\"#\"] = \"#\" def search(self, word: str) -&gt; bool: \"\"\" Returns if the word is in the trie. \"\"\" tree = self.lookup for a in word: if a not in tree: return False tree = tree[a] if \"#\" in tree: return True return False def startsWith(self, prefix: str) -&gt; bool: \"\"\" Returns if there is any word in the trie that starts with the given prefix. \"\"\" tree = self.lookup for a in prefix: if a not in tree: return False tree = tree[a] return True","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"标准完全背包问题","slug":"标准完全背包问题","date":"2020-04-19T03:33:51.000Z","updated":"2020-07-06T05:43:20.000Z","comments":true,"path":"passages/biao-zhun-wan-quan-bei-bao-wen-ti/","link":"","permalink":"http://zivblog.top/passages/biao-zhun-wan-quan-bei-bao-wen-ti/","excerpt":"标准完全背包问题","text":"标准完全背包问题 题目描述 有N种物品和一个容量是V的背包，每种物品都有无限件可用 第i种物品的体积是$v_i$，价值是$w_i$ 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大 返回最大价值 解题思路 我们使用闫式DP分析法给出的框架进行分析 首先，应该明确所有的情况有$2^N$种（每件物品选或不选）,且该问题为最大值问题 状态表示：$f(i, j)$ 集合：所有只从前i个物品中选，总体积不大于j的方案的集合 属性：最大价值 状态计算 与零一背包不同，本题中每个物品是无限的，所以不能以第i件物品放不放为分类标准对集合进行二分类 事实上，应该是k分类，第i件物品放0件、1件、…k件（$k*v_i &lt;= V$） 于是针对每一中情况，取max，表达式如下： $$f(i, j) = max[f(i-1, j), f(i-1, j-v_i)+w_i, … f(i-1, j-kv_i)+kw_i]$$ 表达式看起来比较难实现，我们再来看： $$f(i, j-v_i) = max[f(i-1, j-v_i), … f(i-1, j-(k+1)v_i)+(k+1)w_i]$$ 两个表达式相比较，式一 = max(f(i-1, j), 式二+w_i) 故状态转移方程为： $$f(i ,j) = max[f(i-1, j), f(i-1, j-v_i)+w_i]$$ 最终结果即为：$f(N, V)$ 1234567891011121314def backpack(self, N: int, V: int, v: List[int], w: List[int]) -&gt; int: ''' N: 物品数 V: 背包体积 v: 物品体积列表 w: 物品价值列表 ''' dp = [[0]*(N+1) for _ in range(N+1)] for i in range(1, N+1): for j in range(1, V+1): dp[i][j] = dp[i-1][j] if j &gt;= v[i]: dp[i][j] = max(dp[i][j], dp[i][j-v[i]]+w[i]) return dp[N][V] 优化 上述写法由于是按背包体积从小到大的顺序进行的，所以要判断当前背包能否装下一个物品 优化：从可装下物品的背包体积开始循环 123456789101112131415def backpack(self, N: int, V: int, v: List[int], w: List[int]) -&gt; int: ''' N: 物品数 V: 背包体积 v: 物品体积列表 w: 物品价值列表 ''' dp = [0]*(N+1) for i in range(1, N+1): j = v[i] while j &lt;= V: dp[j] = max(dp[j], dp[j-v[i]]+w[i]) j += 1 return dp[V]","categories":[{"name":"算法","slug":"算法","permalink":"http://zivblog.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"记一次Leetcode春季编程大赛","slug":"记一次Leetcode春季编程大赛","date":"2020-04-18T09:19:09.000Z","updated":"2020-07-06T05:45:36.000Z","comments":true,"path":"passages/ji-yi-ci-leetcode-chun-ji-bian-cheng-da-sai/","link":"","permalink":"http://zivblog.top/passages/ji-yi-ci-leetcode-chun-ji-bian-cheng-da-sai/","excerpt":"记一次Leetcode春季编程大赛","text":"记一次Leetcode春季编程大赛 前言 leetcode上的题目近期刷了100道左右，心想参加一下比赛试试水，可惜可惜，只做出了两道简单题。 简单题十几分钟就做完了，后面几道题看着有思路却总是调试不成功。 革命尚未成功，同志仍需努力，加油！ 拿硬币 桌上有 n 堆力扣币，每堆的数量保存在数组 coins 中。我们每次可以选择任意一堆，拿走其中的一枚或者两枚，求拿完所有力扣币的最少次数。 示例一 输入：[4,2,1] 输出：4 解释：第一堆力扣币最少需要拿 2 次，第二堆最少需要拿 1 次，第三堆最少需要拿 1 次，总共 4 次即可拿完。 示例二 输入：[2,3,10] 输出：8 限制 1 &lt;= n &lt;= 41 &lt;= coins[i] &lt;= 10 123456789101112131415class Solution: def minCount(self, coins: List[int]) -&gt; int: count = 0 for coin in coins: if coin &lt;= 2: count += 1 else: while coin &gt; 0: if coin - 2 &gt;= 0: coin -= 2 count += 1 else: coin -= 1 count += 1 return count 实际上，代码还可以优化 12345678class Solution: def minCount(self, coins: List[int]) -&gt; int: res = 0 for coin in coins: res += (coin+1) // 2 return res 传递信息小朋友 A 在和 ta 的小伙伴们玩传信息游戏，游戏规则如下： 有 n 名玩家，所有玩家编号分别为 0 ～ n-1，其中小朋友 A 的编号为 0 每个玩家都有固定的若干个可传信息的其他玩家（也可能没有）。传信息的关系是单向的（比如 A 可以向 B 传信息，但 B 不能向 A 传信息）。 每轮信息必须需要传递给另一个人，且信息可重复经过同一个人 给定总玩家数 n，以及按 [玩家编号,对应可传递玩家编号] 关系组成的二维数组 relation。返回信息从小 A (编号 0 ) 经过 k 轮传递到编号为 n-1 的小伙伴处的方案数；若不能到达，返回 0。 示例 1： 输入：n = 5, relation = [[0,2],[2,1],[3,4],[2,3],[1,4],[2,0],[0,4]], k = 3 输出：3 解释：信息从小 A 编号 0 处开始，经 3 轮传递，到达编号 4。共有 3 种方案，分别是 0-&gt;2-&gt;0-&gt;4， 0-&gt;2-&gt;1-&gt;4， 0-&gt;2-&gt;3-&gt;4。 示例 2： 输入：n = 3, relation = [[0,2],[2,1]], k = 2 输出：0 解释：信息不能从小 A 处经过 2 轮传递到编号 2 限制： 2 &lt;= n &lt;= 10 1 &lt;= k &lt;= 5 1 &lt;= relation.length &lt;= 90, 且 relation[i].length == 2 0 &lt;= relation[i][0],relation[i][1] &lt; n 且 relation[i][0] != relation[i][1] 123456789101112class Solution: def numWays(self, n: int, r: List[List[int]], k: int) -&gt; int: now = [1]+[0]*(n-1) for i in range(k): snow = [0]*n for x in r: a, b = x[0], x[1] snow[b] += now[a] now = snow return now[n-1] 剧情触发时间在战略游戏中，玩家往往需要发展自己的势力来触发各种新的剧情。一个势力的主要属性有三种，分别是文明等级（C），资源储备（R）以及人口数量（H）。在游戏开始时（第 0 天），三种属性的值均为 0。 随着游戏进程的进行，每一天玩家的三种属性都会对应增加，我们用一个二维数组 increase 来表示每天的增加情况。这个二维数组的每个元素是一个长度为 3 的一维数组，例如 [[1,2,1],[3,4,2]] 表示第一天三种属性分别增加 1,2,1 而第二天分别增加 3,4,2。 所有剧情的触发条件也用一个二维数组 requirements 表示。这个二维数组的每个元素是一个长度为 3 的一维数组，对于某个剧情的触发条件 c[i], r[i], h[i]，如果当前 C &gt;= c[i] 且 R &gt;= r[i] 且 H &gt;= h[i] ，则剧情会被触发。 根据所给信息，请计算每个剧情的触发时间，并以一个数组返回。如果某个剧情不会被触发，则该剧情对应的触发时间为 -1 。 示例 1： 输入： increase = [[2,8,4],[2,5,0],[10,9,8]] requirements = [[2,11,3],[15,10,7],[9,17,12],[8,1,14]] 输出: [2,-1,3,-1] 解释： 初始时，C = 0，R = 0，H = 0 第 1 天，C = 2，R = 8，H = 4 第 2 天，C = 4，R = 13，H = 4，此时触发剧情 0 第 3 天，C = 14，R = 22，H = 12，此时触发剧情 2 剧情 1 和 3 无法触发。 示例 2： 输入： increase = [[0,4,5],[4,8,8],[8,6,1],[10,10,0]] requirements = [[12,11,16],[20,2,6],[9,2,6],[10,18,3],[8,14,9]] 输出: [-1,4,3,3,3] 示例 3： 输入： increase = [[1,1,1]] requirements = [[0,0,0]] 输出: [0] 限制： 1 &lt;= increase.length &lt;= 10000 1 &lt;= requirements.length &lt;= 100000 0 &lt;= increase[i] &lt;= 10 0 &lt;= requirements[i] &lt;= 100000 12 最小跳跃次数为了给刷题的同学一些奖励，力扣团队引入了一个弹簧游戏机。游戏机由 N 个特殊弹簧排成一排，编号为 0 到 N-1。初始有一个小球在编号 0 的弹簧处。若小球在编号为 i 的弹簧处，通过按动弹簧，可以选择把小球向右弹射 jump[i] 的距离，或者向左弹射到任意左侧弹簧的位置。也就是说，在编号为 i 弹簧处按动弹簧，小球可以弹向 0 到 i-1 中任意弹簧或者 i+jump[i] 的弹簧（若 i+jump[i]&gt;=N ，则表示小球弹出了机器）。小球位于编号 0 处的弹簧时不能再向左弹。 为了获得奖励，你需要将小球弹出机器。请求出最少需要按动多少次弹簧，可以将小球从编号 0 弹簧弹出整个机器，即向右越过编号 N-1 的弹簧。 示例 1： 输入：jump = [2, 5, 1, 1, 1, 1] 输出：3 解释：小 Z 最少需要按动 3 次弹簧，小球依次到达的顺序为 0 -&gt; 2 -&gt; 1 -&gt; 6，最终小球弹出了机器。 限制： 1 &lt;= jump.length &lt;= 10^6 1 &lt;= jump[i] &lt;= 10000 12345678910111213141516171819202122232425262728from collections import deque # append(left), pop(left), extendclass Solution: def minJump(self, s: List[int]) -&gt; int: mi = 1 n = len(s) dp = [0]*(n-1)+[1] st = deque([(1, n-1), (0, n)]) for i in range(n-2, -1, -1): if i + s[i] &gt;= n: dp[i] = 1 st = deque([(1, i), (0, n)]) else: x = i+s[i] l, r = 0, len(st)-1 while l+1&lt;r: mi = (l+r)//2 if st[mi][1] &gt; x: r = mi else: l = mi now = min(dp[x], st[l][0]+1) + 1 dp[i]=now while st[0][0]&gt;dp[i]: st.popleft() st.appendleft((dp[i], i)) print(dp) return dp[0] 二叉树任务调度任务调度优化是计算机性能优化的关键任务之一。在任务众多时，不同的调度策略可能会得到不同的总体执行时间，因此寻求一个最优的调度方案是非常有必要的。 通常任务之间是存在依赖关系的，即对于某个任务，你需要先完成他的前导任务（如果非空），才能开始执行该任务。我们保证任务的依赖关系是一棵二叉树，其中 root 为根任务，root.left 和 root.right 为他的两个前导任务（可能为空），root.val 为其自身的执行时间。 在一个 CPU 核执行某个任务时，我们可以在任何时刻暂停当前任务的执行，并保留当前执行进度。在下次继续执行该任务时，会从之前停留的进度开始继续执行。暂停的时间可以不是整数。 现在，系统有两个 CPU 核，即我们可以同时执行两个任务，但是同一个任务不能同时在两个核上执行。给定这颗任务树，请求出所有任务执行完毕的最小时间。 示例 1： 输入：root = [47, 74, 31] 输出：121 解释：根节点的左右节点可以并行执行31分钟，剩下的43+47分钟只能串行执行，因此总体执行时间是121分钟。 示例 2： 输入：root = [15, 21, null, 24, null, 27, 26] 输出：87 示例 3： 输入：root = [1,3,2,null,null,4,4] 输出：7.5 限制： 1 &lt;= 节点数量 &lt;= 1000 1 &lt;= 单节点执行时间 &lt;= 1000 12345678910111213141516171819202122232425262728293031323334353637383940# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def minimalExecTime(self, root: TreeNode) -&gt; float: # def visit(node=root) : # if node is None : # return 0 # node.sum = visit(node.left)+visit(node.right)+node.val # return node.sum # visit() def get_value(node=root): if node.left is None and node.right is None: return node.val, node.val if node.left is None : minv, maxv = get_value(node.right) return minv+node.val, maxv+node.val if node.right is None : minv, maxv = get_value(node.left) return minv+node.val, maxv+node.val minv_left, maxv_left = get_value(node.left) minv_right, maxv_right = get_value(node.right) maxv = maxv_left+maxv_right+node.val if minv_right &gt; maxv_left : minv = minv_right-maxv_left elif minv_left &gt; maxv_right : minv = minv_left - maxv_right else : minv = 0. return minv+node.val, maxv minv, maxv = get_value() return (maxv+minv)/2","categories":[{"name":"算法","slug":"算法","permalink":"http://zivblog.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之数字范围按位与","slug":"Leetcode之数字范围按位与","date":"2020-04-18T03:49:57.000Z","updated":"2020-07-06T05:27:14.000Z","comments":true,"path":"passages/leetcode-zhi-shu-zi-fan-wei-an-wei-yu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-shu-zi-fan-wei-an-wei-yu/","excerpt":"Bitwise AND of Numbers Range","text":"Bitwise AND of Numbers Range Bitwise AND of Numbers Range code with Python title number：201 读题 给定范围[m, n]，其中0 &lt;= m &lt;= n &lt;= 2147483647 返回此范围内所有的数字的按位与（包含两个端点m，n） 解释：范围内所有的数字依次进行按位与运算 例如：[5, 7]，即5 &amp; 6 &amp; 7=4，返回4 思路一 最直接的想法就是遍历区间范围内的所有数字，依次进行与运算 但是这种方式的时间复杂度太高，我们需要通过观察发现某种规律 先看上面的例子：[5, 7]，转化为二进制为： 101, 110, 111，结果是1 来看一个例子：[7, 8]，转化为二进制为： 111, 1000，结果为0 可以发现，当m的位数大于n的位数时，结果必定为0 接下来看一个区间内数字的二进制位数都相同的情况，[20, 23] 10100, 10101, 10110, 10111，结果为16 -&gt; 10000 对m和n做差，23-20=3 -&gt; 100，即从20到23的过程中要加三次1，所以倒数第一位或倒数第二位必定会有0，那么后两位相与必定为0。更进一步，倒数第三位只存在两种情况，原来为0变为1，或原来为1变为0，这样来说，相与也必定是0 所以，结果的后bin(n-m)位必定为0 仍是上面的例子，我们现在已经知道了结果的位数，和后bin(m-n)位的情况，现在只需要确定前几位的情况即可。 而在区间内所有数字位数确定的情况下，并不会有对最高位的进位 也就是前len(bin(n))-len(bin(n-m))位的结果等于m &amp; n的前len(bin(n))-len(bin(n-m))的结果 总结一下 如果bin(n) &gt; bin(m)，解果为0 计算bin(n-m)的位数len_sub 计算n &amp; m的结果 将n &amp; m后bin(n-m)位替换为0即可，或者说是将n &amp; m结果的前len(n)-len_sub位和len_sub个0相加即为结果 12345678def rangeBitwiseAnd(self, m: int, n: int) -&gt; int: if len(bin(n)) &gt; len(bin(m)): return 0 if m == n: return m sub = len(bin(n-m)[2:]) return int(bin(m&amp;n)[2: -sub] + '0'*sub, 2) 可能描述的并不是很容易理解，有疑问可以邮件问我或者看官网题解区的帖子 思路二 只需查找这个区间数字的第i位全为1，那么结构一定是前i位 12345678def rangeBitwiseAnd(self, m: int, n: int) -&gt; int: cnt = 0 while m != n: m &gt;&gt;= 1 n &gt;&gt;= 1 cnt += 1 return m &lt;&lt; cnt","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之岛屿数量","slug":"Leetcode之岛屿数量","date":"2020-04-17T10:26:39.000Z","updated":"2020-07-06T05:10:54.000Z","comments":true,"path":"passages/leetcode-zhi-dao-yu-shu-liang/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-dao-yu-shu-liang/","excerpt":"Number of Islands","text":"Number of Islands Number of Islands code with Python title number：200 读题 给定一个有1（陆地）和0（水）组成的二维网格，计算其中岛屿的数量 岛屿： 被水包围 通过水平或垂直方向上相邻的陆地连接而成 可以认为给定网格的四个边均被水包围 思路一 连通区域问题，可参考被围绕的区域 双循环查找起始位置，对于为1的位置使用DFS进行搜索 已访问位置需要标记，由于不同岛屿之间无关，可以直接将已经访问过的位置置为0 12345678910111213141516171819def numIslands(self, grid: List[List[str]]) -&gt; int: def dfs(grid, i, j): if grid[i][j] != '1' or i &lt; 0 or i &gt;= len(grid) or j &lt; 0 or j &gt;= len(grid[0]): return dfs(grid, i, j+1) dfs(grid, i. j-1) dfs(grid, i+1, j) dfs(grid, i-1, j) if not grid: return 0 count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == '1': dfs(grid, i, j) count += 1 return count","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之二叉树的右视图","slug":"Leetcode之二叉树的右视图","date":"2020-04-16T02:11:34.000Z","updated":"2020-07-06T05:12:05.000Z","comments":true,"path":"passages/leetcode-zhi-er-cha-shu-de-you-shi-tu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-er-cha-shu-de-you-shi-tu/","excerpt":"Binary Tree RIght Side View","text":"Binary Tree RIght Side View Binary Tree RIght Side View code with Python title number：199 读题 给定一棵二叉树，想想自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值 示例 ​ 思路一 转化为层次遍历，即取层次遍历中每层的最后一个结点 具体而言 利用队列来存储结点 取每层的最后一个结点加入最终结果 1234567891011121314151617def rightSideView(self, root: TreeNode) -&gt; List[int]: res = [] if not root: return res deque = [root] while deque: len_ = len(deque) # 仅将当前层的最后一个结点加入结果集中 res.append(deque[-1]) for _ in range(len_): cur = deque.pop(0) if cur.left: deque.append(cur.left) if cur.right: deque.append(cur.right) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之乘积最大子数组","slug":"Leetcode之乘积最大子数组","date":"2020-04-15T06:34:22.000Z","updated":"2020-07-06T05:09:48.000Z","comments":true,"path":"passages/leetcode-zhi-cheng-ji-zui-da-zi-shu-zu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-cheng-ji-zui-da-zi-shu-zu/","excerpt":"Maximum Product Subarray","text":"Maximum Product Subarray Maximum Product Subarray code with Python title number：152 读题 给定一个整数数组，找出数组中乘积最大的连续子数组，返回其乘积 思路一 暴力破解， 穷举所有可能的连续子数组，使用一个变量来存储当前最大的连续子数组之积 1234567891011def maxProduct(self, nums: List[int]) -&gt; int: max_ = nums[0] temp = None for i in range(len(nums)): temp = nums[i] max_ = max(temp, max_) for j in range(i+1, len(nums)): temp *= nums[j] max_ = max(temp, max_) return max_ 意料之中，超时了 思路二 动态规划分析框架，请参考这篇文章 这个题比较特殊，需要分别记录乘积最大和乘积最小的子数组的值。这是因为乘法运算中，一个负数很可以使一个很大的数变为很小的数 状态表示 集合定义 $f(i)$ 以第i个元素为结尾的子数组的乘积的集合 属性 最大值 最小值 状态计算 以第i个数为正数还是负数为划分依据 当第i个数为正数时，第i个数乘以以i-1个数为结尾的最大值即为当前最大值，即$f(i){max} = f(i-1){max} * nums[i]$；同时也要更新当前的最小值，即$f(i){min} = f(i-1){min}*nums[i]$ 当第i个数为负数是，第i个数乘以以i-1个数为结尾的最小值即为当前最大值，即$f(i){max} = f(i-1){min}*nums[i]$；同时也要跟新当前的最小值，即$f(i){min} = f(i-1){max} * nums[i]$ 所求即为dp_max中的最大值 123456789101112def maxProduct(self, nums: List[int]) -&gt; int: n = len(nums) dp_max, dp_min = [1]*(n+1), [1]*(n+1) ans = float('-inf') for i in rnge(1, n+1): dp_max = max(dp_max[i-1]*nums[i-1], dp_min[i-1]*num[i-1], nums[i-1]) dp_min = min(dp_max[i-1]*nums[i-1], dp_min[i-1]*nums[i-1], nums[i-1]) ans = max(ans, dp_max[i]) return ans 我们发现，dp[i]只与dp[i-1]相关，因此我们并不需要两个动态规划数组，只需要两个额外的变量来记录即可 123456789101112def maxProduct(self, nums: List[int]) -&gt; int: n = len(nums) dp_max, dp_min = 1, 1 ans = float('-inf') for i in rnge(1, n+1): temp = dp_max dp_max = max(dp_max*nums[i-1], dp_min*nums[i-1], nums[i-1]) dp_min = min(temp*nums[i-1], dp_min*nums[i-1], nums[i-1]) ans = max(ans, dp_max) return ans 时间和空间上都有所优化","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"标准01背包问题","slug":"标准01背包问题","date":"2020-04-14T13:01:00.000Z","updated":"2020-07-24T03:54:51.000Z","comments":true,"path":"passages/biao-zhun-01-bei-bao-wen-ti/","link":"","permalink":"http://zivblog.top/passages/biao-zhun-01-bei-bao-wen-ti/","excerpt":"标准01背包问题","text":"标准01背包问题 题目描述 有N件物品和一个容量是V的背包。每件物品只能使用一次。 第i件物品的体积是$v_i$，价值是$w_i$ 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大，返回最大价值 解题思路 我们使用闫式DP分析法给出的框架进行分析 首先，应该明确所有的情况有$2^N$种（每件物品选或不选）,且该问题为最大值问题 状态表示：$f(i, j)$ 集合定义：所有只考虑前i个物品且总体积不超过j的选法的集合 属性：上述集合中选法对应价值的最大值 状态计算：根据最后一个不同点划分集合 由于每个物品有两种选择，即选或不选，我们以第i个物品选不选作为集合划分标准 选择第i个物品，则当前体积上限变为$j-V_i$，集合变为了所有只考虑前i-1个物品且总体积不超过$j-V_i$的选法的集合。根据集合定义，表达式为$f(i-1, j-v_i)+w_i$ 不选择第i个物品，则集合变为了所有只考虑前i-1个物品且总体积不超过j的选法的集合，根据集合定义，表达式为$f(i-1, j)$ 综上，$f(i, j) = max[f(i-1, j-v_i)+w_i, f(i-1, j)]$ 所求即为$f(N, V)$：只考虑前N个物品且总体积不超过V的集合中的最大价值 1234567891011121314151617def backpack(self, v: List[int], w: List[int], N: int, V: int) -&gt; int: ''' v: n件物品对应的体积 w: n件物品对应的价值 N: 物品数量 V: 背包容量 ''' f = [[0 for _ in range(V+1)] for _ in range(N+1)] # 遍历物品 for i in range(1, N+1): # 遍历所有可能容积 for j in range(V+1): f[i][j] = f[i-1][j] # 只有在当前的背包空间大于最第i个物品所占空间时 if j &gt;= v[i-1]: f[i][j] = max(f[i][j], f[i-1][j-v[i-1]]+w[i-1]) return f[N][V] 优化 所谓优化是针对代码进行的优化，并不是对算法本身的优化 由于我们的背包空间与第i个物品所占空间之间存在不确定关系，所以将物品所占空间从大到小遍历即可 另外，$f(i ,j)$只与$f(i-1, ~)$有关，所以可以省去一维，节省空间 123456789101112131415def backpack(self, v: List[int], w: List[int], N: int, V: int) -&gt; int: ''' v: n件物品对应的体积 w: n件物品对应的价值 N: 物品数量 V: 背包容量 ''' f = [0 for _ in range(V+1)] j = V for i in range(1, N+1): # 空间从大到小遍历 while j &gt;= v[i-1]: f[j] = max(f[j], f[j-v[i-1]]+w[i-1]) j -= 1 return f[V]","categories":[{"name":"算法","slug":"算法","permalink":"http://zivblog.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"前中后缀表达式的转换及计算","slug":"前中后缀表达式的转换及计算","date":"2020-04-14T03:44:56.000Z","updated":"2020-07-06T05:46:42.000Z","comments":true,"path":"passages/qian-zhong-hou-zhui-biao-da-shi-de-zhuan-huan-ji-ji-suan/","link":"","permalink":"http://zivblog.top/passages/qian-zhong-hou-zhui-biao-da-shi-de-zhuan-huan-ji-ji-suan/","excerpt":"前中后缀表达式的转换及计算","text":"前中后缀表达式的转换及计算 前言 对于人类来讲，中缀表达式是有利于直观理解的，为什么要将中缀表达式转化为前、后缀表达式呢？在我看来，可能有以下几点原因： 中缀表达式有运算符的优先级要求，而前、后缀表达式没有 中缀表达式通过括号提升某些运算的优先级，而前、后缀表达式通过调整运算符位置表示优先级 另外，前、后缀表达式只利用一个栈就能实现表达式的计算，相比于中缀表达式，更适合计算机运算 下面分别介绍中缀表达式如何转化为前、后缀表达式，以及如何使用栈计算前、后缀表达式 表达式的转换中缀转前缀 对于给定的中缀表达式，从右向左扫描 与操作数直接记录（从右向左记录） 与操作符： 栈空时，直接入栈 右括号，直接入栈 其他情况，判断栈顶元素： 栈顶元素为右括号，直接入栈 当前元素优先级小于栈顶元素优先级，栈顶元素出栈 当前元素优先级大于等于栈顶元素优先级，操作符入栈 若栈顶元素为左括号，则栈中左右括号及其之间的元素全部出栈 中缀转后缀 对于给定的中缀表达式，从左向右扫描 操作数直接记录（从左向右记录） 遇操作符： 栈空时，直接入栈 左括号，直接入栈 其他情况，判断栈顶元素： 栈顶为左括号，操作符入栈 当前运算符优先级小于等于栈顶运算符优先级，栈顶元素出栈 当前运算符优先级大于栈顶运算符优先级，操作符入栈 若栈顶为右括号，则栈中左右括号及其之间的元素全部出栈 至扫描完毕 表达式计算计算前缀表达式 对于给定前缀表达式 从右向左扫描 遇操作数入栈 遇操作符： 出栈两个操作数，先出的在左，后出的在右，执行计算 结果入栈 至扫描结束，栈顶元素即表达式结果 计算后缀表达式 对于给定后缀表达式 从左向右扫描 遇操作数入栈 遇操作符： 出栈两个操作数，先出的在右，后出的在左，执行计算 结果入栈 至扫描结束，栈顶元素即表达式结果","categories":[{"name":"算法","slug":"算法","permalink":"http://zivblog.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之逆波兰表达式求值","slug":"Leetcode之逆波兰表达式求值","date":"2020-04-14T03:36:50.000Z","updated":"2020-07-06T05:23:32.000Z","comments":true,"path":"passages/leetcode-zhi-ni-bo-lan-biao-da-shi-qiu-zhi/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-ni-bo-lan-biao-da-shi-qiu-zhi/","excerpt":"Evaluate Reverse Polish Notation","text":"Evaluate Reverse Polish Notation Evaluate Reverse Polish Notation code with Python title number：150 读题 根据逆波兰表达式，求表达式的值 有效的运算符包括+、-、*、/，每个运算对象可以是整数，也可以是另一个逆波兰表达式 说明： 整数除法只保留整数部分 给定的逆波兰表达式总是有效的，不存在除数为0或得不出有效数值的情况 所谓逆波兰表达式即：后缀表达式。 关于前中后缀表达式的转化及计算，请见这篇文章 思路一 根据上面链接中的介绍，后缀表达式的计算需呀借助一个栈来进行，具体细节不再描述 12345678910111213141516171819202122def evalRPN(self, tokens: List[str]) -&gt; int: stack = [] operator = ['+', '-', '*', '/'] for c in tokens: # 操作数，入栈 if c not in operator: stack.append(c) # 操作符，取栈中两个数并计算，注意顺序 else: right = int(stack.pop()) left = int(stack.pop()) if c == '+': stack.append(left+right) elif c == '-': stack.append(left-right) elif c == '*': stack.append(left*right) elif c == '/': stack.append(left/right) return int(stack.pop())","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之目标和","slug":"Leetcode之目标和","date":"2020-04-13T08:32:53.000Z","updated":"2020-07-06T05:23:24.000Z","comments":true,"path":"passages/leetcode-zhi-mu-biao-he/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-mu-biao-he/","excerpt":"Target Sum","text":"Target Sum Target Sum code with Python title number：494 读题 给定一个非负整数数组a1, a2, ... an，和一个目标数S 现有两个符号+和-，对数组中的任意一个整数，你都可以从+和-中选择一个符号添加到整数前面 返回可以使最终数组和为目标数的所有添加符号的方法数 示例： 12345678输入：nums&#x3D;[1, 1, 1, 1, 1], S&#x3D;3输出：5解释：-1+1+1+1+1 &#x3D; 3+1-1+1+1+1 &#x3D; 3+1+1-1+1+1 &#x3D; 3+1+1+1-1+1 &#x3D; 3+1+1+1+1-1 &#x3D; 3 注意： 数组非空 数组和不超过1000 方法一 动态规划，我们使用之前介绍的闫式DP分析法分析该问题 首先我们分析一下，在枚举的情况下，每一个数的后面我们都有两种选择，所以集合的规模是$2^{n}$ 使用之前介绍的框架 状态表示 集合是什么：$f(i, j)$，前i个元素经过计算为j的所有情况的集合 属性：满足条件的序列个数 状态计算 由于每个位置只有两种选择（即+和-），所以我们可以以此来划分集合 集合可以划分为一下两部分，并根据最初对集合的定义分别得到两部分的表达式： 最后一个元素前放置+ 对于这种情况，已经确定最后一项是做加法，那么对于前i-1项的情况则变为：前i-1个元素经过计算为j-num[i]的集合 根据定义，表示为$f(i-1, j-nums[i])$ 最后一个元素前放置- 对于这种情况，已经确定最后一项是做减法，那么对于前i-1项的情况则变为：前i-1个元素经过计算为j+nums[i]的集合 根据定义，表示为$f(i-1, j+nums[i])$ 综合起来，$f(i, j) = f(i-1, j+nums[i]) + f(i-1, j-nums[i])$ 根据定义，所求即为$f(len(nums), S)$，即包含所有元素和为S的情况的数目 朴素版本的代码 123456789101112131415161718192021def findTargetSumWays(self, nums: List[int], S: int) -&gt; int: if len(nums) == 0: return 0 # S的范围至多是[-s, s+1] s = sum(nums) # 使用dict存储，&#123;i : j&#125; dp = [dict() for _ in range(len(nums))] if nums[0] == 0: # 加和减都可以 dp[0][nums[0]] = 2 else: # 加或减 dp[0][nums[0]] = 1 dp[0][-nums[0]] = 1 for i in range(1, length): for j in range(-s, s+1): dp[i][j] = dp[i-1].get(j-nums[i], 0) + dp[i-1].get(j+nums[i], 0) return dp[len(nums)-1].get(S, 0) 优化后的代码 由于$f(i)$只与$f(i-1)$有关，所以我们可以优化代码结构————只需存储$f(i-1)$即可 待实现","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"动态规划","slug":"动态规划","date":"2020-04-13T07:39:51.000Z","updated":"2020-07-23T01:11:23.000Z","comments":true,"path":"passages/dong-tai-gui-hua/","link":"","permalink":"http://zivblog.top/passages/dong-tai-gui-hua/","excerpt":"动态规划","text":"动态规划 前言 先挂两个链接，都是质量非常高的资料，本文也参考了其中的内容 动态规划 闫式DP分析法 借用严总的话来说，动态规划是一种基于经验的算法，了解了基本的算法思想后，需要接触各种类型的题目之后才能对与动态规划做到得心应手 下面给出的分析框架是对闫式DP分析法的总结 后面还会对各种类型DP问题结合经典题目进行分析（待施工） 动态规划 本分析法主要是给出一套分析的框架，不同与常见算法书上的刻板描述，这里给出的分析方法结合集合的概念协助分析流程更为平滑 首先，我们要明确的是动态规划问题都是有限集合的最优化问题（求最值，求数量，判断是否存在）。不过较为特殊的是，集合虽然是有限的，但是集合规模一般很大，使用枚举的方式必定是行不通的 分析过程 两个阶段 状态表示（一般用f(i)或f(i, j)等形式表示）（化零为整） 集合定义 该定义极为关键，贯穿整个问题分析的流程 比如01背包问题中，集合定义为：所有只考虑前n个物品且总体积不超过体积V的选法的集合 属性 一般要求题目要求求什么，属性就是什么 比如01背包问题中，属性就是集合中符合条件的的最大值 状态计算（化整为零） 寻找最后一个不同点（划分依据，即根据最后一个不同点对集合进行分类） 再对不同的子集进行表示，组合成为最终的动态规划表达式（状态转移公式） 要求状态计算过程中做到不重复和不遗漏。实际操作中，对不遗漏要求较高，在必要情况下可以重复（比如在求最值的情况下） 单单框架看下来比较抽象，可结合下面各种类型的动态规划题目进行巩固 另外，对于动态规划的所有优化都是针对代码时间复杂度或空间复杂度的优化（即对代码的等价变换），对于算法本身并不存在优化之说 经典题目分析线性DP 爬楼梯 乘积最大子数组 最长公共子序列 最长上升子序列 最大正方形 完全平方数 鸡蛋掉落 不同路径Ⅱ 最小路径和 分割回文串Ⅱ 编辑距离 打家劫舍系列 打家劫舍 股票问题系列 买股票的最佳时机 买股票的最佳时机Ⅱ 最佳买卖股票时机含冷冻期 区间DP 最长回文子序列 背包DP 目标和，01背包问题 标准01问题 标准完全背包问题 零钱兑换 零钱兑换Ⅱ 分割等和子集，变种01背包问题 树形DP Leetcode周赛-第二题-思路二 状态压缩DP 骑士拨号器 数位DP Leetcode周赛-第四题-思路二 计数型DP 待施工 递推型DP 三角形最小路径和 概率DP 待施工 博弈性DP 待施工 记忆化搜索 待施工","categories":[{"name":"算法","slug":"算法","permalink":"http://zivblog.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之二叉树的前序遍历","slug":"Leetcode之二叉树的前序遍历","date":"2020-04-13T03:08:16.000Z","updated":"2020-07-06T05:11:56.000Z","comments":true,"path":"passages/leetcode-zhi-er-cha-shu-de-qian-xu-bian-li/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-er-cha-shu-de-qian-xu-bian-li/","excerpt":"Binary Tree Preorder Traversal","text":"Binary Tree Preorder Traversal Binary Tree Preorder Traversal code with Python title number：144 读题 给定一棵二叉树，返回其按前序遍历得到的节点值列表 思路一 前面的二叉树的中序遍历和二叉树的层序遍历中都使用到了一种名为颜色标记法的方法，这里先用该方法解题 使用颜色标记结点的状态：新节点：白色；已访问结点：灰色 遇到白色结点，将其标记为灰色并将其右结点，左结点，自身（与前序恰好逆序，出栈后即为前序）入栈 遇到灰色结点，则输出结点值 12345678910111213141516def preorderTraversal(self, root: TreeNode) -&gt; List[int]: w, g = 0, 1 stack = [(root, w)] res = [] while stack: node, color = stack.pop() if node is None: continue if color == w: stack.append((node.right, w)) stack.append((node.left, w)) stack.append((node, g)) if color == g: res.append(node.val) return res 思路二 递归遍历，根-&gt;左-&gt;右 12345678910111213def preorderTraversal(self, root: TreeNode) -&gt; List[int]: res = [] def preorder(root): if root is None: return res.append(root.val) preorder(root.left) preorder(root.right) preorder(root) return res 思路三 迭代，借助栈 12345678910111213141516def preorderTraversal(self, root: TreeNode) -&gt; List[int]: res = [] stack = [root] # 辅助栈 if root is None: return [] while stack: node = stack.pop() res.append(node.val) # 入栈先右后左，出栈才是先左后右 if node.right: stack.append(node.right) if node.left: stack.append(node.left) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之单词拆分","slug":"Leetcode之单词拆分","date":"2020-04-12T06:39:39.000Z","updated":"2020-07-06T05:10:29.000Z","comments":true,"path":"passages/leetcode-zhi-dan-ci-chai-fen/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-dan-ci-chai-fen/","excerpt":"Word Break","text":"Word Break Word Break code with Python title number：139 读题 给定一个非空字符串S和一个包含非空单词列表的字典wordDict 判定S是否可以被空格拆分为一个或多个在字典中出现的单词 注意： 拆分时可以重复使用字典中的单词 拆分时不能重复使用字符串中的字符，即单词之间无交集 可以认为字典中不存在重复单词 思路一 我们使用了回溯法来解决分割回文串中的问题，这道题目虽然也是分割问题，但是与分割回文串还是存在区别的 首先，可划分的子串是确定的（在wordDict中） 其次，只需要判断是否可行，而不用列举所有可能 回溯法会重复计算有些位的可拆分情况，要解决该问题，可以使用记忆化回溯或者动态规划 下面先介绍记忆化回溯 所谓记忆化回溯，就是在回溯法的基础上，保存出现过的情况，避免重复计算，具体而言： 定义回溯函数back_track(s) 若S长度为0，则返回true，表示已经使用wordDict中的单词分割完 初始化当前字符串是否可以被分割res=False 遍历索引i，遍历区间为[1, n+1) 如果s[0:i-1]在wordDict中：res=back_track(s[i, n-1])或res（保存遍历结束索引中，可以使用字符串切割完成的情况） 返回res 1234567891011121314151617def wordBreak(self, s: str, wordDict: List[str]) -&gt; bool: import functools # 提升一个方法频繁用相同参数调用场景下的性能 @functools.lru_cache(None) def back_track(s): if not s: return True res = False for i in range(1, len(n+1)): if s[:i] in wordDict: # 做或运算 res = back_track(s[i:]) or res return res return back_track(s) 思路二 动态规划 定义数组dp[]，dp[i]表示字符子串s[0:i]可以在wordDict中找到 初始化，除dp[0]外全部初始化为False 这里建立的不是dp[i]和dp[i-1]的关系，而是dp[i]和dp[i-len(word)]的关系 终止，遍历完整个字符串 12345678910def wordBreak(self, s: str, wordDict: List[str]) -&gt; bool: dp = [False for _ in range(len(s)+1)] dp[0] = True # 第0个位置表示的是字符串中第一个字母前的位置 # 第一个位置是第一个字符后的位置 for i in range(1, len(s)+1): for word in wordDict: if dp[i-len(word)] &amp;&amp; len(word) &lt;= i: if s[i-len(word):i] == word: dp[i] = True return dp[len(s)] || False","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之分割回文串","slug":"Leetcode之分割回文串","date":"2020-04-11T02:59:18.000Z","updated":"2020-07-06T05:15:59.000Z","comments":true,"path":"passages/leetcode-zhi-fen-ge-hui-wen-chuan/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-fen-ge-hui-wen-chuan/","excerpt":"Palindrome Partitioning","text":"Palindrome Partitioning Palindrome Partitioning code with Python title number：131 读题 给定一个字符串S，将S分割成一些子串，使每个子串都是回文串 返回S的所有分割方案（每个方案存储在一个列表中） 示例： 123456输入：&quot;aab&quot;输出：[ [&#39;aa&#39;, &#39;b&#39;], [&#39;a&#39;, &#39;a&#39;, b]] 从示例中可以发现，分割方案中必定存在每个子串均为一个字符的结果 思路一 题目本质上是在求所有可能，即集合，可以使用回溯法 关于回溯法，已经做过多道类似的题目： 组合总和 组合总和Ⅱ 全排列 全排列Ⅱ 子集 子集Ⅱ 具体而言 不断切分字符串，并判断当前子串是否为回文串 若是，则继续切分其后面的子串 若否，则不再切分 直达整个字符串切分完毕，作为一种情况添加到结果集中 123456789101112131415def partition(self, s: str) -&gt; List[List[str]]: res = [] # tmp是当前回溯过程的一个结果 def helper(s, tmp): if not s: res.append(tmp) for i in range(1, len(s)+1): # 当前s为回文子串 if s[:i] == s[:i][::-1]: # 继续进行 helper(s[i:], tmp+[s[:i]]) helper(s, []) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之被围绕的区域","slug":"Leetcode之被围绕的区域","date":"2020-04-10T08:05:03.000Z","updated":"2020-07-06T05:09:01.000Z","comments":true,"path":"passages/leetcode-zhi-bei-wei-rao-de-qu-yu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-bei-wei-rao-de-qu-yu/","excerpt":"Surrounded Regions","text":"Surrounded Regions Surrounded Regions code with Python title number：130 读题 给定一个二维矩阵，包含X和O两种符号 找到所有被X围绕的区域，并将这些区域里所有的O全部用X填充 示例 1234[[X, X, X, X], [[X, X, X, X], [X, O, O, X], ----&gt; [X, X, X, X], [X, X, O, X], [X, X, X, X], [X, O, X, X]] [X, O, X, X]] 说明： 被围绕的区域不会存在于边界上，即边界上的O都不会被填充为X 任何不在边界上，不与边界上的O相连的O最终都会被填充为X 相连是指两个元素在水平或垂直方向上相邻 思路一 根据题意，我们需要将所有除边界上的O和与边界连通的O之外的所有O全部置为X 这涉及到二维数组的深度遍历（类似的题目见单词搜索） 并且为了方便操作，可以事先将所有位于边界上的O和与边界上O相连的O全部标记（比如使用A代替），然后在结束之后再改回来 所以这变成了一个寻找连通区域的问题，我们只需要找到与边界上O连通的O替换为A，最后将剩余的所有O都替换为X，将所有A替换为O即可 123456789101112131415161718192021222324252627282930313233343536def solve(self, board: List[List[str]]) -&gt; None: # 只有一行或者只有一列 if len(board) &lt;= 2 or len(board[0]) &lt;= 2: return row, col = len(board), len(board[0]) def dfs(i, j): # 深度搜索至边界 if i &lt; 0 or j &lt; 0 or i &gt;= row or j &gt;= col or board[i][j] != 'O': return # 替换 board[i][j] = 'A' # 继续遍历其邻接位置（四个方向） dfs(i, j - 1) dfs(i, j + 1) dfs(i - 1, j) dfs(i + 1, j) # 从边界开始， 标记 for i in range(row): # 从第一行和最后一行开始 dfs(i, 0) dfs(i, col - 1) for j in range(col): # 从第一列和最后一列开始 dfs(0, j) dfs(row - 1, j) for i in range(row): for j in range(col): if board[i][j] == 'O': board[i][j] = 'X' if board[i][j] == 'A': board[i][j] = 'O'","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之求根到叶子节点数字之和","slug":"Leetcode之求根到叶子节点数字之和","date":"2020-04-09T08:06:07.000Z","updated":"2020-07-06T05:24:30.000Z","comments":true,"path":"passages/leetcode-zhi-qiu-gen-dao-xie-zi-jie-dian-shu-zi-zhi-he/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-qiu-gen-dao-xie-zi-jie-dian-shu-zi-zhi-he/","excerpt":"Sum Root to Leaf Numbers","text":"Sum Root to Leaf Numbers Sum Root to Leaf Numbers code with Python title number：129 读题 给定一个二叉树，每个结点存放一个0~9之间的数字 每条从根到叶节点的路径表示一个数字 例如：从根到叶子结点路径1-&gt;2-&gt;3代表数字123 计算所有从根到叶子节点生成的数字之和 思路一 我们可以通过深度遍历得到每条路径，然后将其转化为数字，再求和。这是最直接的想法，但是这样的做法包含很多的冗余操作 可以发现，根据题意，路径长度每加一，之前得到的值就要乘十 所以我们可以直接在遍历的过程中计算该数值 具体而言： 深度遍历整棵树，每便利一层，则值为：当前节点值+10*之前的值 递归进行，在左右子树都为空时表示一条路径结束，将其添加到结果集中 12345678910111213141516171819202122def sumNumbers(self, root: TreeNode) -&gt; int: if root is None: return 0 def dfs(root, val, res): if root is None: return val = 10*val + root.val # 叶子节点，路径结束 if not root.left and not root.right: # 向res中添加截止前遍历过的路径之和 res.append(val+res[-1]) return # 递归 if root.left: dfs(root.left, val, res) if root.right: dfs(root.right, val, res) val = 0 res = [0] # res[-1]存储最终结果 dfs(root, val, res) return res[-1]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"nvidia-smi命令详解","slug":"nvidia-smi命令详解","date":"2020-04-08T13:32:01.000Z","updated":"2020-07-06T05:37:10.000Z","comments":true,"path":"passages/nvidia-smi-ming-ling-xiang-jie/","link":"","permalink":"http://zivblog.top/passages/nvidia-smi-ming-ling-xiang-jie/","excerpt":"nividi-smi","text":"nividi-smi 前言nvidia-smi使用来查看GPU的使用情况的 图片一 第一栏中fan参数的百分比值：表示的是风扇转速 第二栏中的Temp表示的是GPU的温度，单位为摄氏度 第三栏中的Perf表示的是性能状态，从p0~p12分别对应max~min 第四栏中的Pwr表示的是能耗，Persistence-M有两个值on/off是持续模式的状态 第五栏中的Bus-id是涉及GPU总线的东西 第六栏中的Memory-Usage表示显存占用 第八栏中的上方是关于ECC的东西 第八栏中下方Compute M是计算模式 图片二 分别显示每个进程对GPU的显存的使用率 注意显存占用和GPU占用并不相同 显卡有GPU和显存等组成，两者的关系类似内存和CPU的关系","categories":[{"name":"工具配置","slug":"工具配置","permalink":"http://zivblog.top/categories/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://zivblog.top/tags/Tools/"}]},{"title":"Leetcode之路径总和Ⅱ","slug":"Leetcode之路径总和Ⅱ","date":"2020-04-08T02:07:55.000Z","updated":"2020-07-06T05:22:24.000Z","comments":true,"path":"passages/leetcode-zhi-lu-jing-zong-he-ii/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-lu-jing-zong-he-ii/","excerpt":"Path Sum Ⅱ","text":"Path Sum Ⅱ Path Sum Ⅱ code with Python title number：113 读题 给定一棵二叉树，查找满足以下条件的路径 路径从根节点到叶子节点 路径总和等于给定目标和 思路一 回溯法 搜索所有路径，使用temp_path记录当前路径 在访问到叶节点时计算路径总和，若等于给定值则加入结果中 123456789101112131415161718def pathSum(self, root: TreeNode, sum: int) -&gt; List[List[int]]: res = [] if root is None: return [] def dfs(root, sum, temp): if root is None: return # 到达叶节点，并且路径总和等于给定值 if not root.left and not root.right and sum-root.val == 0: temp += [root.val] res.append(temp) return dfs(root.left, sum-root.val, temp+[root.val]) dfs(root.right, sum-root.val, temp+[root.val]) dfs(root, sum, []) return res 关于回溯法与深度优先搜索的区别，请参照回溯法","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之二叉树的锯齿形层次遍历","slug":"Leetcode之二叉树的锯齿形层次遍历","date":"2020-04-07T01:07:03.000Z","updated":"2020-07-06T05:11:46.000Z","comments":true,"path":"passages/leetcode-zhi-er-cha-shu-de-ju-chi-xing-ceng-ci-bian-li/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-er-cha-shu-de-ju-chi-xing-ceng-ci-bian-li/","excerpt":"Binary Tree Zigzag Level Order Traversal","text":"Binary Tree Zigzag Level Order Traversal Binary Tree Zigzag Level Order Traversal code with Python title number：103 读题 给定一个二叉树，返回起结点值的锯齿形层次遍历 即先从左往右，再从右往左进行下一层次遍历，一次类推，层与层之间交替进行 示例： 其锯齿形层次遍历为：[[3], [20, 9], [15, 7]] 思路一 按照二叉树的层序遍历的方法，求得正常情况下的层序遍历结果 再对结果进行后处理，即每隔一层逆置原来的遍历结果 1234567891011121314151617181920212223242526def zigzagLevelOrder(self, root: TreeNode) -&gt; List[List[int]]: if root is None: return [] queue = [root] res = [] # 得到常规的层序遍历结果 while queue: len_ = len(queue) res.append([]) for i in range(len_): node = queue.pop(0) if node.left: queue.append(node.left) if node.right: queue.append(node.right) res[-1].append(node.val) # 调整 tag = False for i in range(len(res)): if tag: res[i] = res[i][::-1] tag = False else: tag = True return res 思路二 上面的思路中进行后调整的做法，会额外的遍历一个结果集，并且需要对其中一半的层进行逆置，额外花费的很多时间 这里我们选择在存储一层结点的时候就按照正向或逆向方式存储，设置一个属性tag用于表示当前层是正向存储还是逆向存储 1234567891011121314151617def zigzagLevelOrder(self, root: TreeNode) -&gt; List[List[int]]: if root is None: return [] queue, res = [root], [] tag = 0 # 表示当前层正向or逆向存储 while queue: res.append([]) for i in range(len(queue)): node = queue.pop(0) if node.left: queue.append(node.left) if node.right: queue.append(node.right) # 正序 or 逆序 if tag % 2 ! = 0: res[-1].insert(0, node.val) else: res[-1].append(node.val) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之二叉树的层序遍历","slug":"Leetcode之二叉树的层序遍历","date":"2020-04-06T07:15:56.000Z","updated":"2020-07-06T05:11:29.000Z","comments":true,"path":"passages/leetcode-zhi-er-cha-shu-de-ceng-xu-bian-li/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-er-cha-shu-de-ceng-xu-bian-li/","excerpt":"Binary Tree Level Order Traversal","text":"Binary Tree Level Order Traversal Binary Tree Level Order Traversal code with Python title number：102 读题 给定一个二叉树，返回按层序遍历得到的结点值 返回的结果为嵌套列表，即每层的节点值分别用一个列表存储 层序遍历：即逐层的，从左往右访问所有节点 思路一 层序遍历一棵树是树的基本操作，操作过程相当于BFS 利用以个队列来存储节点 每次遍历完一层之后判断当前队列中的结点数目（即下一层的结点数，出队该数量的结点，避免判断队列是否为空） 具体操作： 根节点入队 判断当前队列中有多少结点，一次出队并访问 判断其左右子树是否分别存在，存在则入队 1234567891011121314151617def levelOrder(self, root: TreeNode) -&gt; List[List[int]]: if not root: return [] queue = [root] res = [] while queue: # 当前层长度 len_ = len(queue) res.append([]) for i in range(len_): node = queue.pop(0) res[-1].append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return res 思路二 递归 递归访问所有节点，对其左右子树也进行迭代访问 增加一个depth属性，用于标记结点所在的层数 将结点添加到其对应层的列表中 123456789101112def levelOrder(self, root: TreeNode) -&gt; List[List[int]]: res = [] def helper(root, depth): if not root: return if len(res) == depth: res.append([]) res[depth].append(root.val) helper(root.left, depth + 1) helper(root.right, depth + 1) helper(root, 0) return res 思路三 之前在二叉树的中序遍历提到过的颜色标记法，具体思路可看前文 在层序遍历中，需要加一个level属性用于标记层次 1234567891011121314151617def levelOrder(self, root: TreeNode) -&gt; List[List[int]]: w, g = 0, 1 stack = [(root, w, 0)] res = [] while stack: node, color, level = stack.pop() if node: # 结点未访问 if color == w: stack.append((node.right, w, level+1)) stack.append((node.left, w, level+1)) stack.append((node, g, level)) else: if len(res) == level: res.append([]) res[level].append(node.val) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之验证二叉搜索树","slug":"Leetcode之验证二叉搜索树","date":"2020-04-05T07:38:40.000Z","updated":"2020-07-06T05:29:54.000Z","comments":true,"path":"passages/leetcode-zhi-yan-zheng-er-cha-sou-suo-shu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-yan-zheng-er-cha-sou-suo-shu/","excerpt":"Validate Binary Search Tree","text":"Validate Binary Search Tree Validate Binary Search Tree code with Python title number：098 读题 给定一个二叉搜索树，判断其是否是一个有效的二叉搜索树 二叉搜索树特征如下： 节点的左子树只包含小于当前节点的数 节点的右子树只包含大于当前节点的数 所有左子树和右子树自身也必须是二叉搜索树 思路一 根据二叉搜索树的性质，如果我们进行中序遍历，得到的应该是一个升序序列 因此，我们只需进行一次中序遍历，再对遍历得到的序列进行一次遍历 如果存在相邻的两个元素为逆序，则不是二叉搜索树 否则，是二叉搜索树 这个算法的主要优化点在遍历算法，可以尝试时间复杂度更低的，关于中序遍历，可以看这道题的解法 123456789101112131415161718192021def isValidBST(self, root: TreeNode) -&gt; bool: if root is None: return True if root.left is None and root.right is None: return True # 中序遍历 res = [] def inorder(root): if root is None: return inorder(root.left) res.append(root.val) inorder(root.right) inorder(root) # 判断是否有逆序对 for i in range(len(res)-1): if res[i] &gt;= res[i+1]: return False return True 思路二 最大最小值法 由一个点的最大最小值来判断一个结点是否合法 从根节点进行DFS，然后计算每个节点应该的取值范围，如果当前节点不符合就返回 false 例如， 左孩子的范围由父节点的左边界和父节点的值确定 右孩子的范围由父节点的值和父节点的右边界确定 12345678910def isValidBST(self, root: TreeNode): def ds(root, min_, max_): if root is None: return True if root.val &lt;= min_ or root.val &gt;= max_: return False return ds(root.left, min_, root.val) and ds(root.right, root.val, max_) return ds(root, float('-inf'), float(\"inf\"))","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之不同的二叉搜索树","slug":"Leetcode之不同的二叉搜索树","date":"2020-04-04T12:17:58.000Z","updated":"2020-07-06T05:09:09.000Z","comments":true,"path":"passages/leetcode-zhi-bu-tong-de-er-cha-sou-suo-shu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-bu-tong-de-er-cha-sou-suo-shu/","excerpt":"Unique Binary Search Trees","text":"Unique Binary Search Trees Unique Binary Search Trees code with Python title number：096 读题 给定一个整数n，求以1~n为节点组成的二叉搜索树有多少种 示例： 输入：3 输出：5 具体而言： 该题是不同的二叉搜索树Ⅱ的简化版，详细的思路讲解请看这里 思路一 动态规划 定义dp[i]表示i个结点可以有多少种不同结构的二叉树 初始化dp[1]=1 状态转移方程：dp[n]=dp[0]*dp[n-1] + dp[1]*dp[n-2] + dp[n-1]*dp[0] 12345678910def numTrees(self, n): dp = [1]*(n+1) i = 2 while i &lt;= n: res = 0 for j in range(0): res += dp[j] * dp[i-j-1] dp[i] = res i += 1 return dp[n]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之不同的二叉搜索树Ⅱ","slug":"Leetcode之不同的二叉搜索树Ⅱ","date":"2020-04-03T06:14:30.000Z","updated":"2020-07-06T05:09:22.000Z","comments":true,"path":"passages/leetcode-zhi-bu-tong-de-er-cha-sou-suo-shu-ii/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-bu-tong-de-er-cha-sou-suo-shu-ii/","excerpt":"Unique Binary Search Trees Ⅱ","text":"Unique Binary Search Trees Ⅱ Unique Binary Search Trees Ⅱ code with Python title number：095 读题 给定一个整数，生成由1, ..., n为结点的二叉搜索树 示例: 12345678910输入：3输出：[ [1, null, 3, 2], [3, 2, null, 1], [3, 1, null, null, 2], [2, 1, 3], [1, null, 2, null, 3]] 对应于以下五种不同结构的二叉搜索树 思路一 首先，我们要了解二叉搜索树的一个比较好的性质，即在左右子树不为空时： 左子树中的值均小于根节点的值 右子树中的值均大于根节点的值 根据二叉树的性质，我们可以使用递归的方式来构建二叉搜索树 遍历列表1, ...,n，尝试将每一个结点作为根节点，其左边的子列表作为左子树，右边的自列表作为右子树 对左右子树进行同样的处理 至列表只剩一个数或列表为空 例如：把 1 作为根节点，[ ] 空作为左子树，[ 2 … n ] 的所有可能作为右子树；2 作为根节点，[ 1 ] 作为左子树，[ 3…n ] 的所有可能作为右子树 123456789101112131415161718192021222324def generateTrees(self, n: int) -&gt; List[TreeNode]: # n为0 if n == 0: return [] def getAns(start, end): ans = [] # 子列表为空格 if start &gt; end: return [None] # 遍历列表，尝试将每个元素都作为根结点 for i in range(start, end+1): left_tree = getAns(start, i-1) right_tree = getAns(i+1, end) for node_l in left_tree: for node_r in right_node: root = TreeNode(i) root.left = node_l root.right = node_r ans.append(root) return ans return getAns(1, n) 思路二 其实还可以用动态规划解决 定义dp[i][j]表示第i~j个数字的所有可能情况，所以dp[1][n]即为结果集 初始化：若i==j则添加结点val，i&gt;j初始化为空列表，其他情况初始化为[None] 状态转移方程，dp[i][j] = dp[i+1][j]+...dp[j[j]]（i~j之间每个值为顶点的情况之和） 12345678910111213141516171819202122232425262728293031323334def generateTrees(self, n: int) -&gt; List[TreeNode]: if n == 0: return [] dp = [] # 初始化dp数组 for i in range(0, n+1): dp.append([]) for j in range(0, n+1): if i == j: dp[i].append([TreeNode(i)]) elif i &lt; j: dp[i].append([]) else: dp[i].append([None]) dp[0][0] = [None] # 反向遍历 for i in range(n-1, 0, -1): for j in range(i+1, n+1): # i~j每个结点为顶点的情况 for r in range(i, j+1): # 边界判断 left = r+1 if r &lt; j else r # 左右子树的排列组合 for x in dp[i][r-1]: for y in dp[left][j]： node = TreeNode(r) node.left = x node.right = y if r == j: node.right = None # 添加结果 dp[i][j].append(node) return dp[1][n]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之二叉树的中序遍历","slug":"Leetcode之二叉树的中序遍历","date":"2020-04-02T01:29:58.000Z","updated":"2020-07-06T05:12:14.000Z","comments":true,"path":"passages/leetcode-zhi-er-cha-shu-de-zhong-xu-bian-li/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-er-cha-shu-de-zhong-xu-bian-li/","excerpt":"Binary Tree Inorder Traversal","text":"Binary Tree Inorder Traversal Binary Tree Inorder Traversal code with Python title number：094 读题 给定一个二叉树，返回按照中序遍历得到的结点序列 二叉树结点 12345class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None 请尝试使用迭代的方式解决该问题 思路一 递归遍历，左-&gt;根-&gt;右 123456789101112def inorderTraversal(self, root: TreeNode) -&gt; List[int]: res = [] def inorder(root): if root is None: return inorder(root.left) res.append(root.val) inorder(root.right) inorder(root) return res 思路二 鉴于递归效率会比较低，现使用迭代（借助栈）解决 使用栈存储结点 1234567891011121314151617def inorderTraversal(self, root: TreeNode) -&gt; List[int]: res = [] stack = [] # 辅助栈 p = root # 指针 # p或栈为空时 while p or stack: # 左子树不断入栈 while p: stack.append(p) p = p.left p = stack.pop() res.append(p.val) # 访问右子树 p = p.right return res 思路三 在题解中看到了一种比较有趣的方法，作者为其取名颜色标记法 使用颜色标记结点的状态：新结点：白色；已访问结点：灰色。 遇到白色结点，将其标记为灰色并将其右结点，自身，左结点入栈（顺序与中序遍历恰好相反，在出栈时即为中序） 遇到灰色结点，则输出结点 123456789101112131415def inorderTraversal(self, root: TreeNode) -&gt; List[int]: w, g = 0, 1 # 白色&amp;灰色 res = [] stack = [(w, root)] while stack: color, node = stack.pop() if node is None: continue if color == w: stack.append((w, node.right)) stack.append((g, node)) stack.append((w, node.left)) else: res.append(node.val) return res 事实上，这种方法能推广到前序，后续，区别在于调整入栈时的顺序即可","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之反转链表Ⅱ","slug":"Leetcode之反转链表Ⅱ","date":"2020-04-01T02:03:53.000Z","updated":"2020-07-06T05:13:58.000Z","comments":true,"path":"passages/leetcode-zhi-fan-zhuan-lian-biao-ii/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-fan-zhuan-lian-biao-ii/","excerpt":"Reverse Linked List Ⅱ","text":"Reverse Linked List Ⅱ Reverse Linked List Ⅱ code with Python title number：092 读题 给定一个链表和两个值表示链表中的两个位置 反转两个位置之间的链表 请使用一趟扫描完成反转 示例： 输入：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; null, m=2, n=4 输出：1 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; null 思路一 题目要求只能进行一趟扫描，主要的解题思路是： 反转中间部分，再与其余两端不变的部分进行拼接 参照上方的示例， 对位置2~4之间的链表进行反转 再将1和5两段拼接上去 两个关键位置，即1和5需要用指针记下来 注意不能直接返回head，当m=1时会出错，所以需要设置一个虚拟节点指向head 123456789101112131415161718192021222324252627282930313233343536def reverseBetween(self, head: ListNode, m: int, n: int): if m == n: return head first = ListNode(0) first.next = head # 记录拼接点 before_m, after_n = first, None # 记录反转后的链表 between_mn_head, between_mn_end = None, None index = 0 cur_node = first while index &lt; n: index += 1 cur_node == cur_node.next # 找到位置m if index == m-1: before_m = cur_node elif index == m: # 当前的头是反转后的尾 between_mn_end = ListNode(cur_node.val) between_mn_head = between_mn_end elif index &gt; m: # 需要反转的子链表 temp = between_mn_head between_mn_head = ListNode(cur_node.val) between_mn_head.next = temp if index == n: after_n = cur_node.next # 拼接 between_mn_end.next = after_n before_m.next = between_mn_head return first.next 思路二 2020.6.27更新 对比上面的方法，该方法不需要记录区间的前后两个位置 通过不断向区间的前驱位置插入节点的方式进行反转 通过循环遍历区间内部的节点 123456789101112131415161718192021222324252627282930def reverseBetween(self, head: ListNode, m: int, n: int): ''' 由于第一个节点也可能在区间内部，所以需要使用dummy节点 定位到指定区间位置 的 前一个位置 不断将后面的节点插入到区间前去节点的后面 ''' dummy_node = TreeNode(0) dummy_node.next = head pre = dummy_node # 找到区间的前驱节点 for i in ragne(1, n): pre = pre.next # 交换区间的头部，会更新 part_head = pre.next # 交换区间的初始头部 head_ = pre.next for i in range(m, n): temp = head_.next pre.next = temp.next head_.next = part_head temp.next = part_head # 更新头部 part_head = temp return dummy_node.next","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之解码方法","slug":"Leetcode之解码方法","date":"2020-03-31T08:19:36.000Z","updated":"2020-07-06T05:19:04.000Z","comments":true,"path":"passages/leetcode-zhi-jie-ma-fang-fa/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-jie-ma-fang-fa/","excerpt":"Decode Ways","text":"Decode Ways Decode Ways code with Python title number：091 读题 一条包含字母A~Z的消息通过一下方式进行编码： A-&gt; 1 B -&gt; 2 … Z -&gt; 26 给定一个只包含数字的非空字符串，计算该字符串的解码方法总数 思路一 小朋友，不知道你是否联想到了爬楼梯问题 显然，这是一道动态规划的题目 分析一下： 我们可能的编码一共有26种，可以分为两类： 1~9的一个数字的情况 10~26的两个数字的情况 划分子问题 当前元素位一种可能 当前元素与前一个元素是否组成范围内（10~26）的两位数 dp[i]表示到第i个位置时可能的解码方法总数 初始化：dp[0]=0, dp[1]=1 状态转移方程：dp[i] = dp[i-1]+dp[i-2] ，即最后两个一起解码or单独一个解码 结束条件：i == len(nums)-1，即数组被遍历完 注意： 当字符串以0开头时是无法解码的 当字符串以大于2的数组开头时是无法解码的 当前两位大于26时是无法解码的 在字符串中间碰到0的时候要判断前一位是否为1或2，否则返回0 1234567891011121314151617181920212223242526272829def numDecodings(self, s: str) -&gt; int: if s[0] == '0': return 0 if len(s) == 1: return 1 dp = [1] for i in range(1, len(s)): if s[i] == '0': # 30以上 if s[i-1] != '1' and s[i-1] != '2': return 0 else: if i == 1: dp.append(1) else: dp.append(dp[i-2]) continue # 10~19 if s[i-1] == '1': dp.append(dp[i-2]+dp[i-1]) # 20~26 elif s[i-1] == '2' and s[i] &gt;= '1' and s[i]&lt;='6': dp.append(dp[i-1]+dp[i-2]) # 1~9 else: dp.append(dp[i-1]) return dp[-1]","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之子集Ⅱ","slug":"Leetcode之子集Ⅱ","date":"2020-03-30T05:02:41.000Z","updated":"2020-07-06T05:32:28.000Z","comments":true,"path":"passages/leetcode-zhi-zi-ji-ii/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zi-ji-ii/","excerpt":"Subset Ⅱ","text":"Subset Ⅱ Subset Ⅱ code with Python title number：090 读题 给定一个可能包含重复元素的整数数组，返回该数组包含的所有可能的子集 结果中不能包含重复的子集 题目理解 输入中包含重复元素，而结果不允许有重复元素，根据之前的题目的经验，我们对数组进行排序，目的是将所有相同的元素聚集到一起，以便于进行去重操作 这是一道进阶版的递归or回溯的题目，下面的几种思路均基于递归 思路一 子集的最大长度即数组的长度，对于子集中每个位置枚举所有可能 以示例[1, 2, 2]为例，见下图 见上图，由空集出发，每一条子路径代表一个解，并且我们要对包含的重复项进行去重操作 1234567891011121314151617def subsetsWithDup(self, nums: List[int]) -&gt; List[List[int]]: nums.sort() n = len(nums) def dfs(i, tmp): res.append(tmp) if i == n: return for j in range(i, n): if j &gt; i and nums[j] == nums[j-1]: continue dfs(j+1, tmp+[nums[j]]) res = [] dfs(0, []) return res 思路二 对数组中每个位置有两种操作：选择 or 不选择，以此构建树型结构 以示例[1, 2, 2]为例，见下图 见上图，由空集出发，这次我们只需要从叶节点中挑选（去除重复）结果即可 12345678910111213141516def subsetsWithDup(self, nums: List[int]) -&gt; List[List[int]]: nums.sort() n = len(nums) res = [[]] pre = [] # 保存重复数字对应的子集 for i in range(n): # 重复元素 if i &gt; 0 and nums[i]==nums[i-1]: pre = [tmp+[nums[i]] for tmp in pre] else: pre = [tmp+[nums[i]] for tmp in res] res += pre return res 思路三 对于数组中的每一个值（可能有多个相同值的元素），列举每个值的所有可能，构建树型结构 以示例[1, 2, 2]为例，见下图 见上图， 元素1有两种可能，即选0个或1个 元素2有三种可能，即选0个或1个或2个 所有的结果都在叶节点中，而且不包含重复项，即只需返回所有叶节点的集合即可 具体而言，我们可以先统计每个元素的个数，然后进行组合即可 1234567891011121314151617from copy import copydef subsetsWithDup(self, nums: List[int]) -&gt; List[List[int]]: dict = &#123;&#125; for i in nums: if i not in dict: dict[i] = 1 else: dict[i] += 1 res = [[]] for i, v in dict.items(): tmp = res.copy() for j in res: for k in range(v): tmp.append(j+[i]*(k+1)) res = tmp return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之分割链表","slug":"Leetcode之分割链表","date":"2020-03-29T12:11:16.000Z","updated":"2020-07-06T05:16:06.000Z","comments":true,"path":"passages/leetcode-zhi-fen-ge-lian-biao/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-fen-ge-lian-biao/","excerpt":"Partition List","text":"Partition List Partition List code with Python title number：086 读题 给定一个链表和一个特定值x 对链表进行分割，使得所有小于x的结点都在大于或等于x的结点之前 保留两个分区中每个结点的初始相对位置 示例 输入：head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3 输出：1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5 题目理解 值得注意的是，题目的要求并不是用给定元素来将链表分割为前小后大的两部分 而是将所有小于给定值的元素移动到大于等于给定元素的前面。即只需要将小于的部分移动到链表的头部即可，并且不能改变相对位置 思路一 因为要求相对位置不能改变，所以不能通过交换链表中结点的值来完成该要求 设置两个虚拟节点head1, head2（使用两个链表），将小于给定值的结点链接到head1后，将大于等与给定值的结点链接到head2后 最后将两个链表二放到链表一之后 注意将链表二最后一个结点的next置为None 123456789101112131415def partition(self, head: ListNode, x: int) -&gt; ListNode: head1 = ListNode(-1) head2 = ListNode(-1) cur = head cur1, cur2 = head1, head2 while cur is not None: if cur.val &lt; x: cur1.next = cur else: cur2.next = cur cur2.next = None cur1.next = head2.next return head1.next","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之删除排序数组中的重复项Ⅱ","slug":"Leetcode之删除排序数组中的重复项Ⅱ","date":"2020-03-28T05:22:35.000Z","updated":"2020-07-06T05:26:00.000Z","comments":true,"path":"passages/leetcode-zhi-shan-chu-pai-xu-shu-zu-zhong-de-chong-fu-xiang-ii/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-shan-chu-pai-xu-shu-zu-zhong-de-chong-fu-xiang-ii/","excerpt":"Remove Duplicates from Sorted Array","text":"Remove Duplicates from Sorted Array Remove Duplicates from Sorted Array code with Python title number：080 读题 给定一个排序数组，原地删除重复出现的元素，使得每个元素最多出现两次（多于2个的，删除到剩2个，不足2个的不予删除） 返回移除后数组的新长度 示例： nums = [1, 1, 1, 2, 2, 3] 函数应返回新长度5，并返回原数组的前五个元素为：1, 1, 2, 2, 3 无需考虑数组中超出新长度后面的元素 思路一 由于是排序之后的数组，所以相同的元素必定出现在一起 直接对数组中重复次数多于2的元素删除多余项 使用单指针，用于遍历 使用一个计数变量count记录当前项的重复次数 注意：直接在数组上删除了元素会导致数组长度变化，从而带来访问越界的问题。所以在每次删除元素之后要使i-- 12345678910111213141516def removeDuplicates(self, nums: List[int]) -&gt; int: # 直接原地删除重复元素 i, count = 1, 1 while i &lt; len(nums): if nums[i] == nums[i-1]: count += 1 if count &gt; 2: nums.pop(i) # 防止数组越界 i -= 1 else: # 新元素，重新计数 count = 1 return len(nums) 思路二 覆盖重复元素，便利列表，将符合数目要求个数的元素依次放到数组头部位置 使用双指针，i用于遍历数组，j用于指示最终符合条件子数组的尾部 使用计数变量count记录当前项的个数 返回j 并没有修改数组长度，只是使用符合条件的子数组覆盖掉了数组中的内容 123456789101112def removeDuplicates(self, nums: List[int]) -&gt; int: j, count = 1, 1 for i in range(1, len(nums)): if nums[i] == nums[i-1]: count += 1 else: count = 1 if count &lt;= 2: nums[j] = nums[i] j += 1 return j","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之单词搜索","slug":"Leetcode之单词搜索","date":"2020-03-27T08:59:38.000Z","updated":"2020-07-06T05:10:45.000Z","comments":true,"path":"passages/leetcode-zhi-dan-ci-sou-suo/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-dan-ci-sou-suo/","excerpt":"Word Search","text":"Word Search Word Search code with Python title number：079 读题 给定一个二维网格和一个单词，判断该单词是否存在与网格中 所谓存在于网格中，即需要使用网格中相邻字母组成单词（上下相邻或左右相邻） 字母不允许被重复使用 思路一 DFS 首先应该明确，所谓相邻可以是左右相邻，也可以是上下相邻。并且这种相邻是双向的，也就是可以是从左到右，也可以是从右到左 其次，要明确符合单词首个单词的位置并非只有一个，所以要用一个双循环来查找所有的起始可能 再次，避免字母被重复使用，进行一次遍历，对使用过的字母进行mask操作，在进行完当前深度搜索之后再恢复 1234567891011121314151617181920212223242526def exist(self, board: List[List[str]], word: str) -&gt; bool: # 找到start point for i in range(len(board)): for j in range(len(board[0])): if self.helper(board, i, j, word, 0): return True return False def helper(self, board, i, j, word, wordIndex): # 能够找到整个单词 if wordIndex == len(word): return True if i &lt; 0 or i &gt;= len(board) or j &lt; 0 or j &gt;= len(board[0]) or board[i][j] != word[wordIndex]: return False # mask当前位置的元素，防止重复使用 board[i][j] = '#' found = self.helper(board, i+1, j, word, wordIndex+1)\\ or self.helper(board, i, j+1, word, wordIndex+1)\\ or self.helper(board, i-1, j, word, wordIndex+1)\\ or self.helper(board, i, j-1, word, wordIndex+1) board[i][j] = word[wordIndex] return found","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之子集","slug":"Leetcode之子集","date":"2020-03-26T01:21:16.000Z","updated":"2020-07-06T05:32:21.000Z","comments":true,"path":"passages/leetcode-zhi-zi-ji/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zi-ji/","excerpt":"Subsets","text":"Subsets Subsets code with Python title number：078 读题 给定一组不含重复元素的整数数组，返回该数组所有的子集 空集是任何集合的子集 思路一 求集合，而非求极值，所以我们选择回溯法而不是动态规划 1234567891011def subsets(self, nums: List[int]) -&gt; List[List[int]]: res = [] length = len(nums) def backtrack(i, temp): res.append(temp) for j in range(i, length): backtrack(j+1, temp+[nums[j]]) backtrack(0, []) return res 思路二 在评论区看到了一个比较有意思的解法 从后往前遍历，每遍历一个数，就将这个数加到当前结果集中所有已得子集上，组成新的子集 123456789def Subsets(self, nums: List[int]) -&gt; List[List[int]]: res = [[]] # 反向遍历 for i in range(len(nums)-1, -1, -1): for sub in res[:]: res.append(sub+[nums[i]]) return res 事实证明，正向遍历也是可以的 123456789def Subsets(self, nums: List[int]) -&gt; List[List[int]]: res = [[]] # 反向遍历 for i in range(len(nums)): for sub in res[:]: res.append(sub+[nums[i]]) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之颜色分类","slug":"Leetcode之颜色分类","date":"2020-03-25T01:38:07.000Z","updated":"2020-07-06T05:29:47.000Z","comments":true,"path":"passages/leetcode-zhi-yan-se-fen-lei/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-yan-se-fen-lei/","excerpt":"Sort Colors","text":"Sort Colors Sort Colors code with Python title number：075 读题 给定一个包含红、白、蓝三种颜色，一共n个元素的数组，对其进行原地排序 使得相同颜色的元素相邻，并且按照红、白、蓝的顺序排列 使用0、1、2表示三种颜色 思路一 比较直接的想法是，遍历数组，统计0,1,2的个数分别为nums1, nums2, nums3 再次遍历数组，将数组中的元素按照每一种颜色的个数重置 数组需要遍历两遍 1234567891011121314151617def sortColors(self, nums: List[int]) -&gt; None: r, w, b = 0, 0 , 0 for i in range(len(nums)): if nums[i] == 0: r += 1 elif nums[i] == 1: w += 1 else: b += 1 for i in range(r): nums[i] = 0 for i in range(r, r+w): nums[i] = 1 for i in range(r+w, r+w+b): nums[i] = 2 思路二 本题其实就是比较经典的荷兰国旗问题 对于这种问题，我们使用三指针解决，只需遍历数组一遍 将数组分为三部分，只需将两侧的两部分排好序，中间部分自然就排好了 指针cur用于遍历数组，指针pre用于标识第一部分的尾部位置，指针tail用于标识第三部分的头部位置 事实上都无需将所有元素都遍历一遍，当cur和tail相遇之后，即可停止了 12345678910111213def sortColors(self, nums: List[int]) -&gt; None: cur, pre, tail = 0, 0, len(nums)-1 while cur &lt;= tail: if nums[cur] == 0: nums[cur], nums[pre] = nums[pre], nums[cur] pre += 1 cur += 1 elif nums[cur] == 2: nums[cur], nums[tail] = nums[tail], nums[cur] tail -= 1 else: cur += 1","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之矩阵置零","slug":"Leetcode之矩阵置零","date":"2020-03-24T04:09:16.000Z","updated":"2020-07-06T05:19:12.000Z","comments":true,"path":"passages/leetcode-zhi-ju-zhen-zhi-ling/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-ju-zhen-zhi-ling/","excerpt":"Set Matrix Zeroes","text":"Set Matrix Zeroes Set Matrix Zeroes code with Python title number：073 读题 给定一个m*n的矩阵，如果一个元素为0，则将其所在的行和列的所有元素都设为0 请使用原地算法 思路一 最先想到的是暴力解决的方法 即遍历整个矩阵，记录为0的元素的行号和列号（这需要使用m+n的额外空间） 再次遍历矩阵，判断当前元素是否与元素0同行或同列，若是，则置为0 如果使用set来存储为0元素的行列号，可以在矩阵不止一个0的时候省去一点空间 由于要求使用原地算法，这种方法不提倡使用 12345678910111213def setZeroes(self, matrix: List[List[int]]) -&gt; None: rows, cols = set(), set() for i in range(len(matrix)): for j in range(len(matrix[0])): if matrix[i][j] == 0: rows.add(i) cols.add(j) for i in range(len(matrix)): for j in range(len(matrix[0])): if i in rows or j in cols: matrix[i][j] = 0 居然通过了，⊙﹏⊙b汗 思路二 这次仍是两次双循环遍历，不过省去了额外的空间 遍历矩阵，对于为0的元素，我们将其所在行、列的非零元素设置为一个很小的数 再次遍历矩阵，将所有等于我们设置的“很小的数”的元素全部置为0 注意并不提倡直接对非0元素直接置零，这样会带来很多次额外的行列遍历 1234567891011121314def setZeroes(self, matrix: List[List[int]]) -&gt; None: modify = -1000000 for i in range(len(matrix)): for j in range(len(matrix[0])): if matrix[i][j] == 0: for k in range(len(matrix[0])): matrix[i][k] = modify if matrix[i][k]!=0 else 0 for k in range(len(matrix)): matrix[k][j] = modify if matrix[i][k] !=0 else 0 for i in range(len(matrix)): for j in range(len(matrix[0])): if matrix[i][j] == modify: matrix[i][j] = 0 思路三 思路二虽然减少了空间的使用，虽然一定程度上减少了遍历的次数，但是还是会在当同一行或列中存在多个0的时候进行多次遍历 改进思路如下： 我们仅使用当前的行或列的第一个元素来表示该行或该列是否需要置0 由于第一行和第一列的标记重叠，所以需要一个额外的标记来表示第一列是否需要置0。同时第一行和第一列需要单独处理 这样，我们就将第一行和第一列用来完成思路一中的功能 最后，遍历第一行和第一列就可以完成矩阵的置零 1234567891011121314151617181920212223242526def setZeroes(self, matrix: List[List[int]]) -&gt; None: # 表示第一列是否置零 is_col = False # 判断第一列是否需要置零 for i in range(len(matrix)): if matrix[i][0] == 0: is_col = True # 第二列开始 for j in range(1, len(matrix[0])): if matrix[i][j] == 0: matrix[i][0] = 0 matrix[0][j] = 0 # 遍历第一行第一列 for i in range(1, len(matrix)): for j in range(1, len(matrix[0])): if not matrix[i][0] or not matrix[0][j]: matrix[i][j] = 0 # 第一行置0 if matrix[0][0] == 0: for j in range(len(matrix[0])): matrix[0][j] = 0 # 第一列置零 if is_col: for i in range(len(matrix)): matrix[i][0] = 0 代码比较长，但是时间复杂度很低（几乎没有重复操作）","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之不同路径","slug":"Leetcode之不同路径","date":"2020-03-23T05:07:29.000Z","updated":"2020-07-06T05:09:31.000Z","comments":true,"path":"passages/leetcode-zhi-bu-tong-lu-jing/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-bu-tong-lu-jing/","excerpt":"Unique Path","text":"Unique Path Unique Path code with Python title number：062 读题 一个机器人位于一个m*n的网格的左上角，机器人每次只能向下或向右移动一格 机器人视图到达网格的右下角，计算有多少种不同的路径 思路一 这是一道典型的动态规划题目（与爬楼梯相同的解题思路） 按照动态规划的分析思路 定义：dp[i][j]表示从起点到作为为[i, j]的位置最多的路径数 初始状态：dp[0][j]和dp[i][0]位于边界，均为1 状态转移方程：dp[i][j] = dp[i-1][j]+dp[i][j-1]，只能来自上面或左边 结束条件：i==m and j==n 1234567def uniquePaths(self, m: int, n:int) -&gt; int: dp = [[1]*n for _ in range(m)] for i in range(m-1): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[-1][-1] 代码优化 前面使用二维数组来表示到达一个位置的路径数，即当前位置的路径数=上方一格的路径数+左边一格的路径数 换个角度，使用一维数组表示，计算一行的数据的时候，直接将上一行搬下来，每一格子的数据等于其本身加上前一个格子的数据（本身其实就是位于其上方的数据） 1234567def uniquePaths(self, m: int, n: int) -&gt; int: dp = [1]*n for _ in range(1, m): for j in range(1, n): dp[j] += dp[j-1] return dp[n-1] 思路二 通过分析我们可以得出，向下移动和向右移动的次数是一定的，分别为m-1和n-1 所以，这变成了一个组合数学的题目，组合问题，C(n-1, m+n-2) 实现该公式的计算即可 123456789def uniquePaths(self, m: int, n: int) -&gt; int: a = b = 1 for i in range(1, n)； a += i for i in range(m, m+n-1): b *= i return b // a","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之第k个排列","slug":"Leetcode之第k个排列","date":"2020-03-22T06:12:40.000Z","updated":"2020-07-06T05:11:12.000Z","comments":true,"path":"passages/leetcode-zhi-di-k-ge-pai-lie/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-di-k-ge-pai-lie/","excerpt":"Permutation Sequence","text":"Permutation Sequence Permutation Sequence code with Python title number：060 读题 给出集合[1, 2, ..., n]，所有元素有n!中排列 按从小到大顺序列出所有排列，给定n个k，返回第k个排列 1=&lt;n=&lt;9, 1=&lt;k=&lt;n! 思路一 我们不可能通过列出所有的情况，然后再去找第k个 原因是，n!已经是极高的时间复杂度了，所以要寻找规律，减少计算的次数 观察给出的示例 n = 3, k = 3 “123”，”132” “213”，”231” “312”，”321” 可以观察到，以1开头的有2!个，以2开头的有2!个，以3开头的有2!个 经过推理我们可以得出，包含n个元素的数组组成的排列中，以每个数字开头的元素有(n-1)!个 因此，如果我们要找第k个元素，先用k / (n-1)!判断第k个元素落在以哪个元素开头的全排列中，即确定了第一位数字 接下来进行迭代，依次得到每一位数字，组合得到最终结果 12345678910111213141516def getPermutation(self, n: int, k: int) -&gt; str: res = None candidates = [str(i) for i in range(1, n+1)] while n != 0: # 计算n-1的阶乘 facto = math.factorial(n-1) # 落在以哪个元素为首的全排列中 i = math.ceil(k / facto) - 1 res += candidatees[i] candidates.pop(i) k -= facto * i n -= 1 return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之合并区间","slug":"Leetcode之合并区间","date":"2020-03-21T01:21:09.000Z","updated":"2020-07-06T05:16:31.000Z","comments":true,"path":"passages/leetcode-zhi-he-bing-qu-jian/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-he-bing-qu-jian/","excerpt":"Merge Interval","text":"Merge Interval Merge Interval code with Python title numbe：056 读题 给出一个区间的集合，合并所有重叠的区间 示例： 输入：[[1,3],[2,6],[8,10],[15,18]] 输出：[[1,6],[8,10],[15,18]] 解释：区间[1,3]和[2,6]重叠, 将它们合并为[1,6] 思路一 通过示例可以明白，所谓重叠，即较大区间的的左端点小于等于较小区间的右端点（所谓较大较小指的是区间左右端点数值的大小） 所以为了简化操作，我们要对区间进行排序（按照左端点的大小排序） 排序过后对区间集合进行遍历，判断两个区间是否有重叠，如果有则合并，否则跳过 1234567891011121314151617181920def merge(self, intervals: List[List[int]]) -&gt; List[List[int]]: if len(intervals) &lt;= 1: return intervals #获取数组的左端点 def get_first(a): return a[0] # 排序 intervals.sort(key=get_first) # 遍历并合并 res = [intervals[0]] for i in range(1, len(intervals)): # 合并 if intervals[i][0] &lt;= res[-1][1]: res[-1] = [res[-1][0], max(res[-1][1], intervals[i][1])] else: res.append(intervals[i]) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"htop命令的内容含义","slug":"htop命令的使用及内容的含义","date":"2020-03-20T12:12:16.000Z","updated":"2020-07-06T05:08:07.000Z","comments":true,"path":"passages/htop-ming-ling-de-shi-yong-ji-nei-rong-de-han-yi/","link":"","permalink":"http://zivblog.top/passages/htop-ming-ling-de-shi-yong-ji-nei-rong-de-han-yi/","excerpt":"htop命令的内容含义","text":"htop命令的内容含义 主要参数 PID、USER、PR、NI、VIRT、RES、SHR、S、%CPU、%MEM、TIME+、COMMAND PID：进程id，可以通过kill PID来关掉进程 USER：该进程的拥有者 PR：进程优先级 NI：nice值，负值表示高优先级，正值表示低优先级 VIRT：virtual memory usage，当前进程需要的虚拟内存，包括进程使用的库、代码、数据等 RES：resident memory usage，当前进程使用的内存大小 SHR：share memory，除了自身进程的共享内存，也包括其他进程的共享内存 S：进程状态 D：不可中断的睡眠状态 R：运行 S：睡眠 T：跟踪/停止 Z：僵尸进程 %CPU：上次更新到现在的CPU占用百分比 %MEM：进程使用的物理内存百分比 *TIME+ *：进程使用的CPU的时间总计，单位为秒 COMMAND：当前进程执行的命令 默认仅显示以上的比较重要的内容，可以通过提示快捷键更改显示内容","categories":[{"name":"工具配置","slug":"工具配置","permalink":"http://zivblog.top/categories/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://zivblog.top/tags/Tools/"}]},{"title":"Leetcode之跳跃游戏","slug":"Leetcode之跳跃游戏","date":"2020-03-20T08:57:34.000Z","updated":"2020-07-06T05:28:09.000Z","comments":true,"path":"passages/leetcode-zhi-tiao-yue-you-xi/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-tiao-yue-you-xi/","excerpt":"Jump Game","text":"Jump Game Jump Game code with Python title number：055 读题 给定一个数组，数组中元素均为非负整数 你的初始位置位于数组的第一个位置 数组中的每个元素代表你在该位置可以跳跃的最大长度 判断你能否到达最后一个位置 例如：对于数组[2, 3, 1, 1, 4]，即我们可以从位置0跳一步到达位置1，再从位置1跳三步到达最后一个位置 再如：对于数组[3, 2, 1, 0, 4]，我们发现不管怎么选都会到达位置3，而这个 位置的可允许最大跳跃长度为0，即无论如何我们都不能到达最后一个位置 思路一 观察示例中不能到达的情况，产生以下想法： 最朴素的情况就是每一个点都向前条一步，如果有一步跳不过去，那么就无法到达 也就是存在nums[i]==0，并且该位置无法跳过，则失败 1234567891011def canJump(self, nums: List[int]) -&gt; bool: length = len(nums) index = 0 # 记录可以到达的位置 for i in range(length): if index &gt;= length-1: return True # i位置跳不过去 if nums[i]==0 and index &lt;= i: retunn False index = i + nums[i] if index &lt; i+nums[i] else index 思路二 值得注意的一个点是：如果从当前点能到达某个位置x，那么位置x之前的所有位置均能到达 由此，我们可以基于贪心来设计一种思路（选择从当前位置能到达的最远位置）： 设置一个点记录最远位置，初始化为0 遍历数组，如果当前位置能到达，并且当前位置+最大跳数&gt;最远距离，则更新最远位置 比较最远位置与数组长度 注意这里是只要能够到达最终位置即可，也就是只需找到任意一种满足条件的情况 123456def canJump(self, nums: List[int]) -&gt; bool: max_ = 0 for i, jump in enumerate(nums): if max_ &gt; i and i+jump &gt; max_: max_i = i + jump return max_i 思路三 动态规划 要判断从第一个位置能否到达最后一个位置，那么我们先判断从第二个位置能否到达最后一个位置 接着再判断从第一个位置能够到达第二个位置 依次执行 定义：dp[i]表示从第i个坐标能跳到的最远位置，dp[i-1]&gt;=i表示可以到达位置i 初始状态：dp[i]=0 状态转移方程：dp[i] = max(dp[i-1], i+nums[i]) 结束条件：i == length-1时结束，判断dp[length-1]是否大于等于length-1 123456789101112131415def canJump(self, nums: List[int]) -&gt; bool: if len(nums) &lt;= 1: return True dp = [0 for _ in range(len(nums))] dp[0] = nums[0] for i in range(1, len(nums)): if dp[i-1] &gt;= i: dp[i] = max(dp[i-1], i+nums[i]) else: dp[i] = dp[i-1] if dp[i] &gt;= len(nums)-1: return True return False","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"nohup的简单使用","slug":"nohup的简单使用","date":"2020-03-19T13:47:02.000Z","updated":"2020-07-06T05:36:15.000Z","comments":true,"path":"passages/nohup-de-jian-dan-shi-yong/","link":"","permalink":"http://zivblog.top/passages/nohup-de-jian-dan-shi-yong/","excerpt":"nohup","text":"nohup 前言 事情的开始是一直蝙蝠。。。 在家连学校的vpn跑程序总是中断，请教了一位大佬，上网查了一些资料，整理成了这篇文章 用过的都说好 nohup和&amp;的区别 &amp;： 在命令之后加&amp;表示在后台运行 不再接收输入，在终端中键入Ctrl+C，并不会打断程序的运行。 结果会输出到终端 但是在关闭session之后，会打断程序 nohup： 表示不打断的运行程序 会自动将程序的输出存储到nohup.out中，不会输出到前台 使用Ctrl+C会打断程序 关掉session，不会打断程序 使用nohup和&amp;实现程序后台运行 一般在linux上执行程序都死在命令行下直接执行，但如果程序运行的时间比较长，而且存在网络不稳定该怎么办呢？ 这时就需要使用借助nohup和其他命令来实现程序的后台运行 nohup：加在命令的前面，表示不挂断的运行命令 &amp;：加在一个命令后面，表示这个命令放在后台执行 例如：nohup python3 main.py &amp;，程序会在后台运行，并且将输出存储到nohup.out中 关闭后台程序 当执行上述命令后，不能通过Ctrl+C中断程序，只能通过kill 命令打断程序 查看进程 jobs：可以查看当前中断后台执行的任务 ps：查看当前时刻的所有后台进程 关闭后台程序 使用上述命令查看到后台进程的jobnum或者PID之后 分别使用kill %jobnum或者kill %PID关闭进程 前后台进程的切换 fg %jobnum：将选中的后台进程切换为前台执行 Ctrl+Z：将正在前台执行的命令放到后台，并且处于暂停状态 bg %jobnum：将选中的后台进程切换为前台执行","categories":[{"name":"工具配置","slug":"工具配置","permalink":"http://zivblog.top/categories/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://zivblog.top/tags/Tools/"}]},{"title":"Leetcode之实现x的n次幂","slug":"Leetcode之实现x的n次幂","date":"2020-03-19T07:27:32.000Z","updated":"2020-07-06T05:26:57.000Z","comments":true,"path":"passages/leetcode-zhi-shi-xian-x-de-n-ci-mi/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-shi-xian-x-de-n-ci-mi/","excerpt":"Pow(x, n)","text":"Pow(x, n) Pow(x, n) code with Python title number：050 读题 实现pow(x, n)，即计算x的n次幂 -100.0 &lt; x &lt; 100.0 n是32位无符号整数，[-2^31, 2^31-1] 思路一 由于是要我们实现x的n次幂，所以不能调用Python库中的函数 最简单的一种思路就是不断累乘，n为多少就乘多少次 很明显，这种思路必定会超时，简单实现一下 123456789def myPow(self, x: float, n: int) -&gt; float: if n == 0: return 1 if n &lt; 0: return 1 / self.myPow(x, -n) res = 1 for _ in range(n): res *= x return res 思路二 简单的递归 比如： 对于n为偶数，想求x^4，可以转化为(x^2)^2 对于n为奇数，想求x^5，可以转化为x*(x^2)^2 由上面的启发，我们想到使用递归，具体思路如下 假n除以二的结果为a 那么myPow(x, n) = myPow(x, a) * myPow(x, n-a) 123456789def myPow(self, x: float, n: int) -&gt; float: if n == 0: return 1 if n == 1: return x if n &lt; 0: return 1 / self.myPow(x, -n) return self.myPow(x, n // 2) * self.myPow(x, n - n // 2) 可惜这种方法也超时了，原因是存在太多的重复计算 思路三 在上面递归的基础上进行优化 为了减少每次递归是调用本身的次数，优化如下： 如果n是偶数，我们将n折半，底数变为x^2 如果n是奇数， 我们将n减去1，底数不变，得到的结果再乘上底数x 123456789def myPow(self, x: float, n: int) -&gt; float: if n == 0: return 1 if n == 1: return x if n &lt; 0: return 1 / self.myPow(x, -n) return self.myPow(x*x, n // 2) if n % 2 == 0 else x * self.myPow(x, n-1)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之字母异位词分组","slug":"Leetcode之字母异位词分组","date":"2020-03-18T06:27:49.000Z","updated":"2020-07-06T05:32:51.000Z","comments":true,"path":"passages/leetcode-zhi-zi-mu-yi-wei-ci-fen-zu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zi-mu-yi-wei-ci-fen-zu/","excerpt":"Group Anagrams","text":"Group Anagrams Group Anagrams code with Python title number：049 读题 给定一个字符串数组，将字母异位词组合到一起 异位词：指字母相同，但排列不同的字符串 所有输入均为小写，不考虑答案输出的顺序 思路一 比较直观的想法是，对数组的每一项元素（字符串）进行排序，然后使用字典存储，结构为{经过排序的字符串:[原字符串]} 遍历字典，取出所有value即可 12345678910111213141516171819def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]: hash_table = &#123;&#125; res = [] def sort_str(str): str = list(str) str.sort() return \"\".join(str) for s in strs: if sort_str(s) in hash_table: hash_table[sort_str(s)].append(s) else: hash_table[sort_str(s)] = [s] for s in hash_table.keys(): res.append(hash_table[s]) return res 思路二 仍然是上面的思路，不过这次我们判断两个词是否是异位词的方式有所改变 参考桶排序的思路，设计一种方法 我们建立一个长度为26的数组（26个字母），每个字母对应一个数组中的下标 每读一个词，遍历其所有字母，并且在相应位置出统计词中出现的字母的个数 如果两个词得到的数组相同，则说明两者之间可以通过交换顺序得到 其余思路相同 1234567891011121314def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]: # 初始化字典 str_dict = collections.defaultdict(list) for s in strs: s_key = [0]*26 # 遍历词中的字母 for c in s: s_key[ord(c)-ord('a')] += 1 str_dict[tuple(s_key)].append(s) for key in str_dict.keys(): res.append(str_dict[key]) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"桶排序","slug":"桶排序","date":"2020-03-18T02:03:25.000Z","updated":"2020-07-06T05:48:12.000Z","comments":true,"path":"passages/tong-pai-xu/","link":"","permalink":"http://zivblog.top/passages/tong-pai-xu/","excerpt":"桶排序","text":"桶排序 概述 桶排序（Bucket Sort）的原理十分容易理解，就是将数组分到有限数量的桶中，再顺序的从桶中取出，即可得到排序结果 桶排序有两个关键点 待排序元素的值域的划分。即确定每个桶代表了什么，或者说是每个桶允许什么元素装入 排序算法的选择。即每个桶中的元素的排列规则 下面通过两个例子理解桶排序使用时的具体细节 实例一 假设我们现在有n个整数，并且知道整数的范围时[0, max)，现使用桶排序对这n个整数进行排序 值域的划分：由于知道n个整数的范围是[0, max)，所以设置max个桶，每一个整数都会唯一的进入一个桶中 排序算法的选择：由于每个桶中的数字都相同，不需要排序 具体： 设置一个长为max的数组bucket，数组中的每个位置是一个桶 遍历n个整数，将对应整数x放到bucket中对应下标的位置（统计值为x的元素的个数，即bucket[x]+=1） 遍历数组bucket，按照对应位置的值的大小，顺序取出对应个数的值 如上图，得到的排序结果应为[2, 3, 3, 3, 4, 4, 6, 6, 8, 9] 实例二 现有数组[-7, 51, 3, 121, -3, 32, 21, 43, 4, 25, 56, 77, 16, 22, 87, 56, -10, 68, 99, 70]，试用桶排序完成对该数组的排序 值域的划分： 我们观察到，上述数组值域的范围比较大，直接申请大小与值域范围相同的数组势必会造成很多空间的浪费 故另辟蹊径，我们将每个桶可以容纳的元素设置一个范围，这里我们设置间隔为10 对此，我们需要设置一个映射规则，来更加方便的将元素放入对应的桶中 $$f(x)=\\frac{x}{10}-c, (c=\\frac{min}{10})$$ 经计算可得，待排序数组中，max=121, min=-10，所以申请桶的个数为14个 $$\\frac{max}{10}-\\frac{min}{10}+1 = 12-(-1)+1=14$$ 排序算法的选择 不同于前一个例子，桶中存放的将是不同的数字，所以需要寻找一个算法对桶中的元素进行排序。 该排序算法的选择，将直接影响整体的性能 排序结果为 桶下标 桶中元素 0 -7, 3,-10 1 3, 4 2 16 3 21, 25, 22 4 32 5 43 6 51, 56, 56 7 68 8 77, 70 9 87 10 99 11 12 13 121 代码示例 12345678910111213def bucketSort(arr): max, min = max(arr), min(arr) bucketArr = [[] for i in range(max // 10 - min//10 + 1)] # 遍历数组，添加到桶中 for i in arr: index = i bucketArr[index].append(i) arr.clear() # 对每个桶中的元素排序 for i in bucketArr: i.sort() arr.extend(i)","categories":[{"name":"算法","slug":"算法","permalink":"http://zivblog.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之旋转图像","slug":"Leetcode之旋转图像","date":"2020-03-17T13:16:08.000Z","updated":"2020-07-06T05:29:41.000Z","comments":true,"path":"passages/leetcode-zhi-xuan-zhuan-tu-xiang/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-xuan-zhuan-tu-xiang/","excerpt":"Rotate Image","text":"Rotate Image Rotate Image code with Python title number：048 读题 给定一个n*n的二维矩阵用于表示一个图像 将图像顺时针旋转90度 必须原地旋转，不能使用额外的二维矩阵 思路一 由于是要原地旋转矩阵，我们需要找到矩阵旋转90度时，元素位置的变化规律 经过观察可以发现，我们只需要将第i行变成第n-i-1列即可 有个比较巧妙的方法，即利用对称轴旋转达到我们的目的 先进行一次对角线为轴的翻转，然后再进行一次以水平对称线为轴的翻转，即可 123456789def rotate(self, matrix: List[List[int]]) -&gt; None: # 先沿着对角线翻转 n = len(matrix) for i in range(n): for j in (i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # 再沿横对称线翻转 for m in matrix: m.reverse()","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之全排列Ⅱ","slug":"Leetcode之全排列Ⅱ","date":"2020-03-16T09:52:27.000Z","updated":"2020-07-06T05:24:56.000Z","comments":true,"path":"passages/leetcode-zhi-quan-pai-lie-ii/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-quan-pai-lie-ii/","excerpt":"Permutations Ⅱ","text":"Permutations Ⅱ Permutations Ⅱ code with Python title number：047 读题 给定一个可能包含重复数字的序列，返回其所有不重复的全排列 思路一 由于序列中可能包含重复数字，所以要在生成全排列的时候去重 与前面的思路相同，先排序，每使用一个数字就将其pop出，防止重复使用 其他并没有特殊之处 12345678910111213141516171819from copy import copydef permuteUnique(self, nums: List[int]) -&gt; List[List[int]]: nums.sort() res = [] def backtrack(nums, pre_list): if len(nums) &lt;= 0: res.append(pre_list) else: for i in range(len(nums)): if i &gt; 0 and nums[i] == nums[i -1]: continue p_list = pre_list.copy() p_list.appen(nums[i]) left_num = nums.copy() left_nums.pop(i) print('p_list is ', p_list, 'left_nums is ', left_num) backtrack(left_nums, p_list) backtrack(nums, []) return res print()信息如下 p_list is [1] left_nums is [1, 2] p_list is [1, 1] left_nums is [2] p_list is [1, 1, 2] left_nums is [] p_list is [1, 2] left_nums is [1] p_list is [1, 2, 1] left_nums is [] p_list is [2] left_nums is [1, 1] p_list is [2, 1] left_nums is [1] p_list is [2, 1, 1] left_nums is []","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之全排列","slug":"Leetcode之全排列","date":"2020-03-15T08:36:08.000Z","updated":"2020-07-06T05:24:49.000Z","comments":true,"path":"passages/leetcode-zhi-quan-pai-lie/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-quan-pai-lie/","excerpt":"Permutations","text":"Permutations Permutations code with Python title number：046 读题 给定一个没有重复数字的序列，返回其所有可能的全排列 思路一 本题是求集合，并不是求极值，所以不适合使用动态规划 与前面的两道题（题目一，题目二）思路相同，使用回溯法，实际上就是对回溯决策树的遍历 主要问题就是明白三个问题对应什么 路径：已经选择的数字 选择列表：当前可供选择的数字 结束条件：所有数字全部选择一遍 因为是数字序列的全排列，所以每个数字只能用一次（不包含重复数字） 以数字序列[1, 2, 3]为例 12345678910111213141516def permute(self, nums: List[int]) -&gt; List[List[int]]: res = [] length = len(nums) def backtrack(start): if start == length: res.append(nums[:]) for i in range(start, length): nums[start], nums[i] = nums[i], nums[start] backtrack(start+1) nums[start], nums[i] = nums[i], nums[start] backtrack(0) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之组合总和Ⅱ","slug":"Leetcode之组合总和Ⅱ","date":"2020-03-14T08:53:08.000Z","updated":"2020-07-06T05:33:09.000Z","comments":true,"path":"passages/leetcode-zhi-zu-he-zong-he-ii/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zu-he-zong-he-ii/","excerpt":"Combination Sum Ⅱ","text":"Combination Sum Ⅱ Combination Sum Ⅱ code with Python title number：040 读题 给定一个数组candidates和一个目标数target 找出candidates中可以使数字和为target的组合 candidates中的每个数字在每个组合中只能使用一次 所有数字均为正整数 解集中不能包含重复组合 思路一 相比与39题，该题的不同之处在于每个数字只能使用一次 对与这项要求，我们可以在查找下一个数字时从当前位置的下一个位置开始 而要解决解集中不包含重复数，我们可以对数组进行排序，在检查选择列表时，滑过相同值的部分 仍是套用回溯法文章中提到的模版 123456789101112131415161718192021222324def combinationSum2(self, candidates: List[int], target: int) -&gt; List[List[int]]: if not candidates: return [] candidates.sort() size = len(candidates) res = [] # 递归函数 def backtrack(i, temp_sum, temp_list): if temp_sum == target: res.append(temp_list) return for j in range(i, size): # 再加一个值大于target if temp_sum + candidates[j] &gt; target: break # 滑过连续的相同值 if j &gt; i and candidates[j]==candidates[j-1]: continue # 递归 backtrack(j+1, temp_sum+candidates[j], temp_list + [candidates[j]]) backtrack(0, 0, []) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"回溯法","slug":"回溯法","date":"2020-03-13T08:14:04.000Z","updated":"2020-07-31T02:06:22.000Z","comments":true,"path":"passages/hui-su-fa/","link":"","permalink":"http://zivblog.top/passages/hui-su-fa/","excerpt":"回溯法","text":"回溯法 概述 总体上来说，回溯法（Back Tracking）是一种选优搜索算法，即通过试探的方式寻找达到目标的方式。 算法会依次尝试每个分叉点的所有可能，当探索到某一步时，发现当前的选择并不优或者达不到最终目标时，就退回上一步，再选择另一种可能进行探索。这种走不通路就退回再走的方式就是回溯法了 算法讲解直观感受 假设你要从家去一个地方，而去往这个地方的路上有很多个岔路口。用回溯法来找到去往目的地的方法就是一个岔路口一个岔路口的尝试。如果发现走错了，就返回找到岔路口的下一条路，继续尝试，直到找到目的地。 从上面的例子来看，我们使用回溯法解决问题的时候，其实恰好是一次决策树的遍历 细节 既然是决策树的遍历，那我们需要考虑三个问题： 路径：即已经作出的选择 选择列表：当前可以挑选的可能 结束条件：到达决策树的底层，也就是到达终点，无法再进行决策的条件 下面我们将通过8皇后问题来演示回溯法的使用 所谓八皇后问题，就是一个8*8的棋盘上，放置8个皇后，使得它们无法相互攻击 皇后可以攻击同一行、同一列、和所处两条对角线上的任意单位 决策树的每一层对应棋盘上一行的情况，同一层上每个节点的表示在该层的对应位置放置皇后 而使用回溯法，就是遍历该决策树找到符合条件的路径（决策树中的路径对应一种摆放的方案） 既然是决策树的遍历，当然可以通过剪枝来减少代码的复杂度 剪枝 剪枝的方法也很简单直接，即在走过的路径中出现的可能在后面不会再出现 一般通过一个判断路径合法性的函数来实现 需要注意的是，不论如何优化，都无法使算法的复杂度降低太多，因为回溯法本身就是纯暴力穷举，遍历整棵决策树是无法避免的。 代码模版 代码方面，凡使用回溯法解决的问题，都可以套用以下代码模版 123456789result = []def back_tracking(路径, 选择列表): if 结束条件: result.add(路径) return for 选择in 选择列表: 做选择 back_tracking(路径, 选择列表) 回退 DFS与回溯法 回溯法在实现上时遵循深度优先的原则的，即一步一步往前探索 深度优先搜索的目的是遍历，本质上是无序的，即不关心每次访问的次序，重要的是都被访问过 回溯法的目的是求解，本质上是有序的。即每步都是要求的次序 深度优先搜索可以看作是工具，而回溯法是应用 2020.7.31 更新 回溯法常用于遍历列表所有子集，是深度优先遍历的一种，一般用于全排列，穷尽所有可能，便利的过程实际上是一个决策树遍历的过程 回溯法是纯暴力穷举，时间复杂度一般都很高","categories":[{"name":"算法","slug":"算法","permalink":"http://zivblog.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之组合总和","slug":"Leetcode之组合总和","date":"2020-03-13T08:12:51.000Z","updated":"2020-07-06T05:33:00.000Z","comments":true,"path":"passages/leetcode-zhi-zu-he-zong-he/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zu-he-zong-he/","excerpt":"Combnation Sum","text":"Combnation Sum Combnation Sum code with Python title number：039 读题 给定一个无重复元素的数组和一个目标数 找出数组中所有可使数字和为目标数的组合 数组中元素可被无限制重复使用 所有数字均为整数，解的集合中不能包含重复的组合 思路一 很明显，这是一道典型的使用回溯法解决的问题 关于回溯法，可以看另一篇介绍该算法的文章 这里使用减法的思想，例如：target=7, candidates=[2, 3, 6, 7] 对于候选数字2，只需要找到所有7-2=5的所有组合，加上2就是结果了 对于候选数字3，只需要找到所有7-3=4的所有组合，加上3就是结果了 依次类推 这样，我们就可得到一棵决策树，经优化后如下图 正如图中已经经过剪枝，去掉了一些重复的枝叶，在代码中也要有所体现，即设置搜索起点 还有就是，我们还减去了一些从明显不能得到结果的枝叶，比如，当7-3-6之后的下一层就无需再遍历了 另外。对候选数组进行排序也可以加快搜索速度 对于每一条路径的选择，就是深度优先遍历了 123456789101112131415161718192021222324def combinationSum(self, candidates: List[int], target: int) -&gt; List[List[int]]: size = len(candidates) if size == 0: return [] candidates.sort() path, res = [], [] self._dfs(candidates, 0, size, path, res, target) return resdef _dfs(self, candidates, begin, size, path, res, target): if target == 0: res.append(path[:]) return for index in range(begin, size): residue = target - candidates[index] if residue &lt; 0: break path.append(candidates[index]) self._dfs(candidates, index, size, path, res, residue) path.pop()","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之搜索旋转排序数组","slug":"Leetcode之搜索旋转排序数组","date":"2020-03-12T07:05:37.000Z","updated":"2020-07-13T11:36:19.000Z","comments":true,"path":"passages/leetcode-zhi-sou-suo-xuan-zhuan-pai-xu-shu-zu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-sou-suo-xuan-zhuan-pai-xu-shu-zu/","excerpt":"Search Rotated Sorted Array","text":"Search Rotated Sorted Array Search Rotated Sorted Array code with Python title number：033 读题 假设当前的数组是在升序数组的某个结点上进行了旋转后得到 例如：[0, 1, 2, 4, 5, 6, 7] -&gt; [4, 5, 6, 7, 0, 1, 2] 在当前数组中查找一个给定的目标值， 若该值存在，则返回其索引 若不存在，则返回-1 数组中的数不重复 算法时间复杂度必须是O(logn) 思路一 限定了时间复杂度必须是O(logn)，基本上就是在暗示要使用二分搜索了 但是我们知道二分搜索的作用对象必须是有序数组，这里应该也可以用，我们分析一下： 对于数组[4, 5, 6, 7, 0, 1, 2]: 首先通过观察得到，这个数组包含两个有序子数组（前面的子数组整体大于后面的子数组），并且肯定会有一个子数组的长度是大于等于数组长度/2 这样就是一种很好的性质了，假设我们要找的target=6 首先计算mid=(start+end)/2=3， 比较nums[mid]与nums[start]的大小关系足以令我们确定我们现在是位于哪一部分，之后就可以舍弃另一部分了（这和二分搜索一致） 如果nums[mid]&gt;=nums[start]，则nums[mid]位于左边的有序子数组中 如果nums[mid]&lt;nums[start]，则nums[mid]位于右边的有序子数组中 之后我们要确定target的位置，只需要比较target与有序部分边界的关系即可 当nums[mid]在右边的有序部分时，只需判断target与nums[mid]和nums[end]的关系即可 当nums[mid]在左边的有序部分时，只需判断target与nums[mid]和nums[end]的关系即可 12345678910111213141516171819202122232425def search(self, nums: List[int], target: int) -&gt; int: if len(nums) == 0: return -1 start, end = 0, len(nums)-1 while start &lt; end: mid = (end - start) // 2 + start if nums[mid] == target: return mid # mid在在左边有序部分 if nums[mid] &gt; nums[left]: # target在左边有序部分 if nums[start] &lt;= target &lt;= nums[mid]: right = mid else: left = mid+1 # mid在右边有序部分 else: if nums[mid+1] &lt;= target &lt;= nums[right]: left = mid + 1 else: right = mid return left if nums[left] == target else -1","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之下一个排列","slug":"Leetcode之下一个排列","date":"2020-03-11T08:09:45.000Z","updated":"2020-07-06T05:29:34.000Z","comments":true,"path":"passages/leetcode-zhi-xia-yi-ge-pai-lie/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-xia-yi-ge-pai-lie/","excerpt":"Next Permutation","text":"Next Permutation Next Permutation code with Python title number：031 读题 将给定数字序列重新排列成字典序中下一个更大排列 如果不存在下一个更大排列，则将数字重新排列成最小的排列（升序） 原地操作，额外空间数为常数 例如： 1231, 2, 3 -&gt; 1, 3, 23, 2, 1 -&gt; 1, 2, 31, 1, 5 -&gt; 1, 5, 1 这里比较难理解的是下一个更大排列的含义 用一个比较易理解的方式是，将整组数字组成一个整数，下一个更大排列就是下一个刚刚大于当前数字的整数 例如，给定1, 2, 3 -&gt; 123，则刚刚大于它的数字为132 -&gt; 1, 3, 2 更正式一点的说法如下： 所谓的下一个排列，是在当前的基础上，将尾部的最小升序序列标为降序后的整个排列 比如：1, 1, 5的最小升序为1, 5，将其变为降序，则下一个更大排列为1, 5, 1 思路一 理解了下一个更大排列的含义之后，方法就很清晰了 我们从后往前遍历，找到下降点（即nums[i] &gt; nums[i-1]）处 从后往前找到比下降点大的数，与下降点的数交换位置 由于下降点滑倒了后面，要重新排列下降点之后的数字（降序） 如果没有下降点，则重新排序（升序） 12345678910111213141516171819202122def nextPermutation(self, nums: List[int]) -&gt; None: down_index = None # 从后往前遍历 for i in range(len(nums)-2, -1, -1): if nums[i] &lt; nums[i+1]: down_index = i break # 没有下降点，重新排序 if down_index is None: nums.reverse() else: # 从后向前找到大于下降点的数，交换位置 for j in range(len(nums)-1, i, -1): if nums[down_index] &lt; nums[j]: nums[down_index], nums[j] = nums[j], nums[down_index] break # 对后面部分重新排序 i, j = down_index+1, len(nums)-1 while i &lt; j: nums[i], nums[j] = nums[j], nums[i] i += 1 j -= 1 代码再优化 1234567891011def nextPermutation(self, nums: List[int]) -&gt; None: for i in range(len(nums)-1, 0, -1): if nums[i] &gt; nums[i-1]: nums[i:] = sorted(nums[i:]) for j in range(i, len(nums)): if nums[j] &gt; nums[i-1]: nums[i-1], nums[j] = nums[j], nums[i-1] break return # 找不到下降点 nums.sort() 不同之处在于，这里是先对下降点之后的元素进行了排序","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之两数相除","slug":"Leetcode之两数相除","date":"2020-03-10T07:12:16.000Z","updated":"2020-07-06T05:20:43.000Z","comments":true,"path":"passages/leetcode-zhi-liang-shu-xiang-chu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-liang-shu-xiang-chu/","excerpt":"Divivde Two Integers","text":"Divivde Two Integers Divivde Two Integers code with Python title number：029 读题 给定两个整数，被除数dividend和除数dicisor 将两数相除，不能使用乘法、除法和取余运算 返回两数相除得到的商 除数和被除数都是32位有符号整数，且除数不为0 环境只能存储32位有符号整数，范围为[-2^31, 2^31-1]，若结果溢出，则返回2^31-1 思路一 最朴素的思想 判断除数和被除数是否异号 除数和被除数取绝对值，用被除数不断减去除数，至被除数小于除数 根绝两者是否异号还原结果的真实正负情况 1234567891011def divide(self, divdend: int, dividsor: int) -&gt; int: res = 0 sign = 1 if divd ^ dior &gt;= 0 else -1 divd = abs(divd) dior = abs(dior) while divd &gt;= dior: res += 1 divd -= dior res = res if sign==1 else -res return min(max(-2**31, res), 2**31-1) 思路二 思路一中的方式明显会计算次数比较多，我们考虑是否能减少计算的次数 123456789101112观察：10 &#x2F; 3借鉴二分查找的思想，我们每次将除数翻倍（这里的翻倍通过除数自身加自身实现，而不是乘法）10&gt;3可以，10-3,result+1 -&gt; 7&gt;6可以，result+2 -&gt; 1-12&lt;0不行，所以结果是3再举个例子验证一下：12 &#x2F; 312&gt;3可以，12-3，result+1 -&gt; 9&gt;6可以，9-6result+2 -&gt; 3&lt;6不行，-&gt; 再次从3开始判断-&gt; 3&lt;&#x3D;3，3-3，result+1，所以结果是4 另外，我们判断除数和被除数是否异号————这决定结果的正负。在计算时我们使用绝对值函数取两者的绝对值进行计算 12345678910111213141516171819202122232425262728293031323334def divide(self, dividend: int, divisor: int) -&gt; int: # 特殊：被除数为1，需要判断除数的正负，并且考虑边界问题 if abs(divisor) == 1: result = dividend if 1 == divisor else -dividend return min(2**31 - 1, max(-2**31, result)) # 判断除数和被除数是否异号 sign = (dividend &gt;=0) == (divisor &gt;= 0) # 取绝对值 _divisor， _dividend = abs(divisor)， abs(dividend) result = 0 while _divisor &lt;= _dividend: r, _dividend = self.multi_divide(_divisor, _dividend) result += r # 还原结果的正负号 result = result if sign else -result # 检查边界 return min(2**31 -1, max(-2**31, result))def _multi_divide(self, divisor, dividend): # divisor每次翻倍 result = 0 time_count = 1 while divisor &lt;= dividend: dividend -= divisor result += times_count time_count += times_count divisor += divisor return result, dividend 思路三 声明：这种思路参考自题解 联想我们计算两个数除法时使用的竖式计算可以联想到使用移位与减法的组合 1234567891011121314151617181920212223def divide(self, dividend: int, divisor: int) -&gt; int: # 判断两者是否同号 sign = (dividend &gt; 0) == (dividsor &gt; 0) # 取绝对值 dividend, dividsor = abs(dividend), abs(dividsor) count = 0 # 判断除数翻倍多少次会大于被除数，并将divisor变为该数 while dividend &gt;= divisor: count += 1 divisor &lt;&lt;= 1 result = 0 while count &gt; 0: count -= 1 divisor &gt;&gt;= 1 if divisor &lt;= dividend: result == 1 &lt;&lt; count dicidend -= divisor #还原结果的正负号 if sign: result = - result # 处理边界 return result if -2**31 &lt;= result and result &lt;= 2**31-1 else 2**31-1","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之两两交换链表中的节点","slug":"Leetcode之两两交换链表中的节点","date":"2020-03-09T05:15:46.000Z","updated":"2020-07-06T05:20:35.000Z","comments":true,"path":"passages/leetcode-zhi-liang-liang-jiao-huan-lian-biao-zhong-de-jie-dian/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-liang-liang-jiao-huan-lian-biao-zhong-de-jie-dian/","excerpt":"Swap Nodes in Pairs","text":"Swap Nodes in Pairs Swap Nodes in Pairs code with Python title number：024 读题 给定一个链表，两两交换其中相邻的结点 返回交换后的链表 不能只交换结点内部的值，必须操作实际的结点 示例 1-&gt;2-&gt;3-&gt;4经处理后应为2-&gt;1-&gt;4-&gt;3 思路一 通过示例我们可以发现，相邻结点的交换并没有交集，即每个结点只会作为一个结点的相邻结点进行交换 我们使用递归的方式进行 终止条件：当链表为空或只剩一个元素时终止 返回值：应将当前经过交换之后的子链表返回给上一层 递归主体：接收了上一步经过交换的子链表，以及当前结点，共三个结点。其中我们交换前两个结点。 假设两个待交换结点为head, second head要指向返回的子链表，head-&gt;next=swapPairs(...) second要指向head，这里要使用一个临时变量存储second，也就是head-&gt;next 返回值当然是second，因为现在它是交换后子链表的第一个结点 12345678910def swapPairs(self, head: ListNode) -&gt; ListNode: if not head or not head.next: # 没有结点或只有一个结点 return head second = head.next head.next = self.swapPairs(second.next) second.next = head return second 思路二 按照朴素的思想，我们可以一边遍历一边交换 这种情况下，交换两个相邻的结点实际上需要涉及四个结点：即pre，first，second，tail pre-&gt;next = first-&gt;next first-&gt;next = second-&gt;next second-&gt;next = first 注意，每次移动的步长为2 此外，创建一个虚拟头部结点，方便处理 123456789101112131415def swapPairs(self, head: ListNode) -&gt; ListNode: if head is None or head.next is None: return head dummp = ListNode(-1) dummp.next = head pre = dummp while pre.next and pre.next.next: first = pre.next second = first.next pre.next, second.next, first.next = second, first, second.next pre = first return dummp.next 重点还是第一种递归方法的理解，本身想到了递归但是没有写出来，参考了题解中的代码","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之删除链表倒数第n个结点","slug":"Leetcode之删除链表倒数第n个结点","date":"2020-03-08T05:32:18.000Z","updated":"2020-07-06T05:25:20.000Z","comments":true,"path":"passages/leetcode-zhi-shan-chu-lian-biao-dao-shu-di-n-ge-jie-dian/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-shan-chu-lian-biao-dao-shu-di-n-ge-jie-dian/","excerpt":"Remove Nth Node From End of List","text":"Remove Nth Node From End of List Remove Nth Node From End of List code with Python title number：019 读题 给定一个链表和一个数字n 删除链表的倒数第n个结点 思路一 问题的关键在与确定第n个元素的位置 这里我们使用最简单的方式查找第n个元素 第一次遍历统计整个链表的长度count 使用count-n即确定的待删除结点的位置 再次遍历删除即可 注意，要删除第n个结点，我们要找的实际是第n-1个结点 123456789101112131415161718192021def removeNthFromENd(self, head: ListNode, n: int) -&gt; ListNode: helper = ListNode(-1) helper.next = head first = head count = 0 # 统计链表中元素个数 while first: first = first.next count += 1 index = count - n first = helper # 确定待删除元素的位置 while index: first = first.next index -= 1 # 删除元素 first.next = first.next.next return helper.next 建立辅助结点helper是为了更好的处理边界条件：当n等于链表长度时会溢出 思路二 减少遍历链表的次数，是用双指针进行： 初始时指针p和q分别指向helper p指针先移动n次 之后p和q一起移动，当p指针指向None时，q指针恰好指向待删除结点的前一个元素 12345678910111213141516def removeNthFromENd(self, head: ListNode, n: int) -&gt; ListNode: helper = ListNode(-1) helper.next = head p, q = helper, helper while n: p = p.next n -= 1 while p.next != None: p = p.next q = q.next q.next = q.next.next return helper.next","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之三数之和","slug":"Leetcode之三数之和","date":"2020-03-07T05:46:55.000Z","updated":"2020-07-06T05:25:03.000Z","comments":true,"path":"passages/leetcode-zhi-san-shu-zhi-he/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-san-shu-zhi-he/","excerpt":"3 Sum","text":"3 Sum 3 Sum code with Python title number：015 读题 给定一个包含n个整数的数组 判断数组中是否存在三个元素之和为0 找出所有满足条件且不重复的三元组 思路一 按照惯例，暴力法 穷举所有的三元组的可能，并判断每个三元组的和是否为0 由于要求不能有重复的三元组，额外实现一个函数，用于判断两个三元组是否包含的元素相似 这个算法的时间复杂度已经达到了$O(n^3)$，简单写一下伪代码吧 1234567891011121314151617def threeSum(self, nums: List[int]) -&gt; List[List[int]]: res = [] def notInres(arr): # 判断给定三元组是否在答案中 return False if arr in res else True for i in range(len(nums)): for j in range(len(nums)): for k in range(len(nums)): # 判断当前三元组是否和为0 if nums[i] + nums[j] + nums[k] == 0: # 判断答案中是否包含该三元组 if notInres([nums[i], nums[j], nums[k]]): res.append([nums[i], nums[j], nums[k]]) return res 思路二 上面的暴力法存在太多的重复判断，并且是三层循环，我们尝试减少循环的次数 采用分治的思想，我们假定每个元素a[i]都可能是最终组成和为0的三元组中的一个数字，那么剩下的工作就是找到两个和为-a[i]的元素。这样就将循环减少到了两个 问题现在转化成了：给定一个数组，找出其中两个相加等于一个给定值 对于转化后的问题，我们对数组进行升序排序，使用双指针解决 固定三个指针中的最小的指针i，将另外两个指针分别置为l=i+1和r=n-1，通过双指针的交叉移动，记录满足条件的三元组 当nums[i]&gt;0时直接跳过。因为在此条件下nums[i]之后的元素必大于0，不可能相加为0 当nums[i] == nums[i-1]时，已经对nums[i-1]进行过搜索，再次进行必定会得到相同的结果 计算nums[i]+nums[l]+nums[r]的和， 当大于0时l+=1 当小于0时r-=1 当等于0时l+=1,r-=1 另外，如果数组长度小于3，则返回[] 123456789101112131415161718192021222324252627def threeSum(self, nums: List[int]) -&gt; List[List[int]]: res = [] if len(nums) &lt; 3: return [] nums.sort() for i in range(len(nums)): if i &gt; 0 and nums[i] == nums[i-1]: continue l = i+1 r = len(nums)-1 while l &lt; r: if nums[i]+nums[l]+nums[r]==0: res.append([nums[i], nums[l], nums[r]]) while l &lt; r and nums[l]==nums[l+1]: l = l + 1 while l &lt; r and nums[r]==nums[r-1]: r = r - 1 l += 1 r -= 1 elif nums[i]+nums[l]+nums[r] &gt; 0: r -= 1 else: l += 1 return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之盛水最多的容器","slug":"Leetcode之盛水最多的容器","date":"2020-03-06T07:05:23.000Z","updated":"2020-07-06T05:26:25.000Z","comments":true,"path":"passages/leetcode-zhi-sheng-shui-zui-duo-de-rong-qi/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-sheng-shui-zui-duo-de-rong-qi/","excerpt":"Container With Most Water","text":"Container With Most Water Container With Most Water code with Python title number：011 读题 给定n个非负整数a1, ... , an，每个数代表坐标中的一个点(i, ai) 在坐标内画n条垂直线(i, ai)-&gt;(i, 0)，找出其中两条线，使其与x轴围成的容器内可以容纳最多的水 思路一 两条垂直线能够围成矩形面积取决于两个因素 两条垂直线中较短的一条 两条垂直线之间的距离 按照惯例，在情况可穷举的情况下先尝试暴力法 设置一个变量存储截至当前能获得的最大面积 两个循环控制围成矩形的左右垂直线 123456def maxArea(self, height: List[int]) -&gt; int: maxarea = 0 for i in range(len(height)): for j in range(i+1, len(height)): maxarea = max(maxarea, min(height[j], height[i])*(j-i)) return maxarea 不出意外的超时了 思路二 双指针法 设置两个指针，一个指向最前端的垂直线，一个直线末尾的垂直线 设置一个变量存储截至当前能获得的最大面积 计算两个垂直线围成的面积，并且使指向较短垂直线的指针向内移动 可行性 在思路一中我们分析得到能够影响矩形面积的有两个因素：两条中较短的垂直线以及两条垂直线之间的距离 在我们的指针移动时，必然会带来两条垂直线之间距离的减小。如果移动指向两条之中较长的垂直线的指针，则会受较短的垂直线的限制必然导致面积减少；同样的情况下如果移动指向两条中较短的垂直线的指针才有可能带来面积的增加。 123456789101112def maxArea(self, height: List[int]) -&gt; int: maxarea = 0 l, r = 0, len(height)-1 while l &lt; r: maxarea = max(maxarea, min(height[l], height[r])*(r-l)) if height[l] &lt; height[r]: r -= 1 else: l += 1 return maxarea","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之最长回文子串","slug":"Leetcode之最长回文子串","date":"2020-03-05T07:30:23.000Z","updated":"2020-07-06T05:35:09.000Z","comments":true,"path":"passages/leetcode-zhi-zui-chang-hui-wen-zi-chuan/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zui-chang-hui-wen-zi-chuan/","excerpt":"Longest Palindromic Substring","text":"Longest Palindromic Substring Longest Palindromic Substring code with Python title number：005 读题 给定一个字符串，最大长度为1000 找到字符串中的最长回文子串 思路一 老规矩，先上暴力法 使用一个变量存储当前得到的最长回文子串的长度 双循环控制子串的首尾位置，判断子串是否为回文，并且当前子串长度更长时，更新 1234567891011def longestPalindrome(self, s: str) -&gt; str: # 暴力法 max_length = 0 res = \"\" for i in range(len(s)): for j in range(i+1, len(s)+1): temp = s[i:j] if temp == temp[::-1] and len(temp) &gt;= max_length: max_length = len(temp) res = temp return res 很可惜，超时了 思路二 其实这个问题也能使用动态规划来解决 首先想到，当一个字符串的头尾两个字符都不相等时，那这个字符串一定不是回文串； 紧接着，如果头尾两个字符串相等，我们再对去掉首尾字符的内部子串进行判断 如果内部子串也是回文串，那么继续进行 如果内部子串不是回文串，那么就可以宣布结束了 正式一点，按照动态规划的分析方式 定义状态：d[i][j]：表示子串s[i:j]是否为回文子串 初始化： 将初试dp全部设置为False 或者仅将dp[i][i]设置为True其他设置为False 状态转移方程：dp[i][j] = (s[i] == s[j]) and dp[i+1][j-1] 边界条件：[i+1, j-1]不构成区间，即长度小于2（为0或为1） 由此可以直接制定规则，当字符串长度小于2时直接返回该字符串即可 输出：当dp[i][j]=True时返回i和j即可 1234567891011121314151617181920212223def longestPalindrome(self, s: str) -&gt; str: if len(s) &lt; 2: return s dp = [[False for i in range(len(s))] for j in range(len(s))] for i in range(len(s)): dp[i][i] = True for j in range(1, len(s)): for i in range(0, j): if s[i] == s[j]: if j - i &lt; 3: dp[i][j] = True else: dp[i][j] = dp[i+1][j-1] else: sp[i][j] = False if dp[i][j]: cur_len = j - i + 1 if cur_len &gt; max_len: max_len = cur_len start = i return s[start, start+max_len] 这里有一个细节，并不使用单独的结构存储最长回文子串，而是只存储其长度和起始位置，这样可以减少切片带来的时间消耗 思路三 中心扩散法，参考官方题解 思路一中的暴力法是枚举子串的左右边界，然后判断该子串是否为回文串 而该方法的思路是枚举可能出现回文子串的中心位置，从中心位置向外扩散 注意，字符串长度为奇数和偶数时，枚举的回文中心的形式是不同的 当长度为奇数时，可以直接枚举具体的字符 当长度为偶数时，枚举的不再是字符，而是两个字符的间隙，或者说是枚举两个相邻字符作为中心 使用一下方式可以兼容两种情况 传入重合的索引，则按奇数情况中心扩散 传入相邻的索引，则按偶数情况中心扩散 123456789101112131415161718192021222324252627def longestPalindrome(self, s: str) -&gt; str: length = len(s) if length &lt; 2: return s max_len = 1 res = s[0] # 根据传入的索引进行中心扩散 def center_spread(s, size, left, right): i, j = left, right while i &gt;= 0 and j &lt; size and s[i] == s[j]: i -= 1 j += 1 return s[i+1:j], j-i-1 for i in range(length): # 分别进行奇数和偶数的情况 odd, odd_len = center_spread(s, length, i, i) even, even_len = center_spread(s, length, i, i+1) # 找到当前最长回文子串 cur_max = odd if odd_len &gt;= even_len else even if len(cur_max) &gt; max_len: max_len = len(cur_max) res = cur_max return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"博客其他细节优化","slug":"博客其他细节优化","date":"2020-03-04T12:08:38.000Z","updated":"2020-03-04T12:23:16.000Z","comments":true,"path":"passages/bo-ke-qi-ta-xi-jie-you-hua/","link":"","permalink":"http://zivblog.top/passages/bo-ke-qi-ta-xi-jie-you-hua/","excerpt":"","text":"文章置顶 替换插件 123npm uninstall hexo-generator-index --savenpm install hexo-generator-index-pin-top -- save 在需要置顶的文章的Front-matter中加上top属性，并设置为True 1234567---title: 2020data: 2020-03-04catagoris: ***tags: ***top: true--- 链接中汉字转为拼音 安装插件 1npm i hexo-permalink-pinyin --save 修改配置文件 修改根目录下的配置文件，添加以下配置 123permalink_pinyin: enable: true separator: '-'","categories":[{"name":"博客相关","slug":"博客相关","permalink":"http://zivblog.top/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://zivblog.top/tags/Tools/"}]},{"title":"Leetcode之无重复的最长子串","slug":"Leetcode之无重复的最长子串","date":"2020-03-04T04:51:52.000Z","updated":"2020-07-30T01:51:07.000Z","comments":true,"path":"passages/leetcode-zhi-wu-chong-fu-de-zui-chang-zi-chuan/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-wu-chong-fu-de-zui-chang-zi-chuan/","excerpt":"Longest Substring Without Repeating Characters","text":"Longest Substring Without Repeating Characters Longest Substring Without Repeating Characters code with Python title number：003 读题 给定一个字符串，找出其中不含重复字符的最长子串 思路一 最先应该想到的就是暴力法了 穷举所有可能的子串，并判断该子串中字符是否是无重复的 为了代码的整洁，将判断部分抽象成一个函数 遍历字符串中每个字符 如果该字符不在辅助集合中，则添加进去 如果在集合中，则返回False 12345678910111213141516def lengthOfLongestSubstring(self, s: str) -&gt; int: res = 0 for i in range(len(s)): for j in range(i+1, len(s)+1): if self.isUnique(s[i:j]): res = max(res, j-i) return resdef isUnique(self, s): unique = &#123;&#125; for i in range(len(s)): if s[i] in unique: return False else: unique[s[i]] = 1 return True 很遗憾，时间复杂度太高，超时了 思路二 思路一中存在许多重复的检测，例如 s[i:j]是无重复的，那么在检测s[i:j+1]是就只需要判断s[j+1]是否在s[i:j]中即可 直觉上的想法是遍历前面的子串s[i:j]，依次判断其中的元素是否与第s[j+1]相等 但是这样仍会带来比较高的时间复杂度，所以我们使用滑动窗口来实现 使用集合中作为滑动窗口，初始时i=j（i, j分别为滑动窗口的左端和右端，左闭又开） 向右滑动右端点j，并判断s[j]是否在集合中，如果不在，则将其添加到集合中 如果s[j]在集合中，则向右滑动左端点i 这样就可以判断所有以i为左端点的不重复子串了 123456789101112def lengthOfLongestSubstring(self, s: str) -&gt; int: res, i, j = 0, 0, 0 temp = set() while i &lt; len(s) and j &lt; len(s): if s[j] not in temp: temp.add(s[j]) j += 1 res = max(res, j-i) else: temp.remove(s[i]) i += 1 return res 思路三 滑动窗口 思路二实际上还存在重复判断的现象，例如 s[i:j]和s[i+1, j+1]这两种左端点不同的子串就存在重复部分s[i+1,j] 所以我们使用字典来建立字符到索引的映射，而不是使用集合来判断字符是否存在于子串中 具体的，当s[i,j)中存在s[j&#39;]==s[j]，即使逐渐增加左端点i，在i到达j&#39;+1之前，j&#39;+1仍会是到j就停止的阻碍 所以我们选择不逐渐增加左端点，而是直接跳过s[i, j&#39;]范围内的元素，令i=j&#39;+1 1234567891011def lengthOfLongestSubstring(self, s: str) -&gt; int: n, res = len(s), 0 i, j = 0, 0 temp = &#123;&#125; for j in range(n): if s[j] in temp: i = max(temp[s[j]], i) res = max(res, j-i+1) temp[s[j]] = j+1 return res 写在后面 与双指针类似，都是由两个边界指针进行问题的求解 滑动窗口的核心点时维护一个窗口集，其核心步骤是： 右指针右移 收缩 做指针右移 得到结果","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"【置顶】这里是置顶","slug":"这里是置顶","date":"2020-03-03T09:03:09.000Z","updated":"2020-11-28T07:37:49.186Z","comments":true,"path":"passages/zhe-li-shi-zhi-ding/","link":"","permalink":"http://zivblog.top/passages/zhe-li-shi-zhi-ding/","excerpt":"这是小站的导航页","text":"这是小站的导航页 Leetcode精刷题目 原项目在这里 推荐一个较直观的演示图解力扣 更多题目请见leetcode 该部分所刷的题目参考上面项目中的题目，会有部分题目的扩充，重点是解题思路的扩充，基本做到一题多解，思路的描述相对口语化，美中不足是没有绘制相对直观的图例。 Python学习笔记 列表操作 条件语句 字典操作 字符串操作 用户输入及while 函数 程序运行时间计算 匿名函数 文件的删除 简单题目 周一 周二 周三 周四 周五 周六 周日 两数之和 回文数 罗马数字转整数 最长公共前缀 有效的括号 删除排序数组中的重复项 最大子序和 合并两个有序数组 买股票的最佳时机 二叉树的最大深度 买股票的最佳时机Ⅱ 回文串 回文串Ⅱ 只出现一次的数字 最小栈 两数之和Ⅱ 阶乘后的0 多数元素 翻转二进制位 位1的个数 打家劫舍 删除链表元素 反转链表 包含重复数Ⅱ 反转二叉树 使用栈实现队列 丑数 移动0元素 4的阶乘 两个数组的交集 路径之和Ⅲ 两个整数之和 二叉搜索树中的众数 分发糖果 模拟机器人行走 二维网格迁移 平衡二叉树 二叉树的层序遍历Ⅱ 删除排序数组中的重复元素 删除排序数组中的重复元素Ⅱ 删除排序数组中的重复元素 环形链表Ⅱ 回文链表 第一个错误的版本 爬楼梯 反转字符串 斐波那契数 寻找数组的中心索引 搜索插入位置 反转字符串 数组拆分 移除数组 最大连续1的个数 中等题目 周一 周二 周三 周四 周五 周六 周日 两数相加 无重复的最长子串 最长回文子串 盛水最多的容器 三数之和 删除链表倒数第n个结点 两两交换链表中的节点 两数相除 下一个排列 搜索旋转排序数组 组合总和 全排列 全排列Ⅱ 旋转图像 字母异位词分组 实现x的n次幂 跳跃游戏 合并区间 第k个排列 不同路径 矩阵置零 颜色分类 子集 单词搜索 删除排序数组中的重复项Ⅱ 分割链表 子集Ⅱ 解码方法 删除回文子序列 反转链表Ⅱ 二叉树的中序遍历 不同的二叉搜索树Ⅱ 不同的二叉搜索树 验证二叉搜索树 二叉树的层序遍历 路径总和Ⅱ 求根到叶子节点数字之和 被围绕的区域 分割回文串 单词拆分 二叉树的前序遍历 目标和 逆波兰表达式求值 乘积最大子数组 二叉树的右视图 岛屿数量 数字范围按位与 实现Trie 长度最小的子数组 最长公共子序列 添加与搜索单词 数组中第K个最大元素 最大正方形 求众数Ⅱ 二叉搜索树中第K小元素 二叉树的最近公共祖先 除自身以外数组的乘积 搜索二维矩阵Ⅱ 完全平方数 最佳买卖股票时机含冷冻期 零钱兑换 奇偶链表 递增的三元子序列 水壶问题 有序矩阵中第k小的元素 常数时间内插入删除和获取随机元素 分割等和子集 两数相加Ⅱ 四数相加Ⅱ 一和零 最长回文子序列 零钱兑换Ⅱ 朋友圈 在系统中查找重复文件 单词的压缩编码 爱吃香蕉的珂珂 石子游戏 RLE迭代器 排序数组 骑士拨号器 在D天内送达包裹的能力 最佳观光组合 可被K整除的最小整数 可被K整除的最小整数 飞地的数量 驼峰式匹配 两个非重叠子数组的最大和 二叉树寻路 绝对值表达式的最大值 最长定差子序列 飞机座位分配概率 在受污染的二叉树中查找元素 可被三整除的最大和 子串出现的最大次数 子数组异或查询 阈值距离内邻居最少的城市 每个元音包含偶数次的最长子字符串 二叉搜索树中的插入操作 反转链表Ⅱ 排序链表 重排链表 复制带随机指针的链表 字符串解码 克隆图 柱状图中最大的矩形 01矩阵 只出现一次的数字Ⅱ 只出现一次的数字Ⅲ 搜索二维矩阵 第一个错误的版本 寻找旋转排序数组中的最小值 三角形最小路径和 最小路径和 不同路径Ⅱ 最长上升子序列 字符串的排列 找到字符串中所有异位词 删除二叉排序树中的节点 对角线遍历 翻转字符串里的单词 实现strStr 困难题目 周一 周二 周三 周四 周五 周六 周日 鸡蛋掉落 柱状图中最大的矩形 寻找排序数组中的最小值Ⅱ 分割回文串Ⅱ 编辑距离 Lintcode题目补充 主要刷题还在leetcode上 该部分不按难度划分，仅按时间顺序 周一 周二 周三 周四 周五 周六 周日 搜索区间 搜索区间 算法相关文章 排序算法 桶排序 简单选择排序 堆排序 直接插入排序 希尔排序 快速排序 冒泡排序 归并排序 基数排序 回溯法 动态规划 前中后缀表达式的转换及计算 Sword offer 数组中的重复元素 暂停该部分的更新 周知识总结 内容包括机器学习、深度学习、自然语言处理、模型优化等 该部分暂时移除 论文笔记 该部分优化后放回 炼丹手册 对抗学习 模型融合 胶囊网络","categories":[{"name":"置顶","slug":"置顶","permalink":"http://zivblog.top/categories/%E7%BD%AE%E9%A1%B6/"}],"tags":[]},{"title":"Leetcode之删除回文子序列","slug":"Leetcode之删除回文子序列","date":"2020-03-03T08:55:13.000Z","updated":"2020-07-06T05:25:12.000Z","comments":true,"path":"passages/leetcode-zhi-shan-chu-hui-wen-zi-xu-lie/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-shan-chu-hui-wen-zi-xu-lie/","excerpt":"Remove Palindromic Subsequences","text":"Remove Palindromic Subsequences Remove Palindromic Subsequences code with Python title number：1332 读题 给定一个字符串，仅由a和b组成 每次操作可以从字符串中删除一个回文子序列 返回删除给定字符串中所有字符的最小删除次数 注意： 子序列：如果一个字符串可以通过删除原字符串中某些字符而不改变原字符顺序得到，那么这个字符串就是原字符串中的一个子序列 回文：如果一个字符串向后和向前读是一致的，那么这个字符串就是一个回文串 思路一 从题目给出的子序列的定义中可以发现，子序列中的元素在原字符串中可以不连续 又因为字符串只由a和b组成，所以可以得到以下结论： 当字符串为空时，返回0 当字符串全为a或全为b时，返回1 当字符串由a和b组成，返回2（先删除全部的a或b，在删除剩下的） 所以这是一道语文题😂 123456789101112131415def removePalindromeSub(self, s: str) -&gt; int: if s == '': return 0 def isPalindrome(s): # 判断给定字符串是否回文 l, r = 0, len(s) -1 while l &lt; r: if s[l] != s[r]: return False l += 1 r -= 1 return True return 1 if isPalindrome(s) else 2 对于Python，可以通过一些花式操作减少代码量 1234def removePalindromeSub(self, s: str) -&gt; int: if s == '': return 0 return 1 if s == s[::-1] else 2 再次，注意：子序列 !=子串","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之二维网格迁移","slug":"Leetcode之二维网格迁移","date":"2020-03-02T06:14:16.000Z","updated":"2020-07-06T05:13:23.000Z","comments":true,"path":"passages/leetcode-zhi-er-wei-wang-ge-qian-yi/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-er-wei-wang-ge-qian-yi/","excerpt":"Shift 2D Grid","text":"Shift 2D Grid Shift 2D Grid code with Python title number：1260 简单 读题 给定一个m行n列的二维网格和一个整数k 根据规定的操作对二维网格“迁移”k次 每次迁移要进行三种操作： 位于grid[i][j]的元素将会移动到grid[i][j+1] 位于grid[i][n-1]的元素将会移动到grid[i+1][0] 位于grid[m-1][n-1]的元素将会移动到grid[0][0] n是列数，m是行数 返回进行了k次迁移之后的网格 思路一 暴力解决，直接翻译题目的要求 1234567891011121314151617from copy import deepcopydef shiftGrid(self, grid: List[List[int]], k: int) -&gt; List[List[int]]: n = len(grid) m = len(grid[0]) for _ in rnge(k): old = deepcopy(grid) for i in range(n): for j in range(m): if j == m-1: grid[(i+1)%n][0] = old[i][j] elif i == n-1 and j == m-1: grid[0][0] = old[i][j] else: grid[i][j+1] = old[i][j] return grid 思路二 在矩阵的二维表示上并没有发现什么规律，所以我们尝试将二维矩阵变成一维 例如： 12345[[1, 2, 3], k&#x3D;1 [[9, 1, 2], [4, 5, 6] &#x3D;&#x3D;&#x3D;&#x3D;&gt; [3, 4, 5], [7, 8, 9]] [6, 7, 8]] [1, 2, 3, 4, 5, 6, 7, 8, 9] -&gt; [9, 1, 2, 3, 4, 5, 6, 7, 8] 所以，这是一个数组旋转问题，对于数组旋转问题，我们使用循环位移算法（三次翻转） 先把[0, n-k-1]翻转 再把[n-k, n-1]翻转 最后把[0, n-1]翻转 并且对于数组旋转问题，旋转的幅度为数组长度时，是会回到初始的样子的 另外，第189题也是数组旋转 1234567891011121314151617181920212223242526def shiftGrid(self, grid: List[List[int]], k: int) -&gt; List[List[int]]: n, m = len(grid), len(grid[0]) # 二维转一维 arr = [grid[i][j] for i in range(n) for j in range(m)] # 取模，避免不必要的计算 k %= m*n res = [] def reverse(l, r): while l &lt; r: t =arr[l] arr[l] = arr[r] arr[r] = t l += 1 r -= 1 reverse(1, m*n-k-1) reverse(m*n-k, m*n-1) reverse(1, m*n-1) # 一维转二维 row = [] for i in range(n): res.append(arr[i*m, (i+1)*m]) return res","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之模拟机器人行走","slug":"Leetcode之模拟机器人行走","date":"2020-03-01T06:12:31.000Z","updated":"2020-07-06T05:23:16.000Z","comments":true,"path":"passages/leetcode-zhi-mo-ni-ji-qi-ren-xing-zou/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-mo-ni-ji-qi-ren-xing-zou/","excerpt":"Walking Robot Simulation","text":"Walking Robot Simulation Walking Robot Simulation code with Python title number：874 简单 读题 机器人在无限大小的网格上行走 从(0, 0)点出发，面向北方，有三种移动指令 -2：向左转90度 -1：向右转90度 1 &lt;= x &lt;= 9：向前移动x个单位 网格上有障碍物，第i个障碍物位于[obstacles[i][0], obstacles[i][1]] 当机器人视图走到障碍物上方时，它会停留在障碍物的前一个网格方块上，但该路线的其余部分可以继续 求从原点到机器人的最大欧式距离的平方。（根据测试用例发现，此处要求得的是移动过程中的最大距离，而不是原点到终点的距离） 思路一 设置两个变量来存储机器人的当前位置和方向 如果机器人收到了转弯的指令，则更新方向； 如果收到其他指令，则沿当前方向走指定的步数 该问题的关键在与收到指令之后坐标的计算（转向，前进）,参考国际版的题解思路中的规律 左转时：dx, dy = -dy, dx 右转时：dx, dy = dy, -dx 123456789101112131415161718192021222324252627def robotSim(self, commands: List[int], obstacles: List[List[int]]) -&gt; int: dx, dy = 0, 1 # 可以视作速度，初始向北，故dx=0，dy=1 x, y = 0, 0 # 初始位置 distance = 0 # 最大距离 obs_dict = &#123;&#125; # 障碍物，字典 for obs in obstacles: # 元组存储，比列表占用空间小，并且比两个list速度快 obs_dict[tuple(obs)] = 0 # 遍历指令并执行 for com in commands: if com == -2: # 向左转90度 dx, dy = -dy, dx elif com == -1: # 向右转90度 dx, dy = dy, -dx else: # 使用循环，一步一步的走，便于判断与障碍物的关系 for j in range(com): next_x = x + dx next_y = y + dy # 遇到障碍物则停下 if (next_x, next_y) in ons_dict: break x, y = next_x, next_y # 计算当前与原点的距离和最大距离之间的关系 distance = max(distance, x*x + y*y) return distance","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之分发糖果","slug":"Leetcode之分发糖果","date":"2020-02-29T05:59:30.000Z","updated":"2020-07-06T05:15:42.000Z","comments":true,"path":"passages/leetcode-zhi-fen-fa-tang-guo/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-fen-fa-tang-guo/","excerpt":"Distribute Candies","text":"Distribute Candies Distribute Candies code with Python title number：575 简单 读题 给定一个长度为偶数的数组，其中不同的数字代表不同的糖果，每一个数组代表一个糖果 将这些糖果平均分给一个弟弟和一个妹妹 返回妹妹可以获得的最大糖果的种类数 即每个人获得的糖果数必须相同，当是妹妹要获得糖果的种类要尽量的多 思路一 由于糖果的数目是偶数，所以我们要做到两个人的糖果数量一样多，并且每个人只能获得n/2颗糖果 如果糖果种类数大于等于n/2，那么妹妹最多得到n/2种糖果 如果糖果种类数小于n/2，那么妹妹能够得到的糖果种类可以是实际的糖果种类数（至少一种一颗） 至此，分析结束，我们发现这道题并不需要想办法求所有可能的分发，只需要统计糖果的种类个数即可 1234567891011def distributeCandies(self, candies: List[int]) -&gt; int: num = &#123;&#125; for candy in candies: if candy in num: num[candy] += 1 else: num[candy] = 0 if len(num) &gt;= len(candies) // 2: return len(candies) // 2 else: return len(num) 上面是使用字典统计的糖果种类，并且统计了每种糖果的数量，但是后者是我们不需要的，所以简化数据结构，尝试使用列表实现 123456789def distributeCandies(self, candies: List[int]) -&gt; int: num = [] for candy in candies: if candy not in num: num.append(candy) if len(num) &gt;= len(candies) // 2: return len(candies) // 2 else: return len(num) 列表实现超时？没找到原因 还可以使用集合set的特性（没有重复元素）来实现 123456def distributeCandies(self, candies: List[int]) -&gt; int: num = set(candies) if len(num) &gt;= len(candies) // 2: return len(candies) // 2 else: return len(num) 代码再简化（求糖果种类数和n/2的较小值） 12def distributeCandies(self, candies: List[int]) -&gt; int: return min(len(set(candies)), len(candies)//2)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之二叉搜索树中的众数","slug":"Leetcode之二叉搜索树中的众数","date":"2020-02-28T07:27:36.000Z","updated":"2020-07-06T05:13:06.000Z","comments":true,"path":"passages/leetcode-zhi-er-cha-sou-suo-shu-zhong-de-zhong-shu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-er-cha-sou-suo-shu-zhong-de-zhong-shu/","excerpt":"Find Mode in Binary Search Tree","text":"Find Mode in Binary Search Tree Find Mode in Binary Search Tree code with Python title number：501 简单 读题 给定一个二叉搜索树，其中存在相同的数 找出给定树中的所有众数 众数不一定只有一个，不考虑输出顺序 二叉树结构 12345class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None 二叉搜索树的特点 结点左子树中所含结点的值小于当前结点的值 结点右子树中所含结点的值大于当前结点的值 左右子树也都是二叉搜索树 思路一 比较容易想到的是通过遍历树得到所有结点的值，再次遍历有序数组，查找其中的众数 值得注意的是，在二叉树的遍历算法中，对于二叉搜索树，通过中序遍历可以直接得到一个有序数组 12345678910111213141516171819202122232425262728def findMode(self, root: TreeNode) -&gt; List[int]: if not root: return [] self.nums = [] self.inorderTraveral(root) res = [self.nums[0]] max_num, cur_num = 1, 1 for i in range(1, len(self.nums)): if self.nums[i] == self.nums[i-1]: cur_num = cur_num + 1 else: cur_num = 1 if cur_num == max_num: res.append(self.nums[i]) elif cur_num &gt; max_num: res = [] res.append(self.nums[i]) max_num = cur_num return resdef inorderTraveral(self, root): if not root: return self.inorderTraveral(root.left) self.nums.append(root.val) self.inorderTraveral(root.right) 思路二 思路一相当于对树中结点进行了两次遍历，我们尝试减少时间的使用 对树中结点进行遍历，使用字典存储树中的结点及其出现的次数，最后取字典中value最大的key输出 123456789101112131415161718192021def __init__(self): self.res = &#123;&#125; def findMode(self, root: TreeNode) -&gt; List[int]: result = [] if root == None: return [] self.visit(root) Max = max(self.res.values()) for key in self.res: if self.res[key]==Max: result.append(key) return resultdef visit(self, root): if root: if root.val in self.res: self.res[root.val] += 1 else: self.res[root.val] = 0 self.visit(root.left) self.visit(root.right)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之两整数之和","slug":"Leetcode之两整数之和","date":"2020-02-27T07:26:11.000Z","updated":"2020-07-06T05:21:52.000Z","comments":true,"path":"passages/leetcode-zhi-liang-zheng-shu-zhi-he/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-liang-zheng-shu-zhi-he/","excerpt":"Sum of Two Integer","text":"Sum of Two Integer Sum of Two Integer code with Python title number：371 简单 读题 不使用+和-来计算两个数的和 思路一 既然不允许直接使用加法和减法，那么我们只能借助其他的方式来替代这两中运算 首先想到的就是位运算，我们来看一下按位做加法的特点 12340 + 0 = 00 + 1 = 11 + 1 = 01 + 0 = 1 经观察不难发现，这就是位运算中的异或运算 但是使用异或运算只能实现无进位的加法，如何实现进位操作呢，再次观察上面的例子，我们发现，通过与运算可以获得该位置上运算得到的进位 但是，这样得到的进位是在本位置上的，而实际上的进位要在其更高一位的位置上（左侧一位） 所以： 用二进制运算求和可以分为两部分：a和b的无进位结果；a和b的进位情况 前者通过异或运算得到 后者通过与运算和移位（左移一位）得到 循环此过程，直到进位为0，结果即为所求 在Python中需要特殊处理的是： 由于Python中整数不是32位的，我们需要手动对Python中的整数进行处理，手动模拟32位整数 具体来说可以对0x100000000（16进制）取模，得到低位的32位数 123456789101112def getSum(self, a: int, b: int) -&gt; int: mask = 0x100000000 max_int = 0x7FFFFFFF min_int = max_int + 1 while b != 0: # 计算进位 carry = (a &amp; b) &lt;&lt; 1 # 无进位加法 a = (a ^ b) % mask b = carry % mask return a if a &lt;= max_int else ~((a % min_int) ^ max_int)","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之路径之和Ⅲ","slug":"Leetcode之路径之和Ⅲ","date":"2020-02-26T07:24:25.000Z","updated":"2020-07-06T05:22:17.000Z","comments":true,"path":"passages/leetcode-zhi-lu-jing-zhi-he-iii/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-lu-jing-zhi-he-iii/","excerpt":"Path Sum Ⅲ","text":"Path Sum Ⅲ Path Sum Ⅲ code with Python title number：437 简单 读题 给定一颗二叉树，每个结点存放一个整数 树的结点的形式 12345class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None 找出路径和等于给定数值的路径总数 路径不需要从根节点开始，也不必在叶子节点结束，但方向需要向下 示例 123456789101112131415root &#x3D; [10,5,-3,3,2,null,11,3,-2,null,1], sum &#x3D; 8 10 &#x2F; \\ 5 -3 &#x2F; \\ \\ 3 2 11 &#x2F; \\ \\3 -2 1返回3,和等于8的路径有:1. 5 -&gt; 32. 5 -&gt; 2 -&gt; 13. -3 -&gt; 11 思路一 初次读到题目，感觉有些复杂：路径的开头可以不是根节点，结束也可以不是叶子结点 简化一下问题，如果我们规定路径的开始结点必须是根节点，那么我们通过一次遍历就可以得到所有的路径 再进一步，我们可以将树中的任意内部节点作为”根节点”，找到所以以该”根节点”为根的二叉树中符合条件的路径 对的，这样就行成了一个递归结构。其实对于这种问题，首先想到的就是使用递归解决，但是困难的地方在于找到其中的递归结构 123456789101112131415161718def pathSum(self, root: TreeNode, sum: int) -&gt; int: if root == None: return 0 return self.paths(root, sum) + self.pathSum(root.left, sum) + self.pathSum(root.right, sum)def paths(self, root, sum): if root == None: return 0 res = 0 if root.val == sum: res += 1 res += self.paths(root.left, sum - root.val) res += self.paths(root.right, sum - root.val) return res 思路二 第一种方法的递归比较好理解，但是是双重递归，时间复杂度比较高 可否减少递归次数，或者减少计算的次数，从而达到减少耗费时间的目的呢，答案是肯定的 我们可以通过一次遍历，得到树中的所有节点 在此基础上，我们进行反向操纵，即每遍历到一个结点，判断在包含该节点的路径上是否路经本身或者子路径符合条件 由于只进行一次遍历，所以每便利到一个结点时进行的反向计算并不会有重复 1234567891011121314151617181920def pathSum(self, root: TreeNode, sum: int) -&gt; int: self.data = [] # 保存路径上的结点 self.count = 0 # 统计符合的路径数目 self.recursive(root, sum) return self.countdef recursive(self, root, sum): if root == None: return 0 self.data.append(root.val) cur = 0 for i in range(len(self.data)-1, -1, -1): cur += self.data[i] if cur == sum: self.count += 1 self.recursive(root.left, sum) self.recursive(root.right, sum) self.data.pop()","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之两个数组的交集","slug":"Leetcode之两个数组的交集","date":"2020-02-25T08:40:23.000Z","updated":"2020-07-06T05:20:28.000Z","comments":true,"path":"passages/leetcode-zhi-liang-ge-shu-zu-de-jiao-ji/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-liang-ge-shu-zu-de-jiao-ji/","excerpt":"Intersection of Two Array","text":"Intersection of Two Array Intersection of Two Array code with Python title number：349 简单 读题 给定两个数组，计算两个数组的交集 结果中的每个元素是唯一的 不考虑输出结果的顺序 思路一 比较直接的想法是，依次判断nums1中的元素是否在nums2中，如果在，则添加到交集中 因为结果中的每个元素是唯一的，所以要事先对数组进行去重操作，可以使用set事先 123456def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: inter = [] for num in set(nums1): if num in set(nums2): inter.append(num) return inter 思路二 比较取巧的方法，使用语言本身的内置函数 123def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: return list(set(nums1) &amp; set(nums2)) 思路三 上面的两种方法对数组的遍历多次数组，这必定会造成时间上的浪费 使用双指针可以对两个数组只遍历一遍 首先对两个数组进行去重操作，之后再进行排序 设置两个指针，分别指向排序后的两个数组的头部 比较指针指向的两个元素是否相同，若相同则添加到交集中，并将两个指针后移 否则将指向较小元素的指针后移 123456789101112131415def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: inter = [] nums1, nums2 = list(set(nums1)), list(set(nums2)) nums1.sort(), nums2.sort() i, j = 0, 0 while i &lt; len(nums1) and j &lt; len(nums2): if nums1[i] == nums2[j]: inter.append(nums1[i]) i += 1 j += 1 elif nums1[i] &lt; nums2[j]: i += 1 else: j += 1 return inter","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之4的阶乘","slug":"Leetcode之4的阶乘","date":"2020-02-24T08:38:55.000Z","updated":"2020-07-06T05:08:26.000Z","comments":true,"path":"passages/leetcode-zhi-4-de-jie-cheng/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-4-de-jie-cheng/","excerpt":"Power of Four","text":"Power of Four Power of Four code with Python title number：342 简单 读题 给定一个整数（32位有符号数），判断这个是是否为4的幂次方 进阶：尝试不使用循环或者递归实现 思路一 比较直接的想法就是不停的除以4直到不能整除，判断最后的数是否为整数 1234def isPowerOfFour(self, num: int) -&gt; bool: while num and num % 4 == 0: num /= 4 return num == 1 思路二 还有一种更为直接的想法，既然给定的数是32位有符号整数，经过计算，32位有符号整数所能表达的最大的4的幂次方为$4^{15}$ 因此，我们可以穷举所有可能，判断给定的数是否在穷举的结果中即可 注意，4的幂肯定是正整数啊 12345def isPowerOfFour(self, num: int) -&gt; bool: prob = [] for i in range(0, 16): prob.append(pow(4, i)) return num in prob 思路三 下面根据数字本身的数学特点想到的方法 首先观察$num = 4^x$，那么，$x = log_4x = \\frac{1}{2}log_2x$，此处的x应该是整数 再进一步，我们只需要判断$log_2x$是否为偶数即可 1234from math import log2class Solution: def isPowerOfFour(self, num: int) -&gt; bool: return num &gt; 0 and log2(num) % 2 == 0 思路四 位运算 因为4的幂次方必定是2的幂次方，观察2的幂次方的二进制表示 123456789102 104 1008 100016 1000032 10000064 1000000128 10000000256 100000000512 10000000001024 10000000000 可以发现，4的幂次方的二进制中，1出现在奇数位上（很重要的特点） 我们想要找到一个特殊的数：奇数位为1，偶数位为0，这样的一个数与4的幂次方进行与运算，得到的结果与原来的数相同 1010101010101010101010101010101 123456789def isPowerOfFour(self, num: int) -&gt; bool: if num &lt;= 0: return False # 是否为2的幂次方 if (num &amp; num - 1) != 0: return False # 是否为4的幂次方 if num &amp; 0x55555555 == num: return True 注意，一定要先判断数字是否为2的幂次方，否则5,9这种数在进行与运算时也会返回True 代码简化 12def isPowerOfFour(self, num: int) -&gt; bool: return num &gt; 0 and (num &amp; num-1)==0 and num &amp; 0x55555555 == num","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之移动0元素","slug":"Leetcode之移动0元素","date":"2020-02-23T08:37:36.000Z","updated":"2020-07-06T05:30:07.000Z","comments":true,"path":"passages/leetcode-zhi-yi-dong-0-yuan-su/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-yi-dong-0-yuan-su/","excerpt":"Move Zeros","text":"Move Zeros Move Zeros code with Python title number：283 简单 读题 给定一个数组，将数组中所有的数字0移动到数字的末尾 同时需要保证非0元素的相对顺序 需要在原数组上进行操作，不能使用额外的存储空间 示例：[0,1,0,3,12] -&gt; [1,3,12,0,0] 思路一 如果没有限制使用额外空间的话，我们可以分别使用两个数组保存0和非0元素，最后将两个数组进行拼接即可 在不能使用额外数组的限制条件下，需要转变一下思路 0元素最后必定出现在数组的末尾，那么我们可以只操作非0元素，最后在数组后面补0即可 使用快慢指针，fast用于遍历数组，slow用于指向非0元素的最后一位 123456789def moveZeroes(self, nums: List[int]) -&gt; None: fast = slow = 0 while fast &lt; len(nums): if nums[fast] != 0: nums[slow] = nums[fast] slow += 1 fast += 1 for i in range(slow, fast): nums[i] = 0 思路二 思路一对数组的遍历多于一遍，我们尝试节省这部分时间 遍历数组，第一次遇到非0元素就与nums[0]交换位置 依次类推，第i次遇到非0元素就与nums[i]交换，直到遍历结束 123456def moveZeroes(self, nums: List[int]) -&gt; int: i, j = 0 for i in range(len(nums)): if nums[fast] != 0: nums[j], nums[i] = nums[i], nums[j] j += 1","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之丑数","slug":"Leetcode之丑数","date":"2020-02-22T03:04:41.000Z","updated":"2020-07-06T05:10:04.000Z","comments":true,"path":"passages/leetcode-zhi-chou-shu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-chou-shu/","excerpt":"Ugly Number","text":"Ugly Number Ugly Number code with Python title number：263 简单 读题 判断给定的数是否为ugly number 所谓ugly number指的是只包含质因数2,3,5的正整数 思路一 问题的关键在于求质数 首先想到的是先将给定的数进行质数分解，之后再判断分解得到的质数序列中是否含有除2,3,5之外的质数 但是这样需要进行质数分解并且需要使用额外的空间来存储质数序列，和额外的时间来再次遍历质数序列 换一种思路，我们对给定的数字不断除以2,3,5，如果最后的数字不是1，则返回False 12345678910111213141516def isUgly(self, num: int) -&gt; bool: if num &lt;= 0: return False while True: last = num if not num % 2: num = num // 2 if not num % 3: num = num // 3 if not num % 5: num = num // 5 if num == 1: return True if last = num: return False 重构一下代码 1234567def isUgly(self, num: int) -&gt; bool: if num &lt;= 0: return False for x in [2, 3, 5]: while not num % x: num = num // x return num == 1 第二种实现方法的用时明显减少 经分析可能是对于8这种只包含其中一个质数的可以减少很多无用的计算和判断","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之使用栈实现队列","slug":"Leetcode之使用栈实现队列","date":"2020-02-22T03:03:30.000Z","updated":"2020-07-06T05:27:06.000Z","comments":true,"path":"passages/leetcode-zhi-shi-yong-zhan-shi-xian-dui-lie/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-shi-yong-zhan-shi-xian-dui-lie/","excerpt":"Implement Queue using Stack","text":"Implement Queue using Stack Implement Queue using Stack code with Python title number：232 简单 读题 使用栈实现队列的以下功能 push(x)：将一个元素放入队列尾部 pop()：从队列首部移除元素 peek()：获取最前端的元素 empty()：返回队列是否为空 只能使用栈的标准操作，对于不支持栈的语言可以使用list代替 思路一 这个题没有什么特别的思路，重要的是理解栈和队列两种数据结构的特点 栈：先进后出，只能在一端进行操作 队列：先进先出，只能在队头出元素，在队尾进元素 我们使用两个栈来实现队列 一个用来反转元素的入队顺序 一个用来存储元素的最终顺序 入队操作 队列是先进先出的，而栈是先进后出的 最新压入栈的元素需要在栈底，所以我们将栈S1中的所有元素移到栈S2中实现顺序的反转，并将新元素压入S1中，再将S2中的元素放回S1，这时S1中元素的顺序就是队列中的顺序了 出队操作 直接从S1中弹出即可 判空操作 只需要检查S1中是否为空即可 取队首元素 使用front存储队首元素 每次出队入队时都要更新该值 需要的时候只需要返回该值即可 1234567891011121314151617181920class MyQueue: def __init__(self): self.stack = [] self.help_stack = [] def push(self, x: int) -&gt; None: while self.stack: self.help_stack.append(self.stack.pop()) self.stack.append(x) while self.help_stack: self.stack.append(self.help_stack.pop()) def pop(self) -&gt; int: return self.stack.pop() def peek(self) -&gt; int: return self.stack[-1] def empty(self) -&gt; bool: return not bool(self.stack) 思路二 上一种方式使用了辅助栈，需要先弹出再还原，每个元素会访问两遍，所以使用的时间比较多 仍然是使用辅助栈，一个用于输入，一个用于输出 当需要查看或者出队时，我们将输出栈中的元素放入输出栈中，从输出栈中进行输出 当输出栈不为空时可直接从输出栈中输出元素 要保证输出栈中为空的时候才能向其中放入元素 并且一次需要将输入栈中的所有元素全放入输出栈 写一个辅助函数shift用于将输入栈中元素一次性全部放入输出栈中 123456789101112131415161718192021222324252627282930class MyQueue: def __init__(self): self.stack_in = [] self.stack_out = [] def push(self, x: int) -&gt; None: self.stack_in.append(x) def pop(self) -&gt; int: self.shift() return self.stack_out.pop() def peek(self) -&gt; int: self.shift() return self.stack_out[-1] def empty(self) -&gt; bool: if not self.stack_in and not self.stack_out: return True return False def shift(self): if not self.stack_out: while self.stack_in: self.stack_out.append(self.stack_in.pop())","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之反转二叉树","slug":"Leetcode之反转二叉树","date":"2020-02-20T02:22:44.000Z","updated":"2020-07-06T05:13:42.000Z","comments":true,"path":"passages/leetcode-zhi-fan-zhuan-er-cha-shu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-fan-zhuan-er-cha-shu/","excerpt":"Inverted Binary Tree","text":"Inverted Binary Tree Inverted Binary Tree code with Python title number： 226 简单 读题 反转二叉树 左右子树互换 示例 给定二叉树结构 12345class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None 思路一 非常经典的树结构的问题，很适合使用递归方法来解决 如果根节点为空，则返回None 否则递归反转其左右子树 边界条件：结点无左右子女 12345678910def invertTree(self, root: TreeNode) -&gt; TreeNode: if root == None: return None right = self.invertTree(root.right) left = self.invertTree(root.left) root.left = right root.right = left return root 思路二 还可以使用迭代的方式进行 类似于深度优先搜索，我们使用一个队列来协助完成 队列中存储所有还未交换左右子女的结点 初始情况下只有根节点在队列中 出队根节点，交换其左右子女，并且左右子女入队；依次执行，直到树被遍历完 本题的重点在于遍历树的每个节点，只要能访问到树的每个节点，皆可以实现二叉树的反转，至于使用哪种遍历方式则没那么讲究 12345678910111213def inverTree(self, root: TreeNOde) -&gt; TreeNode: if root == None: return None queue = [] queue.append(root) while queue &gt; 0: cur = queue.pop(0) cur.left, cur.right = cur.right, cur.left if cur.left != None: queue.append(cur.left) if cur.right != None: queue.append(cur.right) return root 迭代和递归的区别 简单来说，递归是程序调用自身的一种编程技巧，通常把一个大型的复杂的问题转化为一个与原问题相似的规模较小的问题来解决 而迭代是利用变量的原值推算出变量的新值，是A不断调用B的过程 总体来说，递归中一定有迭代，而迭代中不一定有递归。 大部分情况下可以相互转化，优先选择使用迭代，因为递归调用函数浪费空间，并且递归的太深容易造成堆栈的溢出","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之包含重复数Ⅱ","slug":"Leetcode之包含重复数Ⅱ","date":"2020-02-19T08:02:31.000Z","updated":"2020-07-06T05:08:53.000Z","comments":true,"path":"passages/leetcode-zhi-bao-han-chong-fu-shu-ii/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-bao-han-chong-fu-shu-ii/","excerpt":"Contains Duplicate Ⅱ","text":"Contains Duplicate Ⅱ Contains Duplicate Ⅱ code with Python title number：219 简单 读题 给定一个整数数组和一个整数K 判断数组中是否存在两个不同的位置的元素值相等，并且这两个元素的索引之差的绝对值大于K 思路一 因为需要在给定的数组中查找相同元素，找到之后再判断两者索引之差是否符合要求 这里可以使用一个哈希表来存储，将相同元素的下标存储到一起 具体来说，使用一个字典，key为元素值，value为元素的下标 如果nums[i]不在字典中，则将nums[i]添加到字典中，同时将value设置为其索引 如果nums[i]在字典中，则判断当前的nums[i]的索引与字典中nums[i]对应的value的差值是否符合情况 注意：在数组遍历完之前不能因为一次的判断不符合就返回False，正确的做法是更新字典中nums[i]对应的索引 123456789101112def containsNearbyDuplicate(self, nums: List[int], k: int) -&gt; bool: hash = &#123;&#125; for i in range(len(nums)): if nums[i] not in hash: hash[nums[i]] = i else: if i - hash[nums[i]] &lt;= k: return True else: hash[nums[i]] = i return Fasle 题目比较简单，暂时没有想到其他的思路，做一下代码的简化 12345678def containsNearbyDuplicate(self, nums: List[int], k: int) -&gt; bool: hash = &#123;&#125; for index, num in enumerate(nums): if num in hash and index - hash[num] &lt;= k: return True hash[num] = index return False 思路二 这个方法时间复杂度太高，不可行 遍历数组，每检查一个数，就去遍历其后面k个数，看是否有相等的，有则返回True 当数组遍历完仍未发现符合的情况，则返回False 1234567def containsNearbyDuplicate(self, nums: List[int], k: int) -&gt; bool: for index, num in enumerate(nums): for i in range(1, k+1): if index+i &lt; len(nums): if num == nums[index+i]: return True return False","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之反转链表","slug":"Leetcode之反转链表","date":"2020-02-18T08:01:25.000Z","updated":"2020-07-06T05:13:50.000Z","comments":true,"path":"passages/leetcode-zhi-fan-zhuan-lian-biao/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-fan-zhuan-lian-biao/","excerpt":"Reverse Linked List","text":"Reverse Linked List Reverse Linked List code with Python title number：206 简单 读题 反转链表 迭代 or 递归 关键词：链表 思路一 典型的链表操作 最直接的想法就是使用一个等长的数组存储链表的元素 反向遍历数组，并将链表中的结点的值修改即可 12345678910111213def reverseList(self, head: ListNode) -&gt; ListNode: nums = [] cur = head while cur: nums.append(cur.val) cur = cur.next cur = head for i in range(len(nums), 0, -1): cur.val = nums[i-1] cur = cur.next return head 可以通过，但是耗费的时间比较多，对链表进行了两次遍历 思路二 将链表反转，实际上只需要把所有的指针方向改变即可 还有一个要改变的地方是原来的头指针要指向null 这里使用双指针迭代法 设置两个指针：pre和cur 初始情况下：pre=null, cur=head 将cur指向pre，之后不断迭代cur，每次迭代cur都将cur-&gt;next指向pre，同时将pre和cur同时向后移 12345678910def reverseList(self, head: ListNode) -&gt; ListNode: pre = None cur = head while cur: tmp = cur.next cur.next = pre pre = cur cur = tmp return pre 思路三 递归，本质上还是指针方向的改变 既然是递归，我们就像想一下终止条件等问题 终止条件：当前结点或下一节点指向null 递归主体：当前结点的下一个结点的next指向当前结点 12345678910def reverseList(self, head: ListNode) -&gt; ListNode: if head==None or head.next==null: return head # 跳出递归时指向的是最后一个元素 cur = self.reverseList(head.next) head.next.next = head head.next = None return cur 思路四 相信在学习数据结构中链表的插入时，都学过一种名叫头插法的插入方式 可以利用这种方式，在遍历链表的过程中，不断将链表结点添加到链表的头部 123456789101112def reverseList(self, head: ListNode) -&gt; ListNode: if head == None: return cur = head.next # 用于遍历链表 head.next = None head_ = head while cur: temp = cur.next cur.next = head_ head_ = cur cur = temp return head_","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之删除链表元素","slug":"Leetcode之删除链表元素","date":"2020-02-17T07:59:52.000Z","updated":"2020-07-06T05:25:29.000Z","comments":true,"path":"passages/leetcode-zhi-shan-chu-lian-biao-yuan-su/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-shan-chu-lian-biao-yuan-su/","excerpt":"Remove Linked List Elements","text":"Remove Linked List Elements Remove Linked List Elements code with Python title number：203 简单 读题 删除链表中等于给定值val的所有结点 关键词：链表 Python中给定的链表结构 1234class ListNode: def __init__(self, x): self.val = x self.next - None 思路一 常规的链表题目 双指针：pre, cur，分别指向前一个元素和当前元素 初始，pre=head，cur=head 遍历列表，遇到需要删除的结点时，将pre-&gt;next指向cur-&gt;next 需要单独处理几种特殊情况： 链表为空 待删除结点在链表头部 1234567891011121314151617181920def removeElement(self, head: ListNode, val: int) -&gt; ListNode: # 链表为空 if not head: return None # 待删除元素为第一个结点 while head and head.val == val: head = head.next pre, cur = head, head while cur != None: if cur.val == val: # 删除当前元素 cur = cur.next pre.next = cur else: pre = cur cur = cur.next return head 添加一个在头部的辅助结点，将几种特殊情况转化为可以一起处理的通用情况 1234567891011def removeElement(self, head: ListNode, val: int) -&gt; ListNode: prev =ListNode(0) prev.next = head cur = prev while cur.next: if cur.next.val == val: cur.next = cur.next.next else: cur = cur.next return prev.next","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之打家劫舍","slug":"Leetcode之打家劫舍","date":"2020-02-16T04:03:32.000Z","updated":"2020-07-06T05:10:22.000Z","comments":true,"path":"passages/leetcode-zhi-da-jia-jie-she/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-da-jia-jie-she/","excerpt":"House Robber","text":"House Robber House Robber code with Python title number：198 简单 读题 你是一个小偷，计划偷沿街的房子，要求在限定条件下取得尽可能多的现金 当你在同一晚上潜入了相邻的两间房子，警报会被触发 例如：[1,2,3,1] 即相邻的四座房子中分别可以偷到金额为1,2,3,1的现金 最佳方案是偷第一间和第三间房子，获得金额为4的现金 关键词：动态规划 思路一 习惯了暴力求解，这道题其实也可已通过穷举所有可能进行求解，但是考虑所有可能的抢劫方案过于困难 但是这是一道动态规划的题目，天生的动态规划题目，哈哈 动态规划的本质在解决第i个元素取不取的问题，对应到该题目就是第i个房子抢不抢的问题 我们前i个房子能获得的最大价值为dp[i] 判断的依据就是抢与不抢两种情况下哪一种带来的价值最大 如果抢的话，当前获得的总价值就是nums[i] + dp[i-2]（相邻房子不能抢） 如果不抢的话，当前获得的总价值就是dp[i-1] 所以最难确定的状态转移方程就是dp[i]=max(dp[i-2]+nums[i], dp[i-1]) 初始状态：dp[0]=0 返回值为dp的最后一个元素，即所有房间可以获得的最大价值 123456789101112def rob(self, nums: List[int]) -&gt; int: if len(nums) == 0: return 0 if len(nums) == 1: return nums[0] dp = nums dp[0], dp[1] = nums[0], max(nums[0], nums[1]) for i in range(2, len(nums)): dp[i] = max(dp[i-2]+nums[i], dp[i-1]) return dp[len(nums)-1] 由于dp[i]只与dp[i-1]和dp[i-2]有关，设置两个变量交替存储，代替使用dp数组，可以减少空间的使用 123456789101112def rob(self, nums: List[int]) -&gt; int: if not nums: return 0 length = len(nums) if length == 1: return nums[0] prev= nums[0] cur = max(prev, nums[1]) for i in range(2, length): cur, prev = max(prev+nums[i], cur), cur return cur 将cur和pre初始设置为0，可以将nums长为1和0的两种情况包含进来，进一步简化代码 12345def rob(self, nums: List[int]) -&gt; int: cur, pre =0, 0 for num in nums: cur, pre = max(pre+num, cur), cur return cur","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之位1的个数","slug":"Leetcode之位1的个数","date":"2020-02-15T08:54:01.000Z","updated":"2020-07-06T05:28:46.000Z","comments":true,"path":"passages/leetcode-zhi-wei-1-de-ge-shu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-wei-1-de-ge-shu/","excerpt":"Number of 1 Bits","text":"Number of 1 Bits Number of 1 Bits code with Python title number：191 简单 读题 给定一个无符号整数，返回其二进制表达式中1的个数 也称为汉明重量 思路一 比较直接的方法就是，遍历数字的32位，如果某一个二进制位为1，则计数加一，最后返回计数即可 123456def hammingWeight(self, n: int) -&gt; int: n = bin(n) for c in n: if c == '1': count += 1 return count 思路二 按照十进制转二进制的方式，每得到一位，判断其是否为1 注意，区别与之前翻转二进制的题目，这里统计的是1的个数，并不需要补零的操作 12345678def hammingWeight(self, n: int) -&gt; int: count = 0 while n: res = n % 2 if res == 1: count += 1 n //= 2 return count 由于中间涉及比较多的计算，耗费的时间比较多 思路三 我们知道两个不同长度的二进制数进行运算，会将长度较短的二进制数左端补零。 根据这一特性，将n与1进行与运算，将能得到n的最低位数字 之后再将n右移一位 重复以上操作，直到n==0 123456def hammingWeight(self, n: int) -&gt; int: count = 0 while n: count += n&amp;1 n &gt;&gt;= 1 return count 花费的时间比较少 总结 三个思路基本思想一致，都是遍历每位，判断是否是1，然后计数 区别在于获取每一位的方式不同 其中第三种方法分要注意，重点是其中涉及到的二进制运算的知识","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之翻转二进制位","slug":"Leetcode之翻转二进制位","date":"2020-02-15T08:52:46.000Z","updated":"2020-07-06T05:13:32.000Z","comments":true,"path":"passages/leetcode-zhi-fan-zhuan-er-jin-zhi-wei/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-fan-zhuan-er-jin-zhi-wei/","excerpt":"Reverse Bits","text":"Reverse Bits Reverse Bits code with Python title number：190 简单 读题 颠倒给定的32位无符号整数的二进制位 关键词：位运算 无符号整数 计算机中的数是用二进制表示的 最左边的这一位如果用来表示这个数是正数还是负数，这样的数被称为有符号整数 最左边的这一维如果不用来表示这个数是正还是负，这样的数被成为无符号整数，无符号整数只能是正数 位运算相关操作123456789&lt;&lt; 按位左移，左移n位相当于乘以2的n次方&gt;&gt; 按位右移，右移n位相当于除以2的n次方&amp; 按位与，参与计算的两个二进制位同且为1，结果为1，否则为0| 按位或，参与计算的两个二进制位有1，结果为1，否则为0^ 按位异或，参与计算的两个二进制位不同，结果为1，否则为0~ 按位取反，参与计算的二进制位中0变为1，1变成0python中，将整数取反之后要进行切片，去掉前面的0bbin(num) 将整数转化为二进制数 思路一 最先联想到的是字符串的翻转 使用两个指针，分别指向字符串的头和尾 交换两个指针指向的元素，直到指针相遇或相邻（奇数位相遇，偶数位相邻） 但是这个问题中的二进制整数并不能通过下标访问每一位，所以需要有所改动 比较直接的方法就是将二进制转化为字符串再进行翻转，位数不够进行补位，最后再转化为整数 12345def reverseBits(self, n: int) -&gt; int: str1 = bin(n)[2:][::-1] while len(str1) &lt; 32: str1 += '0' return int(str1, 2) 由于是32位无符号整数，我们进行转化得到的数可能是高位有0，而在Python中转化之后是没有的，但是反转之后要在最后面追加0 例如： 1234567str1 = bin(n) # 0b10100101000001111010011100str1 = bin(n)[2:] # 10100101000001111010011100str1 = bin(n)[2:][::-1] # 00111001011110000010100101# 可以看到，翻转之后的数字是不够32位的，所以要在后面追加0while len(str1) &lt; 32: str1 += '0'# 00111001011110000010100101000000 思路二 位运算 回想反转10进制的时候，我们的操作是这样的 12ans = ans * 10 + n % 10n /= 10 同样的，反转二进制我们也可以如此 12ans = ans * 2 + n % 2n /= 2 但是要额外处理的问题还是高位的0 比如：00110 计算得到的是 011，而实际应该得到的是01100 所以，要计算指定次数 -&gt; 32次，而不是ans为0结束 另外，上面的四则元算可以用位运算代替 1234ans = (ans &lt;&lt; 1) | (n &amp; 1)n &gt;&gt;= 1# n&amp;1 == 1, 说明n的最后一位是1, n&amp;1 == 0, 说明n的最后一位是0 123456def reverseBits(self, n: int) -&gt; int: ans = 0 for i in range(32): ans = (ans &lt;&lt; 1) | (n &amp; 1) n &gt;&gt;= 1 return ans","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之多数元素","slug":"Leetcode之多数元素","date":"2020-02-15T08:48:18.000Z","updated":"2020-07-06T05:11:20.000Z","comments":true,"path":"passages/leetcode-zhi-duo-shu-yuan-su/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-duo-shu-yuan-su/","excerpt":"Majority Element","text":"Majority Element Majority Element code with Python title number：169 简单 读题 给定一个大小为n的数组，找到其中多数的元素 多数元素：在数组中出现的次数大于n/2 给定的数组中肯定存在多数元素 关键字：位运算、数组、分治算法 思路一 使用字典结构 如果元素不在字典中，将元素加入字典，并设置value为1 如果元素在字典中，value计数加一 123456789101112def majorityElement(self, nums: List[int]) -&gt; int: count = dict() for x in nums: if x in count.keys(): count[x] += 1 else: count[x] = 1 for key in count.keys(): if count[key] &gt; len(nums)/2: return key 时间复杂度高的感人，不过还是AC了 思路一优化 使用哈希表代替字典结构，这样可以减少空间复杂度，也能减小时间复杂度 123def majorityElement(self, nums: List[int]) -&gt; int: count = collections.Counter(nums) return max(count.keys(), key=count.get) 空间复杂度有所下降，时间复杂度没有明显改善 思路二 将数组中元素排序，排序之后的数组中，多数元素的出现位置有规律 如果多数元素是数组中的最小值，那么数组中第（n为偶数时，n/2+1；n为奇数时n/2）个元素必为多数元素 如果多数元素是数组中的最大值，同理 如果多数元素既不是最小值也不是最大值，那么有序数组的中间元素必为多数元素 123def majorityElement(self, nums: List[int]) -&gt; int: nums.sort() return nums[len(nums)//2] 思路三 随机数（类似抽奖） 因为多数元素在数组中占据的位置大于50%，所以我们可以每次取一个数 遍历一遍数组，判断取出的数是否为多数元素 这种做法可能会永远取不到多数元素（无穷），但是也有可能一次成功（线性时间） 12345678910def majorityElement(self, nums: List[int]) -&gt; int: majority_num = len(nums) // 2 while True: rand = random.choice(nums) count = 0 for x in nums: if x == rand: count += 1 if count &gt; majority_num: return rand 可以AC 思路四 投票算法 遍历nums，初始情况下将第一个元素作为候选的多数元素， 在遍历的过程中，遇到候选的多数元素，则计数器加一，否则减一 当计数器为0时，则遗忘掉之前的元素，使用下一个元素作为新的候选多数元素，继续遍历 这种算法直觉上不好判断它的正确性，我们来分析一下 举个例子：[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7] 在上述例子中，竖线位置处计数器会归零，也就是说，在竖线之前我们忽略掉了同样多数目的多数元素和非多数元素，在剩下的数组元素中，原来的多数元素仍是现在的多数元素，可以放心求解 总会有一组后缀会使计数器大于0，此时的候选多数元素即为所求 1234567891011def majorityElement(self, nums: List[int]) -&gt; int: count = 0 candidate = None for num in nums: if count == 0: candidate = num if num == candidate: count+=1 else: count-=1 return candidate 思路五 想法与思路四类似，不过借用了栈来辅助，更加直观一些 遍历数组，将元素入栈 如果后来的元素与栈顶元素相同，则出栈栈顶元素，否则入栈 栈顶元素即为多数元素，最终返回栈顶元素 123456789def majorityElement(self, nums: List[int]) -&gt; int: stack = [] for num in nums: if len(stack)==0 or stack[len(stack)-1] == num: stack.append(num) else: stack.remove(stack[len(stack)-1]) return stack[len(stack)-1] 时间复杂度感人，但是可以AC 用来帮助理解投票算法","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之阶乘后的0","slug":"Leetcode之阶乘后的0","date":"2020-02-12T05:05:36.000Z","updated":"2020-07-06T05:18:56.000Z","comments":true,"path":"passages/leetcode-zhi-jie-cheng-hou-de-0/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-jie-cheng-hou-de-0/","excerpt":"Factorial Trailing Zeroes","text":"Factorial Trailing Zeroes Factorial Trailing Zeroes code with Python title number：172 简单 读题 给定一个整数n，返回$n!$结果位数中零的个数 例如： 3! = 6，所以返回0 5! = 120，所以返回1 时间复杂度应为$O(logn)$ 关键词：数学 思路一 最直接的想法就是对指定的整数先求阶乘，然后判断阶乘结果尾部0的个数 但是这种方法很容易就溢出，并且这种方法并不满足时间复杂度为O(logn) 思路二 这种题目并没有通用的解法，只能通过对题目的理解寻找解决方案 首先我们知道，结尾处的0与数字10有很强的关联，即每乘一个10，答案的结尾就会出现一个0 所以问题转化成了阶乘中能得出几个10，我们又发现，想要的到10，需要2和5相乘（1*10不行，因为已经出现10了） 所以问题又转化了，转化成寻找阶乘中有多少对2,5 例如： 5! = 120是因为：5! = 5 * 4 * 3 * 2 * 1，其中出现了一对2，5，所以结果的末尾有一个0 再看一个例子：11! = 11 * (5*2) * 9 * (4*2) * 7 * (3*2) * (5*1) * (2*2) * 3 * (2*1) * 1 其中，含2的因子有：(5*2),(4*2),(3*2),(2*2),(1*2) 含5的因子有：(5*2),(5*1) 可以发现，含有2的因子每隔两个出现一次，含有5的因子每隔5个出现一次。因此，2的个数一定是远多余5的 所以问题转化为，阶乘中有多少5 因为每隔5个数出现一个5，所以5的个数使用n/5就可以得到 另外，每个25个数出现的是两个5，每隔125个数，出现的是三个5 综上，5的个数可以通过n/5+n/25+n/125...计算得到 123456def trailingZeroes(self, n: int) -&gt; int: count = 0 while n &gt; 0: count += n//5 n = n // 5 return count 通过修改循环中计算的顺序，每次循环能减少一次计算，时间也大大减少了 123456def trailingZeroes(self, n: int) -&gt; int: count = 0 while n &gt; 0: n = n // 5 count += n return count 代码没有多少，主要考察的是分析问题和问题转化的能力，非常有趣的题目~","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之两数之和Ⅱ","slug":"Leetcode之两数之和Ⅱ","date":"2020-02-12T05:04:08.000Z","updated":"2020-07-06T05:21:40.000Z","comments":true,"path":"passages/leetcode-zhi-liang-shu-zhi-he-ii/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-liang-shu-zhi-he-ii/","excerpt":"Two Sum Ⅱ - Input array is sorted","text":"Two Sum Ⅱ - Input array is sorted Two Sum Ⅱ - Input array is sorted code with Python title number：167 简单 读题 给定一个升序排列的数组，找到两个数，使两者的加和等于目标数 要求返回两个数的下标，第一个数的下标要小于第二个数 说明： 每个输入答案唯一 关键字：数组、双指针、二分查找 思路一 最先想到的当然是暴力破解 双循环，每个元素分别与其他元素相加，判断是否得到目标数 要注意，两个下标不能相等，这个要在求和时判断 12345def twoSum(self, numbers: List[int], target: int) -&gt; List[int]: for i in range(len(numbers)): for j in range(i, len(numbers)): if numbers[i] + numbers[j] == target and i != j: return [i+1, j+1] 可能会超出时间限制 思路一优化 令temp=target-numbers[i]，使用二分查找在其余的元素中查找值与temp相等的数 找到之后，返回下标 123456789101112def twoSum(self, numbers: List[int], target: int) -&gt; List[int]: for i in range(len(numbers)): temp = target - numbers[i] left, right = i+1, len(numbers)-1 while left &lt;= right: mid = int((left+right)/2) if numbers[mid]==temp: return [i+1, mid+1] elif numbers[mid] &lt; temp: left = mid+1 else: right = mid-1 思路二 比较直观的思路，双指针 left指向左端点，right指向右端点 计算两个指针指向的元素的和，判断其与目标数的大小 大于目标数，则right左移 小于目标数，则left右移 12345678910def twoSum(self, numbers: List[int], target: int) -&gt; List[int]: left, right = 0, len(numbers)-1 while left &lt; right: if numbers[left] + numbers[right] &lt; target: left += 1 elif numbers[left] + numbers[right] &gt; target: right -= 1 else: return [left+1, right+1] 代码优化 1234567891011def twoSum(self, numbers: List[int], target: int) -&gt; List[int]: left, right = 0, len(numbers)-1 while left &lt; right: if numbers[left] + numbers[right] == target: return [left+1, right+1] elif numbers[left] + numbers[right] &lt; target: left += 1 else: right -= 1 return []","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之最小栈","slug":"Leetcode之最小栈","date":"2020-02-12T05:03:00.000Z","updated":"2020-07-06T05:34:33.000Z","comments":true,"path":"passages/leetcode-zhi-zui-xiao-zhan/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zui-xiao-zhan/","excerpt":"Min Stack","text":"Min Stack Min Stack code with Python title number：155 简单 读题 设计一个支持push、pop、top的栈，能在常数时间内找到栈中的最小元素 push()：将元素入栈 pop()：删除栈顶元素 top()：获取栈顶元素 getMin()：检索最小元素 关键词：栈、设计 思路一 常规思路，就是在普通栈的基础上，每次入栈的时候更新最小值 但是当最小值被出栈之后，由于最小值没有被更新，所以会出现问题 出栈的时候判断一下最小值有没有被出栈，如果被出栈了，需要遍历栈找到新的最小值 12345678910111213141516171819202122232425262728class MinStack: def __init__(self): self.min = float('inf') self.stack = [] def push(self, s: int) -&gt; None: self.stack.append(s) if s &lt; self.min: self.min = s def pop(self) -&gt;None: if not self.stack: return None temp = self.stack.pop() if temp == self.min: self.min = float('inf') for x in self.stack: if x &lt; self.min: self.min = x def top(self) -&gt; int: if not self.stack: return None temp = self.stack[-1] return temp def getMin(self) -&gt; int: return self.min 思路二 栈内存储的不是实际值，而是真实值与当前最小值之间的差值，并且在push和pop操作时更新最小值 仅当top操作取数据的时候，需要对数据进行还原（栈顶元素+上一个最小值） 关键问题是在还原数据时如何求得上一个最小值 如果栈顶元素小于0，说明栈顶元素是当前的最小值（栈顶元素当前值-上一个最小值，而上一个最小值只会比当前的最小值小），将其出栈会改变栈中的最小值，上一个最小值通过min - 栈顶元素 如果栈顶元素大于0，则出栈栈顶元素对最小值没有影响 1234567891011121314151617181920212223242526272829class MinStack: def __init__(self): self.min = float('inf') self.stack = [] def push(self, x: int) -&gt; None: self.stack.append(x-self.min) if s &lt; self.min: self.min = s def pop(self) -&gt;None: if not self.stack: return None temp = self.stack.pop() if temp &lt; 0: self.min -= temp def top(self) -&gt; int: if not self.stack: return None temp = self.stack[-1] if temp &lt; 0: return self.min else: return self.min + temp return temp def getMin(self) -&gt; int: return self.min","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之只出现一次的数字","slug":"Leetcode之只出现一次的数字","date":"2020-02-12T05:01:34.000Z","updated":"2020-07-06T05:31:35.000Z","comments":true,"path":"passages/leetcode-zhi-zhi-chu-xian-yi-ci-de-shu-zi/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zhi-chu-xian-yi-ci-de-shu-zi/","excerpt":"Single Number","text":"Single Number Single Number code with Python title number：136 简单 读题 给定一个非空数组，数组中只有一个元素出现的次数为1次，其余的元素出现的次数均为两次，找出只出现一次的元素 关键词：位运算，哈希表 不能使用额外空间，并且要将时间复杂度控制在线性时间 思路一 常规思路，时间复杂度取决于排序算法 对数组进行排序，排序后相同的元素都挨在一起 再对数组进行一次遍历即可找到唯一出现一次的元素 12345678def singleNumber(self, nums: List[int]) -&gt; int: nums.sort() for i in range(len(nums), 0, -1): if i-1 != 0 and i-1 &lt; len(nums): if nums[i-1]==nums[i-2]: del nums[i-1] del nums[i-2] return nums[0] 思路二 常规思路，时间复杂度$O(n^2)$ 使用字典结构，每遇到一个字典中未出现过的字，加入字典并计数 遍历字典中的key，取value为1的key 1234567891011def singleNumber(self, nums: List[int]) -&gt; int: dic = dict() for num in nums: if str(num) in dic.keys(): dic[str(num)] += 1 else: dic[str(num)] = 1 for key in dic.keys(): if dic[key] == 1: return key 思路三 常规思路，使用额外的空间 列表no_dup用于存储不重复的元素 遍历nums，如果不在no_dup中，则添加 若在no_dup中出现过，则删除 12345678def singleNumber(self, nums: List[int]) -&gt; int: no_dup = [] for num in nums: if num not in no_dup: no_dup.append(num) else: no_dup.remove(num) return no_dup[0] 思路四 比较难考虑的一种，利用二进制异或的性质： 任何数和本身异或则为0 任何数和0异或为其本身 满足结合律，即$a \\bigoplus a \\bigoplus b = a \\bigoplus b \\bigoplus a = b$ 初始设置single_number=0 遍历整个数组，与single_number依次做异或操作 123456def singleNumber(self, nums: List[int]) -&gt; int: single_number = 0 for num in nums: single_number ^= num return single_number 思路五 数学：$2*(a+b+c)-(a+a+b+b+c)=c$ 利用该公式即可得到唯一出现一次的元素的值（前提是只有一个元素出现一次，其余元素均出现两次） 123def singleNumber(self, nums: List[int]) -&gt; int: single_number = 2*sum(set(nums)) - sum(nums) return single_number","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之回文串Ⅱ","slug":"Leetcode之回文串Ⅱ","date":"2020-02-12T04:59:37.000Z","updated":"2020-07-06T05:17:05.000Z","comments":true,"path":"passages/leetcode-zhi-hui-wen-chuan-ii/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-hui-wen-chuan-ii/","excerpt":"Valid Palindrome Ⅱ","text":"Valid Palindrome Ⅱ Valid Palindrome Ⅱ code with Python title number：680 简单 读题 给定一个字符串，至多删除一个字符，判断能否变成回文串 字符串只包含a-z的小写字母 关键字：字符串 思路一 因为字符串只包含小写字母，无需对字符串进行处理 暴力破解 先判断未删除时是否是回文串 穷举所有的删除可能，然后判断字符串是否回文 思路二 使用双指针分别指向字符串的头部和尾部，遍历，判断指针指向的元素是否相同 若相同，则移动指针 若不同，则分别尝试删除两个指针指向的元素，再继续判断是否是回文串 1234567891011121314151617def validPalindrome(self, s: str) -&gt; bool: if s == s[::-1] return True left, right = 0, len(s)-1 while left &lt; right: if s[left] != s[right]: a = s[:left] + s[left+1:] if a == a[::-1]: return True b = s[:right] + s[right+:] if b == b[::-1]: return True return False else: left += 1 right -=1 return False","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之回文串","slug":"Leetcode之回文串","date":"2020-02-12T04:57:23.000Z","updated":"2020-07-06T05:16:56.000Z","comments":true,"path":"passages/leetcode-zhi-hui-wen-chuan/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-hui-wen-chuan/","excerpt":"Valid Palindrome","text":"Valid Palindrome Valid Palindrome code with Python title number：125 简单 读题 给定一个字符串，判断其是否是回文串 不考虑大小写 从示例来看，不考虑空格和标点 关键字：双指针，字符串 思路一 很容易想到的是双指针（头尾指针） 头指针指向第一个元素，尾指针指向最后一个元素 先判断指针指向的元素是否是数字or字母，不是则跳过 如果两个指针指向的元素不同，返回false 如果两个指针指向的元素相同，则移动指针（头指针向后，尾指针向前） 直到两个指针相遇 123456789101112131415def isPalindrome(self, s: str) -&gt; bool: left, right = 0, len(s)-1 while left &lt; right: if not s[left].isalnum(): left += 1 continue if not s[right].isalnum(): right -= 1 continue if s[left].lower() == s[right].lower(): left += 1 right -= 1 else: return False return True 注意：isalnum()，字符串自带函数，用于判断字符串是否只由数字和字母组成 思路二 还是双指针，只是对字符串进行了预处理，将非数字和字母的元素删除 可以使用额外的空间来存储顺序字母和数字 可以在原字符串上操作，需要从后向前操作，放置数组访问出错 主体操作还是头尾两个指针 12345678910111213def isPalindrome(self, s: str) -&gt; bool: s_temp = [] for i in range(len(s)): if not s[i].isalnum(): s_temp.append(s[i].lower()) left, right = 0, len(s)-1 while left &lt; right: if s[left] == s[right]: left += 1 right -= 1 else: return False return True 空间复杂度比较高，毕竟申请了额外的空间 123456789101112def isPalindrome(self, s: str) -&gt; bool: for i in range(len(s), 0, -1): if not s[i-1].isalnum(): s = s[:i-1] + s[i:] left, right = 0, len(s)-1 while left &lt; right: if s[left].lower() == s[right].lower(): left += 1 right -= 1 else: return False return True 时间复杂度感人，仅击败了5%","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之买股票的最佳时机Ⅱ","slug":"Leetcode之买股票的最佳时机Ⅱ","date":"2020-02-12T04:55:23.000Z","updated":"2020-07-06T05:22:57.000Z","comments":true,"path":"passages/leetcode-zhi-mai-gu-piao-de-zui-jia-shi-ji-ii/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-mai-gu-piao-de-zui-jia-shi-ji-ii/","excerpt":"Best Time to Buy and Sell Stock Ⅱ","text":"Best Time to Buy and Sell Stock Ⅱ Best Time to Buy and Sell Stock Ⅱ code with Python title number：122 简单 读题 给定一个数组，一只股票，第i个元素表示给定股票第i天的价格 可以尽可能多的进行交易，求能获得的最大利润 售出必须在买进之后进行，再次买进时需要先售出持有的股票 思路一 贪心算法，分步操作，每步只选赚钱的 由题意知，因为在买股票前需要把手中的股票先卖出，所以有两种情况 连续上涨交易日：有一段时间股票价格连续上涨，则这段时间的第一天买入，最后一天卖出利润最大 连续下降交易日：有一段时间股票价格连续下降，则不买卖股票最佳，不会亏钱 这样比较不容易理解，可以把一段时间的股票持有等价为在这段时间里每天都买卖， 例：p1,p2,p3,p4,p55天连续上涨，应该第一天买，最后一天卖，即p5-p1；按照上面的理解，也可以表示为p5-p1 = (p2-p1)+(p3-p2)+(p4-p3)+(p5-p4) 算法： 遍历整个价格列表，所有上涨交易都日买卖，所有下降交易日都不买卖 由于我们将所有交易都拆分为了连续两天的交易， 所以，遍历整个列表，计算第i-1日买入且第i日卖出的利润，若利润大于0，则添加到总利润中，若利润小于等于0则不进行买卖 12345678def maxProfit(self, prices: List[int]) -&gt; int: profit_sum = 0 for i in range(1, len(prices)): profit = prices[i] - prices[i-1] if profit &gt; 0: profit_sum += profit return profit_sum 注意：这种算法里的计算方式并不是实际操作，而是将连续时间的股票持有转化为了每天都进行买卖 思路二 仍是我们熟悉的暴力破解，由于数组长度有限，必定可以穷举所有的交易组合，计算相应的利润，取最大值即可 但是时间复杂度太高，有$O(n^n)$ 思路三 动态规划，一般来说，可以用贪心算法解决的，都可以使用动态规划进行解决 定义状态，设置一个二维矩阵dp[i][j]： 第一维i表示第i天，第二维j用来表示是否持有股票（0表示未持有，1表示持有） value为当前的收益 状态转移方程 0-&gt;1-&gt;0-&gt;1-&gt;0…. 初始状态 dp[0][0]=0 dp[0][1]=-prices[0] 输出 dp[len-1][0]为最终结果 123456789101112def maxProfit(self, prices: List[int]) -&gt; int: if len(prices) &lt; 2: return 0 dp = [[0]*2 for i in range(len(prices))] dp[0][0] = 0 dp[0][1] = -prices[0] for i in range(len(prices)): dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices) dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices) return dp[len(prices)-1][0] 耗时感人，仅击败5%~~","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之二叉树的最大深度","slug":"Leetcode之二叉树的最大深度","date":"2020-02-06T05:25:32.000Z","updated":"2020-07-06T05:12:23.000Z","comments":true,"path":"passages/leetcode-zhi-er-cha-shu-de-zui-da-shen-du/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-er-cha-shu-de-zui-da-shen-du/","excerpt":"Maximum Depth of Binary Tree","text":"Maximum Depth of Binary Tree Maximum Depth of Binary Tree code with Python title number：104 简单 读题给定一个二叉树，求其最大深度 最大深度指的是从根节点到最深的叶节点的路径上的结点个数 看一下给定的示例： [3, 9, 20, null, null, 15, 7] ​ 3​ / 9 20​ / ​ 15 7 可以观察到，二叉树是通过层次遍历的顺序来表示的 不过这都不重要，我们在程序中获得的是一棵树 12345class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None 关键词：二叉树、深度优先搜索 思路一 深度优先遍历（DFS），使用递归的方式对二叉树的高度进行求解 如果根节点为空，则树空，高度为0 如果不为空则递归求解其左右子树的高度，并且取其中较大的，再加一 直到到达叶子节点位置 12345678def maxDepth(self, root: TreeNode) -&gt; int: if root is None: return 0 else: left_height = self.maxDepth(root.left) right_height = self.maxDepth(root.right) return max(left_height, right_height) + 1 思路二 还是深度优先遍历（DFS），不过这次我们使用非递归的方式实现。需要借助栈来进行 设置变量depth用于记录树的深度 先将根节点入栈 当栈不为空时，迭代 出栈栈顶元素，更新最大深度（当前结点的深度和最大深度的较大值） 根节点不为空则将根节点的左右结点入栈 123456789101112131415def maxDepth(self, root: TreeNode) -&gt; int: stack = [] depth = 0 if root is not None: stack.append((1, root)) while stack is not None: cur_depth, root = stack.pop() if root is not None: depth = max(cur_depth, depth) stack.append((cur_depth+1, root.left)) stack.append((cur_depth+1, root.right)) return depth 思路三 既然是求最大深度，我们只需要按层遍历，并且记录树的层数，即可得到树的最大深度 层序遍历 or 广度优先遍历 在队列中使用None来划分每一层，当出队时遇到None则深度+1 123456789101112131415161718def maxDepth(self, root: TreeNode) -&gt; int: queue = [] depth = 1 if root is None: return 0 queue.append(root) queue.append(None) while queue: node = queue.pop(0) if node: if node.left: queue.append(node.left) if node.right: queue.append(node.right) elif queue: queue.append(None) depth+=1 return depth List.pop(num)可以弹出指定位置的元素 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之买股票的最佳时机","slug":"Leetcode之买股票的最佳时机","date":"2020-02-06T05:21:10.000Z","updated":"2020-07-06T05:22:49.000Z","comments":true,"path":"passages/leetcode-zhi-mai-gu-piao-de-zui-jia-shi-ji/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-mai-gu-piao-de-zui-jia-shi-ji/","excerpt":"Best Time to Buy and Sell Stock","text":"Best Time to Buy and Sell Stock Best Time to Buy and Sell Stock code with Python title number：121 简单 读题 给定一个数组，一只股票 数组的第i位表示该股票第i天的价格 你只能进行一次买卖，计算最大利润（卖出时间不能早于买入时间） 相关标签：数组，动态规划 思路一 该问题抽象一下，就是求数组中两个数的最大差值（max(price[j]-price[i])，i&lt;=j） 首先想到的当然是暴力法啦 两层循环，外层循环遍历表示买入价格，内层循环遍历表示卖出价格 12345678910def maxProfit(self, prices: List[int]) -&gt; int: if len(prices) &lt; 2: return 0 res = 0 for i in range(len(prices)-1): for j in range(i+1, len(prices)): res = max(res, prices[j]-prices[i]) return res 很遗憾，超时 思路一改进 针对给定的示例[7,1,5,3,6,4]进行观察，我们发现有很多次的计算是无用的，为了更直观 即我们只需要关注之前观察到的最低股价即可，用一个变量记录便利过程中的最低股价，就可以省去内层的循环 1234567891011def maxProfit(self, prices: List[int]) -&gt; int: if len(prices) &lt; 2: return 0 res = 0 min_p = prices[0] for i in range(len(prices)): res = max(res, prices[i]-min_p) min_p = min(min_p, prices[i]) return res 思路二 类似于之前那道Maximum Subarray，这也是一道动态规划的题目 整体思想是: 正向，求得截至当前能买入的最低价 反向，求得当前买入的能卖出的最高价， 然后两者做差即可 以示例做演示：[7,1,5,3,6,4]，则 正向：[7,1,1,1,1,1]，逆向：[7,6,6,6,6,4] 做差并取最大值：5 1234567891011def maxProfit(self, prices: List[int]) -&gt; int: if len(prices) &lt; 2: return 0 max_profit = 0 in_price = prices[0] for i in range(len(prices)): if prices[i] &lt; in_price: in_price = prices[i] elif prices[i] - in_price &gt; max_profit: max_profit = prices[i] - in_price return max_profit 还是思路二 按照动态规划来一遍 定义状态：max_profit是前i天的最大收益 状态转移方程：（分情况讨论） 在第i天售出能不获得最大收益 在第i天售出能获得最大收益，并且是在第i天之前买入的 即前i天的最大收益 = max(前i-1天的最大收益，第i天的价格-前i-1天的最小价格) 初始条件：min_price=prices[0], max_profit=0 list长度为0和1时单独处理 顺手优化了一下代码 12345678910def maxProfit(self, prices: List[int]) -&gt; int: if len(prices) &lt; 2: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: min_price = min(price, min_price) max_profit = max(max_profit, price-min_price) return max_profit 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之合并两个有序数组","slug":"Leetcode之合并两个有序数组","date":"2020-02-06T05:20:48.000Z","updated":"2020-07-06T05:16:23.000Z","comments":true,"path":"passages/leetcode-zhi-he-bing-liang-ge-you-xu-shu-zu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-he-bing-liang-ge-you-xu-shu-zu/","excerpt":"Merge Sorted Array","text":"Merge Sorted Array Merge Sorted Array code with Python title number：88 简单 读题给定两个有序的数组nums1和nums2，将nums2合并到nums1中形成有序数组 nums1中有足够的位置用来存放nums2的元素，不能额外申请存储空间 关键词：数组，双指针 思路一 最直接的想法就是借鉴传统的Merge sort算法： 使用两个指针分别指向两个有序数组的头部，从前往后比较指针指向的元素的大小，将较小的元素放入申请的空间中，并且对应的指针后移 不过这样需要额外申请大小为m+n的空间，由于题目中说明了nums1的空间足够存储两个数组的所有元素，所以可以使用num1的空间来存储合并后的数组，申请大小为m的数组用来存储nums1即可 12345678910111213141516def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None: p, q, f = 0, 0, 0 nums1_temp = nums1[:m] while p &lt; m and q &lt; n: if nums1_temp[p] &lt; nums2[q]: nums1[f] = nums1_temp[p] p += 1 else: nums1[f] = nums2[q] q += 1 f += 1 if p &lt; m: nums1[p+q:] = nums1_temp[p:] if q &lt; n: nums1[p+q:] = nums2[q:] 奇怪，用时比下面的两种还少，内存消耗也没有明显增加…… 思路一改进 如果按照传统的合并算法，至少需要申请大小为m的空间。 我们还知道，num1中本身就有足够的空间来容纳nums2中的元素，而这些位置几种在数组的尾部 所以，由此我们想到，使用双指针从后往前遍历并比较，这样就可以利用num1后面的空闲位置了 需要三个指针，其中两个指针分别指向nums1和nums2中的最后一个元素，另外再有一个指针指向nums1中新添加元素的位置 123456789101112def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None: p, q = m-1, n-1 t = m+n-1 while p&gt;=0 and q&gt;=0: if nums1[p] &lt; nums2[q]: nums1[t] = nums2[q] q -= 1 else: nums1[t] = nums1[p] p -= 1 t -= 1 nums1[:q+1] = nums2[:q+1] 其实指针p、q、t完全可以省略，直接使用m,n,m+n-1代替，简化版如下 123456789def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None: while m&gt;0 and n&gt;0: if nums1[m-1] &lt; nums2[n-1]: nums1[m+n-1] = nums2[n-1] n -= 1 else: nums1[m+n-1] = nums1[m-1] m -= 1 nums1[:n] = nums2[:n] 思路二 其实还有一个更简洁的想法 直接将nums2添加到nums1的尾部，在对nums1进行排序即可 12345def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None: for i in range(len(nums2)): nums1[m+i] = nums2[i] nums1.sort() 但事后想来，这与题目的考查点不符（相关标签中提到了双指针），就当作是一种比较有意思的想法吧，以前掌握两种想法为主 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之最大子序和","slug":"Leetcode之最大子序和","date":"2020-02-06T05:17:45.000Z","updated":"2020-07-06T05:33:27.000Z","comments":true,"path":"passages/leetcode-zhi-zui-da-zi-xu-he/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zui-da-zi-xu-he/","excerpt":"Maximum Subarray","text":"Maximum Subarray Maximum Subarray code with Python title number：53 简单 读题给定一个整数数组，找到一个连续的子串，这个子串的和最大，返回子串的和 例：-2,1,-3,4,-1,2,1,-5,4中能取得最大和的子串为4,-1,2,1，则返回6 思路一 要求返回的是连续最大子序列和，最先想到的就是暴力求解 使用两层循环，外层循环控制子串头部的位置，内层循环控制子串尾部的位置 利用双层循环，穷举求和所有子串的和，返回最大值 该方法超时 1234567891011def maxSubArray(self, nums: List[int]) -&gt; int: max = nums[0] sub_sum = 0 for i in range(len(nums)): for j in range(i, len(nums)): for k in range(i,j+1): sub_sum += nums[k] if sub_sum &gt; max: max = sub_sum sub_sum = 0 return max 思路一优化 简单分析一下，时间复杂度高的原因主要是 ​ 对数组进行了多次的遍历 ​ 进行了多次的重复计算 重复计算的问题，例如：计算[0, 3]的和时就又计算了[0, 0], [0, 1], [0, 2]的和 所以可以在[0, 2]的基础上计算[0, 3]的和 优化方案为： ​ 穷举子序列左端点，遍历其右端点，用sum记录当前和，用max记录最大子序列值 ​ 可以减少一层循环 12345678def maxSubArray(self, nums: List[int]) -&gt; int: max_num = nums[0] for i in range(len(nums)): sum = 0 for j in range(i, len(nums)): sum += nums[j] max_num = max(max_num, sum) return max_num 思路一再优化 可以使用空间换时间的思想，使用数组pre_nums存储截止到i的子序列和 计算[1, 3]的子序列和可以通过pre_nums[3]-pre_nums[1]来得出 这样可以更大程度上减少运算 事实上，我们可以使用原数组表示存储pre_nums，这样连空间都省了 思路二尝试使用动态规划的思想，重点在于寻找状态转移方程 定义状态：dp[i]：表示以nums[i]结尾的连续最大子序列和 状态转移方程：（分情况讨论） 如果dp[i-1]&gt;=0，那么dp[i]=dp[i-1]+nums[i] 如果dp[i-1]&lt;0，那么dp[i]=nums[i] 综合一下两种情况我们可以得到：dp[i]=max(nums[i], dp[i-1]+nums[i]) 初始值：dp[0]=nums[0] 输出：值得注意的是，要遍历所有的dp[i]，取其中最大的返回 12345678910def maxSubArray(self, nums: List[int]) -&gt; int: if len(nums) == 1: return nums[0] # dp = [0 for i in range(len(nums))] dp = nums[:] # 减少了申请数组时的耗时 # dp[0] = nums[0] for i in range(1, len(nums)): dp[i] = max(dp[i-1]+nums[i], nums[i]) return max(dp) 换了种写法，时间减少了近一半，懵逼中…… 12345678910def maxSubArray(self, nums: List[int]) -&gt; int: size = len(nums) result = sum = nums[0] for i in range(1, size): if sum &lt; 0: sum = 0 sum += nums[i] if sum &gt; result: result = sum return result 动态规划问题经常需要分类讨论，因为动态规划问题本身就是通过小问题的最优解来得到大问题的最优解。因此，需要分类讨论大问题的小问题有哪些 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之删除排序数组中的重复项","slug":"Leetcode之删除排序数组中的重复项","date":"2020-02-06T05:17:19.000Z","updated":"2020-07-06T05:25:52.000Z","comments":true,"path":"passages/leetcode-zhi-shan-chu-pai-xu-shu-zu-zhong-de-chong-fu-xiang/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-shan-chu-pai-xu-shu-zu-zhong-de-chong-fu-xiang/","excerpt":"Remove Duplication from Sorted Array","text":"Remove Duplication from Sorted Array Remove Duplication from Sorted Array code with Python title number：26 简单 读题给排序后的数组，删除重复元素，返回修改后数组的长度 关键点：原地操作，不能占用额外的内存空间 标签：双指针和数组 思路一：既然是排序后的数组，说明相同的元素都连续存在 返回新的数组长度，将不重复的元素聚集在数组的前部， 如此便可以不用删除元素，而是将不重复的元素聚集的数组前部，并且不用考虑返回值范围之外的元素是什么。计数不重复元素的个数，返回不重复元素的个数。 设置两个指针，前者用于指向不重复的元素，后者用于遍历数组 初始状态，指针P指向第一个元素，指针Q指向第二个元素， 判断两个指针所指向的元素是否相同， 若相同，则Q向后遍历 若不同，则P先向后移动，再将Q指向位置的元素赋值给P指向位置的元素 最后返回P指向位置的下标（需要+1，数组下标从0开始） 另外，数组长度小于2时直接返回数组长度即可 例： 1,1,2,2,3,4,4 -&gt; 1,2,3,4,3,4,4，返回长度为4 12345678910def removeDuplicates(self, nums: List[int]) -&gt; int: if len(nums)==0: return 0 p = 0 for q in range(1, len(nums)): if nums[p] != nums[q]: p += 1 nums[p] = nums[q] return p+1 思路二： 我们尝试正常的删除元素 但是使用从前向后遍历删除元素，会导致数组访问越界（遍历数组的时候，遍历的次数并不会减少，数组元素减少了，回到之后面的访问越界） 所以可以从后往前遍历，先访问下标大的元素， 初始状态，P指向最后一个元素，Q指向倒数第二个元素 若P指向位置的元素等于Q指向位置的元素，删除Q指向位置的元素，P、Q均向前移动1 若P指向位置的元素不等于Q指向位置的元素，P、Q均向前移动1 最后返回数组长度 另外， 数组长度小于2时直接返回数组长度 与第一种思路不同，相比的两个元素是相邻的，可以只用一个指针，要控制边界 例： 1,1,2,3,3,4-&gt;1,1,2,3,3,4-&gt;1,1,2,3,4-&gt;1,1,2,3,4-&gt;1,2,3,4，返回数组长度4 1234567891011# range(end, start, -1)即可输出倒序的数组，注意是前闭后开# del函数删除数组元素def removeDuplicates(self, nums: List[int]) -&gt; int: if len(nums)&lt;2: return len(nums) for q in range(len(nums), 0, -1): if q-1 != 0: if nums[q-1]==nums[q-2]: del nums[q-1] return len(nums) 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"常见的模型评估标准","slug":"常见的模型评估标准","date":"2019-10-21T07:56:06.000Z","updated":"2020-11-28T07:17:38.215Z","comments":true,"path":"passages/chang-jian-de-mo-xing-ping-gu-biao-zhun/","link":"","permalink":"http://zivblog.top/passages/chang-jian-de-mo-xing-ping-gu-biao-zhun/","excerpt":"常见的模型评估标准","text":"常见的模型评估标准 写在前面 平时做比赛和看论文的时候会看到一些模型的评估参数，都是碰到了再查，今天下定决心整理一下，给之后的工作省点劲 本文分为两块： 以西瓜书为主要参考资料的模型评估标准论述 以scikit-learn中文文档为主的相关函数使用方法 模型评估标准方法 留出法 简单来说就是将训练数据集划分为互斥的两部分，一部分用来训练模型，一部分用来评估模型的性能 需要注意的是： 训练集和测试集要保持数据的分布一致，从划分数据集时采样的方法来看，可以使用“分层采样” 另外，数据集的划分也存在很多种可能，所以一般都要使用多次留出法对模型进行评估，最后将均值作为评估的结果 此外，划分为两部分的数据集在规模上不宜相差过大，一般取2/3~4/5作为训练集，剩余的用作测试 交叉验证法 在了解留出法之后，理解交叉验证就会容易很多了 交叉验证的思想是： 将数据集划分为k个大小相同的互斥的数据集 使用其中k-1个数据集进行训练，使用剩余的一个作为测试集进行测试 从而进行k次训练和测试，最终返回的是k个测试结果的均值 它还存在一种特殊情况：k=样本个数，这种划分方式我们称为“留一法” 需要注意的是： 数据集划分的时候为了保证各个子集之间数据分布一致，使用“分层采样” 数据集的划分存在多种可能，一般要使用多次交叉验证，最后将均值返回 留一法在数据集较大的时候不适用，因为会十分显著的增加计算成本 自助法 以上两种方法在模型的训练过程中，并没有使用全部的数据，为了解决这个问题，提出了“自助法” 自助法： 对于数据集D，对齐进行随机放回的下采样，建立$D^{&#39;}$ 使用D用来训练模型，使用$D^{&#39;}$来进行测试 值得注意的是： 自助采样仍会一定程度上改变初始数据的分布，对测试结果有一定的影响 所以在初始数据量足够的情况下，使用留出法和交叉验证法比较好 模型性能评估 错误率与精度 错误率是分类错误的样本占样本总数的比例 精度是分类正确的样本占样本总数的比例 混淆矩阵 先解释一下各个值代表的含义： TP：表示被正确分类的正样本的个数 FP：表示被错误分类的负样本的个数 FN：表示被错误分类的正样本的个数 TN：表示被正确分类的负样本的个数 直观来讲，我们希望TP与TN的数量越大越好，而FP与FN的数量越小越好 针对混淆矩阵，又提出了四个二级指标： Accuracy（准确率）= $\\frac{TP+TN}{TP+TN+FP+FN}$：模型判断正确的结果占总观测值的比重 Precision（精确率）= $\\frac{TP}{TP+FP}$：在模型预测是正例的结果中，预测正确的比重 Sensitivity（灵敏度） = Recall（召回率）= $ \\frac{TP}{TP+FN}$：在真实值是正例的所有结果中，模型预测对的比重 Specificity（特异度）= $ \\frac{TN}{TN+FP}$：在真实值是负例的所有结果中，模型预测对的比重 针对上面四个指标，又提出了三级指标： F1-score = $\\frac{2PrecisionRecall}{Precision + Recall}$：综合和精确率与召回率产出的结果 ROC与AUC ROC和AUC是一个从整体上评价二分类模型性能的指标 其中AUC（Area Under Curve）是坐标系中AUC曲线下面的面积 ROC根据真阳率和假阳率分别作为纵坐标和横坐标 真阳率表示正样本被预测为正样本的比例，记为TPR 假阳率表示负样本被预测为正样本的比例，记为FPR 从图形的角度来看，我们希望真阳率越大越好，假阳率越小越好，也就是曲线越上凸越好 AUC的值越大越好 调包指南交叉验证 使用train_test_split对数据集进行划分 12345from sklearn.model_selection import train_test_splitfrom sklearn import datasetsiris = datasets.load_iris()X_train, X_test, y_train, y_test = train_test_split(iris.data, iris.target, test_size=0.25, random_state=0) 验证集的准备和使用 如果将数据集划分为：训练集、验证集、测试集，就会导致训练数据不足，因此这里可以使用交叉验证来实现 12345678910111213from sklearn.model_selection import cross_val_scorefrom sklearn.svm import SVCclf = SVC(kernel='linear', C=1)# cv是整数时，使用k-foldscores = cross_val_score(clf, iris.data, iris.target, cv=5) #5-foldprint(scores)# cv还可以详细设置数据集划分from sklearn.model_selection import ShuffleSplitcv = ShuffleSplit(n_splits=3, test_size=0.3, random_state=0)scores = cross_val_score(clf, iris.data, iris.target, cv=cv)print(scores) 学习到其他奇技淫巧，随时更新 参考资料 西瓜书，《机器学习》周志华 scikit-learn中文文档","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://zivblog.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://zivblog.top/tags/AI/"}]},{"title":"Python之文件的删除","slug":"Python之文件的删除","date":"2019-10-06T11:35:49.000Z","updated":"2020-07-06T05:44:13.000Z","comments":true,"path":"passages/python-zhi-wen-jian-de-shan-chu/","link":"","permalink":"http://zivblog.top/passages/python-zhi-wen-jian-de-shan-chu/","excerpt":"文件删除","text":"文件删除 写在前面 本文主要介绍文件的几种操作，包括： 判断文件是否存在 判断是文件or文件夹 删除文件和文件夹 递归删除文件夹下的所有文件（不包括文件夹） 使用的工具包为os，要记得import奥 判断文件是否存在123import osos.path.exists(path) 删除文件1234import osif os.path.exists(path): os.remove(path) 判断是文件还是文件夹1234567import os# 判断是否为文件print(os.path.isfile(path))# 判断是否为文件夹print(os.path.isdir(path)) 创建文件夹1234import osif not os.path.exists(path): os.makedirs(path) 删除文件夹1234import osif os.path.exists(path): os.removedirs(path) 递归删除文件夹下的所有文件1234567def del_file(dir_path): for i in os.listdir(dir_path): file_path = os.path.join(dir_path, i) if os.path.isfile(file_path) == True: os.remove(file_path) else: del_file(file_path) 介绍一种动态绝对路径的方法12345678'''很多时候会因为文件路径导致程序产生一些模型奇妙的问题一般来说，绝对路径是最保险的，但是缺点就是缺乏动态性这里我们使用：项目文件夹绝对路径+文件夹内相对路径，结合绝对路径和相对路径的优势，基本不会因为文件路径造成问题了'''project_path = os.path.dirname(os.path.abspath(__file__))file_path = os.path.join(project_path, dirname, file_name) 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://zivblog.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://zivblog.top/tags/Python/"}]},{"title":"机器学习之支持向量机","slug":"机器学习之支持向量机","date":"2019-10-02T10:36:00.000Z","updated":"2020-11-28T07:17:56.039Z","comments":true,"path":"passages/ji-qi-xue-xi-zhi-zhi-chi-xiang-liang-ji/","link":"","permalink":"http://zivblog.top/passages/ji-qi-xue-xi-zhi-zhi-chi-xiang-liang-ji/","excerpt":"支持向量机","text":"支持向量机 算法要点 支持向量机学习的基本想法是求解能够正确划分训练数据集并且几何间隔最大的分离超平面 对训练数据集找到几何间隔最大的超平面意味着以充分大的置信度对训练数据进行分类 支持向量机是：最大化分类间隔的线性分类器 三种情况 训练数据线性可分时，通过硬间隔最大化，得到线性可分支持向量机 训练数据近似线性可分时，通过软间隔最大化，得到线性支持向量机 训练数据线性不可分时，通过使用核技巧及软间隔最大化，得到非线性支持向量机 函数间隔和几何间隔 函数间隔 可以表示分类预测的正确性和确信度 表示为$\\gamma_i = y_i(w \\cdot x_i + b)$ 几何间隔，对函数间隔的法向量w进行规范化等约束，防止参数成比例改变带来的问题 对函数间隔中的$w$和$b$进行归一化处理之后就是几何间隔了 几何间隔表示为：$\\gamma_i = y_i(\\frac{w}{||w||} \\cdot x_i + \\frac{b}{||w||})$ 支持向量 训练数据集的样本点中与分离超平面距离最近的样本点的实例称为支持向量 支持向量是使约束条件式等号成立的点 决定分离超平面时，只有支持向量起作用 间隔边界 支持向量所在的两个超平面称为间隔边界 间隔依赖于分离超平面的法向量$w$，等于$\\frac{2}{||w||}$ 松弛变量 在线性支持向量机中，会存在某些样本点无法满足函数间隔大于等于1的约束条件 为了解决这个问题，对每个点引入松弛变量，使函数间隔加上松弛变量大于等于1 约束条件变为：$y_i(w \\cdot x_i + b) &gt;= 1 - \\xi_i$ 惩罚因子 因为引入了松弛变量的样本点分类的置信度是不足够大的，所以对于每个松弛变量，支付一个代价（乘以一个系数） $C &gt; 0$ C值大时对误分类的惩罚增大，C值小时对误分类的惩罚减小 核函数 非线性分类问题无法在当前的空间内实现分类，需要映射到更高维的空间来寻找分割超平面 所采用的方法是进行一个非线性变换，将非线性问题转换为线性问题 首先使用一个变换将原空间的数据映射到新空间 在新空间中使用线性分类学习方法从训练数据中学习分类模型 核技巧的思想是：在学习和预测过程中，只定义核函数$K(x, z)$，而不显式地定义映射函数 在SVM中的应用就是将目标函数和决策函数中的实例与实例之间的内积使用核函数代替 SMO算法（sequential minimal optimization，序列最小优化算法） SMO算法是支持向量机学习的一种快速算法 不断将原二次规划问题分解为只有两个变量的二次规划子问题，并对子问题进行解析求解，直到所有变量满足KKT条件为止 通过启发式的方法得到原二次规划问题的最优解 SVM算法理解 SVM脉络图 ​ 图片来源：公众号SIGAI 线性分类器 SVM可以说是起源于线性分类器，所以理解线性分类器对理解SVM是有很大帮助的 线性分类器是在n维空间中的分类超平面，将空间分割成两个部分 对于二维空间，线性分类器是一条直线；对于三维空间，线性分类器是一个平面 线性分类器的超平面方程为：$w^Tx + b = 0$，其中$w和b$是通过训练得到的参数 最大化分类间隔（线性可分支持向量机） 一般情况下，给定一组训练样本，可行的线性分类器不止一个 如何在所有可行的线性分类器中选择效果（泛化能力）最好的分类器呢？（有一下几点考虑） 分类平面不应该偏向任何一类 距离两个类别的样本都要尽可能的远 这样，就是我们最大化间隔的基本就形成了；最大化间隔就是SVM的基本思想 如何衡量间隔是最大的呢？ 假设：给定训练样本集I，特征向量有n维，类别标签为-1和+1 SVM为该分类任务寻找最优分类超平面：$w^Tx + b = 0$ 首先，保证每个样本被正确的分类，即： 对于正样本，$w^Tx + b &gt;= 0$ 对于负样本，$w^Tx + b &lt;= 0$ 可以统一写成：$y_i(w^Tx_i + b) &gt;= 0$，其中$y_i$是训练集样本的标签 其次，超平面距离两类样本的距离要尽可能大， 每个样本点到超平面的举例为：$d = \\frac{|w^Tx_i + b|}{||w||}$ $||w||$是向量的L2范数，是一个常数（范数是对向量长度的一种度量） 对于超平面方程，两边同乘不等于0的常数，还是用一个超平面，根据此特性可以化简求解问题 给$w$和$b$加上如下约束，$min_{x_i}|w^Tx_i + b|=1$ 消掉此冗余并化简点到超平面距离计算公式，分类超平面的约束变成：$y_i(w^Tx_i + b)&gt;=1$ 分类超平面与两类样本之间的间隔为： $d(w, b) = min_{x_i,y_i=-1}d(w, b; x_i)+min_{x_i, y_i=1}d(w, b; x_i)= \\frac{2}{||w||}$ 目标是使该间隔最大化，这与最小化$||w||$等价，同时也与最小化$\\frac{1}{2}||w||^2$等价 于是，优化问题最后变成 $$min \\frac{1}{2}w^Tw$$ $$y_i(w^Tx_i+b) &gt;= 1$$ 这是一个凸优化问题，并且满足Slater条件 凸优化问题意味着我们可以得到全局最优解 满足Slater条件意味着我们可以用拉格朗日对偶将其转化为对偶问题（对偶问题的求解会更加简单）进行求解 对偶问题 之前的优化问题中，包含许多的不等式约束，因此通过拉格朗日对偶将其转化成对偶问题，对偶问题为： $$min_\\alpha \\frac{1}{2}\\sum^l_{i=1}\\sum^l_{j=1}\\alpha_i\\alpha_jy_iy_jx_i^Tx_j - \\sum^l_{i=1}\\alpha_i$$ $$\\alpha_i &gt;= 0, i=1,…,l$$ $$\\sum^l_{i=1}\\alpha_iy_i = 0$$ 这里的$\\alpha$是拉个朗日乘子变量，在对偶问题中，它们是优化变量 值得注意的是，只有问题满足强对偶条件，也就是原问题与对偶问题有相同的最优解 强对偶成立的判断依据是Slater条件 梳理一下 初始是最大化间隔：$\\frac{1}{2} ||w||^2，s.t. y_i(w \\cdot x_i + b) - 1 &gt;= 0$ 应用拉格朗日对偶性构建拉格朗日函数（引入拉格朗日乘子$\\alpha $） $L(w, b, \\alpha) = \\frac{1}{2} ||w||^2 - \\sum^N_{i=1}\\alpha_iy_i(w \\cdot x_i + b) + \\sum^N_{i=1}\\alpha_i$ 根据拉格朗日对偶性，原始问题的对偶问题是极大极小问题：$max_\\alpha min_{w, b}L(w, b, \\alpha)$ 对于该问题，我们先求对$w$和$b$的极小，再对$\\alpha $求极大 求极小的方法就是将$L(w, b, \\alpha )$对$w$和$b$求偏导并令其等于0 将偏导数等于0代会，可得： $min_{w, b} L(w, b, \\alpha ) = -\\frac{1}{2} \\sum^N_{i=1}\\sum^N_{j=1} \\alpha_i \\alpha_j y_i y_j(x_i \\cdot x_j) + \\sum^N_{i=1} \\alpha_i$ 下一步是对上式再对$\\alpha $再求极大，但是我们可以对上式两边同乘-1转化为求极小的问题，即： $$max_\\alpha min_{w, b} L(w, b, \\alpha) = min_\\alpha \\frac{1}{2} \\sum^N_{i=1}\\sum^N_{j=1} \\alpha_i \\alpha_j y_i y_j(x_i \\cdot x_j) + \\sum^N_{i=1} \\alpha_i$$ 求得最优解$\\alpha^{*} = (\\alpha^{*}_i, …, \\alpha^{*}_N)$ 计算 $w^{*} = \\sum^N_{i=1}\\alpha^{*}_iy_ix_i$ $b^{*} = y_i - \\sum^N_{i=1}\\alpha^{*}_iy_i(x_i \\cdot x_j)$ 求得分离超平面：$w^{*} \\cdot x + b^{*} = 0$ 决策函数：$f(x) = sign(w^{*} \\cdot x + b^{*})$ 线性支持向量机 引入了惩罚因子和松弛变量 也可以通过转化为对偶问题解决 如下： $$min_\\alpha \\frac{1}{2}\\sum^l_{i=1}\\sum^l_{j=1}\\alpha_i\\alpha_jy_iy_jx_i^Tx_j - \\sum^l_{i=1}\\alpha_i$$ $$0 &lt;= \\alpha_i &lt;= C$$ $$\\sum^l_{j=1}\\alpha_jy_j = 0$$ 相比于线性可分的对偶问题，多了个$\\alpha_i &lt;= C$的约束 分离超平面$\\sum^N_{i=1}\\alpha^{*}_iy_i(x \\cdot x_i) +b^{*} = 0$ 决策函数为$f(x) = sign(\\sum^l_{i=1}\\alpha_i^{*}y_i(x \\cdot x_i) + b^{*})$ 非线性可分支持向量 使用的核技巧，还是线性可分的问题 对偶问题变为 $$min_\\alpha \\frac{1}{2}\\sum^l_{i=1}\\sum^l_{j=1}\\alpha_i\\alpha_jy_iy_j\\phi(x_i)^T\\phi(x_j) - \\sum^l_{i=1}\\alpha_i$$ = $$min_\\alpha \\frac{1}{2}\\sum^l_{i=1}\\sum^l_{j=1}\\alpha_i\\alpha_jy_iy_jK(x_i, x_j) - \\sum^l_{i=1}\\alpha_i$$ $$0 &lt;= \\alpha_i &lt;= C$$ $$\\sum^l_{j=1}\\alpha_jy_j = 0$$ 决策函数为$f(x) = sign(\\sum^l_{i=1}\\alpha^{*}_iy_iK(x , x_i) + b^{*})$，其中$K(x, x_i)= \\phi(x) \\cdot \\phi(x)$ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192import numpy as npimport pandas as pdfrom sklearn.datasets import load_irisfrom sklearn.model_selection import train_test_splitimport matplotlib.pyplot as pltdef create_data(): iris = load_iris() df = pd.DataFrame(iris.data, columns=iris.feature_names) df['label'] = iris.target df.columns = ['sepal length', 'sepal width', 'petal length', 'petal width', 'label'] data = np.array(df.iloc[:100, [0, 1, -1]]) # 将三类转化成两类：（1，-1） for i in range(len(data)): if data[i, -1] == 0: data[i, -1] == -1 return data[:, :2], data[:, -1]class SVM: def __init__(self, max_iter=100, kernel='linear'): self.max_iter = max_iter self._kernel = kernel def init_args(self, features, labels): self.m, self.n = features.shape self.X = features self.Y = labels self.b = 0.0 # 将Ei保存在一个列表中 self.alpha = np.ones(self.m) self.E = [self._E(i) for i in range(self.m)] # 松弛变量 self.C = 1.0 def _KKT(self, i): y_g = self._g(i) * self.Y[i] if self.alpha[i] == 0: return y_g &gt;= 1 elif 0 &lt; self.alpha[i] &lt;self.C: return y_g == 1 else: return y_g &lt;= 1 def _g(self, i): # g(x)预测值，输入xi(X[i]) r = self.b for j in range(self.m): r += self.alpha[j] * self.Y[j] * self.kernel(self.X[i], self.X[j]) return r def kernel(self, x1, x2): # 核函数 if self._kernel == 'linear': return sum([ x1[k] * x2[k] for k in range(self.n)]) elif self._kernel == 'poly': return (sum([ x1[k] * x2[k] for k in range(self.n)]) + 1) **2 return 0 def _E(self, i): # E(x)为g(x)对输入x的预测值和y的差 return self._g(i) - self.Y[i] def _init_alpha(self): # 外层循环遍历所有满足0&lt;a&lt;C的样本点， 检验是否满足KKT index_list = [i for i in range(self.m) if 0 &lt; self.alpha[i] &lt; self.C] # 否则遍历整个训练集 non_satisfy_list = [i for i in range(self.m) if i not in index_list] index_list.extend(non_satisfy_list) for i in index_list: if self._KKT(i): continue E1 = self.E[i] # 如果E2是+，选择最小的；如果E2是负的，选择最大的 if E1 &gt;= 0: j = min(range(self.m), key=lambda x: self.E[x]) else: j = min(range(self.m), key=lambda x: self.E[x]) return i, j def _compare(self, _alpha, L, H): if _alpha &gt; H: return H elif _alpha &lt; L: return L else: return _alpha def fit(self, features, labels): self.init_args(features, labels) for t in range(self.max_iter): # train i1, i2 = self._init_alpha() # 边界 if self.Y[i1] == self.Y[i2]: L = max(0, self.alpha[i1] + self.alpha[i2] - self.C) H = min(self.C, self.alpha[i1] + self.alpha[i2]) else: L = max(0, self.alpha[i2] - self.alpha[i1]) H = min(self.C, self.C + self.alpha[i2] - self.alpha[i1]) E1 = self.E[i1] E2 = self.E[i2] # eta = k11 + k22 - 2k12 eta = self.kernel(self.X[i1], self.X[i1]) + self.kernel( self.X[i2], self.X[i2]) - 2*self.kernel(self.X[i1], self.X[i2]) if eta &lt;= 0: continue alpha2_new_unc = self.alpha[i2] + self.Y[i2] * (E1 - E2)/eta alpha2_new = self._compare(alpha2_new_unc, L, H) alpha1_new = self.alpha[i1] + self.Y[i1] * self.Y[i2] * ( self.alpha[i2] - alpha2_new) b1_new = -E1 - self.Y[i1] * self.kernel(self.X[i1], self.X[i1]) * ( alpha1_new - self.alpha[i1]) - self.Y[i2] * self.kernel( self.X[i2], self.X[i1]) * (alpha2_new - self.alpha[i2]) + self.b b2_new = -E2 - self.Y[i1] * self.kernel(self.X[i1], self.X[i2]) * ( alpha1_new - self.alpha[i1]) - self.Y[i2] * self.kernel( self.X[i2], self.X[i2]) * (alpha2_new - self.alpha[i2]) + self.b if 0 &lt; alpha1_new &lt; self.C: b_new = b1_new elif 0 &lt; alpha2_new &lt; self.C: b_new = b2_new else: # 选择中点 b_new = (b1_new + b2_new)/2 # 更新参数 self.alpha[i1] = alpha1_new self.alpha[i2] = alpha2_new self.b = b_new self.E[i1] = self._E(i1) self.E[i2] = self._E(i2) print(\"train_done!\") def predict(self, data): r = self.b for i in range(self.m): r += self.alpha[i] * self.Y[i] * self.kernel(data, self.X[i]) return 1 if r &gt; 0 else -1 def score(self, X_test, y_test): right_count = 0 for i in range(len(X_test)): result = self.predict(X_test[i]) if result == y_test[i]: right_count += 1 return right_count / len(X_test) def _weight(self): yx = self.Y.reshape(-1, 1) * self.X self.w = np.dot(yx.T, self.alpha) return self.wif __name__ == \"__main__\": X, y = create_data() X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25) plt.scatter(X[:50,0],X[:50,1], label='0') plt.scatter(X[50:,0],X[50:,1], label='1') plt.show() svm = SVM(max_iter=200) svm.fit(X_train, y_train) score = svm.score(X_test, y_test) print(score) 关于凸优化问题、拉格朗日乘子法、slater条件、KKT条件、SMO会在另一篇文章中进行整理参考资料 《统计学习方法（第二版）》 黄海广博士的代码 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://zivblog.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://zivblog.top/tags/AI/"}]},{"title":"机器学习之逻辑回归","slug":"机器学习之逻辑回归","date":"2019-09-25T14:11:08.000Z","updated":"2020-11-28T07:18:23.219Z","comments":true,"path":"passages/ji-qi-xue-xi-zhi-luo-ji-hui-gui/","link":"","permalink":"http://zivblog.top/passages/ji-qi-xue-xi-zhi-luo-ji-hui-gui/","excerpt":"逻辑回归","text":"逻辑回归 逻辑回归 逻辑回归，虽然名字中带有“回归”的字样，但是它并不是做回归任务的，而是用回归的思想来做分类 根据数据对分类边界线建立回归公式，以此进行分类 算法概述 以二分类为例，逻辑回归会计算输入的实例在已知x的条件下$P(Y=1|x)$和$P(Y=0|x)$的概率，并将实例分到概率值较大的那一类 优缺点 优点：计算代价不高，易于理解和实现 缺点：容易欠拟合，分类精度可能不高 多项逻辑回归模型可以用于多分类 逻辑回归与最大熵模型都是对数线性模型，当标签值只有两个的时候的最大熵模型就是逻辑回归模型 回归模型：$f(x) = \\frac{1}{1+e^{-wx}}$ 最大熵模型 熵表示的是数据的不确定性，熵越大，不确定性越大 最大熵模型：保留所有的不确定性，将风险降到最低 最大熵模型的学习过程就是在可能的模型集合中选择最优模型，熵最大的情况就是等概率，即最不确定的情况 最大熵模型也可以用于二分类和多分类任务 最大熵模型的具体推导过程还在学习中，后续持续更新 相关数学知识 经验分布：经验分布是指依据样本频率估计概率的方式得到的与实际近似的分布 极大似然估计：利用已知的样本结果，反推最有可能（最大概率）导致这样结果的参数值 代码实现及测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687# 导入相关包from math import expimport numpy as npimport pandas as pd import matplotlib.pyplot as plt from sklearn.datasets import load_irisfrom sklearn.model_selection import train_test_splitdef create_data(): # 加载iris数据集并转化格式 iris = load_iris() df = pd.DataFrame(iris.data, columns=iris.feature_names) df['label'] = iris.target # 选择前100行中的前两列和最后一列，即数据结构为(x, y, label) data = np.array(df.iloc[:100, [0, 1, -1]]) return data[:, :-1], data[:, -1]class LogisticRegressionClassifier: def __init__(self, max_iter=200, learning_rate=0.01): self.max_iter = max_iter self.learning_rate = learning_rate def sigmod(self, x): return 1 / (exp(-x) + 1) def data_matrix(self, X): # 将X转化成矩阵，并将第一行设置成1，这样[1, x][w, b] data_mat = [] for d in X: # print(d) data_mat.append([1.0, *d]) return data_mat def fit(self, X, y): data_mat = self.data_matrix(X) # 初始化权重为0，长度为len(x)+1, 即[b, w] self.weights = np.zeros((len(data_mat[0]), 1), dtype=np.float32) for iter_ in range(self.max_iter): for i in range(len(X)): # w*x + b result = self.sigmod(np.dot(data_mat[i], self.weights)) error = y[i] - result # 权重更新 self.weights += self.learning_rate * error *np.transpose([data_mat[i]]) print('LogisticRegression Model(learning_rate=&#123;&#125;,max_iter=&#123;&#125;)'.format( self.learning_rate, self.max_iter)) def score(self, X_test, y_test): right = 0 X_test = self.data_matrix(X_test) for x, y in zip(X_test, y_test): result = self.sigmod(np.dot(x, self.weights)) # 统计预测正确的数量 if (result &gt; 0 and y==1) or (result &lt; 0 and y==0): right += 1 return right/float(len(X_test))if __name__ == \"__main__\": # 数据准备 X, y = create_data() X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3) # print(X_train, X_test, y_train, y_test) lr_clf = LogisticRegressionClassifier() # 训练 lr_clf.fit(X_train, y_train) # 用测试集测试模型性能 lr_clf.score(X_test, y_test) # 绘制 x_points = np.arange(4, 8) # 拟合曲线weights = [b, Wx, Wy], 曲线为：weights[1]*x + weights[2]*y + b = 0 ---&gt; y = (weights[1]*x + b) / weights[2] y_ = -(lr_clf.weights[1]*x_points + lr_clf.weights[0]) / lr_clf.weights[2] plt.plot(x_points, y_) # 散点 plt.scatter(X[:50, 0], X[:50, 1], label='0') plt.scatter(X[50:, 0], X[50:, 1], label='1') plt.show() print(lr_clf.weights) 参考资料 《统计学习方法（第二版）》 《机器学习实战》 黄海广博士的代码 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://zivblog.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://zivblog.top/tags/AI/"}]},{"title":"机器学习之决策树","slug":"机器学习之决策树","date":"2019-09-24T13:55:40.000Z","updated":"2020-11-28T07:18:48.146Z","comments":true,"path":"passages/ji-qi-xue-xi-zhi-jue-ce-shu/","link":"","permalink":"http://zivblog.top/passages/ji-qi-xue-xi-zhi-jue-ce-shu/","excerpt":"决策树","text":"决策树 算法要点 决策树是一种基本的分类与回归方法 决策树模型可以认为是if-then规则的集合，也可以认为是定义在特征空间与类空间上的条件概率分布 决策树的学习过程主要分为三个步骤：特征选择、决策树的生成、决策树的修剪 优点：计算复杂度不高，输出结果易于理解，对中间的缺失不敏感，可以处理不相关特征数据 缺点：可能会产生过度匹配问题 决策树的训练 决策树学习，本质上是从训练数据中归纳出一组分类规则，由于符合这一规则的决策树可能有多个，故我们要寻找的是一个与训练数据矛盾较小的决策树，同时具有较好的泛化能力。 决策树的学习策略是：以损失函数（通常是正则化的极大似然函数）为目标函数的最小化。 递归的选择最优特征（该特征对数据集的划分是当前最优的划分），并根据该特征对训练数据进行分割，直到所有子集中只包含一个类别的数据 具体训练过程 开始，构建根节点，将所有训练数据都放在根节点 选择一个最优特征，按照这一特征将训练数据分割成子集 如果子集已经可以被很好的分类了，则构建叶节点，并将这个子集放到叶节点之中 若还存在子集不能被很好的分类，那么对这些子集选择新的最优特征，继续进行分类 直到所有训练数据子集被基本正确分类，或者没有合适的特征为止 以上步骤进行完毕之后，我们还需要防止决策树的过拟合，也就是对决策树的剪枝，使其拥有较好的泛化能力 决策树的生成值考虑局部最优，决策树的剪枝则需要考虑全局最优 决策树常用的学习算法有：ID3、C4.5、CART 特征选择 特征选择在于选取对于训练数据具有分类能力的特征，特征选择的准则通常使用信息增益和信息增益比 熵表示的是随机变量不确定性的度量；熵越大，随机变量的不确定性就越大 条件熵$H(Y|X)$表示在已知随即便来那个X的情况下随机变量Y的不确定性 信息增益表示得之特征X的信息而使类Y的信息的不确定性减少的程度（也就是X对 最终确定类别Y的贡献度），信息增益越大的特征具有更强的分类能力 特征A对数据集合D的信息增益，定义为：集合D的经验熵（由数据估计得到的熵）$H(D)$与特征A给定条件下D的经验条件熵$H(D|A)$之差，即$g(D, A) = H(D) - H(D|A)$ 根据信息增益选择特征的方式是：计算所有特征的信息增益，并选择信息增益最大的特征作为当前的划分依据 由于信息增益偏向于选择取值较多的特征，所以提出信息增益比来矫正该问题，定义为：特征A对数据集合D的信息增益与训练数据集D关于特征A的值的熵之比 决策树的生成 ID3算法 从根节点开始，对节点计算所有可能的特征的信息增益，选择信息增益最大的特征作为节点的特征，由该特征的不同取值建立子节点，再对子节点递归的调用以上方法；直到所有特征的信息增益均很小或没有特征可以选择为止 ​ ID3算法只有树的生成，所以该算法生成的树容易产生过拟合 C4.5算法 相比于ID3算法，C4.5使用信息增益比为标准来进行决策树的构建 剪枝处理 剪枝的目的主要是为了防止过拟合 在学习时过多的考虑如何提高对训练数据的正确分类，从而构建出过于复杂的决策树 具体来说，剪枝从已经生成的树上裁剪掉一些字数或叶子结点，并将其根节点或父节点作为新的叶节点 通过优化损失函数还考虑了减少模型复杂度，从整体上优化了模型 CART算法 CART：分类与回归树，可以用于回归，也可以用于分类 决策树生成：基于训练数据集生成决策树，生成的决策树要尽量大 决策树剪枝：用验证数据集对已生成的树进行剪枝并选择最优子树，这是用损失函数最小作为剪枝的标准 ​ 首先从生成算法产生的决策树T0底端开始不断剪枝，直到T0的根节点，形成一个子树序列， ​ 然后，通过交叉验证法在独立的验证数据集上对子树序列进行测试，从中选择最优子树 决策树的生成就是递归地构建二叉决策树的过程。对于回归树用平方误差最小化准则；对于分类书用基尼指数最小化准则进行特征选择 代码实现及测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169import numpy as np import pandas as pd import matplotlib.pyplot as plt import mathfrom math import logimport pprint# 利用ID3算法生成决策树class Node: # 结点类，树的节点 def __init__(self, root=True, label=None, feature_name=None, feature=None): self.root = root self.label = label self.feature_name = feature_name self.feature = feature self.tree = &#123;&#125; self.result = &#123; 'label':self.label, 'feature':self.feature, 'tree':self.tree &#125; def __repr__(self): return '&#123;&#125;'.format(self.result) def add_node(self, val, node): self.tree[val] = node def predict(self, features): if self.root is True: return self.label return self.tree[features[self.feature]].predict(features)class DTree: def __init__(self, epsilon=0.1): self.epsilon = epsilon self._tree = &#123;&#125; # 熵 def calc_ent(self, datasets): data_length = len(datasets) label_count = &#123;&#125; for i in range(data_length): label = datasets[i][-1] if label not in label_count: label_count[label] = 0 label_count[label] += 1 ent = -sum([(p/data_length) * log(p/data_length, 2) for p in label_count.values()]) return ent # 经验条件熵 def cond_ent(self, datasets, axis=0): data_length = len(datasets) feature_sets = &#123;&#125; for i in range(data_length): feature = datasets[i][axis] if feature not in feature_sets: feature_sets[feature] = [] feature_sets[feature].append(datasets[i]) cond_ent = sum([(len(p)/data_length)*self.calc_ent(p) for p in feature_sets.values()]) return cond_ent # 信息增益 def info_gain(self, ent, cond_ent): return ent - cond_ent def info_gain_train(self, datasets): count = len(datasets[0]) - 1 ent = self.calc_ent(datasets) best_feature = [] for c in range(count): c_info_gain = self.info_gain(ent, self.cond_ent(datasets, axis=c)) best_feature.append((c, c_info_gain)) # 比较大小 best_ = max(best_feature, key=lambda x: x[-1]) return best_ def train(self, train_data): ''' input: 数据集，特征集，阈值eta output：决策树T ''' _, y_train, featrues = train_data.iloc[:, :-1], train_data.iloc[:, -1], train_data.columns[:-1] # 若D中实例属于同一类Ck，则T为单结点树，并且Ck为结点的类别，返回T if len(y_train.value_counts()) == 1: return Node(root=True, label=y_train.iloc[0]) # 如果特征集A为空，则T为单节点树，将D中实例树最大的类Ck作为该节点的类标记，返回T if len(featrues) == 0: return Node(root=True, label=y_train.value_counts().sort_values(ascending=False).index[0]) # 计算最大信息增益，Ag为信息增益最大的特征 max_feature, max_info_gain = self.info_gain_train(np.array(train_data)) max_feature_name = featrues[max_feature] # 信息增益Ag如果小于阈值eta（相当于特征集为空），则T为单节点树，并将D中是实例数最大的类别Ck作为该节点的类标记 if max_info_gain &lt; self.epsilon: return Node(root=True, label=y_train.value_counts().sort_values(ascending=False).index[0] ) # 构建Ag子集 node_tree = Node( root=False, feature_name=max_feature_name, feature=max_feature ) featrue_list = train_data[max_feature_name].value_counts().index for f in featrue_list: sub_train_df = train_data.loc[train_data[max_feature_name] == f].drop([max_feature_name], axis=1) # 递归生成树 sub_tree = self.train(sub_train_df) node_tree.add_node(f, sub_tree) # pprint.pprint(node_tree.tree) return node_tree def fit(self, train_data): self._tree = self.train(train_data) return self._tree def predict(self, X_test): return self._tree.predict(X_test)def create_data(): datasets = [['青年', '否', '否', '一般', '否'], ['青年', '否', '否', '好', '否'], ['青年', '是', '否', '好', '是'], ['青年', '是', '是', '一般', '是'], ['青年', '否', '否', '一般', '否'], ['中年', '否', '否', '一般', '否'], ['中年', '否', '否', '好', '否'], ['中年', '是', '是', '好', '是'], ['中年', '否', '是', '非常好', '是'], ['中年', '否', '是', '非常好', '是'], ['老年', '否', '是', '非常好', '是'], ['老年', '否', '是', '好', '是'], ['老年', '是', '否', '好', '是'], ['老年', '是', '否', '非常好', '是'], ['老年', '否', '否', '一般', '否'], ] labels = [u'年龄', u'有工作', u'有自己的房子', u'信贷情况', u'类别'] # 返回数据集和每个维度的名称 return datasets, labelsif __name__ == \"__main__\": datasets, labels = create_data() data_df = pd.DataFrame(datasets, columns=labels) dt = DTree() tree = dt.fit(data_df) # print(tree) print(dt.predict(['老年', '否', '否', '一般'])) 参考资料 《统计学习方法（第二版）》 《机器学习实战》 黄海广博士的代码 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://zivblog.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://zivblog.top/tags/AI/"}]},{"title":"Leetcode之有效的括号","slug":"Leetcode之有效的括号","date":"2019-09-24T13:52:16.000Z","updated":"2020-07-06T05:30:24.000Z","comments":true,"path":"passages/leetcode-zhi-you-xiao-de-gua-hao/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-you-xiao-de-gua-hao/","excerpt":"有效的括号","text":"有效的括号 题目描述 题目详情见：有效的括号 题目难度：简单 相关标签：栈、字符串 思路 括号匹配是栈的应用之一，这里讲一下思路 只要遇到左括号就入栈，遇到右括号则右括号与栈顶元素匹配， 如果匹配则栈顶元素出栈 如果不匹配则失败 直到所有括号均遍历一遍 可以使用Python的字典{‘左括号’：’右括号’}，右括号是不会有入栈的可能的 几个特殊情况 栈空时的pop操作会报错，所以我们给栈赋初值，并对该初值在字典中建立对应关系 当序列以左括号结尾是，也是需要特殊处理的，这时判断一下栈内的元素个数即可（加上我们的初值长度应该为2） 代码一12345678910111213141516171819def isValid(self, s: str) -&gt; bool: dict = &#123;'(': ')', '[': ']', '&#123;': '&#125;', '?': '?'&#125; stack = ['?'] for c in s: # 左括号，入栈 if c in dict: stack.append(c) # 右括号 else: top = stack.pop() # 匹配失败 if dict[top] != c: return False if len(stack) == 1: return True if len(stack) == 2: # 左括号结尾,匹配失败 return False 代码二1234567891011# 与代码一实现的算法思想是相同的，但是代码实现上更加简洁紧凑def isValid(self,s: str) -&gt; bool: dict = &#123;'(': ')', '[': ']', '&#123;': '&#125;', '?': '?'&#125; stack = ['?'] for c in s: if c in dict: stack.append(c) elif dict[stack.pop()] != c: return False return len(stack) == 1 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之最长公共前缀","slug":"Leetcode之最长公共前缀","date":"2019-09-22T12:08:00.000Z","updated":"2020-07-06T05:34:50.000Z","comments":true,"path":"passages/leetcode-zhi-zui-chang-gong-gong-qian-zhui/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zui-chang-gong-gong-qian-zhui/","excerpt":"最长公共前缀","text":"最长公共前缀 题目描述 题目详情见：最长公共前缀 题目难度：简单 相关标签：字符串 思路 输入只有小写字母，不存在干扰数据，可以直接处理 最直接的思路就是选定一个字符串，将其前缀依次与各个字符串的前缀比较，前缀长度依次加1，时间复杂度很高（不写了，有兴趣的可自行实现） 将字符串数组是做二维数组，按列扫描，直到发现某一列不完全相同，之前的列中任取一行就是最长共同前缀（见代码一） 利用set：每次取每个字符串的同一列，放入set中，如果set长度为1，则是共同字符 利用zip()函数：返回strs的每个字符串的迭代器 前两个字符串找最长公共子串，结果再与第三个字符串找共同前缀，直到整个字符串数组全部参与（见代码二） 这里还可以进行优化：求所有字符串长度的最小值，所有求公共字串的过程都只需要求最小值长度的即可 在讨论区看到了一个超赞的想法，这里记录一下（见代码二） 代码一12345678910111213141516def longestCommonPrefix(self, strs: List[str]) -&gt; str： if not strs: return \"\" # 返回每一列的集合（不含重复元素） ss = list(map(set, zip(*strs))) res = \"\" for i, x in enumerate(ss): x = list(x) # 长度大于1说明该列不完全相同 if len(x) &gt; 1: break # 将完全相同的列的字母添加到最长公共子串中 res = res + x[0] return res 代码二1234567891011def longestCommonPrefix(self, strs): if not strs: return \"\" s1 = min(strs) s2 = max(strs) for i, x in enumerate(s1): if x != s2[i] return s2[:i] return s1 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"机器学习之朴素贝叶斯","slug":"机器学习之朴素贝叶斯","date":"2019-09-22T12:05:14.000Z","updated":"2020-11-28T07:19:56.618Z","comments":true,"path":"passages/ji-qi-xue-xi-zhi-po-su-bei-xie-si/","link":"","permalink":"http://zivblog.top/passages/ji-qi-xue-xi-zhi-po-su-bei-xie-si/","excerpt":"朴素贝叶斯","text":"朴素贝叶斯 算法要点 朴素贝叶斯是基于贝叶斯定理与特征条件独立假设的分类方法 算法概述 对于给定的训练数据集，首先基于特征条件独立假设学习输入输出的联合概率分布； 然后基于此模型，对给定输入的x，利用贝叶斯定理求出后验概率最大的输出y 优缺点 优点：在数据较少的情况下仍然有效，可以完成多分类任务 缺点：对于输入数据的准备方式较为敏感 相关数学知识 先验概率分布 与实验结果无关，与随机抽样无关，反应在进行统计试验之前根据其他有关参数的知识而得知的分布 条件概率 已知某条件的情况下，计算事件发生的概率 $P(事件1|条件) = \\frac{P(时间1 and 条件)}{P(条件)}$ 已知$P(x|c)$求$P(c|x)$，$P(c|x) = \\frac{P(x|c)P(c)}{P(x)}$ 极大似然估计 已知某个参数值能使这个样本出现的概率最大，我们就直接将这个参数的值做为估计的真实值 模型： 高斯模型 多项式模型 伯努利模型 代码实现及测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106import numpy as np import pandas as pd import matplotlib.pyplot as plt from sklearn.datasets import load_irisfrom sklearn.model_selection import train_test_splitfrom collections import Counterimport mathdef create_data(): # 读取数据并返回X，y iris = load_iris() df = pd.DataFrame(iris.data, columns=iris.feature_names) df['label'] = iris.target df.columns = ['sepal length', 'sepal width', 'petal length', 'petal width', 'label'] data = np.array(df.iloc[:100, :]) # 返回X，y return data[:, :-1], data[:, -1]class NaiveBayes: def __init__(self): self.model = None # 数学期望（平均值） def mean(self, X): return sum(X) / float(len(X)) # 标准差（方差的算术平方根 sqrt(sum(x - r)^2)/N） def stdev(self, X): avg = self.mean(X) return math.sqrt(sum([pow(x - avg, 2) for x in X]) / float(len(X))) # 概率密度函数 def gaussian_probability(self, x, mean, stdev): exponent = math.exp(-(math.pow(x - mean, 2) / (2 * math.pow(stdev, 2)))) return (1 / (math.sqrt(2 * math.pi) * stdev)) * exponent # 处理X_train: 取每一条数据的均值和标准差 def summarize(self, train_data): summaries = [(self.mean(i), self.stdev(i)) for i in zip(*train_data)] return summaries # 分类别求出数学期望和标准差 def fit(self, X, y): # 无重复的标记 labels = list(set(y)) # 根据类别标记创建类别标记数个字典键值对 data = &#123;label: [] for label in labels&#125; # 将不同类别标记的实例放到不同的列表中 for f, label in zip(X, y): data[label].append(f) self.model = &#123; label: self.summarize(value) for label, value in data.items() &#125; return 'gassianNB train done !' # 计算概率 def calculate_probabilities(self, input_data): probabilities = &#123;&#125; for label, value in self.model.items(): probabilities[label] = 1 for i in range(len(value)): mean, stdev = value[i] # 计算高斯概率密度函数 probabilities[label] *= self.gaussian_probability(input_data[i], mean, stdev) return probabilities def predict(self, X_test): label = sorted( self.calculate_probabilities(X_test).items(), key=lambda x: x[-1])[-1][0] return label def score(self, X_test, y_test): # 计算预测正确率 right = 0 for X, y in zip(X_test, y_test): label = self.predict(X) if label == y: right += 1 return right / float(len(X_test)) if __name__ == \"__main__\": X, y = create_data() X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3) # print(X_test[0], y_test[0]) model = NaiveBayes() model.fit(X_train, y_train) print('X is [4.4, 3.2, 1.3, 0.2], label is &#123;&#125;'.format(model.predict([4.4, 3.2, 1.3, 0.2]))) print('model score : ', model.score(X_test, y_test)) 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://zivblog.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://zivblog.top/tags/AI/"}]},{"title":"xgboost和lightGBM的安装","slug":"xgboost和lightGBM的安装","date":"2019-09-22T11:59:49.000Z","updated":"2020-07-06T05:42:36.000Z","comments":true,"path":"passages/xgboost-he-lightgbm-de-an-zhuang/","link":"","permalink":"http://zivblog.top/passages/xgboost-he-lightgbm-de-an-zhuang/","excerpt":"LightGBM，XGBoost","text":"LightGBM，XGBoost LightGBM，XGBoost作为非常经典的GBDT模型，在机器学习的比赛中使用的频率也是非常之高。这里记录一下安装这两个库的步骤 配置环境 Windows10 Python3.7 Xgboost的安装 官网上有很详细的安装方法，但折腾了半天还是不能使用。所以这里我们选择使用离线安装的方式进行安装 首先在这里下载对应版本的xgboost版本 将目录切换到whl文件所在的目录 使用pip install xgboost-XXXXXX.whl进行安装 安装完成之后，使用import xgboost as xgb测试是否安装成功 lightGBM的安装 LightGBM是微软开源的一个Python工具包 网上大部分的安装教程都是编译安装的，坑点比较多，这里介绍一种简单的安装方式 在这里下载whl安装包 将目录切换到lightGBM所在的目录 使用pip install lightgbm-XXXXX.whl进行安装 使用import lightgbm as lgb测试 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"工具配置","slug":"工具配置","permalink":"http://zivblog.top/categories/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://zivblog.top/tags/Tools/"}]},{"title":"机器学习之感知机模型","slug":"机器学习之感知机模型","date":"2019-09-20T13:59:29.000Z","updated":"2020-11-28T07:20:16.381Z","comments":true,"path":"passages/ji-qi-xue-xi-zhi-gan-zhi-ji-mo-xing/","link":"","permalink":"http://zivblog.top/passages/ji-qi-xue-xi-zhi-gan-zhi-ji-mo-xing/","excerpt":"感知机模型","text":"感知机模型 算法要点 感知机是线性分类模型，属于判别模型，二分类模型 旨在求出特征空间中将实例划分为正负两类的分离超平面 算法概述 感知机是根据输入实例的特征向量对其进行而分类的线性分类模型 感知机学习的策略是极小化损失函数 感知机学习算法是基于随即梯度下降法的对损失函数的最优化算法 输入空间到输出空间的函数（感知机）：$f(x) = sign(w*x + b)$ 损失函数：$L(w, b) = - \\sum_{x_i \\in M}{y_i(w \\cdot x_i + b)}$ 学习策略：在假设空间中选取使损失函数最小的模型参数$w, b$ 优化过程 每次随机选取其中一个误分类点计算损失 损失函数分别对$w, b$求偏导 根据学习率进行参数值的更新 当训练数据集线性可分时，感知机学习算法是收敛的 代码实现及测试1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import pandas as pd import numpy as np from sklearn.datasets import load_irisimport matplotlib.pyplot as plt class Perceptron: def __init__(self): # 初始化模型的参数：w初始化为与data长度相同的一维向量，b初始化为0，learning rate为0.1 self.w = np.ones(len(data[0])-1, dtype=np.float32) self.b = 0 self.l_r = 0.1 def sign(self, x, w, b): y = np.dot(x, w) + b return y def fit(self, X_train, y_train): # 随机梯度下降 is_wrong = False # 有误分点的时候才会进行梯度下降 while not is_wrong: wrong_count = 0 for d in range(len(X_train)): X = X_train[d] y = y_train[d] if y*self.sign(X, self.w, self.b) &lt;= 0: self.w = self.w + self.l_r * np.dot(y, X) self.b = self.b + self.l_r * y wrong_count += 1 if wrong_count == 0: is_wrong = True return 'Perceptron Model' def predict(self, X): if np.dot(self.w, X) + self.b &gt; 0: return 1 else: return -1 def score(self): passif __name__ == \"__main__\": # 加载数据集 iris = load_iris() # 转化数据格式 df = pd.DataFrame(iris.data, columns=iris.feature_names) df['label'] = iris.target df.columns = ['sepal length', 'sepal width', 'petal length', 'petal width', 'label'] data = np.array(df.iloc[:100, [0, 1, -1]]) X, y = data[:, :-1], data[:,-1] # 将实例的target分为两类（感知机是二分类模型）,并且target设为1，-1 y = np.array([1 if i==1 else -1 for i in y]) # 加载模型并训练 perceptron = Perceptron() perceptron.fit(X, y) x_points = np.linspace(4, 7, 10) # 划分超平面 y_ = -(perceptron.w[0] * x_points + perceptron.b) / perceptron.w[1] # 直线 plt.plot(x_points, y_) # 散点图 plt.plot(data[:50, 0], data[:50, 1], 'bo', color='blue', label='1') plt.plot(data[50:100, 0], data[50:100, 1], 'bo', color='orange', label='-1') plt.xlabel('sepal length') plt.ylabel('sepal width') plt.legend() plt.show() # print(perceptron.predict([1, 2])) 参考资料 《统计学习方法（第二版）》 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://zivblog.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://zivblog.top/tags/AI/"}]},{"title":"机器学习之K邻近算法","slug":"机器学习之K临近算法","date":"2019-09-20T13:56:48.000Z","updated":"2020-11-28T07:20:51.761Z","comments":true,"path":"passages/ji-qi-xue-xi-zhi-k-lin-jin-suan-fa/","link":"","permalink":"http://zivblog.top/passages/ji-qi-xue-xi-zhi-k-lin-jin-suan-fa/","excerpt":"K临近算法","text":"K临近算法 算法要点 KNN是一种有监督的机器学习算法 不具有显示的学习过程，预测 –&gt; 现场投票 结果唯一确定 算法概述 给定一个训练数据集，对于任意的待预测实例，计算该实例与训练集中所有实例的距离，选择与该实例距离最近的K个实例进行投票，实例数最多的类别即被认定为待预测实例的类别 关键参数：K，即允许参与最终投票的实例数 距离度量 欧式距离 曼哈顿距离 各坐标距离的最大值 特殊情况：当k=1的时候，称为最临近算法。也即是只与输入实例点最近的实例的类别有关 K值的取值 选择较小的K值，近似误差会减小，估计误差会增大。也就是说K值的减小就意味着整体模型变得复杂，容易发生过拟合 选择较大的K值，可以减少模型的估计误差，但是学习的近似误差会增大。意味着模型变得简单。 代码实现及测试12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697import math from itertools import combinationsimport numpy as np import pandas as pd import matplotlib.pyplot as plt from sklearn.datasets import load_irisfrom sklearn.model_selection import train_test_splitfrom collections import Counter'''验证数据集：鸢尾花数据集算法：自主实现的KNN辅助： 使用sklearn中的函数将数据集划分为训练集和测试集 使用Counter函数作为计数器'''def show_data(iris): # 转化数据格式 df = pd.DataFrame(iris.data, columns=iris.feature_names) df['label'] = iris.target df.columns = ['sepal length', 'sepal width', 'petal length', 'petal width', 'label'] # 绘制散点图（取前两个维度作为坐标，每一个类别取50个） plt.scatter(df[:50]['sepal length'], df[:50]['sepal width'], label='0') plt.scatter(df[50:100]['sepal length'], df[50:100]['sepal width'], label='1') plt.xlabel('sepal length') plt.ylabel('sepal width') plt.legend() plt.show()class KNN: def __init__(self, X_train, y_train, n_neighbors=3, p=2): # 默认K取3，距离默认使用欧式距离 self.n = n_neighbors self.p = p self.X_train = X_train self.y_train = y_train def predict(self, X): ''' 将输入的X与训练集的各个实例计算距离，取前n_neighbors个进行投票 ''' knn_list = [] # 先将前n个存入knn_list，再计算后len(X_train)-n个，同时比较，将距离更小的替换进来 # 可减小内存压力 for i in range(self.n): # 计算所有实例与待预测实例之间的距离 dist = np.linalg.norm(X - self.X_train[i], ord=self.p) # (距离, target)作为数据对 knn_list.append((dist, self.y_train[i])) for i in range(self.n, len(self.X_train)): max_index = knn_list.index(max(knn_list, key=lambda x: x[0])) dist = np.linalg.norm(X - self.X_train[i], ord=self.p) if knn_list[max_index][0] &gt; dist: knn_list[max_index] = (dist, self.y_train[i]) # 统计实例数最多的类别 knn = [k[-1] for k in knn_list] count_pairs = Counter(knn) max_count = sorted(count_pairs.items(), key=lambda x: x[1])[-1][0] return max_count def score(self, X_test, y_test): ''' 计算预测正确率 ''' right_count = 0 for X, y in zip(X_test, y_test): label = self.predict(X) if label == y: right_count += 1 return right_count / len(X_test)if __name__ == \"__main__\": # 加载数据集 iris = load_iris() # 显示数据 # show_data(iris) # 预处理数据 new_iris = np.column_stack((iris.data, iris.target)) # 划分数据集 X_train, X_test, y_train, y_test = train_test_split(new_iris[:, :4],new_iris[:, -1], test_size = 0.3, random_state=0) clf = KNN(X_train, y_train) print(clf.score(X_test, y_test)) 参考资料 《统计学习方法（第二版）》 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://zivblog.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://zivblog.top/tags/AI/"}]},{"title":"Python库之collections","slug":"Python库之collections","date":"2019-09-20T13:49:17.000Z","updated":"2020-07-06T05:38:40.000Z","comments":true,"path":"passages/python-ku-zhi-collections/","link":"","permalink":"http://zivblog.top/passages/python-ku-zhi-collections/","excerpt":"collections","text":"collections 今天看代码的时候发现了collections这个Python库，遂学习一下 collections是什么 collections是一个Python内建的集合模块，提供许多有用的集合类 collections模块提供了特定目标的容器，以提供Python标准内建容器dict、list、set、tuple的替代选择 collections提供的功能模块 namedtuple：用来创建一个自定义的tuple对象，并且规定了tuple元素的个数，并可以用属性而不是索引来引用tuple的某个元素 deque：为了高效实现插入和删除操作的双向列表，适合用于队列和栈 ChainMap：类似字典的容器类，将多个映射集合到一个视图里面 Counter：一个简单的计数器（使用频率较高） OrderedDict：字典的子类，保存了他们被添加的顺序 defaultdict：key不存在时，返回一个默认值，而默认的dict在key不存在是会抛出keyError UserDict：封装了字典对象，简化了字典子类化 UserList：封装了列表对象，简化了列表子类化 UserString：封装了列表对象，简化了字符串子类化 实例 namedtuple 1234567891011121314from collections import namedtuple'''namedtuple允许自定义tuple对象，可以规定tuple的元素个数，允许使用属性来引用元素'''# 定义一个坐标点tuple，并规定元素个数为2Point = namedtuple('Point', ['x', 'y'])p = Point(1, 2)# 使用属性和索引都可以引用元素print(p.x, p.y) # 1 2print(p[0], p[1]) # 1 2 deque 123456789101112from collections import deque'''deque高效实现列表的插入和删除元素，适合用于队列和栈另外还实现了除list本身的append()和pop()方法之外的appendleft()和popleft()，即允许高效的从头部添加和删除元素'''q = deque(['a', 'b', 'c'])q.append('x')q.appendleft('y')print(q) # deque(['y', 'a', 'b', 'c', 'x']) defaultdict 1234567891011from collections import defaultdict'''defaultdict在dict中引用的key不存在的时候，不会抛出KeyError，而是抛出一个预先设定的值'''dd = defaultdict(lambda :'N/A')dd['key1'] == 'abc'print(dd['key1']) # abcprint(dd['key2']) # N/A OrderedDict 1234567891011from collections import OrderedDict'''OrderedDict字典在迭代时是无序的而OrderedDict，保存了他们被添加的顺序'''d = dict([('a', 1), ('b', 2), ('c', 3)])print(d) # &#123;'a': 1, 'c': 3, 'b': 2&#125;od = OrderedDict([('a', 1), ('b', 2), ('c', 3)])print(od) # OrderedDict([('a', 1), ('b', 2), ('c', 3)]) Counter 123456from collections import Counter '''Counter计数器'''print(Counter('programming')) # Counter(&#123;'g': 2, 'm': 2, 'r': 2, 'a': 1, 'i': 1, 'o': 1, 'n': 1, 'p': 1&#125;) ChainMap 1234567891011121314from collections import ChainMap'''ChainMap将多个字典或者映射，将它们从逻辑上合并为一个单一的映射后执行某些操作'''a = &#123;'x': 1, 'z': 3 &#125;b = &#123;'y': 2, 'z': 4 &#125;c = ChainMap(a,b)print(c['x']) # 1 (from a)print(c['y']) # 2 (from b)print(c['z']) # 3 (from a) UserDict、UserList、UserString需要的可以自行查阅官方帮助文档 参考资料 廖雪峰的官方网站 Python官方文档 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://zivblog.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://zivblog.top/tags/Python/"}]},{"title":"Leetcode之罗马数字转整数","slug":"Leetcode之罗马数字转整数","date":"2019-09-19T14:22:59.000Z","updated":"2020-07-06T05:22:37.000Z","comments":true,"path":"passages/leetcode-zhi-luo-ma-shu-zi-zhuan-zheng-shu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-luo-ma-shu-zi-zhuan-zheng-shu/","excerpt":"罗马数字转整数","text":"罗马数字转整数 题目描述 题目详情见：罗马数字转整数 题目难度：简单 相关标签：数字、字符串 思路 我们发现特殊情况下，左边的数字小于右边的数字。也就是说，从左往右看的时候，左边的字符表示的数字小于右边的字符表示的数字，则需要用右边的字符减去左边的（这里可以通过将左边的字符表示的数字取负来实现） 其他情况下（左边的字符大于或等于右边的字符），只需要将它们表示的数字相加即可 建立字典：单个罗马字符与数字之间的映射 使用语言：Python 代码12345678910111213def ramonToInt(s: str): roma_nums = &#123;'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000&#125; num = 0 for i in range(len(s) - 1): if roma_nums[s[i]] &gt;= roma_nums[s[i+1]]: num += roma_nums[s[i]] else: num -= roma_nums[s[i]] last_num = s[len(s)-1] num = num + roma_nums[last_num] return num 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"Leetcode之回文数","slug":"Leetcode之回文数","date":"2019-09-18T13:58:29.000Z","updated":"2020-03-04T06:26:00.000Z","comments":true,"path":"passages/leetcode-zhi-hui-wen-shu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-hui-wen-shu/","excerpt":"尽量使用Python解决，不排除使用C编写代码","text":"尽量使用Python解决，不排除使用C编写代码 题目描述 题目详情请见回文数 题目难度：简单 相关标签：数学 思路 判断一个整数是否是回文数，最直接的想法就是利用字符串来处理 进阶要求：不允许将整数转化为字符串 注意负号会影响回文，例如：-121反过来是121-，所以我们可以认为负数不可能是回文数 我们这里要求的是整数，所以要注意反转数字时的溢出问题（MIN_VALUE~MAX_VALUE） 这里有一点要注意：如果是回文数，显然是不会溢出的，所以溢出的必然不是回文数 总结一下：负数不可能是回文数，反转之后溢出的不是回文数，10的倍数不是回文数 使用字符串（见代码一）： 先判断是否为负数，如果是负数，则返回False 如果是正数，则转化成字符串，再将字符与反转之后的字符串比较 相等，则返回True；否则，返回False 不使用字符串（见代码二）： 主要思想是：取其后半段与前半段进行比较即可，这样不用处理溢出问题 要注意数字的位数是偶数还是奇数 具体做法见代码 代码一12345678910# 一般要求，使用字符串来处理def isPalindrome(self, x: int) -&gt; bool: if x &lt; 0: return False else: x_str = str(x) if x_str[::-1] == x_str: return True else: return False 代码二123456789101112131415161718192021# 具体做法# 1. 每次进行取余操作，去除最低位（y = x % 10）# 2. 将最低为的数字加到取出数的末尾（rN = rN*10 + y）# 3. 每取一个最低为数字，x都要自除以10# 4. 判断x是否小于rN，小于的时候说明已经对半或过半了# 5. 最后判断奇数偶数位分别判断（奇数位的中间一位不需要判断）bool isPalindrome(int x)&#123; int rN=0; if(x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0))&#123; // 负数不是回文数，10的倍数不可能是回文数，因为末位为0 return false; &#125;else&#123; while(x &gt; rN)&#123; rN = rN * 10 + x % 10； x = x / 10; &#125; // 分别处理偶数位和奇数位的情况 return x == rN || x = rN / 10; &#125;&#125; ​ 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"信息熵","slug":"信息熵","date":"2019-09-17T14:22:51.000Z","updated":"2020-07-06T05:48:40.000Z","comments":true,"path":"passages/xin-xi-shang/","link":"","permalink":"http://zivblog.top/passages/xin-xi-shang/","excerpt":"信息熵","text":"信息熵 信息熵定义 任何信息都存在冗余，冗余大小与信息中每个符号的出现概率（不确定性）有关 把信息中排除了冗余后的平均信息量即为信息熵 表征了随机变量X所有情况下的平均不确定度 定义：$H(X)=-\\sum_{x \\in X}{P(x)log(P(X))}$ 概率大，出现的机会多，不确定性就小；反之，概率小，不确定性就大，所以不确定性函数f(X)是概率P(X)的单调递减函数：即概率越大，不确定性越小 独立符号的不确定性是可加的，即$f(P_1, P_2) = f(P_1) + f(P_2) 对定义的理解 下面我们对一些概念做更加通俗的理解： 为什么有的信息量大，有的信息量小？ 有些事情本来不是很确定，例如明天股票的涨跌；所以你的信息对明天股票是涨是跌带来的信息量很小。但是如果告诉你明天NBA决赛开始了，两者似乎没什么联系，但是加入决赛开始大家都去看球不关注股市了，没人坐庄的股票很大概率会跌，所以这句话信息量很大，因为本来不确定的事情便的十分确定了。 有些事本来就很确定，例如太阳从东边升起，你再说100遍，你的话还是没有任何信息量，因为这件事不能更加确定了 所以说信息量的大小跟事情不确定性的变化有关 不确定性的变化与什么有关呢？ 跟事情的可能结果的数量有关。也就是说可能结果数量比较大时，我们得到的新信息才由潜力拥有大量信息。 跟概率有关，尤其是初始概率。比如电影院由225个座位，小明坐哪个座位的结果数量很多，但是如果说一开始就知道小明在第一排最左边的可能是99%，那么结果就几乎确定了，也就是说在这个时候再告诉我小明的什么信息也没有了。 如何衡量不确定性的变化的大小呢？ 不能是负数 信息量之间可以相加 信息量连续依赖于概率，也就是说，某个概率变化了极小一个值，信息量不应该变化很大 信息量的大小跟可能结果数量有关。如果每一个结果出现的概率一样，那么对于可能结果数量多的那个时间，新信息有更大的潜力具有更大的信息量。因为初始状态下不确定性更大 所以数学上，信息熵是信息量的期望（累加和） 举个例子 在自然语言处理中，信息熵只反映内容的随机性（不确定性）和编码情况，与内容本身无关 也就是说，对于一篇文章，其信息熵反映的是文章中字符编码之间的关系，也就是与有多少个不同字符有关，而与一共有多少字符没有关系 一本100万字的中文书平均有多少信息量？ 根据之前的知识，我们知道100万这个数字是没有用的，我们关注的不是文章总共有多少字，而是有多上个字是频繁出现的 我们知道，常用的汉字约7000个，假设每个汉字等概率，那么一个汉字的信息熵为： $H = -(1/7000log(1/7000) +….1/7000log(1/70000)) \\approx 13$ 也就是说，整本书的信息量大约是1300万 所以 信息量的大小和事件发生的概率成反比，表示为： $$h(x) = -log(P(x))$$ 信息量度量的是一个具体事件发生所带来的信息，而熵则是在结果出来之前对可能产生的信息量的期望——考虑该随机变量的所有可能取值，即所有可能发生事件所带来的信息量的期望 信息熵是用来衡量事物不确定性的。信息熵越大，事物越具不确定性，事物越复杂，信息量就越大 如果您发现错误或有疑问，欢迎交流指or指教 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"自然语言处理","slug":"自然语言处理","permalink":"http://zivblog.top/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"}],"tags":[{"name":"NLP","slug":"NLP","permalink":"http://zivblog.top/tags/NLP/"}]},{"title":"词袋模型（BOW）","slug":"词袋模型（BOW）","date":"2019-09-17T14:19:48.000Z","updated":"2020-07-06T05:43:44.000Z","comments":true,"path":"passages/ci-dai-mo-xing-bow/","link":"","permalink":"http://zivblog.top/passages/ci-dai-mo-xing-bow/","excerpt":"词袋模型","text":"词袋模型 词袋模型可以用来干什么？ 词袋模型可以用于表示一段文本，包括句子、篇章等。 词袋模型是如何实现的？ 首先将文本划分为一个个独立的词 将这些词无重复的存到一个“袋子”里，这个就叫做词袋 统计每个词的词频（在该段文本中出现的次数），存入对应词相同的下标位置 这个词频就作为该词的编码 举个例子 John likes to watch movies. Mary likes too. But I do not like. 单词列表：[‘John’, ‘likes’, ‘to’, ‘watch’, ‘movies’, ‘Mary’, ‘too’, ‘But’, ‘I’, ‘do’, ‘not’,’like’] 建立词典：{‘John’: 1, ‘likes’: 2, ‘to’: 1, ‘watch’: 1, ‘movies’: 1, ‘Mary’: 1, ‘too’: 1, ‘But’: 1, ‘I’: 1, ‘do’: 1, ‘not’:1, ‘like’:1} 三句文本的编码为依次为： [1, 2, 1, 1, 1] [1, 2, 1] [1, 1, 1, 1, 1] 词袋模型有什么缺陷？ 忽略了文本的语法和语序信息，仅仅将其看作若干词汇的集合 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"自然语言处理","slug":"自然语言处理","permalink":"http://zivblog.top/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"}],"tags":[{"name":"NLP","slug":"NLP","permalink":"http://zivblog.top/tags/NLP/"}]},{"title":"Leetcode之整数取余","slug":"Leetcode之整数取余","date":"2019-09-17T14:12:38.000Z","updated":"2020-07-06T05:31:28.000Z","comments":true,"path":"passages/leetcode-zhi-zheng-shu-qu-yu/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-zheng-shu-qu-yu/","excerpt":"整数取余","text":"整数取余 题目描述 题目详情见：整数反转 题目难度：简单 相关标签：数学 思路 输入的数字是32位的有符号整数，要注意是否会产生溢出 值得注意的是题目要求只能用int来存储，那么想要使用Long类型来存储的想法也行不通了 如果没有溢出问题，本题的思路是非常简单的，直接使用栈或者数组记录每一位的数字，再依次乘以相应的10^n累加即可 解决溢出一般有两种思路，一种是转化成字符串，使用try_catch结构来解决；另一种是使用数学的方式来解决 通过数学的方式来解决溢出问题 通过循环求得数字X的每一位，在每一步计算新值的时候都进行溢出判断 int的最大值是MAX_VALUE=2147483647，最小值是MIN_VALUE=-2147483648‬，这里我们假设当前计算结果是anw，下一位为next 当出现anw &gt; MAX_VALUE / 10并且还有next添加时，必定会上溢出 当出现anw == MAX_VALUE / 10并且next &gt; 7时，必定会上溢出 当出现anw &lt; MIN_VALUE / 10并且还有next需要添加时，必定会下溢出 当出现anw == MIN_VALUE / 10并且next &lt; -8时，并定会下溢出 通过转化为字符串来解决溢出问题 先将给定的数字转化成字符串，再利用字符串可以随机访问每一个位置的元素值的特性，依次取值，添加到新的字符串中 使用int()将字符串转化为数字 要注意的是负数的str[0]是不需要参与反转的，只需要再最后转化层整数的时候加负号即可 代码一12345678910111213141516# 由于对于负数取余上的一些不同，我们使用java语言实现该算法class Solution &#123; public int reverse(int x) &#123; int ans = 0; while (x != 0) &#123; int pop = x % 10; if (ans &gt; Integer.MAX_VALUE / 10 || (ans == Integer.MAX_VALUE / 10 &amp;&amp; pop &gt; 7)) return 0; if (ans &lt; Integer.MIN_VALUE / 10 || (ans == Integer.MIN_VALUE / 10 &amp;&amp; pop &lt; -8)) return 0; ans = ans * 10 + pop; x /= 10; &#125; return ans; &#125;&#125; 代码二1234567891011121314151617def reverse(self, x: int) -&gt; int: #MAX_VALUE = 2147483647 #MIN_VALUE = -2147483648 strx = str(x) # 转化成字符串 n = len(strx) # 字符串长度 strxx = '' if x &gt;= 0: for i in range(n): strxx = strx[i] + strxx return int(strxx) if int(strxx)&lt;=2147483647 else 0 else: # 负数反转时要跳过负号 for i in range(1, n): strxx = strx[i] + strxx return -int(strxx) if -int(strxx)&gt;=-2147483648 else 0 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"离线安装Pytorch","slug":"离线安装Pytorch","date":"2019-09-11T08:06:12.000Z","updated":"2020-07-06T05:46:26.000Z","comments":true,"path":"passages/chi-xian-an-zhuang-pytorch/","link":"","permalink":"http://zivblog.top/passages/chi-xian-an-zhuang-pytorch/","excerpt":"离线安装Pytorch","text":"离线安装Pytorch 今天在新电脑上配置环境，无奈暂时没有有线网络和无线网卡，遂使用其他机器下载离线whl包进行了Pytorch的安装，这里略作整理，供有相关需要的同行们查阅。 安装环境 Windows10专业版 Python3.7 操作步骤 首先要下载离线包，由于每个人的电脑硬件配置不同，这里建议如下操作： 打开Pytorch的官网，按照引导选择自己的配置，注意安装工具那里选择pip，这时你会得到一个网址，像这样： 我们复制其中的网址到浏览器打开，就可以在其中选择要下载的离线包了。 之后就是安装了 执行conda install torch-xxxx和conda install torchvision xxxx即可安装成功了。 测试 在python文件中或命令行下的python环境中执行import torch和import torchvision，若成功导入，则说明安装成功。 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"工具配置","slug":"工具配置","permalink":"http://zivblog.top/categories/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://zivblog.top/tags/Tools/"}]},{"title":"conda创建虚拟环境","slug":"Conda虚拟环境创建","date":"2019-09-10T08:17:29.000Z","updated":"2020-07-06T05:06:51.000Z","comments":true,"path":"passages/conda-xu-ni-huan-jing-chuang-jian/","link":"","permalink":"http://zivblog.top/passages/conda-xu-ni-huan-jing-chuang-jian/","excerpt":"conda创建虚拟环境","text":"conda创建虚拟环境 conda是什么？ 简单来说，conda就是一个Python包的管理工具，用于管理Python的各种工具包；同时conda还可以用于虚拟环境之间的创建和切换，可以实现多套环境之间的共存，满足使用者对多重不同环境配置的需求。 更换软件源 conda默认的软件源是国外的，在软件包的安装的时候速度会受限，多以更换为国内的源会有所改善。 这里以Windows下将软件源修改为清华源为例 12345$ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/$ conda config --set show_channel_urls yes注意要删除掉.condarc文件，默认在C:/username/Anaconda/pkgs/free文件夹下 另外，国内主流的文件源还有中科大源，需要的可自行百度。 conda常用命令 1234567891011121314151617181920212223# 列出当前conda环境所链接的所有软件包$ conda list# 列出当前创建的所有虚拟环境$ conda env list# 创建conda虚拟环境$ conda create -n 环境名 python=指定python版本# 在指定环境中安装工具包包$ conda install -n 环境名 工具包名# 激活虚拟环境$ activate 虚拟环境名# 关闭虚拟环境（使用系统默认环境）$ deactivate 环境名# 删除虚拟环境$ conda remove -n 虚拟环境名 --all# 卸载环境中的一个包$ conda remove -n 环境名 包名 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"工具配置","slug":"工具配置","permalink":"http://zivblog.top/categories/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://zivblog.top/tags/Tools/"}]},{"title":"Numpy100题之81~100","slug":"Numpy100题之81-100","date":"2019-09-01T11:22:21.000Z","updated":"2020-03-04T06:35:28.000Z","comments":true,"path":"passages/numpy100-ti-zhi-81-100/","link":"","permalink":"http://zivblog.top/passages/numpy100-ti-zhi-81-100/","excerpt":"学习笔记 答案整理 原文地址：https://zhuanlan.zhihu.com/p/76186124 总结：有些操作过分为了操作而操作，使用频率不高，不必花费过多时间在上面","text":"学习笔记 答案整理 原文地址：https://zhuanlan.zhihu.com/p/76186124 总结：有些操作过分为了操作而操作，使用频率不高，不必花费过多时间在上面 考虑一个数组Z = [1,2,3,4,5,6,7,8,9,10,11,12,13,14]，如何生成一个数组R = [[1,2,3,4]， [2,3,4,5], [3,4,5,6], ...,[11,12,13,14]]? 1234567891011121314151617# np.stride_tricks.as_strided(x, shape, strides, subok, writeable) 按照shape对x进行分块Z = np.arange(1, 15, dtype=np.uint32)R = np.lib.stride_tricks.as_strided(Z, (11, 4), (4, 4))print(R)结果：[[ 1 2 3 4] [ 2 3 4 5] [ 3 4 5 6] [ 4 5 6 7] [ 5 6 7 8] [ 6 7 8 9] [ 7 8 9 10] [ 8 9 10 11] [ 9 10 11 12] [10 11 12 13] [11 12 13 14]] 计算一个矩阵的秩 12345678# np.linalg.svd() 奇异值分解，三个返回值，s的对角线是奇异值，由大到小排列Z = np.random.uniform(0, 1, (10, 10))U, S, V = np.linalg.svd(Z)rank = np.sum(S &gt; 1e-10)print(rank)结果：10 如何找到一个数组中出现频率最高的值？ 1234567# np.bincount(), argmax()# 使用宾count()统计元素值的频率，argmax()返回的索引即为频率最高的元素Z = np.random.randint(0, 10, 50)print(np.bincount(Z).argmax())结果：1 从一个10x10的矩阵中提取出连续的3x3区块 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# np.lib.stride_tricks.as_strided()Z = np.random.randint(0, 5, (10, 10))n = 3i = 1 + (Z.shape[0]-3)j = 1 + (Z.shape[1]-3)C = np.lib.stride_tricks.as_strided(Z, shape=(i, j, n, n), strides=Z.strides + Z.strides)print(C)结果：[[1 4 4 4 3 4 0 4 0 0] [4 3 0 3 0 2 3 1 4 4] [0 2 2 0 2 4 1 2 0 1] [2 2 4 2 2 3 4 0 3 3] [2 0 1 2 0 0 0 0 3 4] [4 1 0 4 4 4 3 1 2 0] [2 0 4 2 2 2 2 3 0 2] [3 0 2 0 3 1 2 3 0 0] [4 0 3 2 0 4 0 0 1 0] [1 4 3 4 4 0 2 4 4 2]][[[[1 4 4] [4 3 0] [0 2 2]] [[4 4 4] [3 0 3] [2 2 0]] [[4 4 3] [0 3 0] [2 0 2]] [[4 3 4] [3 0 2] [0 2 4]] [[3 4 0] [0 2 3] [2 4 1]] [[4 0 4] [2 3 1] [4 1 2]] [[0 4 0] [3 1 4] [1 2 0]] ... [[3 0 0] [0 1 0] [4 4 2]]]] 创建一个满足Z[i,j]==Z[j,i]的子类 1234567891011121314# 类的定义class Symetric(np.ndarray): def __setitem__(self, index, value): i, j = index super(Symetric, self).__setitem__((i, j), value) super(Symetric, self).__setitem__((j, i), value) def symetric(Z): return np.asarray(Z + Z.T - np.diag(Z.diagonal())).view(Symetric) S = Symetric(np.random.randint(0, 10, (5, 5)))S[2, 3] = 42print(S)结果： 考虑p个nxn矩阵和一组形状为(n,1)的向量，如何直接计算p个矩阵的乘积(n,1)？ 12345678910111213141516171819202122232425262728# np.tensordot() 沿指定轴计算张量的点积p, n = 10, 20M = np.ones((p, n, n))V = np.ones((p, n, 1))S = np.tensordot(M, V, axes=[[0, 2], [0, 1]])print(S)结果：[[200.] [200.] [200.] [200.] [200.] [200.] [200.] [200.] [200.] [200.] [200.] [200.] [200.] [200.] [200.] [200.] [200.] [200.] [200.] [200.]] 对于一个16x16的数组，如何得到一个区域(block-sum)的和(区域大小为4x4)? 1234567891011# np.add.reduceat() 功能等同于np.sum()，实际上np.sum()调用的就是前者Z = np.ones((16, 16))k = 4S = np.add.reduceat(np.add.reduceat(Z, np.arange(0, Z.shape[0], k), axis=0), np.arange(0, Z.shape[1], k), axis=1)print(S)结果：[[16. 16. 16. 16.] [16. 16. 16. 16.] [16. 16. 16. 16.] [16. 16. 16. 16.]] 如何利用Numpy数组实现Game of Life? 123456789101112131415161718192021222324252627282930313233''' 生命游戏中，对于任意细胞： 每个细胞有两种状态：存活或死亡。每个细胞与以自身为中心的周围八格细胞产生互动。 1.当前细胞为存活状态时，当周围的活细胞低于2个时， 该细胞因孤独而死亡; 2.当前细胞为存活状态时，当周围有2个或3个活细胞时， 该细胞保持原样; 3.当前细胞为存活状态时，当周围有3个以上活细胞时，该细胞因资源匮乏而死亡; 4.当前细胞为死亡状态时，当周围有3个活细胞时，该细胞变成存活状态(模拟繁殖)。'''def iterate(Z): # Count neighbours N = (Z[0:-2,0:-2] + Z[0:-2,1:-1] + Z[0:-2,2:] + Z[1:-1,0:-2] + Z[1:-1,2:] + Z[2: ,0:-2] + Z[2: ,1:-1] + Z[2: ,2:]) # Apply rules birth = (N==3) &amp; (Z[1:-1,1:-1]==0) survive = ((N==2) | (N==3)) &amp; (Z[1:-1,1:-1]==1) Z[...] = 0 Z[1:-1,1:-1][birth | survive] = 1 return ZZ = np.random.randint(0,2,(50,50))for i in range(100): Z = iterate(Z) print (Z) 结果：[[0 0 0 ... 0 0 0] [0 0 0 ... 0 0 0] [0 0 0 ... 0 0 0] ... [0 0 0 ... 0 0 0] [0 0 0 ... 0 0 0] [0 0 0 ... 0 0 0]] 如何找到一个数组的第n个最大值? 12345678# argsort()排序后读取倒数第n个值Z = np.arange(10000)np.random.shuffle(Z)n = 5print(Z[np.argsort(Z)[-n:]])结果：[9995 9996 9997 9998 9999] 给定任意个数向量，创建笛卡尔积(每一个元素的每一种组合) 1234567891011121314151617181920212223242526# 笛卡尔积：两个集合的组合# np.indices()def cartesian(arrays): arrays = [np.asarray(a) for a in arrays] shape = (len(x) for x in arrays) ix = np.indices(shape, dtype=int) ix = ix.reshape(len(arrays), -1).T for n, arr in enumerate(arrays): ix[:, n] = arrays[n][ix[:, n]] return ixprint(cartesian(([1, 2, 3], [4, 5], [6, 7])))结果：[[1 4 6] [1 4 7] [1 5 6] [1 5 7] [2 4 6] [2 4 7] [2 5 6] [2 5 7] [3 4 6] [3 4 7] [3 5 6] [3 5 7]] 如何从一个正常数组创建记录数组(record array)? 1234567# np.core.records.fromarrays()Z = np.array([(\"Hello\", 2.5, 3), (\"World\", 3.6, 2)])R = np.core.records.fromarrays(Z.T, names='col1, col2, col3', formats='S8, f8, i8')print(R)结果：[(b'Hello', 2.5, 3) (b'World', 3.6, 2)] 考虑一个大向量Z, 用三种不同的方法计算它的立方 12345678910111213# np.power() 对列表、矩阵、数组等求n次方# '*'# np.einsum() 将向量插入某一行或列# 方法一x = np.random.rand()np.power(x, 3)# 方法二x*x*x# 方法三np.einsum('i, i, i-&gt;i', x,x,x) 考虑两个形状分别为(8,3)和(2,2)的数组A和B. 如何在数组A中找到满足包含B中元素的行？(不考虑B中每行元素顺序)？ 12345678910# np.where()A = np.random.randint(0, 5, (8, 3))B = np.random.randint(0, 5, (2, 2))C = (A[..., np.newaxis, np.newaxis] == B)rows = np.where(C.any((3, 1)).all(1))[0]print(rows)结果：[6 7] 考虑一个10x3的矩阵，分解出有不全相同值的行 (如[2,2,3]) 12345678910111213141516171819202122232425262728293031Z = np.random.randint(0, 5, (10, 3))print(Z)E = np.all(Z[:,1:] == Z[:,:-1], axis=1)U = Z[~E]print(U)结果：Z：[[4 0 3] [1 3 3] [2 0 4] [1 0 2] [0 2 2] [3 2 4] [0 1 2] [4 4 2] [0 0 0] [2 1 2]]U：[[1 2 2] [4 4 1] [0 1 3] [0 4 0] [3 1 0] [4 4 0] [1 3 2] [2 3 4] [4 4 1] [1 2 3]] 将一个整数向量转换为二进制矩阵matrix binary的表现形式 12345678910111213141516# np.unpackbits() 把整数转化乘二进制I = np.array([0, 1, 2, 3, 4, 15, 16, 32, 64, 128])B = ((I.reshape(-1, 1)&amp;(2**np.arange(8)))!=0).astype(int)print(B[:,::-1])结果：[[0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 1] [0 0 0 0 0 0 1 0] [0 0 0 0 0 0 1 1] [0 0 0 0 0 1 0 0] [0 0 0 0 1 1 1 1] [0 0 0 1 0 0 0 0] [0 0 1 0 0 0 0 0] [0 1 0 0 0 0 0 0] [1 0 0 0 0 0 0 0]] 给定一个二维数组，如何提取出唯一的(unique)行？ 1234567891011121314# np.ascontiguousarray() 将一个内存不连续存储的数组转化为内存连续存储的数组，加快运行速度Z = np.random.randint(0,2,(6,3))T = np.ascontiguousarray(Z).view(np.dtype((np.void, Z.dtype.itemsize * Z.shape[1])))_, idx = np.unique(T, return_index=True)uZ = Z[idx]print (uZ)结果：[[0 1 0] [0 1 1] [1 0 1] [1 1 0]] 考虑两个向量A和B，写出用einsum等式对应的inner, outer, sum, mul函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# np.einsumA = np.random.uniform(0, 1, 10)B = np.random.uniform(0, 1, 10)print('sum')print(np.einsum('i-&gt;', A))结果：sum4.903677057922876print('A * B')print(np.einsum('i, i-&gt;i', A, B))结果：A * B[0.47153643 0.25317511 0.20142837 0.05835824 0.20308374 0.10641387 0.21122253 0.54794781 0.21782327 0.18996213]print('inner')print(np.einsum('i, i', A, B))结果:inner2.4609515005732665 print('outer')print(np.einsum('i, j-&gt;ij', A, B))结果：outer[[0.47153643 0.22882703 0.27068423 0.41698768 0.22448079 0.33164545 0.67680915 0.39473786 0.37198788 0.35538228] [0.52170974 0.25317511 0.29948609 0.46135679 0.24836641 0.36693382 0.74882428 0.4367395 0.41156883 0.39319634] [0.35089156 0.17028053 0.20142837 0.31029937 0.16704629 0.24679237 0.50364427 0.29374228 0.27681298 0.26445601] [0.06599245 0.03202479 0.03788279 0.05835824 0.03141652 0.04641443 0.09472076 0.05524434 0.05206043 0.04973644] [0.42659055 0.20701571 0.24488317 0.37724128 0.20308374 0.3000337 0.6122971 0.35711226 0.33653076 0.32150798] [0.15130018 0.0734229 0.08685347 0.13379732 0.07202834 0.10641387 0.2171653 0.1266581 0.1193584 0.11403022] [0.14715983 0.07141367 0.08447671 0.13013594 0.07005727 0.10350184 0.21122253 0.12319208 0.11609214 0.11090977] [0.65455427 0.31764186 0.37574514 0.57883347 0.31160871 0.46036729 0.93949967 0.54794781 0.51636785 0.49331711] [0.27611547 0.13399321 0.15850335 0.2441736 0.1314482 0.19420014 0.39631609 0.23114487 0.21782327 0.2080996 ] [0.25204989 0.12231468 0.14468857 0.22289201 0.11999149 0.17727411 0.36177412 0.21099883 0.19883831 0.18996213]] 考虑一个由两个向量描述的路径(X,Y)，如何用等距样例(equidistant samples)对其进行采样(sample)? 12345678910111213141516# np.sumsum(), np.interpphi = np.arange(0, 10*np.pi, 0.1)a = 1x = a*phi*np.cos(phi)y = a*phi*np.sin(phi)dr =(np.diff(x)**2 + np.diff(y)**2)**.5r = np.zeros_like(x)r[1:] = np.cumsum(dr) # integrate pathr_int = np.linspace(0, r.max(), 200) # regular spaced pathx_int = np.interp(r_int, r, x) # integrate pathy_int = np.interp(r_int, r, y)结果： 给定整数n和2D数组X，从X中选择可以解释为具有n度的多项分布的绘制的行，即，仅包含整数并且总和为n的行。 123456789# np.logical_and.reduce(), np.mod()X = np.asarray([[1.0, 0.0, 3.0, 8.0], [2.0, 0.0, 1.0, 1.0], [1.5, 2.5, 1.0, 1.0]])n = 4M = np.logical_and.reduce(np.mod(X, 1) == 0, axis=-1)M &amp;= (X.sum(axis=-1) == n)print(X[M])结果：[[2. 0. 1. 1.]] 计算1D阵列X的平均值的自举95％置信区间（即，对替换N次的阵列的元素进行重新采样，计算每个样本的平均值，然后计算均值上的百分位数）。 123456789X = np.random.randn(100) # random 1D arrayN = 1000 # number of bootstrap samplesidx = np.random.randint(0, X.size, (N, X.size))means = X[idx].mean(axis=1)confint = np.percentile(means, [2.5, 97.5])print (confint)结果：[0.06141008 0.46613253] 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://zivblog.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://zivblog.top/tags/Python/"}]},{"title":"Numpy100题之61-80","slug":"Numpy100题之61-80","date":"2019-08-28T04:54:21.000Z","updated":"2020-03-04T06:34:57.000Z","comments":true,"path":"passages/numpy100-ti-zhi-61-80/","link":"","permalink":"http://zivblog.top/passages/numpy100-ti-zhi-61-80/","excerpt":"学习笔记 答案整理 原文地址：https://zhuanlan.zhihu.com/p/76186124","text":"学习笔记 答案整理 原文地址：https://zhuanlan.zhihu.com/p/76186124 从数组中的给定值中找出最近的值 12345678910# 使用到abs()、flat()、argmin()# 功能分别为：取绝对值、返回一个数组的迭代器，可通过for循环访问、获取最小值的索引Z = np.random.uniform(0, 1, 10)z = 0.5m = Z.flat[np.abs(Z-z).argmin()]print(m)结果：0.5390768396166375 如何用迭代器(iterator)计算两个分别具有形状(1,3)和(3,1)的数组? 1234567891011121314# np.nditer()，传入的数组，返回一个可迭代的迭代器A = np.arange(3).reshape(3, 1)B = np.arange(3).reshape(1, 3)it = np.nditer([A, B, None])for x, y, z in it: z[...] = x + yprint(it.operands[2])结果：[[0 1 2] [1 2 3] [2 3 4]] 创建一个具有name属性的数组类 1234567891011121314151617# 类的定义class NamedArray(np.ndarray): def __new__(cls, array, name=\"no name\"): obj = np.asarray(array).view(cls) obj.name = name return obj def __array_finalize__(self, obj): if obj is None: return self.info = getattr(obj, 'name', \"no name\") Z = NameArray(np.arange(10), \"range_10\")print(Z.name)结果：range_10 考虑一个给定的向量，如何对由第二个向量索引的每个元素加1(小心重复的索引)? 1234567891011121314151617181920# 题设要求对于重复给出的索引每次遇到均+1# 使用bincount()函数，该函数可以对数组中出现的值的次数进行统计，反映在输出向量的相应下标的位置# 方法一Z = np.ones(10) # 给定向量I = np.random.randint(0, len(Z), 20) # 索引向量Z += np.bincount(I, minlength=len(Z))print(Z)结果：[2. 4. 3. 1. 4. 2. 5. 6. 2. 1.]# 方法二# at() 对Z中的元素，根据I中的索引，每次+1np.add.at(Z, I, 1)print(Z)结果：[2. 4. 3. 1. 4. 2. 5. 6. 2. 1.] 根据索引列表(I)，如何将向量(X)的元素累加到数组(F)? 12345678X = [1, 2, 3, 4, 5, 6]I = [1, 3, 9, 3, 4, 1]F = np.bincount(I, X)print(F)结果：[0. 7. 0. 6. 5. 0. 0. 0. 0. 3.] 考虑一个(dtype=ubyte) 的 (w,h,3)图像，计算其唯一颜色的数量 12345678910# 使用unique()函数：对于数组或者列表，去除其中重复的元素，按元素由大到小返回一个无重复的列表或数组w, h = 16, 16I = np.random.randint(0, 2, (h, w, 3)).astype(np.ubyte)F = I[..., 0]*(256*256) + I[..., 1]*256 + I[..., 2]n = len(np.unique(F))print(n)结果：8 考虑一个四维数组，如何一次性计算出最后两个轴(axis)的和？ 123456789# sum(axis=) 指定计算根据的的轴A = np.random.randint(0, 10, (3, 4, 3, 4))sum = A.sum(axis=(-2, -1))print(sum)结果：[[64 55 51 45] [38 55 48 53] [73 73 60 50]] 考虑一个一维向量D，如何使用相同大小的向量S来计算D子集的均值？ 12345678910111213# np.bincount()D = np.random.uniform(0, 1, 100)S = np.random.randint(0, 10, 100)D_sums = np.bincount(S, weights=D)D_counts = np.bincount(S)D_means = D_sums / D_countsprint(D_means)结果：[0.40365511 0.52710526 0.67046511 0.33109763 0.67705689 0.49109846 0.36351819 0.53482213 0.58558006 0.5682075 ] 如何获得点积dot prodcut的对角线? 12345678# diag()，当传入一维数组时，结果形成一个以一维数组为对角线元素的矩阵；当传入的是二维数组时，结果输出矩阵的对角线元素A = np.random.uniform(0, 1, (5, 5))B = np.random.uniform(0, 1, (5, 5))# 5*5与5*5矩阵的点乘积仍是5*5矩阵np.diag(np.dot(A, B))结果：array([0.70100234, 0.92730124, 1.89491706, 1.79228104, 1.48440929]) 考虑一个向量[1,2,3,4,5]，如何建立一个新的向量，在这个新向量中每个值之间有3个连续的零？ 123456# 创建一个足够长度的0矩阵，将向量中的元素按每隔3个0替换一个A = np.array([1, 2, 3, 4, 5])nz = 3A0 = np.zeros(len(A) + (len(A)-1)*nz)A0[::nz+1] = Aprint(A0) 考虑一个维度(5,5,3)的数组，如何将其与一个(5,5)的数组相乘？ 123456789101112131415161718192021222324252627282930313233343536# 将B构造成第三个维度为None的三维数组A = np.ones((5, 5, 3))B = 2*np.ones((5, 5))print(A * B[:,:,None])结果：[[[2. 2. 2.] [2. 2. 2.] [2. 2. 2.] [2. 2. 2.] [2. 2. 2.]] [[2. 2. 2.] [2. 2. 2.] [2. 2. 2.] [2. 2. 2.] [2. 2. 2.]] [[2. 2. 2.] [2. 2. 2.] [2. 2. 2.] [2. 2. 2.] [2. 2. 2.]] [[2. 2. 2.] [2. 2. 2.] [2. 2. 2.] [2. 2. 2.] [2. 2. 2.]] [[2. 2. 2.] [2. 2. 2.] [2. 2. 2.] [2. 2. 2.] [2. 2. 2.]]] 如何对一个数组中任意两行做交换? 12345678910A = np.arange(25).reshape(5, 5)A[[0, 1]] = A[[1, 0]]print(A)结果：[[ 5 6 7 8 9] [ 0 1 2 3 4] [10 11 12 13 14] [15 16 17 18 19] [20 21 22 23 24]] 考虑一个可以描述10个三角形的数组triplets，找到可以分割全部三角形的line segment 1234567891011121314151617181920# repeat(axis=) 复制多维数组的每一个元素，axis来控制复制的行和列# np.roll(array, shift, axis=) array沿axis的方向滚动shift长度 # np.sort() 排序# view() 区别与copy(),与原始数据共享一份内存# np.unique() 返回列表或数组中不重复元素组成的列表或数组faces = np.random.randint(0, 100, (10, 3))F = np.roll(faces.repeat(2, axis=1), -1, axis=1)F = F.reshape(len(F)*3, 2)F = np.sort(F, axis=1)G = F.view(dtype=[('p0', F.dtype), ('p1', F.dtype)])G = np.unique(G)print(G)结果：[( 5, 31) ( 5, 53) (11, 25) (11, 46) (12, 37) (12, 85) (20, 35) (20, 51) (20, 84) (22, 47) (22, 84) (25, 46) (27, 47) (27, 66) (31, 53) (35, 84) (37, 85) (47, 66) (47, 84) (51, 84) (58, 63) (58, 77) (58, 95) (58, 99) (63, 79) (63, 92) (63, 99) (77, 95) (79, 92)] 给定一个二进制的数组C，如何产生一个数组A满足np.bincount(A)==C 123456C = np.bincount([1, 1, 2, 3, 4, 4, 6])A = np.repeat(np.arange(len(C)), C)print(A)结果：[1 1 2 3 4 4 6] 如何通过滑动窗口计算一个数组的平均数? 1234567891011# cumsum() 沿指定轴累加数组元素def moving_average(a, n=3): ret = np.cumsum(a, dtype=float) ret[n:] = ret[n:] - ret[:-n] return ret[n-1:]/nZ = np.arange(20)print(moving_average(Z, n=3))结果：[ 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18.] 考虑一维数组Z，构建一个二维数组，其第一行是(Z [0]，Z [1]，Z [2])，每个后续行移1（最后一行应该是(Z[-3], Z[-2], Z[-1]) 123456789101112131415161718from numpy.lib import stride_tricksdef rolling(a, window): shape = (a.size - window + 1, window) strides = (a.itemsize, a.itemsize) return stride_tricks.as_strided(a, shape=shape, strides=strides)Z = rolling(np.arange(10), 3)print(Z)结果：[[0 1 2] [1 2 3] [2 3 4] [3 4 5] [4 5 6] [5 6 7] [6 7 8] [7 8 9]] 如何对布尔值取反，或者原位(in-place)改变浮点数的符号(sign)？ 123456789101112131415161718192021222324252627282930313233343536373839# lofical_not()逻辑非、negative()数值取反# 方法一# 随机整数Z = np.random.randint(0, 2, 100)np.logical_not(Z, out = Z)结果：array([0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0])# 方法二：# uniform() 均匀分布Z = np.random.uniform(-1.0, 1.0, 100)np.negative(Z, out=Z)结果：array([ 0.05031312, 0.97772171, -0.67264233, -0.04618383, -0.75397481, -0.34317743, -0.53194673, -0.51918606, -0.37304893, -0.4663474 , -0.78875942, 0.01936397, 0.80160394, 0.39005544, -0.93873232, 0.15195121, -0.94860217, 0.2568072 , -0.97441577, 0.03277601, 0.23323496, 0.10736939, -0.16071465, 0.34222035, 0.96903346, 0.58671838, -0.43651958, -0.56495989, 0.24749138, 0.77204365, 0.92396754, 0.73266475, -0.89578353, -0.61700747, 0.68577537, 0.74575805, 0.03375484, 0.61118915, 0.28219652, -0.15861781, 0.04221261, 0.55310498, -0.15580574, 0.60873475, 0.02851121, 0.19668448, -0.04052335, -0.73228185, 0.25773921, -0.90191087, -0.74177161, -0.25423155, -0.25450614, 0.44865308, -0.21338786, 0.59592018, -0.29278901, 0.16500941, 0.28332166, -0.2661733 , -0.93792278, 0.29708284, 0.35718338, -0.70322395, -0.71643805, -0.9543976 , 0.65792415, 0.35181269, -0.78627817, 0.48762508, -0.51068373, 0.76540099, 0.89172685, 0.15993627, 0.64279179, 0.32152709, 0.25847394, -0.36426917, -0.74235575, -0.48144595, 0.51877578, 0.86605299, 0.51672054, 0.79402976, -0.11626431, -0.34747431, 0.59585038, 0.1204304 , 0.35118293, 0.44558852, 0.56999461, -0.4820329 , 0.81815528, -0.29603943, 0.68750352, -0.50152259, -0.85042461, -0.36994314, -0.23032343, 0.43806343]) 考虑两组点集P0和P1去描述一组线(二维)和一个点p,如何计算点p到每一条线 i(P0[i],P1[i])的距离？ 1234567891011121314151617def distance(P0, P1, p): # 计算点到直线的距离 T = P1 - P0 L = (T**2).sum(axis = 1) U = -((P0[:, 0]-p[..., 0])*T[:, 0] + (P0[:, 1]-p[..., 1])*T[:, 1])/L U = U.reshape(len(U), 1) D = P0 + U*T - p return np.sqrt((D**2).sum(axis=1))P0 = np.random.uniform(-10, 10, (10, 2))P1 = np.random.uniform(-10, 10, (10, 2))p = np.random.uniform(-10, 10, (1, 2))print(disrance(P0, P1, p))结果：[ 6.46089551 2.02019414 7.64957844 10.26739442 4.32840633 5.87598718 3.46730169 10.69040697 3.7238278 9.71021116] 考虑两组点集P0和P1去描述一组线(二维)和一组点集P，如何计算每一个点 j(P[j]) 到每一条线 i (P0[i],P1[i])的距离？ 123456789101112131415161718192021222324252627282930313233343536# 区别于上一个题，这里的点更多def distance(P0, P1, p): # 计算点到直线的距离 T = P1 - P0 L = (T**2).sum(axis = 1) U = -((P0[:, 0]-p[..., 0])*T[:, 0] + (P0[:, 1]-p[..., 1])*T[:, 1])/L U = U.reshape(len(U), 1) D = P0 + U*T - p return np.sqrt((D**2).sum(axis=1))P0 = np.random.uniform(-10, 10, (10, 2))P1 = np.random.uniform(-10, 10, (10, 2))p = np.random.uniform(-10, 10, (10, 2))print(np.array([distance(P0, P1, p_i) for p_i in p]))结果：[[ 5.40670646 4.80013481 13.30601528 8.6187585 7.35755714 12.54151718 9.24071207 5.34703263 14.54922937 4.14588354] [ 2.63018703 0.08876084 4.14888539 1.65492189 7.70382067 7.36081638 6.90710177 6.81786912 1.07761109 8.51096456] [ 2.0266857 4.72537985 3.16720835 2.75861123 4.44025815 3.15808096 7.75627919 9.49123505 2.26774137 11.02113161] [ 0.34856518 0.72250344 3.4643871 1.70975185 1.83784162 10.92846839 0.64753047 0.5347269 6.3404948 2.05269702] [12.82851216 14.21297741 6.8487462 14.30053038 7.75964014 0.48502181 1.07738736 7.4534913 3.65341342 8.50158022] [ 4.35980428 5.21646493 6.17805894 6.46221918 2.49150711 8.03708833 1.71241686 1.40535458 7.06802357 2.73535593] [12.91407892 14.72355803 4.92113516 14.05365253 6.65559267 2.09719282 3.26734451 9.57392312 1.44886514 10.64497421] [ 0.26278106 4.226739 9.6454433 0.05753583 9.3296571 0.06745266 14.25882312 14.97942175 8.66727328 16.65261174] [ 1.44097653 3.77673716 1.70901896 2.47012398 3.90447614 4.93446335 5.88189824 7.47118652 0.34370906 9.000505 ] [ 7.46966507 10.6966451 3.60754571 7.64953446 1.57566894 3.00667962 10.52316245 14.30615261 5.43992693 15.66648646]] 考虑一个任意数组，写一个函数，提取一个固定形状的子部分，并以给定元素为中心（fill必要时填充一个值） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# minimum, maximum# 在10*10的数组中，提取5*5的子部分，中心为0Z = np.random.randint(0, 10, (10, 10))shape = (5, 5)fill = 0position = (1, 1)R = np.ones(shape, dtype=Z.dtype)*fillP = np.array(list(position)).astype(int)Rs = np.array(list(R.shape)).astype(int)Zs = np.array(list(Z.shape)).astype(int)R_start = np.zeros((len(shape),)).astype(int)R_stop = np.array(list(shape)).astype(int)Z_start = (P-Rs//2)Z_stop = (P+Rs//2)+Rs%2R_start = (R_start - np.minimum(Z_start,0)).tolist()Z_start = (np.maximum(Z_start,0)).tolist()R_stop = np.maximum(R_start, (R_stop - np.maximum(Z_stop-Zs,0))).tolist()Z_stop = (np.minimum(Z_stop,Zs)).tolist()r = [slice(start,stop) for start,stop in zip(R_start,R_stop)]z = [slice(start,stop) for start,stop in zip(Z_start,Z_stop)]R[r] = Z[z]print (Z)print (R)结果：[[2 5 6 6 7 5 3 3 1 8] [5 7 0 5 6 3 8 2 4 0] [5 5 0 5 8 3 0 9 1 4] [9 3 3 5 0 1 6 7 3 2] [1 7 2 2 6 4 7 7 9 2] [0 5 7 6 2 0 7 7 7 9] [3 2 0 3 1 1 8 4 0 0] [8 1 7 9 8 9 5 0 0 7] [1 1 9 0 4 4 1 9 5 4] [5 1 0 7 6 9 4 1 3 6]][[0 0 0 0 0] [0 2 5 6 6] [0 5 7 0 5] [0 5 5 0 5] [0 9 3 3 5]] 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://zivblog.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://zivblog.top/tags/Python/"}]},{"title":"Numpy之genfromtxt函数","slug":"Numpy之genfromtxt函数","date":"2019-08-26T13:41:24.000Z","updated":"2020-07-06T05:36:52.000Z","comments":true,"path":"passages/numpy-zhi-genfromtxt-han-shu/","link":"","permalink":"http://zivblog.top/passages/numpy-zhi-genfromtxt-han-shu/","excerpt":"genfromtext","text":"genfromtext genfromtxt()函数位于numpy.genfromtxt() 函数的完整形式为 1numpy.genfrom(fname, dtype= , comments='#', delimiter=None, skip_header=0, skip_footer=0, converters=None, missing_values=None, filling_values=None, usecols=None, names=None, excludelist=None, deletechars=None, replace_space='_', autostrip=Falsem, case_sensitive=True, defaultfmt='f%i', unpack=None, usemask=False, loose=True, invalid_raise=True, max_rows=None)[source] 下面详细介绍各个参数的意义： fname：文件名 dtype：表明数据的类型 comments：参数是一个字符串，标志着一个注释的开始符号，默认是“#” delimiter：分隔符，可以是str、int、sequence、optional skip_header：跳过页眉，参数值是个整数，表示跳过的行数，默认为0 skip_footer：跳过页脚，参数值是个整数，表示跳过的行数，默认为0 converters：用以定义转换函数 missing_values：默认情况下空字符串都被标记为缺少，使用该参数可以将更多类型的字符串识别为缺少，例如N/A filling_values：将missing_values识别出的标记为缺少的位置替换为该参数提供的值，可以是单个值、值序列、字典 usecols：参数是一个整数序列，选择读取哪些行 names：处理表格是要为每一列分配一个名称，可以通过显式的dtype来设置；或者names参数接收以个关键字与逗号组成的字符串；将该参数设为True会将文件第一行的内容读作文件名，不管是是注释 exclueslist：一系列要删除的 deletechars：需要删除的连接符，默认为‘’!@#$%^&amp;*()——+=|]}({;:/?&gt;,&lt; replace_space：替换变量名称中的空格 autostrip：设为True可以去掉序列中每一项前后的多余空格 case_sensitive：字段名是否区分大小写 defaultfmt：只有在名字没有定义式才会使用该属性，用以覆盖默认值‘f%i’ unpack：是否对读取的数组进行转置 usemask：构造布尔掩码来追踪丢失数据的出现，返回掩码序列；将该属性设为True后，有缺失数据为True，没有缺失数据则为False loose：不对无效之引发错误 invalid_raise：如果为true，则在检测到列数不一致时引发异常。如果为false，将发出警告并跳过违规行 max_rows：要读取的最大行数。不能同时与skip_footer一起使用。如果给定，值必须至少为1。默认值是读取整个文件 一个例子（代码来自网络，仅作整理，添加注释） 123456789101112# 引入一个数据集import urllib2url = 'http://aima.cs.berkeley.edu/data/iris.csv'u = urllib2.urlopen(url)localFile = open('iris.csv'', 'w')localFile.write(u.read())localFile.close() # 将数据集导入到程序from numpy import genfromtxt,zerosdata = genfomtxt('iris.csv', delimiter=',', usecols=(0, 1, 2, 3))target = genfromtxt('iris.csv', delimiter=',', usecols=(4), dtype=str) 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://zivblog.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://zivblog.top/tags/Python/"}]},{"title":"Numpy100题之41~60","slug":"Numpy100题之41-60","date":"2019-08-23T10:57:41.000Z","updated":"2020-03-04T06:34:34.000Z","comments":true,"path":"passages/numpy100-ti-zhi-41-60/","link":"","permalink":"http://zivblog.top/passages/numpy100-ti-zhi-41-60/","excerpt":"学习笔记 答案整理 原文地址：https://zhuanlan.zhihu.com/p/76186124","text":"学习笔记 答案整理 原文地址：https://zhuanlan.zhihu.com/p/76186124 对于一个小数组，如何用比np.sum更快的方式对其求和？ 1234567# 使用np.add.reduce()，两者功能相同# 但对于小型数组，np.add.reduce()的速度比np.sum()快两倍Z = np.arange(10)np.add.reduce(Z)结果：45 对于两个随机数组A和B，检查它们是否相等 12345678910111213141516171819# np.allclose()可判断两个array是不是每个元素都相等# np.array_equal()判断两个数组是否相等# 创建两个随机整型数组A = np.random.randint(0, 2, 5)B = np.random.randint(0, 2, 5)equal1 = np.allclose(A, B)equal2 = np.array_equal(A, B)ABequal1equal2结果：array([0, 1, 0, 1, 1])array([1, 0, 0, 1, 0])FalseFalse 创建一个只读数组(read-only) 123# 通过设置数组的flags.writeable属性来指定数组是否只读Z = np.zeros(10)Z.flags.writeable = False 将笛卡尔坐标下的一个10x2的矩阵转换为极坐标形式 12345678910111213141516# 使用到开方函数np.sqrt()、反三角函数np.arctan2()函数# 随机生成一个指教坐标系下的坐标Z = np.random.random((10, 2))X, Y = Z[:, 0], Z[:, 1]R = np.sqrt(X**2 + Y**2)T = np.arctan2(Y, X)RT结果：array([0.3944447 , 0.94777816, 0.83140372, 0.74598633, 0.91967574, 0.75524468, 0.79999599, 0.6049436 , 0.43862584, 1.09668726])array([1.45680562, 0.40002162, 1.13268754, 1.00810909, 0.08777813, 0.79438818, 0.19055149, 0.6108188 , 0.61328375, 1.08466593]) 创建一个长度为10的向量，并将向量中最大值替换为1 12345678910111213# 使用argmax()获取想两种最大值的索引Z = np.random.random(10)ZZ[Z.argmax()] = 1Z结果：array([0.15094359, 0.9866758 , 0.19716025, 0.753693 , 0.3756874 , 0.61064317, 0.32985381, 0.37475131, 0.11217617, 0.71798767])array([0.15094359, 1. , 0.19716025, 0.753693 , 0.3756874 , 0.61064317, 0.32985381, 0.37475131, 0.11217617, 0.71798767]) 创建一个结构化数组，并实现x和y坐标覆盖[0,1]x[0,1]区域 1234567891011121314151617# np.meshgrid() 生成网格点坐标矩阵，把两个数组的笛卡尔积内的元素的第一二个坐标分别放入两个矩阵中Z = np.zeros((5, 5), [('x', float), ('y', float)])Z['x'], Z['y'] = np.meshgrid(np.linspace(0, 1, 5), np.linspace(0, 1, 5))Z结果：array([[(0. , 0. ), (0.25, 0. ), (0.5 , 0. ), (0.75, 0. ), (1. , 0. )], [(0. , 0.25), (0.25, 0.25), (0.5 , 0.25), (0.75, 0.25), (1. , 0.25)], [(0. , 0.5 ), (0.25, 0.5 ), (0.5 , 0.5 ), (0.75, 0.5 ), (1. , 0.5 )], [(0. , 0.75), (0.25, 0.75), (0.5 , 0.75), (0.75, 0.75), (1. , 0.75)], [(0. , 1. ), (0.25, 1. ), (0.5 , 1. ), (0.75, 1. ), (1. , 1. )]], dtype=[('x', '&lt;f8'), ('y', '&lt;f8')]) 给定两个数组X和Y，构造Cauchy矩阵C(每个元素：$C_{ij} =1/(x_i - y_j)$) 12345678910111213141516171819202122232425X = np.arange(8)Y = X + 0.5C = 1.0 / np.subtract.outer(X, Y)Cprint(np.linalg.det(C))结果：array([[-2. , -0.66666667, -0.4 , -0.28571429, -0.22222222, -0.18181818, -0.15384615, -0.13333333], [ 2. , -2. , -0.66666667, -0.4 , -0.28571429, -0.22222222, -0.18181818, -0.15384615], [ 0.66666667, 2. , -2. , -0.66666667, -0.4 , -0.28571429, -0.22222222, -0.18181818], [ 0.4 , 0.66666667, 2. , -2. , -0.66666667, -0.4 , -0.28571429, -0.22222222], [ 0.28571429, 0.4 , 0.66666667, 2. , -2. , -0.66666667, -0.4 , -0.28571429], [ 0.22222222, 0.28571429, 0.4 , 0.66666667, 2. , -2. , -0.66666667, -0.4 ], [ 0.18181818, 0.22222222, 0.28571429, 0.4 , 0.66666667, 2. , -2. , -0.66666667], [ 0.15384615, 0.18181818, 0.22222222, 0.28571429, 0.4 , 0.66666667, 2. , -2. ]])3638.1636371179666 打印每个Numpy标量类型的最小值和最大值 123456789101112131415161718192021222324252627# np.iinfo：整型的机器限制，包括最大值最小值# np.finfo, eps：浮点型的机器限制for dtype in [np.int8, np.int32, np.int64]: print(np.iinfo(dtype).min) print(np.iinfo(dtype).max)结果：-128127-21474836482147483647-92233720368547758089223372036854775807for dtype in [np.float32, np.float64]: print(np.finfo(dtype).min) print(np.finfo(dtype).max) print(np.finfo(dtype).eps) 结果：-3.4028235e+383.4028235e+381.1920929e-07-1.7976931348623157e+3081.7976931348623157e+3082.220446049250313e-16 如何打印一个数组中的所有数值? 123456789101112131415161718192021222324# 使用np.set_printoptions(threshold=nan)设置打印时的显示方式# 其中threashold=nan表示输出数组时完全输出，不会使用省略号省略中间数据np.set_printoptions(threshold=np.inf)Z = np.zeros((16, 16))print(Z)结果：[[0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]] 给定标量时，如何找到数组中最接近标量的值？ 1234567891011121314151617# 使用argmin()获取最小值的下标# 最接近指定标量的值，可以通过取每个值与指定标量的绝对值，然后取绝对值最小的Z =np.arange(100)v = np.random.uniform(0, 100)index = (np.abs(Z-v)).argmin()print(Z[index])结果：指定标量v为：33数组Z内容array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99])33 创建一个表示位置(x,y)和颜色(r,g,b)的结构化数组 12345678910# 两个属性，分别是position和colorZ = np.zeros(10, [('position', [('x', float, 1), ('y', float, 1)]), ('color', [('r', float, 1), ('g', float, 1), ('b', float, 1)])])print(Z)结果：[((0., 0.), (0., 0., 0.)) ((0., 0.), (0., 0., 0.)) ((0., 0.), (0., 0., 0.)) ((0., 0.), (0., 0., 0.)) ((0., 0.), (0., 0., 0.)) ((0., 0.), (0., 0., 0.)) ((0., 0.), (0., 0., 0.)) ((0., 0.), (0., 0., 0.)) ((0., 0.), (0., 0., 0.)) ((0., 0.), (0., 0., 0.))] 对一个表示坐标形状为(100,2)的随机向量，找到点与点的距离 12345678910111213141516171819202122232425262728# np.atleast_1d(), np.atleast_2d(), np.atleast_3d()# 分别用于将输入转化为至少具有一个、两个、三个维度的数组Z = np.random.random((10, 2))X , Y = np.atleast_2d(Z[:, 0], Z[:, 1])D = np.sqrt((X - X.T)**2, (Y - Y.T)**2)print(D)结果：[[0. 0.38993115 0.01674273 0.1174607 0.01335761 0.37033472 0.04442136 0.50701389 0.00334056 0.38674937] [0.38993115 0. 0.40667389 0.50739185 0.40328876 0.01959643 0.34550979 0.11708273 0.38659059 0.00318179] [0.01674273 0.40667389 0. 0.10071797 0.00338513 0.38707745 0.0611641 0.52375662 0.02008329 0.4034921 ] [0.1174607 0.50739185 0.10071797 0. 0.1041031 0.48779542 0.16188206 0.62447459 0.12080126 0.50421007] [0.01335761 0.40328876 0.00338513 0.1041031 0. 0.38369232 0.05777897 0.52037149 0.01669817 0.40010697] [0.37033472 0.01959643 0.38707745 0.48779542 0.38369232 0. 0.32591336 0.13667917 0.36699416 0.01641465] [0.04442136 0.34550979 0.0611641 0.16188206 0.05777897 0.32591336 0. 0.46259252 0.0410808 0.342328 ] [0.50701389 0.11708273 0.52375662 0.62447459 0.52037149 0.13667917 0.46259252 0. 0.50367333 0.12026452] [0.00334056 0.38659059 0.02008329 0.12080126 0.01669817 0.36699416 0.0410808 0.50367333 0. 0.38340881] [0.38674937 0.00318179 0.4034921 0.50421007 0.40010697 0.01641465 0.342328 0.12026452 0.38340881 0. ]] 如何将32位的浮点数(float)转换为对应的整数(integer)? 1234567# 使用astype(copy = False)修改数据类型Z = np.arange(10, dtype=np.int32)Z = Z.astype(np.float32, copy=False)print(Z)结果：[0. 1. 2. 3. 4. 5. 6. 7. 8. 9.] 如何读取以下文件? 见genfromtxt函数详细介绍的博客 对于Numpy数组，enumerate的等价操作是什么？ 123456789101112131415161718192021222324252627282930# enumerate指的是枚举# numpy中可以通过np.ndenumerate()和np.ndindex()实现枚举Z = np.arange(9).reshape(3, 3)for index, value in np.ndenumerate(Z): print(index, value)结果：(0, 0) 0(0, 1) 1(0, 2) 2(1, 0) 3(1, 1) 4(1, 2) 5(2, 0) 6(2, 1) 7(2, 2) 8for index in np.ndindex(Z.shape): print(index, Z[index]) 结果：(0, 0) 0(0, 1) 1(0, 2) 2(1, 0) 3(1, 1) 4(1, 2) 5(2, 0) 6(2, 1) 7(2, 2) 8 生成一个通用的二维Gaussian-like数组 12345678910111213141516171819202122232425262728# np.meshgrid() 生成网格点坐标矩阵，把两个数组的笛卡尔积内的元素的第一二个坐标分别放入两个矩阵中X, Y = np.meshgrid(np.linspace(-1, 1, 10), np.linspace(-1, 1, 10))D = np.sqrt(X*X + Y*Y)sigma, mu = 1.0, 0.0G = np.exp(-((D-mu)**2/(2.0*sigma**2)))print(G)结果：[[0.36787944 0.44822088 0.51979489 0.57375342 0.60279818 0.60279818 0.57375342 0.51979489 0.44822088 0.36787944] [0.44822088 0.54610814 0.63331324 0.69905581 0.73444367 0.73444367 0.69905581 0.63331324 0.54610814 0.44822088] [0.51979489 0.63331324 0.73444367 0.81068432 0.85172308 0.85172308 0.81068432 0.73444367 0.63331324 0.51979489] [0.57375342 0.69905581 0.81068432 0.89483932 0.9401382 0.9401382 0.89483932 0.81068432 0.69905581 0.57375342] [0.60279818 0.73444367 0.85172308 0.9401382 0.98773022 0.98773022 0.9401382 0.85172308 0.73444367 0.60279818] [0.60279818 0.73444367 0.85172308 0.9401382 0.98773022 0.98773022 0.9401382 0.85172308 0.73444367 0.60279818] [0.57375342 0.69905581 0.81068432 0.89483932 0.9401382 0.9401382 0.89483932 0.81068432 0.69905581 0.57375342] [0.51979489 0.63331324 0.73444367 0.81068432 0.85172308 0.85172308 0.81068432 0.73444367 0.63331324 0.51979489] [0.44822088 0.54610814 0.63331324 0.69905581 0.73444367 0.73444367 0.69905581 0.63331324 0.54610814 0.44822088] [0.36787944 0.44822088 0.51979489 0.57375342 0.60279818 0.60279818 0.57375342 0.51979489 0.44822088 0.36787944]] 对一个二维数组，如何在其内部随机放置p个元素? 123456789101112131415161718192021# np.put(ind, [])：将数组中索引为ind的元素用[]中的元素代替# 与之相对np.take(ind)：将数组中索引为ind的元素取出# np.random.choice(a, size=,replace=True, p=None)：从a中随机选取size个元素，replace表示抽样之后是否放回，p为每个元素被选取的概率，默认等概率n = 10p = 3Z = np.zeros((n, n))np.put(Z, np.random.choice(range(n*n), p, replace=False), 1)print(Z)结果：[[0. 0. 0. 0. 0. 1. 0. 1. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 1. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]] 减去一个矩阵中的每一行的平均值 123456789101112131415161718# np.mean(a, axis, dtype, out, keepdims)# axis不设置表示对所有元素求均值，axis为0表示对各列求均值，axis为1表示对各行求均值X = np.random.rand(5, 10)Y = X - X.mean(axis=1, keepdims=True)print(Y)结果：[[-0.03275755 -0.03035167 -0.08707745 -0.25124861 0.03642215 -0.04187207 -0.25630029 0.49229668 -0.03462927 0.20551809] [ 0.08456354 -0.39740261 0.2759206 -0.22989044 -0.03611724 -0.59011478 0.23584573 0.28327169 0.09127001 0.2826535 ] [ 0.3791585 0.1788899 -0.2672872 0.17179428 -0.0422312 -0.39381341 -0.45286872 0.33314372 0.35918018 -0.26596606] [ 0.24243083 -0.4746942 0.2044127 0.2530425 -0.15927489 -0.57245357 0.24327986 -0.00992776 0.23649468 0.03668986] [-0.25147254 0.45156914 0.28612509 -0.10173569 -0.08643743 0.15675954 0.41942699 -0.42012685 -0.03718232 -0.41692593]] 如何通过第n列对一个数组进行排序? 12345678910111213# argsort()返回的是数组值从小到大的索引值Z = np.random.randint(1, 10, (3, 3))print(Z)print(Z[Z[:, 1].argsort()])结果：[[6 7 6] [7 2 3] [5 3 8]][[6 2 9] [6 5 1] [1 5 8]] 如何检查一个二维数组是否有空列？ 1234567# 使用any、~# any()用于判断给定的可迭代参数是否全部为False，若全部为False则返回FalseZ = np.random.randint(0, 3, (3, 10))print((~Z.any(axis=0)).any())结果：False 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://zivblog.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://zivblog.top/tags/Python/"}]},{"title":"Numpy100题之21-40","slug":"Numpy100题之21-40","date":"2019-08-22T05:52:42.000Z","updated":"2020-03-04T06:34:10.000Z","comments":true,"path":"passages/numpy100-ti-zhi-21-40/","link":"","permalink":"http://zivblog.top/passages/numpy100-ti-zhi-21-40/","excerpt":"学习笔记 答案整理 原文地址：https://zhuanlan.zhihu.com/p/76186124","text":"学习笔记 答案整理 原文地址：https://zhuanlan.zhihu.com/p/76186124 用tile函数去创建一个8x8的棋盘样式矩阵 1234567891011121314# tile(array, num) 将原矩阵横向、纵向地复制# 将array复制num次；若num是个n元组，则依次是各个维度上复制的次数Z = np.tile(np.array([[1, 0], [1, 0]]), (4,4))print(Z)结果：[[1 0 1 0 1 0 1 0] [1 0 1 0 1 0 1 0] [1 0 1 0 1 0 1 0] [1 0 1 0 1 0 1 0] [1 0 1 0 1 0 1 0] [1 0 1 0 1 0 1 0] [1 0 1 0 1 0 1 0] [1 0 1 0 1 0 1 0]] 对一个5x5的随机矩阵做归一化 12345678910111213# 归一化：将数据转化乘(0, 1)或(-1, 1)之间的小数# 归一化：(Z - Z.min)/(Z.max - Z.min)Z = np.random.random((5, 5))Zmax, Zmin = Z.max(), Z.min()Z = (Z - Zmin)/(Zmax - Zmin)print(Z)结果：[[0.49837306 0.08864194 0.68784483 0.84959538 0.53010616] [0.62847499 0.06661639 0.64068999 1. 0.17954986] [0.73358673 0. 0.04020008 0.95159169 0.14104298] [0.99773013 0.50224238 0.28422327 0.62605846 0.02929286] [0.91979782 0.81827956 0.19822701 0.78475044 0.54114787]] 创建一个将颜色描述为(RGBA)四个无符号字节的自定义dtype？ 12345color = np.dtype([(\"r\", np.ubyte, 1), (\"g\", np.ubyte, 1), (\"b\", np.ubyte, 1), (\"a\", np.ubyte, 1)])color结果：dtype([('r', 'u1'), ('g', 'u1'), ('b', 'u1'), ('a', 'u1')]) 一个5x3的矩阵与一个3x2的矩阵相乘，实矩阵乘积是什么？ 12345678910# 使用dot()进行矩阵间的点乘Z = np.dot(np.ones((5, 3)), np.ones((3, 2)))print(Z)结果：[[3. 3.] [3. 3.] [3. 3.] [3. 3.] [3. 3.]] 给定一个一维数组，对其在3到8之间的所有元素取相反数？ 123456Z = np.arange(11)Z[(3 &lt; Z)&amp;(Z &lt;= 8)] *= -1Z结果：array([ 0, 1, 2, 3, -4, -5, -6, -7, -8, 9, 10]) 下面脚本运行后的结果是什么? 1234567891011121314# 注意Python自带的sum()函数和numpy中的sum()函数的区别# numpy中的sum()是对矩阵中所有元素的求和# Python中的sum()传入的是参数列表，即对所有传入的数据全部加和from numpy import *print(sum(range(5),-1))结果：10 # 即0~4累加print(sum(range(5),-1))结果：9 # 即0~4累加，再加-1 考虑一个整数向量Z,下列表达合法的是哪个? 1234567891011Z**Z # 合法，结果为[ 1, 1, 4, 27, 256]2&lt;&lt;Z&gt;&gt;2 # 不合法Z&lt;-Z # 合法，结果为[False, False, False, False, False]1j*Z # 合法，结果为[0.+0.j, 0.+1.j, 0.+2.j, 0.+3.j, 0.+4.j]Z/1/1 # 合法，结果为[0., 1., 2., 3., 4.]Z&lt;Z&gt;Z # 不合法 下列表达式的结果分别是什么? 1234567891011np.array(0) /np.array(0)结果：nannp.array(0) //np.array(0)结果：0 #但是0作为分母np.array([np.nan]).astype(int).astype(float)结果：array([-2.14748365e+09]) 如何从零位对浮点数组做舍入? 12345678910# 创建一个指定格式的随机数组Z = np.random.uniform(-10, +10, 10)Z结果：array([ 2.4142539 , 6.56990199, 8.70723106, 5.97495463, -5.30474813, -0.69522623, 0.69668324, -7.06029374, -8.52539933, 5.67250038])print (np.copysign(np.ceil(np.abs(Z)), Z))结果：[ 3. 7. 9. 6. -6. -1. 1. -8. -9. 6.] 如何找到两个数组中的共同元素? 12345678910111213141516# 创建两个数组Z1 = np.random.randint(0,10,10)Z2 = np.random.randint(0,10,10)Z1Z2结果：array([7, 6, 1, 7, 8, 5, 2, 0, 1, 5])array([2, 2, 6, 0, 8, 7, 7, 8, 0, 6])# 使用intersect1d()函数求两个数组的交集print(np.intersect1d(Z1,Z2))结果：[2 4 5 6 7 8] 如何忽略所有的Numpy警告(尽管不建议这么做)? 123# 可以忽略python的所有警告import warningswarnings.filterwarnings(\"ignore\") 下面的表达式是正确的吗? 12345# 虚数np.sqrt(-1) ==np.emath.sqrt(-1)结果：False 如何得到昨天，今天，明天的日期? 12345678910111213# 使用到np.datetime64和np.timedelta64yesterday = np.datetime64('today', 'D') - np.timedelta64(1, 'D')today = np.datetime64('today', 'D')tomorrow = np.datetime64('today', 'D') + np.timedelta64(1, 'D')print('Yesterday is ' + str(yesterday))print('Today is ' + str(today))print('Tomorrow is ' + str(tomorrow))结果：Yesterday is 2019-08-21Today is 2019-08-22Tomorrow is 2019-08-23 如何得到所有与2016年7月对应的日期? 123456789101112# 使用arange()，设置起始点为七月和八月，元素类型设为datetime64的日Z = np.arange('2016-07', '2016-08',dtype='datetime64[D]')print(Z)结果：['2016-07-01' '2016-07-02' '2016-07-03' '2016-07-04' '2016-07-05' '2016-07-06' '2016-07-07' '2016-07-08' '2016-07-09' '2016-07-10' '2016-07-11' '2016-07-12' '2016-07-13' '2016-07-14' '2016-07-15' '2016-07-16' '2016-07-17' '2016-07-18' '2016-07-19' '2016-07-20' '2016-07-21' '2016-07-22' '2016-07-23' '2016-07-24' '2016-07-25' '2016-07-26' '2016-07-27' '2016-07-28' '2016-07-29' '2016-07-30' '2016-07-31'] 如何直接在位计算(A+B)\\*(-A/2)(不建立副本)? 123456789101112131415161718192021# 使用函数add()计算加法，使用negative()计算取负值，使用multiply()计算乘法，使用divide()计算除法# 并且使用这些函数的out属性指定输出的矩阵，不再自动创建新矩阵# 创建三个数组A = np.ones(3)*1B = np.ones(3)*2C = np.ones(3)*3np.add(A, B, out=B)np.divide(A, 2, out=A)np.negative(A, out=A)np.multiply(A, B, out=A)结果：&gt;&gt;&gt; np.add(A, B, out=B)array([3., 3., 3.])&gt;&gt;&gt; np.divide(A, 2, out=A)array([0.5, 0.5, 0.5])&gt;&gt;&gt; np.negative(A, out=A)array([-0.5, -0.5, -0.5])&gt;&gt;&gt; np.multiply(A, B, out=A)array([-1.5, -1.5, -1.5]) 用五种不同的方法去提取一个随机数组的整数部分？ 12345678910111213141516171819# %, np.floor, np.ceil, astype, np.trunc# 创建随机数组Z = np.random.uniform(0, 10, 10)结果：&gt;&gt;&gt; print(Z - Z%1)[3. 6. 1. 4. 8. 7. 5. 6. 5. 5.]&gt;&gt;&gt;&gt;&gt;&gt; print(np.floor(Z))[3. 6. 1. 4. 8. 7. 5. 6. 5. 5.]&gt;&gt;&gt;&gt;&gt;&gt; print(np.ceil(Z)-1)[3. 6. 1. 4. 8. 7. 5. 6. 5. 5.]&gt;&gt;&gt;&gt;&gt;&gt; print(Z.astype(int))[3 6 1 4 8 7 5 6 5 5]&gt;&gt;&gt;&gt;&gt;&gt; print(np.trunc(Z))[3. 6. 1. 4. 8. 7. 5. 6. 5. 5.] 创建一个5x5的矩阵，其中每行的数值范围从0到4 123456789101112# 先创建全为0的矩阵，再讲0~4依次加到每一行Z = np.zeros((5, 5))Z += np.arange(5)print(Z)结果：[[0. 1. 2. 3. 4.] [0. 1. 2. 3. 4.] [0. 1. 2. 3. 4.] [0. 1. 2. 3. 4.] [0. 1. 2. 3. 4.]] 通过一个可生成10个整数的函数，来构建一个数组 12345678910# 使用np.fromiter()函数从一个可迭代对象创建一个一维数组def generate(): for x in range(10): yield xZ = np.fromiter(generate(), dtype=float, count=-1)print(Z)结果：[0. 1. 2. 3. 4. 5. 6. 7. 8. 9.] 创建一个长度为10的随机向量，其值域范围从0到1，但是不包括0和1 12345678# 使用linspace(start, end, num, endpoint=)# 创建一个指定起始点的元素个数为num的间隔均匀的数组，endpoint指定数组中是否包含endZ = np.linspace(0, 1, 11, endpoint=False)[1:]Z结果：array([0.09090909, 0.18181818, 0.27272727, 0.36363636, 0.45454545, 0.54545455, 0.63636364, 0.72727273, 0.81818182, 0.90909091]) 创建一个长度为10的随机向量，并将其排序 12345678# 使用sort()函数对数组排序Z = np.random.random(10)Z.sort()print(Z)结果：[0.09179728 0.39609427 0.39989882 0.52910508 0.5780039 0.66504509 0.73527613 0.77932581 0.9451393 0.99063504] 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://zivblog.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://zivblog.top/tags/Python/"}]},{"title":"Numpy100题之1~20","slug":"Numpy100题之1-20","date":"2019-08-21T12:02:58.000Z","updated":"2020-07-06T05:36:20.000Z","comments":true,"path":"passages/numpy100-ti-zhi-1-20/","link":"","permalink":"http://zivblog.top/passages/numpy100-ti-zhi-1-20/","excerpt":"学习笔记 答案整理 原文地址：https://zhuanlan.zhihu.com/p/76186124","text":"学习笔记 答案整理 原文地址：https://zhuanlan.zhihu.com/p/76186124 导入Numpy并简写为np 1import numpy as np 打印Numpy的版本信息和配置说明 123456import numpy as np# 版本信息print(np.__version__)# 配置说明np.show_config 创建长度为10的空向量 123456# 空向量使用zeros()函数创建Z = np.zeros(10)print(Z)结果：[0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] 如何找到任意数组的内存大小 12345678# 定义大小为10*10的空数组Z = np.zeros((10*10))# 输出内存大小print(Z.size * Z.itemsize)结果：800 从命令行得到Numpy中add函数的说明文档 123456789101112131415161718192021222324252627282930np.info(np.add)结果：add(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])Add arguments element-wise.Parameters----------x1, x2 : array_like The arrays to be added. If ``x1.shape != x2.shape``, they must be broadcastable to a common shape (which may be the shape of one or the other).out : ndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or `None`, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs.where : array_like, optional Values of True indicate to calculate the ufunc at that position, values of False indicate to leave the value in the output alone.**kwargs For other keyword-only arguments, see the :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.Returns-------add : ndarray or scalar The sum of `x1` and `x2`, element-wise. This is a scalar if both `x1` and `x2` are scalars. 创建一个长度为10并且除了第五个值为1的空向量 123456Z = np.zeros(10)Z[4] = 1Z结果：array([0., 0., 0., 0., 1., 0., 0., 0., 0., 0.]) 创建一个值域范围从10到49的向量 1234567Z = np.arange(10, 50)Z结果：array([10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49]) 反转一个向量 12345678910111213Z = np.arange(50)Z = Z[::-1]Z‘’‘解释：np.array[起点:终点:步长]若起点终点未给出则自动设为最小值和最大值，步长为-1则表示倒序‘’‘结果：array([49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]) 创建一个3*3并且值从0到8的矩阵 12345678# 可以先创建0~8的一维矩阵，再利用reshape()函数调整矩阵形状Z = np.arange(9).reshape(3, 3)Z结果：array([[0, 1, 2], [3, 4, 5], [6, 7, 8]]) 找到数组[1, 2, 0, 0, 4, 0]中非0元素的位置索引 1234567# 使用nonzero()函数，可返回非0元素索引z = np.array([1, 2, 0, 0, 4, 0])nz = np.nonzero(z)print(nz)结果：[0, 1, 4] 创建3*3的单位矩阵 12345678# 使用函数eye()创建单位矩阵Z = np.eye(3)Z结果：[[1., 0., 0.], [0., 1., 0.], [0., 0., 1.]] 创建一个3*3*3的随机矩阵 12345678910111213141516# 使用random()函数创建随机矩阵Z = np.random.random((3, 3, 3))Z结果：array([[[0.46112045, 0.8449696 , 0.93452669], [0.40335357, 0.19589526, 0.06190673], [0.59191213, 0.5485013 , 0.04418769]], [[0.19128822, 0.87667495, 0.52180477], [0.20406144, 0.24655701, 0.5104405 ], [0.10757664, 0.29771709, 0.03340503]], [[0.18824317, 0.70162351, 0.98969992], [0.05169308, 0.10910609, 0.26606144], [0.16278269, 0.4546617 , 0.86494887]]]) 创建一个10*10的随机矩阵并找到矩阵中的最大值和最小值 123456789# 使用max()、min()函数获取矩阵中的极值Z = np.random.random((10*10))Zmin, Zmax = Z.min(), Z.max()ZminZmax结果：0.00188398126643218870.9990252431012059 创建一个长度为30的随机向量并找到它的平均值 123456789101112131415# 使用random()创建随机向量，使用mean()计算平均值Z = np.random.random(30)m = Z.mean()Zm结果：array([0.65300995, 0.20141719, 0.14618305, 0.04388761, 0.11318013, 0.69235091, 0.21181151, 0.57945835, 0.65998752, 0.53460023, 0.73048382, 0.06537182, 0.09899469, 0.24646227, 0.1852686 , 0.39034113, 0.83176693, 0.61448157, 0.50298701, 0.67282915, 0.59650845, 0.22505482, 0.69479162, 0.62462672, 0.24771051, 0.17731379, 0.8212477 , 0.00564217, 0.21590246, 0.69027938])0.41579836854559904 创建一个二维数组，其中边界值为1，其余值为0 12345678910111213141516# 创建一个全为1的数组，再将中间的数字改为0Z = np.ones((10, 10))Z[1:-1,1:-1] = 0Z结果：array([[1., 1., 1., 1., 1., 1., 1., 1., 1., 1.], [1., 0., 0., 0., 0., 0., 0., 0., 0., 1.], [1., 0., 0., 0., 0., 0., 0., 0., 0., 1.], [1., 0., 0., 0., 0., 0., 0., 0., 0., 1.], [1., 0., 0., 0., 0., 0., 0., 0., 0., 1.], [1., 0., 0., 0., 0., 0., 0., 0., 0., 1.], [1., 0., 0., 0., 0., 0., 0., 0., 0., 1.], [1., 0., 0., 0., 0., 0., 0., 0., 0., 1.], [1., 0., 0., 0., 0., 0., 0., 0., 0., 1.], [1., 1., 1., 1., 1., 1., 1., 1., 1., 1.]]) 对于一个存在在数组，如何添加一个用0填充的边界? 123456789101112131415161718192021222324252627# 使用pad(array, pad_width, mode, **kwargs)填充矩阵边界Z = np.ones((5, 5))Z = np.pad(Z, pad_width=1, mode='constant', constant_values=0)print(Z)结果：[[0. 0. 0. 0. 0. 0. 0.] [0. 1. 1. 1. 1. 1. 0.] [0. 1. 1. 1. 1. 1. 0.] [0. 1. 1. 1. 1. 1. 0.] [0. 1. 1. 1. 1. 1. 0.] [0. 1. 1. 1. 1. 1. 0.] [0. 0. 0. 0. 0. 0. 0.]]Z = np.pad(Z, pad_width=2, mode='constant', constant_values=0)Z结果：array([[0., 0., 0., 0., 0., 0., 0., 0., 0.], [0., 0., 0., 0., 0., 0., 0., 0., 0.], [0., 0., 1., 1., 1., 1., 1., 0., 0.], [0., 0., 1., 1., 1., 1., 1., 0., 0.], [0., 0., 1., 1., 1., 1., 1., 0., 0.], [0., 0., 1., 1., 1., 1., 1., 0., 0.], [0., 0., 1., 1., 1., 1., 1., 0., 0.], [0., 0., 0., 0., 0., 0., 0., 0., 0.], [0., 0., 0., 0., 0., 0., 0., 0., 0.]]) 以下表达式运行的结果分别是什么? 123456789101112131415161718192021222324# NaN: not a number, inf: infinity0*np.nan结果：nannp.nan == np.nan结果：Falsenp.nan is np.nan结果：Truenp.inf &gt; np.nan结果：Falsenp.nan-np.nan结果：nan0.3 == 3*0.1结果：False 创建一个5x5的矩阵，并设置值1,2,3,4落在其对角线下方位置 123456789101112# 使用diag(v, k=0)函数创建对角阵# v是对角线元素# k默认为0.k&gt;0则对角线之上，k&lt;0则对角线之下Z = np.diag(1+np.arange(4), k=-1)Z结果：array([[0, 0, 0, 0, 0], [1, 0, 0, 0, 0], [0, 2, 0, 0, 0], [0, 0, 3, 0, 0], [0, 0, 0, 4, 0]]) 创建一个8x8的矩阵，并且设置成棋盘样式 123456789101112131415# 使用zeros()先创建0矩阵，再填充为1的位置Z = np.zeros((8, 8), dtype=int)Z[1::2,::2] = 1Z[::2, 1::2] = 1Z结果：array([[0, 1, 0, 1, 0, 1, 0, 1], [1, 0, 1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 0, 1, 0, 1], [1, 0, 1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 0, 1, 0, 1], [1, 0, 1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 0, 1, 0, 1], [1, 0, 1, 0, 1, 0, 1, 0]]) 考虑一个 (6,7,8) 形状的数组，其第100个元素的索引(x,y,z)是什么? 12345# 使用unravel_index(num,array.shape)求指定形状的矩阵中第num个元素的索引print(np.unravel_index(100, (6, 7 ,8)))结果：(1, 5, 4) 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://zivblog.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://zivblog.top/tags/Python/"}]},{"title":"Python之lambda匿名函数","slug":"Python之lambda匿名函数","date":"2019-08-21T07:23:46.000Z","updated":"2020-11-28T07:28:25.816Z","comments":true,"path":"passages/python-zhi-lambda-ni-ming-han-shu/","link":"","permalink":"http://zivblog.top/passages/python-zhi-lambda-ni-ming-han-shu/","excerpt":"匿名函数","text":"匿名函数 什么是匿名函数？ 匿名函数，顾名思义就是具体的函数名但是有函数功能的函数或子程序。lambda函数可以接收任意多个参数并且返回单个表达式的值。 为什么要使用匿名函数？ 在函数功能不是很复杂的情况下，如果不想去费神命名一个函数时，可以使用匿名函数。也就是说匿名函数可以使代码变得更简洁，但是相对应的会增加阅读代码时的难度，所以不要盲目的使用匿名函数。 使用ambda定义匿名函数有什么要注意的？ lambda函数不能包含命令 包含的表达式不能超过一个 使用lambda定义匿名函数的格式？ lambda 参数列表 : 表达式 使用lambda定义匿名函数和常规函数定义的区别？ 1234567# 常规函数定义def sum(x, y): return x + y# 使用lambda定义add = lambda x, y : x + yadd(1, 2) lambda的用法 1234567891011121314151617181. 将lambda函数赋值给一个变量，通过这个变量简洁调用lambda函数add = lambda x, y : x + yadd(1, 2)2. 将lambda函数赋值给其他函数，从而将其他函数用该lambda函数替换# 例如对标准库中的函数time.sleep，可以使用lambda将其覆盖掉，下一次调用sleep的使用就是定义的lambda函数的内容了time.sleep = lambda x:None3. 将lambda函数作为其他函数的返回值def add(x, y): return lambda x, y : x + y4. 将lambda函数作为参数传递给其他函数# 部分Python内置函数接收函数作为参数，例如：filter函数sorted函数map函数reduce函数 另外，lambda是Python的关键字，Python的关键字还有： 1234import keywordkeyword.kwlist['False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield'] 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://zivblog.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://zivblog.top/tags/Python/"}]},{"title":"Numpy学习笔记（进阶）","slug":"Numpy学习笔记（进阶）","date":"2019-08-14T14:13:52.000Z","updated":"2020-03-04T06:36:11.000Z","comments":true,"path":"passages/numpy-xue-xi-bi-ji-jin-jie/","link":"","permalink":"http://zivblog.top/passages/numpy-xue-xi-bi-ji-jin-jie/","excerpt":"学习笔记 参考资料：Numpy官方文档","text":"学习笔记 参考资料：Numpy官方文档 进阶操作广播法则 使用广播法则能使通用函数处理不具有相同形状的输入 广播第一法则：如果所有的输入数组维度均不相同，会填充1在较小维度的数组上，使所有的数组拥有一样的维度。 广播第二法则：确定长度为1的数组沿着特殊的方向表现的好像它有沿着该方向最大形状的大小。对于数组来说，沿着该维度的数组元素的值理应相同。 应用了广播法则之后，所有的数组的大小就会匹配了。 索引技巧 除了Python本身提供的索引整数和切片，数组还可以被整数数组和布尔数组索引。 通过数组索引，例子： 1234567891011121314151617181920212223242526272829303132333435363738394041# 创建数组from numpy import *a = arange(12)**2# 使用一维数组索引，得到的结果也是一维数组i = array([1, 1, 3, 8, 5])a[i]结果：array([ 1, 1, 9, 64, 25])# 使用二维数组索引，得到的结果也是二维数组j = array([[3, 4], [9, 7]])a[j]结果：array([[ 9, 16], [81, 49]])# 若被索引的数组是多维时，每个索引数列指向a的第一维# 在这里，每个索引数列中的元素指定其中的一行palette = array( [ [0,0,0], [255,0,0], [0,255,0], [0,0,255], [255,255,255] ] ) image = array( [ [ 0, 1, 2, 0 ], [ 0, 3, 4, 0 ] ] )palette[image] 结果：array([[[ 0, 0, 0], [255, 0, 0], [ 0, 255, 0], [ 0, 0, 0]], [[ 0, 0, 0], [ 0, 0, 255], [255, 255, 255], [ 0, 0, 0]]]) 索引可以不止一维，但每一维的索引数组形状需要相同 例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# 创建数组a = arange(12).reshape(3,4)a结果：array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]])# 多维索引i = array([[0, 1], [1, 2]])j = array([[2, 1], [3, 3]])a[i, j]结果：array([[ 2, 5], [ 7, 11]])'''得到的是a[0, 2],a[1, 1], a[1, 3], a[2, 3],且两个为一组'''a[i, 2]结果：array([[ 2, 6], [ 6, 10]])a[:, j]结果：array([[[ 2, 1], [ 3, 3]], [[ 6, 5], [ 7, 7]], [[10, 9], [11, 11]]])# 可以借助列表先将两个索引组合起来，使用列表进行索引l = [i, j]a[l]结果：array([[ 2, 5], [ 7, 11]])# 这里不能使用数组将i，j组合起来，因为外层数组会被当作索引的第一维，报错或得到的结果不正确 使用数组索引作为目标来赋值 12345678910111213# 创建数组a = arange(5)a结果：array([0, 1, 2, 3, 4])a[[1, 3, 4]] = 0a结果：array([0, 0, 2, 0, 0])# 多次赋值以最后一次赋值为结果 通过布尔数组索引 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# 创建数组a = arange(12).reshape(3, 4)b = a &gt; 4b结果：array([[False, False, False, False], [False, True, True, True], [ True, True, True, True]], dtype=bool)# 实际上是返回所有为True的位置的元素值a[b]结果：array([ 5, 6, 7, 8, 9, 10, 11])# 此功能可用于赋值，比如，将a中所有大于4的值赋值为0b = a &gt; 4a[b] = 0a结果：array([[0, 1, 2, 3], [4, 0, 0, 0], [0, 0, 0, 0]])# 对每一个维度给一个一维布尔数组来选择我们想要的切片a = arange(12).reshape(3, 4)b1 = array([False, True, True])b2 = array([True, False, True, False])a[b1, :]结果：array([[ 4, 5, 6, 7], [ 8, 9, 10, 11]])a[b1]结果：array([[ 4, 5, 6, 7], [ 8, 9, 10, 11]])a[:, b2]结果：array([[ 0, 2], [ 4, 6], [ 8, 10]])a[b1,b2] 结果：array([ 4, 10]) 注意：一维数组的长度必须和想要切片的维度或轴的长度一致，前面的例子中，b1是一个秩为1长度为三的数组(a的行数)，b2(长度为4)与a的第二秩(列)相一致 ix_()函数 ix_()函数可以组合不同向量以得到多元组的结果，例如使用向量a、b、c组成的三元组来计算a+b*c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869# 创建向量a = array([2, 3, 4, 5])b = array([8, 5, 4])c = array([5, 4, 6, 8, 3])ax, bx, cx = ix_(a, b, c)axbxcx结果：# 从形式上来看转化了向量的形状，使之符合计算的需求array([[[2]], [[3]], [[4]], [[5]]])array([[[8], [5], [4]]])array([[[5, 4, 6, 8, 3]]])ax.shapebx.shapecx.shape结果：(4, 1, 1)(1, 3, 1)(1, 1, 5)result = ax + bx * cxresult结果：array([[[42, 34, 50, 66, 26], [27, 22, 32, 42, 17], [22, 18, 26, 34, 14]], [[43, 35, 51, 67, 27], [28, 23, 33, 43, 18], [23, 19, 27, 35, 15]], [[44, 36, 52, 68, 28], [29, 24, 34, 44, 19], [24, 20, 28, 36, 16]], [[45, 37, 53, 69, 29], [30, 25, 35, 45, 20], [25, 21, 29, 37, 17]]])# 读取结果中的一个元素result[3, 2, 4]结果：17# 使用向量中的一个值进行计算a[3] + b[2] * c[4]结果：4 + 5 * 3 = 17 线性代数 数组运算 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# 导入数组计算的的包和函数from numpy import *from numpy.linalg import *# 创建数组a = array([[1.0, 2.0], [3.0, 4.0]])print(a)结果：[[ 1. 2.] [ 3. 4.]]# 求转置a.transpose()结果：array([[ 1., 3.], [ 2., 4.]])# 求逆矩阵inv(a)结果：array([[-2. , 1. ], [ 1.5, -0.5]])# 生成对角矩阵u = eye(2) # 2*2u结果：array([[1., 0.], [0., 1.]])# 求点积j = array([[0.0, -1.0], [1.0, 0.0]])dot (j, j)结果：array([[-1., 0.], [ 0., -1.]])# 求矩阵的迹（特征值之和）trace(u)结果：2.0# 求解线性矩阵方程y = array([[5.], [7.]])solve(a, y)结果：array([[-3.], [ 4.]])# 计算矩阵特征值、特征向量eig(j)结果：(array([ 0.+1.j, 0.-1.j]), array([[ 0.70710678+0.j , 0.70710678-0.j ], [ 0.00000000-0.70710678j, 0.00000000+0.70710678j]])) 矩阵类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# 创建矩阵A = matrix('1.0 2.0; 3.0 4.0')A结果：matrix([[ 1., 2.], [ 3., 4.]])# 判断类型type(A)结果：numpy.matrixlib.defmatrix.matrix# 求矩阵的转置A.T结果：matrix([[ 1., 3.], [ 2., 4.]])X = matrix('5.0 7.0')Y = X.TY结果：matrix([[ 5.], [ 7.]])# 矩阵相乘print(A*Y)结果：[[ 19.] [ 43.]]# 求逆矩阵print(A.I)结果：[[-2. 1. ] [ 1.5 -0.5]]# 求解线性矩阵方程solve(A, Y)结果：matrix([[-3.], [ 4.]]) 注意 Numpy的两个基本对象：N维数组对象，通用函数对象 矩阵继承自数组对象的二维数组对象 直方图 可以使用histogram函数应用到一个数组会返回：直方图数组和箱式向量 注意这里只返回数据，并直接绘制出具体的图形 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://zivblog.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://zivblog.top/tags/Python/"}]},{"title":"Numpy学习笔记（基础）","slug":"Numpy学习笔记（基础）","date":"2019-08-14T14:09:03.000Z","updated":"2020-03-04T06:35:54.000Z","comments":true,"path":"passages/numpy-xue-xi-bi-ji-ji-chu/","link":"","permalink":"http://zivblog.top/passages/numpy-xue-xi-bi-ji-ji-chu/","excerpt":"笔记 学习笔记 参考资料：Numpy官方文档","text":"笔记 学习笔记 参考资料：Numpy官方文档 基础知识 Numpy是用来处理多维数组的工具，在Numpy中，维度叫做轴，轴的个数叫做秩。 例如，[1, 2, 3]是一个秩为1的数组，因为它只有一个维度，即一个轴。轴的长度为3. 而[[1, 0, 0], [0, 1, 2]]的秩为2，即两个轴。第一个轴的长度为2，第二个轴的长度为3。 Numpy的数组类叫做ndarray，可以处理多维的数组。需要注意的是numpy.array和array.array,后者只能处理简单的一维数组。ndarray的对象属性有： ndarray.ndim：数组轴的个数，即秩。 ndarray.shape：数组在每一个维度上大小的维度，是一个元组，例如：一个n排m列的数组的shape是(n, m)，这个元组的长度是秩，因为这个数组只有两个轴。 ndarray.size：数组元素的总和，等于shape属性元组中元素的乘积。 ndarray.dtype：数组中元素类型。注意一个数组中的元素类型是统一的。 ndarray.itemsize：元素的字节大小。 ndarray.data：包含实际数组元素的缓冲区。 例子： 123456789101112131415161718192021from numpy import *# 创建一个长为15且内容为0~14的数组，并转化成3*5的数组a = arange(15).reshape(3,5)print(a)print('a.ndim is ',a.ndim)print('a.dtype is ', a.dtype)print('a.shape is ', a.shape)print('a.itemsize is ', a.itemsize)print('a.size is ', a.size)结果：[[ 0 1 2 3 4] [ 5 6 7 8 9] [10 11 12 13 14]] a.ndim is 2a.dtype is int32a.shape is (3, 5)a.itemsize is 4a.size is 15 创建数组 使用array()函数将常规的Python列表和元组转化为数组，数组类型可在创建时指定 例子： 1234567from numpy import * a = array([1, 2, 3])或b = array((1, 2, 3))或c = array([(1, 2, 3), (1, 2, 3)]) 使用可用于创建指定数组的函数，数组类型可在创建时指定 例子： 12345678910111213# 创建全为0的指定形式的数组zeros((3, 5)) # 创建全为1的指定形式和类型的数组ones((3, 4,), dtype=int32) # 创建内容随机的指定形式的数组empty((4, 3)) # arange()函数，返回的是数组而非列表arange(10, 40, 6) random.random((2, 3)) 基本运算 数组间的运算是按照元素来进行的，将结果存入新的数组 例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from numpy import *a = array([(2, 4), (6, 8)])b = arange(4).reshape((2, 2)) # 对应元素值之差c = a - bprint(a)print(b)print(c) 结果：[[2 4] [6 8]] [[0 1] [2 3]] [[2 3] [4 5]] # b^2b**2结果：array([[0, 1], [4, 9]], dtype=int32) # sin(a)sin(a)结果：array([[ 0.90929743, -0.7568025 ], [-0.2794155 , 0.98935825]])10*sin(a)结果：array([[ 9.09297427, -7.56802495], [-2.79415498, 9.89358247]]) # 判断每个元素是否符合要求a &lt; 3结果：array([[ True, False], [False, False]]) # 3*aa *= 3结果：[[4, 8], [12, 16]] 注意矩阵乘法需要使用dot()函数或创建矩阵对象实现，直接相乘得到的是元素对应相乘 例子： 1234567891011# 元素对应乘积a*b结果：array([[ 0, 4], [12, 24]]) # 矩阵点乘dot(a, b)结果：array([[ 8, 14], [16, 30]]) 若两个矩阵相加使用+=，则精度更精确的要作为接收的数组 用于计算的函数 例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788# e^xd = exp(a*1j)d结果：array([[-0.41614684+0.90929743j, -0.65364362-0.7568025j ], [ 0.96017029-0.2794155j , -0.14550003+0.98935825j]]) d.dtype.name 结果：'complex128'# 数组中元素值之和a = random.random((2, 3))print('the sum of a is ', a.sum())​ 结果：array([[0.89005106, 0.20091997, 0.35641668], [0.15765842, 0.16708008, 0.38590499]]) the sum of a is 2.1580312015631193 # 数组中元素的最大值a.max() 结果：0.8900510634052407 # 按第一个坐标轴求最大值（每列中的最大值）a.max(axis=0) 结果：array([0.89005106, 0.20091997, 0.38590499]) # 指定坐标轴进行计算b = arange(12).reshape(3, 4)b print('b.shape is ', b.shape# 按第一个坐标轴计算，即按列加和b.sum(axis=0)# 按第二个坐标轴计算，即按行加和b.sum(axis=1) 结果：array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]])b.shape is (3, 4) array([12, 15, 18, 21]) array([6, 22, 38]) # 求数组中的最小值print('b.min is ', b.min())print('b.min in each row ', b.min(axis=1)) 结果：b.min is 0b.min in each row is [0, 4, 8] # 矩阵累积和（顺序自矩阵中元素之和）b.cumsum()结果：array([ 0, 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 66], dtype=int32) # 按行计算b.cumsum(axis=1)结果：array([[ 0, 1, 3, 6], [ 4, 9, 15, 22], [ 8, 17, 27, 38]], dtype=int32) # 按列计算b.cumsum(axis=0)结果：array([[ 0, 1, 2, 3], [ 4, 6, 8, 10], [12, 15, 18, 21]], dtype=int32) 通用函数 常见的有sin()，cos()，exp()等，作用于数组时按元素计算，返回结果仍是数组。 常见的有 1exp(A), sqrt(A), add(A, B), all(), alltrue(), any(), apply(), along axis(), argmax(), argmin(), argsort(), average(), bincount(), ceil(), clip(), conj(), conjugate(), corrcoef(), cov(), cross(), cumprod(), cumsum(), diff(), dot(), floor(), inner(), inv(), lexsort(), max(), maximum(), mean(), median(), min(), minimum(), nonzero(), outer(), prod(), re(), round(), sometrue(), sort(), std(), sum(), trace(), transpose(), var(), vdot(), vectorize(), where() 此类函数的使用详情请到官网查询官网 求逆矩阵：np.linalg.inv(arr) 求行列式：np.linalg.det(arr) 求特征值与特征向量：e,v = np.linalg.eig(arr) 切片、索引和迭代 一维数组可以被索引、切片和迭代，与列表和其他Python序列操作相同 例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243# 迭代a = arange(10)**3a结果:array([ 0, 1, 8, 27, 64, 125, 216, 343, 512, 729], dtype=int32)# 根据索引访问数组内容a[2]结果：8# 切片a[2:5]结果：array([ 8, 27, 64])# 前6个元素，每两个有一个设置为-1000a[:6:2] = -1000a结果：array([-1000, 1, -1000, 27, -1000, 125, 216, 242, 512, 729], dtype=int32)# 逆置数组a[::-1]结果：array([729, 512, 343, 216, 125, 64, 27, 8, 1, 0], dtype=int32)# 遍历数组for i in a: print(i)结果：[ 0, 1, 8, 27, 64, 125, 216, 343, 512, 729] 多维数组可以每个轴有一个索引，这些索引由一个逗号分割的元素给出 例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465# 使用fromfunction创建数组def f(x, y): retuen 10*x + y# f是函数，(5, 4)是数组的形状，得到的数组内容是下标在函数中经过计算得到的值b = fromfunction(f, (5, 4), dtype=int)b结果：array([[ 0, 1, 2, 3], [10, 11, 12, 13], [20, 21, 22, 23], [30, 31, 32, 33], [40, 41, 42, 43]])# 索引访问数组内容b[2,3]结果：23# 对一个维度使用切片# 读取第二列的内容b[:5, 1]结果：array([ 1, 11, 21, 31, 41])# 多个维度上使用切片# 读取第2、3行b[1:3, :]结果：array([[10, 11, 12, 13], [20, 21, 22, 23]])# 缺失的索引默认为全部# 读取倒数第一行b[-1]结果：array([40, 41, 42, 43])# 多维数组的迭代是以第一个轴为基准的for row in b: print(row) 结果：[0 1 2 3][10 11 12 13][20 21 22 23][30 31 32 33][40 41 42 43]# 对数组中每个元素进行计算，使用flat(迭代器)for element in b.flat: print(element, end=',') 结果：0,1,2,3,10,11,12,13,20,21,22,23,30,31,32,33,40,41,42,43, 形状操作 改变数组形状，目标形状包含的元素个数要与原数组的元素个数相同 例子： 123456789101112131415161718192021222324252627282930313233343536373839404142# 创建数组# floor()函数：向下取整a = floor(10*random.random((3, 4)))结果：array([[ 6., 7., 4., 3.], [ 0., 0., 2., 6.], [ 7., 7., 8., 6.]])# 转化成一维数组a.reval()a结果：array([ 6., 7., 4., 3., 0., 0., 2., 6., 7., 7., 8., 6.])# 修改形状# 转化成6*2,但不修改真正的数组内容a.reshape(6, 2)结果：array([[6., 0.], [5., 5.], [5., 6.], [1., 3.], [4., 7.], [6., 4.]])# 使用resize()直接修改数组本身a.resize((2, 6))结果：array([[ 6., 7., 4., 3., 0., 0.], [ 2., 6., 7., 7., 8., 6.]])# 转置a.shape = (6, 2)a.transpace()结果：array([[ 6., 4., 0., 2., 7., 8.], [ 7., 3., 0., 6., 7., 6.]]) 组合不同的数组（stack） 可以沿不同轴将数组堆叠在一起 例子： 12345678910111213141516171819202122232425262728293031# 创建数组a = floor(10*random.random((2, 3)))ab = floor*(10*random.random(2, 2))b结果：array([[ 1., 5.], [ 6., 7.]])array([[ 5., 5.], [ 4., 5.]])# 组合# 按行组合vstack((a, b))结果：array([[ 1., 5.], [ 6., 7.], [ 5., 5.], [ 4., 5.]])# 按列组合hstack((a, b))结果：array([[ 1., 5., 5., 5.], [ 6., 7., 4., 5.]]) 另一个例子： 123456789101112131415161718192021222324252627a = array([4, 2])b = array([2, 8])# newaxis相当于创建了一个维度，这里是将a由1*2转化成2*1# 可以用于从多维数组中取一列，但并不改变列的信息，不会取出来之后变成了一维数组a[:,newaxis]结果：array([[ 4.], [ 2.]])# 将两个一维数组组合起来column_stack((a[:, newaxis], b[:, newaxis]))结果：array([[ 4., 2.], [ 2., 8.]])vstack((a[:, newaxis], b[:, newaxis]))结果：array([[ 4.], [ 2.], [ 2.], [ 8.]]) 将数组分割成几个小数组（split） 可以沿水平轴分割(hsplit())，或者指定返回相同形状的数组的个数，或者指定在那些列之后进行分割 例子： 123456789101112131415161718192021222324252627# 创建数组a = floor(10*random.random((2,12)))a结果：array([[ 3., 7., 0., 6., 0., 6., 8., 5., 8., 2., 7., 1.], [ 7., 7., 2., 3., 4., 8., 8., 5., 2., 5., 5., 4.]])# 沿水平轴分割，分割成三个形状相同的数组hsplit(a, 3)结果：[array([[ 3., 7., 0., 6.], [ 7., 7., 2., 3.]]), array([[ 0., 6., 8., 5.], [ 4., 8., 8., 5.]]), array([[ 8., 2., 7., 1.], [ 2., 5., 5., 4.]])]# 在第三列、第四列之后进行分割hsplit(a, (3, 4))结果：[array([[ 3., 7., 0.], [ 7., 7., 2.]]), array([[ 6.], [ 3.]]), array([[ 0., 6., 8., 5., 8., 2., 7., 1.], [ 4., 8., 8., 5., 2., 5., 5., 4.]])] 复制和视图 对数组进行处理是，它们的有时不会拷贝到新数组 完全不拷贝 1234567891011121314a = arange(12)b = aprint(b is a)结果：Trueb.shape = 3, 4a.shape结果：(3, 4)b就是a本身 视图和浅复制 12345678910111213141516171819202122232425262728293031323334# 不同的数组对象分享同一个数据。视图方法创造一个新的数组对象指向同一数据c = a.view()c is a 结果：Flase# c是a的视图，则a是c的basec.base is a结果：True# c是否有自身的数据c.flags.owndata结果：False# 视图的形状改变不影响数组本身c.shape = 2, 6a.shape结果：(3, 4)# 视图内容的改变会改变原数组c[0, 4] = 1234a结果：array([[ 0, 1, 2, 3], [1234, 5, 6, 7], [ 8, 9, 10, 11]]) 深复制 完全复制数组和它的数据 例子： 123456789101112131415161718192021# 完全拷贝，d与a是完全无关的两个实体d = a.copy()d is a结果：False# d也不是a的视图d.base is a结果：False# d的内容的修改也不会影响ad[0, 0] = 9999a结果：array([[ 0, 10, 10, 3], [1234, 10, 10, 7], [ 8, 10, 10, 11]]) 方法总览 创建数组 12arange, array, copy, empty, empty_like, eye, fromfile, fromfunction, identity, linspace, logspace, mgrid, ogrid, ones, ones_like, r , zeros, zeros_like 转化 1astype, atleast 1d, atleast 2d, atleast 3d, mat 操作 12array split, column stack, concatenate, diagonal, dsplit, dstack, hsplit, hstack, item, newaxis, ravel, repeat, reshape, resize, squeeze, swapaxes, take, transpose, vsplit, vstack 询问（判断） 1all, any, nonzero, where 排序 1argmax, argmin, argsort, max, min, ptp, searchsorted, sort 运算 1choose, compress, cumprod, cumsum, inner, fill, imag, prod, put, putmask, real, sum 基本统计 1cov, mean, std, var 基本线性代数 1cross, dot, outer, svd, vdot 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://zivblog.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://zivblog.top/tags/Python/"}]},{"title":"mysql解压版安装配置","slug":"mysql解压版安装配置","date":"2019-04-17T07:32:55.000Z","updated":"2020-07-06T05:35:43.000Z","comments":true,"path":"passages/mysql-jie-ya-ban-an-zhuang-pei-zhi/","link":"","permalink":"http://zivblog.top/passages/mysql-jie-ya-ban-an-zhuang-pei-zhi/","excerpt":"mysql安装时有安装版和解压版两种方式，本文讲解的是解压版的配置过程。 本文使用的mysql5.5，你可以选则喜欢的版本进行下载。","text":"mysql安装时有安装版和解压版两种方式，本文讲解的是解压版的配置过程。 本文使用的mysql5.5，你可以选则喜欢的版本进行下载。 下载Mysql 在这里下载mysql，并解压到你喜欢的目录下。 配置Mysql 将mysql主文件夹下的my.default.ini改名为my.ini并移动到bin目录下 如果没有则创建my.ini并移动到bin目录下 添加以下内容 123456789101112131415161718192021[Client]port = 3306[mysqld]# 端口port = 3306# 安装目录basedir=D:\\mysql-5.5.62# 数据存放目录datadir=D:\\mysql-5.5.62\\data# 最大连接数max_connections=200# 服务器端默认字符集character-set-server=utf8# 创建新表时使用的默认存储引擎default-storage-engine=INNODBsql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES [mysql]# 客户端默认字符集default-character-set=utf8 将mysql下的bin目录添加到Path环境变量中 安装Mysql服务 以管理员打开cmd 将目录切换到mysql下的bin目录 执行mysqld install 启动mysql服务 控制面板-&gt;管理工具-&gt;服务 -&gt; mysql -&gt; 启动 填坑 原有mysql服务卸载不完全 12执行sc delete mysql 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"工具配置","slug":"工具配置","permalink":"http://zivblog.top/categories/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://zivblog.top/tags/Tools/"}]},{"title":"Pycharm2017版激活","slug":"Pycharm2017版激活","date":"2019-04-15T10:57:11.000Z","updated":"2020-03-04T06:37:05.000Z","comments":true,"path":"passages/pycharm2017-ban-ji-huo/","link":"","permalink":"http://zivblog.top/passages/pycharm2017-ban-ji-huo/","excerpt":"本教程仅供个人学习使用，如有需要，请前往官方渠道购买正版产品。","text":"本教程仅供个人学习使用，如有需要，请前往官方渠道购买正版产品。 Pycharm下载 在这里选择2017版的pycharm下载，注意要选择professional版本的。 communtiy版本的是可以免费使用的，基本功能都有，可以满足日常使用。 下载完成后按指示安装即可。 安装完成后打开如下图所示 Pycharm激活 从这里下载http://idea.lanyus.com/jar/JetbrainsCrack-2.6.2.jar 将下载的jar包放在Pycharm安装目录下的bin目录下 修改pycharm.exe.vmoptions和pycharm64.exe.vmoptions文件，使用记事本打开即可 在其文件末尾添加-javaagent:你的pycharm安装目录\\bin\\JetbrainsCrack-2.6.10-release-enc.jar 重新启动Pycharm，选择Activiate code，输入以下内容 1BIG3CLIK6F-eyJsaWNlbnNlSWQiOiJCSUczQ0xJSzZGIiwibGljZW5zZWVOYW1lIjoibGFuIHl1IiwiYXNzaWduZWVOYW1lIjoiIiwiYXNzaWduZWVFbWFpbCI6IiIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IkZvciBlZHVjYXRpb25hbCB1c2Ugb25seSIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiQUMiLCJwYWlkVXBUbyI6IjIwMTctMTEtMjMifSx7ImNvZGUiOiJETSIsInBhaWRVcFRvIjoiMjAxNy0xMS0yMyJ9LHsiY29kZSI6IklJIiwicGFpZFVwVG8iOiIyMDE3LTExLTIzIn0seyJjb2RlIjoiUlMwIiwicGFpZFVwVG8iOiIyMDE3LTExLTIzIn0seyJjb2RlIjoiV1MiLCJwYWlkVXBUbyI6IjIwMTctMTEtMjMifSx7ImNvZGUiOiJEUE4iLCJwYWlkVXBUbyI6IjIwMTctMTEtMjMifSx7ImNvZGUiOiJSQyIsInBhaWRVcFRvIjoiMjAxNy0xMS0yMyJ9LHsiY29kZSI6IlBTIiwicGFpZFVwVG8iOiIyMDE3LTExLTIzIn0seyJjb2RlIjoiREMiLCJwYWlkVXBUbyI6IjIwMTctMTEtMjMifSx7ImNvZGUiOiJEQiIsInBhaWRVcFRvIjoiMjAxNy0xMS0yMyJ9LHsiY29kZSI6IlJNIiwicGFpZFVwVG8iOiIyMDE3LTExLTIzIn0seyJjb2RlIjoiUEMiLCJwYWlkVXBUbyI6IjIwMTctMTEtMjMifSx7ImNvZGUiOiJDTCIsInBhaWRVcFRvIjoiMjAxNy0xMS0yMyJ9XSwiaGFzaCI6IjQ3NzU1MTcvMCIsImdyYWNlUGVyaW9kRGF5cyI6MCwiYXV0b1Byb2xvbmdhdGVkIjpmYWxzZSwiaXNBdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlfQ&#x3D;&#x3D;-iygsIMXTVeSyYkUxAqpHmymrgwN5InkOfeRhhPIPa88FO9FRuZosIBTY18tflChACznk3qferT7iMGKm7pumDTR4FbVVlK&#x2F;3n1ER0eMKu2NcaXb7m10xT6kLW1Xb3LtuZEnuis5pYuEwT1zR7GskeNWdYZ0dAJpNDLFrqPyAPo5s1KLDHKpw+VfVd4uf7RMjOIzuJhAAYAG+amyivQt61I9aYiwpHQvUphvTwi0X0qL&#x2F;oDJHAQbIv4Qwscyo4aYZJBKutYioZH9rgOP6Yw&#x2F;sCltpoPWlJtDOcw&#x2F;iEWYiCVG1pH9AWjCYXZ9AbbEBOWV71IQr5VWrsqFZ7cg7hLEJ3A&#x3D;&#x3D;-MIIEPjCCAiagAwIBAgIBBTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE1MTEwMjA4MjE0OFoXDTE4MTEwMTA4MjE0OFowETEPMA0GA1UEAwwGcHJvZDN5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO&#x2F;5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij&#x2F;78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB&#x2F;xVy&#x2F;VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE&#x2F;EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl&#x2F;GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9 常见问题failed to create JVM: error code -1 在网上查阅了一些经验，最终是以以下方案解决的。 卸载java并删除注册表： 卸载java并删除环境变量 win+r，输入regedit启动注册表管理器 删除HKEY_CURRENT_USER\\Software\\JavaSoft 删除HKEY_LOCAL_MACHINE\\SOFTWARE\\JavaSoft 重新安装java并配置环境变量 从这里下载java8并安装 我的电脑-&gt;右键属性-&gt;高级系统设置-&gt;环境变量 系统变量中新建JAVA_HOME变量，值为你的java安装目录 选中系统变量中的Path，点击编辑，新建两条路径 打开cmd，依次输入java、javac、java -version确认安装配置正确 重新激活即可 key is invalid 从http://idea.lanyus.com/下载最新的补丁 删除 `C:/Users/用户名/.PycharmXXXX.XX文件 重新进入就不会有问题了 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"工具配置","slug":"工具配置","permalink":"http://zivblog.top/categories/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://zivblog.top/tags/Tools/"}]},{"title":"hexo博客主题配置","slug":"hexo博客主题配置","date":"2019-04-12T08:50:17.000Z","updated":"2020-07-06T05:07:55.000Z","comments":true,"path":"passages/hexo-bo-ke-zhu-ti-pei-zhi/","link":"","permalink":"http://zivblog.top/passages/hexo-bo-ke-zhu-ti-pei-zhi/","excerpt":"hexo博客主题配置","text":"hexo博客主题配置 在这里，挑选一款自己喜欢的主题，下载。 解压，将整个主题文件夹放到博客主文件夹下的themes文件夹下。 将主配置文件中的theme字段后的landscapes改为你主题文件夹的名称。 配置主题文件夹中的config.yml。 具体配置在主题的文档中都有，各个主题的配置过程都大同小异，请参照文档配置。 本站使用的主题是ad，欢迎来信交流。 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"博客相关","slug":"博客相关","permalink":"http://zivblog.top/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://zivblog.top/tags/Tools/"}]},{"title":"Pycharm使用小技巧","slug":"Pycharm使用小技巧","date":"2019-04-07T10:27:13.000Z","updated":"2020-03-04T06:37:34.000Z","comments":true,"path":"passages/pycharm-shi-yong-xiao-ji-qiao/","link":"","permalink":"http://zivblog.top/passages/pycharm-shi-yong-xiao-ji-qiao/","excerpt":"Pycharm的一些使用技巧 不断更新中","text":"Pycharm的一些使用技巧 不断更新中 打开时显示最后一次打开的项目or显示欢迎界面 file -&gt; settings -&gt; Appearance&amp;Behavior -&gt; System steeings -&gt; Reopen … 勾选or取消勾选 Pycharm使用conda虚拟环境 使用conda env list可以查看创建的虚拟环境 File -&gt; Settings -&gt; Project XXXX -&gt; Project Interpreter -&gt; add local Python Interpreter 选择Existing environment -&gt; XXXX/Anaconda/envs/your_env_name/python.exe 设置Pycharm文件编码 file -&gt; settings -&gt; Editor -&gt; File Encodings 按照自己的意愿设置即可 设置文件模版 file -&gt; Settings -&gt; Editor -&gt; File and Code Templates 此处以设置python文件模板为例 点击“Python Script” 字段解释 123456789101112131415161718192021$&#123;USER&#125; 当前系统用户$&#123;DATE&#125; 当前系统日期$&#123;TIME&#125; 当前系统时间$&#123;PRODUCT_NAME&#125; 创建文件的IDE名称也可直接添加文本信息其他可用：$&#123;PROJECT_NAME&#125; - 当前项目的名称。$&#123;NAME&#125; - 在文件创建过程中在“新建文件”对话框中指定的新文件的名称。$&#123;YEAR&#125; - 今年。$&#123;MONTH&#125; - 当月。$&#123;DAY&#125; - 当月的当天。$&#123;HOUR&#125; - 目前的小时。$&#123;MINUTE&#125; - 当前分钟。$&#123;PRODUCT_NAME&#125; - 将在其中创建文件的IDE的名称。$&#123;MONTH_NAME_SHORT&#125; - 月份名称的前3个字母。 示例：一月，二月等$&#123;MONTH_NAME_FULL&#125; - 一个月的全名。 示例：一月，二月等 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"工具配置","slug":"工具配置","permalink":"http://zivblog.top/categories/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://zivblog.top/tags/Tools/"}]},{"title":"苏州大学计算机考研初复试总结","slug":"苏州大学计算机考研初复试总结","date":"2019-04-04T07:11:47.000Z","updated":"2020-07-06T05:47:53.000Z","comments":true,"path":"passages/su-zhou-da-xue-ji-suan-ji-kao-yan-chu-fu-shi-zong-jie/","link":"","permalink":"http://zivblog.top/passages/su-zhou-da-xue-ji-suan-ji-kao-yan-chu-fu-shi-zong-jie/","excerpt":"苏州大学计算机考研初复试总结","text":"苏州大学计算机考研初复试总结 写在前面很早就想写一篇总结了，一直没有着手，一来是没有构思好具体的结构，另一方面是成绩还没出来，总觉得这个时候发篇总结容易打脸。 先介绍一下自己的情况吧。本科山东某双非本科，今年报考的是苏州大学的计算机专硕，专业课代号872。初试分数365，排名15。 典型工科男，没什么文笔，写的可能像是流水账一样，大家多担待。 今年由于政策变动，录取结果出的可能会晚一些。 今年统考全日制软件专硕取消了，不过计算机专硕最终扩招了，整体名额和去年差不多。 4月8日更新 成绩出来了，有幸上岸，感谢感谢。 备考时间安排 正式开始大约是在4月中旬，在之前也有看过一些高数，寒假结束之前差不多听完了朱伟的恋练有词。 英语真题从5月份开始，大约一周做一年的真题。 6月结束之前看完了汤老师的高数基础班和李永乐老师的线性代数。 暑假的时候看了一遍王道的数据结构和操作系统，听完了线代和高数的强化班。 九月份开始听徐涛的政治强化班并开始做数学的真题。 十月份开始刷肖秀荣的1000题并做了苏大近15年的真题。 十一月主要回顾了一遍高数和线代的笔记。 十一月中旬开始背作文和政治的大题。 每天的有效学习时间一般在8~9个小时。 使用参考书 英语：《恋练有词》、真题黄皮书（英一、英二）、《恋练有辞写作宝典》 政治：《核心考案》（徐涛）、《1000题》（肖秀荣）、《冲刺背诵笔记》（徐涛）、《肖四》、《肖八》 数学：《高数复习讲义》（汤家凤）、《线性代数辅导讲义》（李永乐）、《1800题》（汤家凤）、《真题》（张宇）、《张宇八套卷》 专业课：王道考研的《数据结构》和《操作系统》、近15年真题 视频网课 恋练有词（18年）。不建议看最新的，太拖了。 语法（唐静）。有时间可以看一下，开倍速或者跳着看都行。 阅读（唐迟）。可以针对实在看不懂的阅读来看一下，没必要全看。 徐涛政治强化班。不建议看基础班。 徐涛时政押题直播班。b站就可以看，一般直播之后过一天就有了。 汤家凤高数基础班、强化班。个人感觉跟着汤老师还是很踏实的，就是方言比较严重。 李永乐线代基础班、强化班。 汤家凤公众号的一些直播录像。 几点建议 专业课请务必重视专业课真题，尤其是操作系统，个人感觉苏大的专业课个性化很强，想拿高分不是很容易，有时间和机会的化可以看一下苏大本科的期末考试题。 英语阅读要认真练，每一篇文章都要认真去读。建议做完一遍之后隔几天再拿出来当作翻译精读一下。 英语重点就是阅读，请多花些时间在上面。 肖秀荣的四套卷一定要做，很真题。说实话都有些怀疑他是不是被派来泄题的（滑稽保命）。 李永乐的线代讲义一定要做，这么多年线代辅导独一份不是盖的，有时间可以听一下李永乐的强化班，有些技巧书里没有。 汤家凤的高数还是很踏实的，就是有点方言，个人比较推荐看一下他中值定理部分的强化班，很详细。 数学必须必须必须多做题，做真题，模拟题不建议做。真题值得刷好几遍（注意控制时间，模拟考场氛围）。 政治1000题的主要作用就是巩固知识点，不要太较真了，如果嫌多的话可以做徐涛的优题库，题量小一点。 政治马原建议看一下视频，其中的一些政治经济学的东西自己不太好懂。 政治看视频的话建议徐涛强化班，比较生动有趣。 没学过操作系统的，建议看mooc，苏大的老师讲的。 想到再来补充吧 经验之谈 考研不仅是知识上的较量，更是心态的较量，考研期间保持心情愉快是很关键的。 考研过程中收获的也不仅仅是最终的录取结果，还有心态和眼界上的提升。 请务必合理评估自己的实力，选择一个能通过半年多努力上岸的学校，这点很重要也很现实。 一个合适的研友对你来说不仅是学习上的陪伴，还是精神上的陪伴。一定要找一个肯沉下心学习的一起学习，如果你自制力强的也可以自己进行。 做规划是很有必要的，长短期都要大致有个计划。比如今天回宿舍前将明天的计划做一下，每个月结束前对上个月总结以下，对下个月计划一下。 数学和专业课值得花最多的时间去准备，英语学习需要贯穿整个备考过程。 不管初试复试分数占比如何，初试分数高一些总归是有好处的。根据今年的政策来说，初试成绩高一点可以让你更容易选到心仪的导师。 有问题一定要及时解决，不要害怕去请教别人，不要嫌请教别人花时间，给别人讲题也能加深你对知识的认识。 政治不建议暑假结束之前看，没必要，更会占用暑假最珍贵的数学强化时间。 政治和英语作文在最后两个月开始就行，时间很足够。 最后两个月基本就是政治和英语作文，其他题型的练习了，所以数学一定要在暑假结束之前打好底子，不然后期会手忙脚乱。 心态平和，按照自己的计划一步一步的进行，不要被别人的进度影响。 苏大的报名人数还是挺多的，不过不要害怕，做好自己就好了。 不要太过于追求技巧和方法，脚踏实地的练习才是最关键的。 文笔一般，大家凑活看吧，有问题可以联系我，本文也会继续补充。 下面的是复试的一点总结复试成绩不是很理想，就不谈什么经验了，说一下复试的流程吧。 今年是先选导师后复试，初试成绩高一点对联系导师还是有些优势的。 时间安排 复试通知 招生计划 资格审查 上机 面试 体检 一共是两天的时间 联系导师 注意有礼貌 不要同时联系多个同组的老师，会很尴尬（别问我为什么知道=_=） 有条件的话可以联系几个目标院校的学长学姐问一下。 研究方向 导师简介 学院导师联系方式 笔试（上机+选择） 前15年的上机真题很多考验群里都有，我在博客上也有整理（其实就是稍微整理了一下思路）。 主要就是文件操作和一些简单数据处理。 最后提交的程序一定要编译通过，有步骤分的。 进机房需要鞋套，可以提前买，学校里面的超市里也有卖的。 选择题刷二级c语言单选就可以了，但是还是有点区别的。总之二级c语言刷一段时间，40+应该没问题。 19年的上机题我有记过，一并放在本站了，需要的自取。 复试主要拉分的就是机试，一定要好好准备。 面试 面试分为三块：自我介绍（英文）、文献翻译、专业课知识（抽题，最多三次）。 今年专硕分了4组，面试顺序按成绩的升序排的。 今年的自我介绍要求用ppt来讲，时间在5分钟以内。 文献翻译大致就是一些数据结构和操作系统的知识，平时注意一些专业名词即可。 专业课知识包含的面很广，本科学的都有机会问到，还有一些当前的热点事件等。 据说跨考的同学答不上来的话会问一些本科本专业学的东西，所以不用害怕。 面试拉分不大，成绩给的也都挺高的。 其实面试不用紧张，尽可能去说就可以了，不会的可以说以下自己的看法，注意礼貌。 关于本科院校其实大家根本不用担心什么本科院校歧视什么的。 本科院校好的话顶多在联系导师的时候占点优势，在其他地方没什么差别。 一来初试和上机对于本科是哪里的根本没有关系，就看谁肯下功夫。 二来复试中的面试根本不会看你的成绩单之类的东西。 现阶段把初试的分数尽量考高点就是最大的优势了。 你们最关心的 总结了一下最近被问到的问题 面试时是否会问大学时的项目经验？ 我面试的时候，下面打分的老师们几乎都不讲话，也没有提问，全程只有一个助理在指导你该干什么。进去的时候不让带奖状、证书、成绩单等，老师们根本没时间看。还有就是你的初试分数如果低一点的话可以在自我介绍是适当加一些自己的各种经历，可能会是加分项。 上机题只能用c语言么？ 是的。20年的暂时还不知道，不过之前都是c语言程序设计。只能用有限的头文件，c++里的stl都不能用。主要考察的是文件操作，把历年的上机题敲两遍就差不多了。 上机使用什么工具？ 上机只能用vs2010，因为这边的机房电脑上只有这个，提前熟悉一下，有突发情况的话可以现场问监考的老师。 上机题必须全部做出来才有分么？ 不是。上机题一般有一道，但分为很多问，或者要求实现多个函数（今年）。每一问、每个函数都有分数。值得注意的是提交的程序必须是编译通过并且有输出的。 我去年4月份的进度？ 去年四月份差不多才算正儿八经的开始。刚听完去年学长们的经验分享。进度大约是高数听完了汤家凤的基础班，英语听完了恋练有词。 需不需要初试之前联系导师，与什么要注意的？ 个人感觉初试之前联系必要性不高，除非是很抢手的导师。毕竟连初试能不能过都不确定，导师那边也不好给答复，这个时候联系最大的作用就是留个印象。 联系导师首先要有礼貌，邮件里注意礼貌用于，将自己的意图表达清楚，附上自己的简历。 不要同时给多个同组的导师发邮件，在一个导师确定没有机会或长时间没有回复时再联系下一个。 看数据结构之前需不需要先看c语言的相关内容？ 数据结构主要考察的是思想，解决问题的思路。 数据结构答题时用伪代码即可，不用过分注意语法错误，达到能在注释的帮助下使别人看懂你的代码即可。 如果看数据结构的时候看不懂书上的代码，相应的查以下即可，主要就是循环、顺序、选择几种结构。 专业课是围绕真题还是以课本/辅导书为主？ 首先我的专业课成绩刚刚够三位数，在这里直说几点教训。 操作系统要重视真题，适应苏大的出题方式。 数据结构要重视每一个点，不要有遗漏。 我是直接看的王道，看完之后做了一遍真题，做的时候又回顾的知识点，最后又过了一遍知识点和真题。 出初试成绩后联系导师的模版 尊敬的XX教授： ​ 您好，我叫XXX，就读于XX，目前为大四在读。 ​ 我今年参加了贵校计算机专业硕士的入学考试，总成绩为XXX分，专业排名为XX，其中数学XXX，英语XX，专业课XXX，政治XX。按照往年的分数线，我将有机会参加贵校的研究生复试，我希望能够有幸攻读您2019年的研究生，所以十分冒昧给您发这封邮件。 ​ 我大学期间成绩在专业前XX%，专业课成绩良好，曾多次获得校级二等奖学金，优秀学生干部等荣誉。我已经通过了英语六级考试，具备一定的英文文献阅读能力，相信这对以后的科研工作会有所帮助。 ​ 大学课余期间我积极学习知识，具有对未知领域强烈的好奇心和一定的自学能力。曾自学一段时间的机器学习算法和python，参加过相关的线上比赛。后来接触到XX，十分感兴趣，希望能跟随一名该方面的专家进行研究学习，在这个方向上有所建树。 ​ 我目前正在积极准备研究生复试和毕业设计，毕业设计是XX的研究。 ​ 冒昧请问老师您是否还有统招名额，如果我能够通过取得苏州大学的研究生入学资格，希望能有机会攻读您的2019级研究生。如果能有幸攻读您的研究生，我将踏实学好专业知识并努力完成您下达的任务，竭力向您一样在行业内取得不俗的成就。 ​ 再次感谢您能在百忙之中阅读我的邮件，并对冒昧打扰致以歉意，同时期待收到您的回复。随邮件附个人简历及成绩证明。 ​ 祝老师生活工作愉快。 ​ 此致敬礼 ​ 学生：XXX ​ XXXX年X月X日 复试之前需要联系导师么？ 今年的政策不一样，复试之前必须先填一个表，必须导师那边同意之后才能填的，因为每个老师名额有限。 今年的情况是，只要复试前联系好导师，最后上岸后就确定是你联系的导师了，一般不能再改了。 由此看来，初试成绩高一点对选导师还是很友好的。 硕导和博导的区别？ 说实话我也不是很清楚，但是从另一个角度来说，有博士生招生资格的一般资历比较老，而且这样的话你就会有同门的博士生师兄，还是比较好的。 学硕和专硕在选导师时有没有区别？ 只要注意老师是的招生名额里是否有专硕招生，因为有的导师是不收专硕的。 其他的没有区别，放手去联系吧，说不定有大佬就同意了呢。 读研的方向怎么确定？ 学硕的化报名的时候就填一个方向，专硕报名时不用填。 根据你选的实验室和联系的导师的方向而定。 专业课面试如何准备？ 说实话，到时候就算不会也没什么问题，如实说就行了，比如说：学过去的时间比较长了，而且用的也不多，忘得差不多了。 最好是会。 想复习的话看看本科期间学过的专业课，比如数据库等（我今年就抽了两个数据库的题，都不会。。。） 再关注一些计算机方面的热点新闻即可。 对跨考是否友好 专业课考两门，如果有些基础的话，这一点可以忽略。 初试解决了专业课，其实大家都差不多。 复试好好准备上机就可以了，面试还是很友好的。 福利 准备初试和复试的一点电子版的资料，有些是考研群里的，搬运整理了一下。 请自取 最后别人的经历和经验用来听听，或者吸取一些有用的部分就好了，找到自己的复习节奏和方法才能事半功倍。 谢谢你的观看，考研过程中有问题可以联系我，我会尽力给出一点建议。 发邮件或加qq都可以。 就这样，祝大家都能成功上岸。 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"}],"tags":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"}]},{"title":"2019上机题回忆","slug":"2019年上机题回忆","date":"2019-04-04T07:10:01.000Z","updated":"2020-07-06T05:05:43.000Z","comments":true,"path":"passages/2019-nian-shang-ji-ti-hui-yi/","link":"","permalink":"http://zivblog.top/passages/2019-nian-shang-ji-ti-hui-yi/","excerpt":"2019上机题回忆","text":"2019上机题回忆 数据放在D盘根目录下名为Data.txt的文本文件中。 文件中存储有100个不超过32768的非负整数。 编写函数read_file()：读取文件中的数据，按文件中顺序存放在arr中 编写函数print()：将arr中的内容显示在屏幕上，每行10个数，每个整数占6列 编写函数count()：统计0~9在arr中所有整数中出现的次数，并存放到res中 编写函数print_res()：将res输出，每行5个元素，可复用print() 编写函数sort_array()：将arr中的整数按因子和升序排列，因子和相等的则按原大小排列（1和其本身也是因子） 编写函数filter_array()：对arr进行筛选，将偶数筛选出来放在头部，其他的放在后面。若使用辅助数组扣10分 编写函数write_file()：将偶数质数分解，每个数占一行写到output.txt中 给定主函数，修改一处扣5分。 满分100分。 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"}],"tags":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"},{"name":"c语言","slug":"c语言","permalink":"http://zivblog.top/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"hexo+github博客绑定域名","slug":"hexo之github博客绑定域名","date":"2019-04-01T02:27:12.000Z","updated":"2020-07-06T05:07:59.000Z","comments":true,"path":"passages/hexo-zhi-github-bo-ke-bang-ding-yu-ming/","link":"","permalink":"http://zivblog.top/passages/hexo-zhi-github-bo-ke-bang-ding-yu-ming/","excerpt":"从阿里云购买域名，绑定到托管在Github上的博客。","text":"从阿里云购买域名，绑定到托管在Github上的博客。 写在前面由于我们的网站主题是托管在github上的，也就相当于服务器在国外的情况，所以购买的域名并不需要备案，只需要实名认证一下就可以了。实名认证的时间大约在1~2天，速度还是很快的。 购买域名 首先我们需要注册一个阿里云账户，在这里注册。可以使用支付宝账户登录。 注册完之后进行实名认证等工作。 依次选择产品-&gt;精选-&gt;域名注册，输入你想要的域名进行购买。（这里建议可以一次多买几年，因为之后再续费的话费用会变高） 在阿里云的控制台中选择域名进行管理。 一开始的话，域名的状态是未实名认证的，认证以下就可以了，过程就不赘述了。 域名绑定 域名实名认证之后就可以开始下面的操作了。 首先在本地的博客主目录下的source文件夹下创建CNAME文件（注意是大写，并且没有文件后缀名）。 将你注册的域名写入CNAME 在github上托管你的博客的仓库的setting中，找到github pages，在custom domain中填入的你域名。 进入阿里云控制台域名管理界面，点击解析。 添加两条记录。 其中要填入的记录值可以通过ping你的github耳机域名获得 1ping yourname.github.io 再次在本地将你的博客生成一遍，同步到github上之后就可以用你自己的域名访问啦。 基本命令 1234hexo clean 清空数据库和生成的静态网页文件hexo g 生成静态网站hexo s 本地预览网页情况（通过localhost:4000访问）hexo d 同步到github上 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"博客相关","slug":"博客相关","permalink":"http://zivblog.top/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://zivblog.top/tags/Tools/"}]},{"title":"hexo博客中添加图片","slug":"hexo博客中添加图片","date":"2019-04-01T02:09:41.000Z","updated":"2020-03-04T06:20:56.000Z","comments":true,"path":"passages/hexo-bo-ke-zhong-tian-jia-tu-pian/","link":"","permalink":"http://zivblog.top/passages/hexo-bo-ke-zhong-tian-jia-tu-pian/","excerpt":"本文使用的是安装插件的方式添加图片，需要其他方式的请另行百度。","text":"本文使用的是安装插件的方式添加图片，需要其他方式的请另行百度。 首先在主配置文件中将post_asset_folder设置为true。 修改设置之后每次用hexo n &quot;&quot;创建文件是都会生成一个同名的文件夹，你所有的相关资源都应该放在这里面。 接下来需要安装一个插件，使用npm install hexo-asset-image --save安装。 出现上述提示就表示安装好了，下面的warning可以不用在意。 插件位置 在文件中引用图片时使用![文件替代文字](文件夹名/图片名)即可。 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"博客相关","slug":"博客相关","permalink":"http://zivblog.top/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://zivblog.top/tags/Tools/"}]},{"title":"苏州大学2018年复试上机题","slug":"苏州大学2018年复试上机题","date":"2019-03-19T08:38:16.000Z","updated":"2020-03-04T07:18:56.000Z","comments":true,"path":"passages/su-zhou-da-xue-2018-nian-fu-shi-shang-ji-ti/","link":"","permalink":"http://zivblog.top/passages/su-zhou-da-xue-2018-nian-fu-shi-shang-ji-ti/","excerpt":"","text":"题目描述 读取文件中的20000个数字，求其最大子集 子集中的数字互不为倍数，互不为因数，最大公约数为1 不允许使用预设的排序函数qsort() 题目分析 从二进制文件中读取数据（wb，rb） 排序（任意，这里使用的是选择排序） 首先判断是否为素数，加入结果集 对于非素数的数字，求其与结果集中的各个数字是否最大公约数全为1，加入结果集 将结果集写入文件中 代码结构 void make_data() 生成数据集（1~500，排除3,5,7） void swap(int *a, int *b) 交换传入的两个整数 int compare(int a, int b) 比较两个整数的大小 int selection_sort(int *ptr) 选择排序 int is_prime(int n) 判断传入的数字是否为素数 int gcd(int a, int b) 求两个数的最大公约数 void filter_data(int *data, int *result) 筛选符合条件的数据 void display(int *ptr, int n) 输出传入的数据集 void output(int *result, int count) 将结果集输出到文件 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;// 数据文件路径#define DATA_PATH \"C://Users//Y//Desktop//data.dat\"// 输出文件路径#define OUTPUT_PATH \"C://Users//Y//Desktop//output.txt\"// 文件中共20000条数据#define N 20000// 文件中数据的值位于1~500之间#define MAX 500void make_data()&#123; /* 生成数据 */ // 申请数据空间 int *num = (int*)malloc(sizeof(int)*N); int i, n = 1; FILE *fp = fopen(DATA_PATH, \"wb\"); // 生成20000条数据 for(i = 0; i &lt; N; i++)&#123; if(n &gt; 500) n = 1; if(n == 3 || n == 5 || n == 7) n++; num[i] = n; // debug // printf(\"%d \", num[i]); n++; &#125; // printf(\"source:\\n\"); // display(num, N); // 将数据写入文件中 fwrite(num, sizeof(int), N, fp); free(num); fclose(fp);&#125;void swap(int *a, int *b)&#123; /* 交换传入的两个数字 */ int temp = *a; *a = *b; *b = temp;&#125;int compare(int a, int b)&#123; /* 比较传入的两个数字的大小 */ if(a &lt; b) return -1; if(a &gt; b) return 1; if(a == b) return 0;&#125;void selection_sort(int *ptr)&#123; /* 选择排序 */ int i, j; for(i = 0; i &lt; N; i++)&#123; for(j = i + 1; j &lt; N; j++) if(compare(ptr[i], ptr[j]) &gt; 0) swap(&amp;ptr[i], &amp;ptr[j]); &#125;&#125;int is_prime(int n)&#123; /* 判断传入的数字是否为素数 */ int i; if(n &lt; 2) return 0; for(i = 2; i*i &lt;= n; i++)&#123; if(n % i == 0) return 0; &#125; return 1;&#125;int gcd(int a, int b)&#123; /* 求两个数字的最大公约数 */ if(a % b == 0) return b; return gcd(b, a % b);&#125;int filter_data(int *data, int *result)&#123; /* 筛选数据 */ int result_count = 0; int i, j; for(i = 0; i &lt; N; i++)&#123; // printf(\"data[%d] = %d\\n\", i, data[i]); if(data[i] &lt; 2)&#123; continue; &#125; else if(is_prime(data[i]))&#123; // 素数，且未在结果集中 // printf(\"\\nis prime\\n\"); for(j = result_count - 1; j &gt;= 0; j--)&#123; if(data[i] == result[j]) break; &#125; if(j == -1) // debug // printf(\"result_count = %d\", result_count); result[result_count++] = data[i]; &#125; else&#123; // 是否与结果集最大公约均数为1 for(j = 0; j &lt; result_count; j++)&#123; if(gcd(data[i], result[j]) != 1) break; &#125; if(j == result_count) result[result_count++] = data[i]; &#125; &#125; return result_count;&#125;void display(const int *data, int count)&#123; /* 输出传入的整数集 */ int i; printf(\"\\n\"); for(i = 0; i &lt; count; i++)&#123; printf(\"%d \", data[i]); &#125;&#125;void output(const int *result, int result_count)&#123; /* 将结果集输出到文件中 */ int i; FILE *fp = fopen(OUTPUT_PATH, \"w\"); for(i = 0; i &lt; result_count; i++)&#123; // printf(\"%d \", result[i]); fprintf(fp, \"%d \", result[i]); &#125; fclose(fp);&#125;int main()&#123; int *data, *result; int result_count; FILE* fp; data = (int*)malloc(sizeof(int)*N); result = (int*)malloc(sizeof(int)*100); // 生成数据 make_data(); // 读取数据 fp = fopen(DATA_PATH, \"rb\"); fread(data, sizeof(int), N, fp); // 输出读取的数据 // printf(\"\\ndata: \\n\"); // display(data, N); // 排序 selection_sort(data); // 排序后的数据 // printf(\"\\nsort:\\n\"); // display(data, N); // 筛选数据，返回数据个数 result_count = filter_data(data, result); printf(\"\\nresult_count: %d\\n\", result_count); // 结果输出到文件 output(result, result_count); // 输出结果 display(result, result_count); free(result); free(data); fclose(fp); return 0;&#125; 欢迎来信交流||指教。","categories":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"}],"tags":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"},{"name":"c语言","slug":"c语言","permalink":"http://zivblog.top/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"ubuntu下安装docker","slug":"ubuntu下安装docker","date":"2019-03-16T07:59:52.000Z","updated":"2020-07-06T05:41:07.000Z","comments":true,"path":"passages/ubuntu-xia-an-zhuang-docker/","link":"","permalink":"http://zivblog.top/passages/ubuntu-xia-an-zhuang-docker/","excerpt":"ubuntu &amp; docker","text":"ubuntu &amp; docker ubuntu中安装的docker 系统版本ubuntu server 16.04 卸载可能存在的旧版本 1$ sudo apt-get remove docker docker-engine docker-ce docker.io 更新apt包索引 1$ sudo apt-get update 安装以下包使apt可以通过https使用存储库 1$ sudo apt-get install -y apt-transport-https ca-certificates curl software-properties-common 添加docker官方GPG密钥 1$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - 设置stable存储库 1$ sudo add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\" 更新apt索引包 1$ sudo apt-get update 安装最新版本的Docker CE 1$ apt-cache madison docker-ce 可安装列表 1$ apt-cache madison docker-ce 安装指定版本的docker 1$ sudo apt-get install docker-ce=&lt;VERSION&gt; docker基本命令 启动docker 1$ sudo systemctl start docker 查看docker 1$ systemctl status docker 关闭docker 1$ sudo systemctl stop docker 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"工具配置","slug":"工具配置","permalink":"http://zivblog.top/categories/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://zivblog.top/tags/Tools/"}]},{"title":"xshell连接虚拟机","slug":"xshell连接虚拟机","date":"2019-03-16T04:53:26.000Z","updated":"2020-07-06T05:42:55.000Z","comments":true,"path":"passages/xshell-lian-jie-xu-ni-ji/","link":"","permalink":"http://zivblog.top/passages/xshell-lian-jie-xu-ni-ji/","excerpt":"xshell","text":"xshell 查看虚拟机ip 1$ ipconfig 从这里下载xshell6。 启动xshell6，依次选择文件-&gt;新建，协议选择ssh，ip填入第一步查找到的ip，端口为22。 ubuntu中安装openssh 1sudo apt install openssh-server 安装openssh报错 1234567891011121314Reading package lists... DoneBuilding dependency tree Reading state information... DoneSome packages could not be installed. This may mean that you haverequested an impossible situation or if you are using the unstabledistribution that some required packages have not yet been createdor been moved out of Incoming.The following information may help to resolve the situation:The following packages have unmet dependencies: openssh-server : Depends: openssh-client (= 1:7.2p2-4ubuntu2.8) Depends: openssh-sftp-server but it is not going to be installed Recommends: ssh-import-id but it is not going to be installedE: Unable to correct problems, you have held broken packages. 需卸载掉默认安装的openssh-client（因版本较新，而openssh-server依赖的版本较旧）： 1sudo apt-get autoremove openssh-client 然后再重新安装它们： 1sudo apt-get install openssh-client openssh-server 启动sshd服务: 1sudo /etc/init.d/ssh start 查看ssh是否成功启动 1service sshd status 设置ssh开机自启动 1chkconfig sshd on 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"工具配置","slug":"工具配置","permalink":"http://zivblog.top/categories/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://zivblog.top/tags/Tools/"}]},{"title":"vs2010的简单使用","slug":"vs2010的简单使用","date":"2019-03-16T04:51:23.000Z","updated":"2020-03-04T06:43:36.000Z","comments":true,"path":"passages/vs2010-de-jian-dan-shi-yong/","link":"","permalink":"http://zivblog.top/passages/vs2010-de-jian-dan-shi-yong/","excerpt":"复试的上机要求使用vs2010编写c语言控制台程序。之前没有用过这款软件，与codeblocks还是有很大差异的，这里记录一些使用的方法，希望对后来人有帮助。 研究生复试的上机要求使用vs2010编写c语言控制台程序。之前没有用过这款软件，与codeblocks还是有很大差异的，这里记录一些使用的方法，希望对后来人有帮助。","text":"复试的上机要求使用vs2010编写c语言控制台程序。之前没有用过这款软件，与codeblocks还是有很大差异的，这里记录一些使用的方法，希望对后来人有帮助。 研究生复试的上机要求使用vs2010编写c语言控制台程序。之前没有用过这款软件，与codeblocks还是有很大差异的，这里记录一些使用的方法，希望对后来人有帮助。 创建项目 打开vs2010，在右上方菜单栏选择文件-&gt;新建-&gt;项目。 选择win32控制台应用程序，填写项目名称，文件存储位置。 在应用程序向导中注意应用程序类型选择控制台应用程序，附加选项勾选空项目，取消勾选预编译头。 添加源文件 在项目文件夹中源文件文件夹上选择添加-&gt;新建项。 选择c++文件，填写文件名即可。 生成程序 编写完代码后，点击上方工具栏中的生成-&gt;编译完成编译工作。 编译完成后在菜单栏选择项目-&gt;仅用于项目-&gt;仅链接“项目名”完成链接工作。 可在文件夹中点击文件名.exe执行，也可以直接使用F5运行。 调试 找到一个位置，右键-&gt;断点-&gt;插入断点。 按F5运行程序，程序会运行到断点位置，软件面板下方看到当前变量 的值 按ctrl + F11快捷键，程序会单步执行，下方显示变量的当前值 在调试过程中鼠标悬停在变量上可以查看变量当前的值 选中变量可以添加监视，在下方监视中查看 关于安全周期检测 使用scanf和printf，在编译时会提醒该方法不安全，需要使用scanf_s 在项目文件夹上右键属性-&gt;配置属性-&gt;C\\C++-&gt;预处理器-&gt;右侧下拉菜单中点击编辑-&gt;添加——CRT_SECURE_NO_DEPRECATE 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"工具配置","slug":"工具配置","permalink":"http://zivblog.top/categories/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://zivblog.top/tags/Tools/"}]},{"title":"ubuntu修改软件源","slug":"ubuntu修改软件源","date":"2019-03-16T04:49:26.000Z","updated":"2020-07-06T05:41:44.000Z","comments":true,"path":"passages/ubuntu-xiu-gai-ruan-jian-yuan/","link":"","permalink":"http://zivblog.top/passages/ubuntu-xiu-gai-ruan-jian-yuan/","excerpt":"ubuntu软件源","text":"ubuntu软件源 图形界面下 在设置中的”软件和更新“中 修改Download from为Other 在弹出框汇中选择China 选择mirrors.aliyun.com 点击 Choose Server 非图形界面下 备份/etc/apt/sources.listcp /etc/apt/sources.list /etc/apt/souces.list.bak 修改文件内容sudo gedit /etc/apt/sources.list修改为： 123456789101112deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial main restricted universe multiverse deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-security main restricted universe multiverse deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-updates main restricted universe multiverse deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-backports main restricted universe multiverse ##测试版源 deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-proposed main restricted universe multiverse # 源码 deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial main restricted universe multiverse deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-security main restricted universe multiverse deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-updates main restricted universe multiverse deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-backports main restricted universe multiverse ##测试版源 deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-proposed main restricted universe multiverse # Canonical 合作伙伴和附加 deb http:&#x2F;&#x2F;archive.canonical.com&#x2F;ubuntu&#x2F; xenial partner deb http:&#x2F;&#x2F;extras.ubuntu.com&#x2F;ubuntu&#x2F; xenial main 保存 退出 运行sudo apt update使更新生效 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"工具配置","slug":"工具配置","permalink":"http://zivblog.top/categories/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://zivblog.top/tags/Tools/"}]},{"title":"win7下安装ubuntu双系统","slug":"win7下安装ubuntu双系统","date":"2019-03-16T01:21:24.000Z","updated":"2020-07-06T05:42:11.000Z","comments":true,"path":"passages/win7-xia-an-zhuang-ubuntu-shuang-xi-tong/","link":"","permalink":"http://zivblog.top/passages/win7-xia-an-zhuang-ubuntu-shuang-xi-tong/","excerpt":"windows &amp; ubuntu","text":"windows &amp; ubuntu 工具： ubuntu16.04 64位 easyBCD UltraISO 步骤： 在硬盘上划分区域 我的电脑-&gt;右键-&gt;管理-&gt;磁盘管理 选择较大的盘符-&gt;右键-&gt;压缩卷-&gt;选择压缩的大小（用于安装系统的磁盘） 制作启动盘： 格式化u盘，注意选择fat32格式 打开UltraISO软件 选择ubuntu16.04镜像 点击启动-&gt;写入硬盘镜像 写入方式为usb-HDD+ 点击便捷启动-&gt;写入新的驱动器引导扇区-&gt;Syslinux 点击写入，等待文件拷贝完成 安装系统 将系统启动盘插在电脑上 重启电脑，进入启动项选择，选择U盘启动 进入安装界面-&gt;选择中文或英文-&gt;点击安装Ubuntu 准备界面，可以联网安装，也可以安装完成后手动更I型呢 安装类型-&gt;选择其他选项 分区设置-&gt;选中刚才分好的空闲分区（可能不是“空闲“，点击“-”即可） 新建分区-&gt;点击”+“-&gt;”用于“设置成交换空间，分区类型-&gt;逻辑分区（小于物理机内存即可，例如8000M）, 新建分区-&gt;点击”+“-&gt;设置ubuntu的启动引导分区（200M差不多就够了），用于Ext4日志文件系统，挂载点/boot 新建分区-&gt;设置”/“主分区，相当于Win7的系统C盘,同样的方法,将剩余空间设置“/home”分区,用于存在文件。 点击”继续“-&gt;”继续“-&gt;安装 easyBCD修改系统启动项 添加新引导-&gt;选择linux-&gt;Drive选择刚才设置的/boot分区 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"工具配置","slug":"工具配置","permalink":"http://zivblog.top/categories/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://zivblog.top/tags/Tools/"}]},{"title":"centos6下升级内核并安装docker","slug":"centos6下内核升级及docker安装","date":"2019-03-14T02:48:48.000Z","updated":"2020-03-04T06:11:21.000Z","comments":true,"path":"passages/centos6-xia-nei-he-sheng-ji-ji-docker-an-zhuang/","link":"","permalink":"http://zivblog.top/passages/centos6-xia-nei-he-sheng-ji-ji-docker-an-zhuang/","excerpt":"centos内核升级及docker安装","text":"centos内核升级及docker安装 升级内核 查看系统版本 1cat /etc/issue 查看内核版本 1uname -r 导入public key 1rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org 安装ml内核（主线最新版本） 1yum --enablerepo=elrepo-kernel -y install kernel-ml 安装lt内核（长期支持版本） 1yum --enablerepo=elrepo-kernel -y install kernel-lt 以上两个版本二选一即可 修改主配置文件 123vim &#x2F;etc&#x2F;grub,conf将default&#x3D;1改为default&#x3D;0 重启系统即可 导入public key时若报错 error: https://www.elrepo.org/RPM-GPG-KEY-elrepo.org: import read failed(2). 使用yum -y update nss即可 安装docker 使用yum install docker-io安装 报错 12No package docker-io available.Error: Nothing to do yum install docker-io，这句话是用源安装docker，可是源一般是国外源，用这个命令因为GFW被墙，根本安装不了。 使用以下命令安装即可 1yum install https:&#x2F;&#x2F;get.docker.com&#x2F;rpm&#x2F;1.7.1&#x2F;centos-6&#x2F;RPMS&#x2F;x86_64&#x2F;docker-engine-1.7.1-1.el6.x86_64.rpm 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"工具配置","slug":"工具配置","permalink":"http://zivblog.top/categories/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://zivblog.top/tags/Tools/"}]},{"title":"苏州大学2013年复试上机题","slug":"苏州大学2013年复试上机题","date":"2019-03-13T12:39:43.000Z","updated":"2020-03-04T07:07:32.000Z","comments":true,"path":"passages/su-zhou-da-xue-2013-nian-fu-shi-shang-ji-ti/","link":"","permalink":"http://zivblog.top/passages/su-zhou-da-xue-2013-nian-fu-shi-shang-ji-ti/","excerpt":"","text":"题目描述 从一个文件中读取航班信息，从另一个文件中读取航班路径请求，并输出需要的信息。 判断一个特定的机场能否经过指定次数的跳数到达指定机场。一次跳跃是指从始发机场到目的地之间的一次任意两个机场之间的航行 例如：PVG到PEK是PVG-&gt;CAN-&gt;PEK。所以PVG-&gt;CAN是一跳，CAN-&gt;PEK也是一跳。 路径输入文件PathInput_2013.txt，文件包含多对始发点与终点的序列，文件第一行有一个数字，表示有多少个数据对。 12345676[PVG, CAN][CAN, PEK][PVG, CTU][CTU, DLC][DLC, HAK][HAK, LXA] 路径请求文件PathRequest_2013.txt，文件中包含一系列序列[起始点，终点]及最大跳数，第一行是一个数字，表示有多少个序列。 1232[PVG, DLC, 2][PVG, LXA, 2] 输出文件Output.txt，对于请求文件中的每个请求，输出请求并在其后跟YES或NO,表示是否能在指定跳数之内完成请求。 每个机场名均为三个大写字母，任意[起始/终点]对之间均是单向的。 题目分析 使用图解决问题 图使用邻接表存储图 根据Pathinput.txt中的序列建立邻接表 使用深度优先遍历判断图中初始点和终点之间是否有同路且跳数是否符合要求 代码结构 struct Edge：边结点 struct Vertex：顶点 struct Graph：图 int find(Vertex* vertices, int count, char src[4])：从顶点表中查找指定的结点，并返回下标 void add_edge(Graph* g, char src[4], char dst[4])：构造邻接表 bool is_possible(Graph* g, bool* visited, char src[4], char dst[4],int step)： 判断两个点之间是否可达 深度优先遍历 void destruct(Graph* g)：释放邻接表 void display(Graph* g)：输出图 int main()： 打开文件 读取PathInput.txt文件 读取PathRequest.txt文件 判断是否满足 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219#include&lt;math.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;time.h&gt;#include&lt;stdbool.h&gt;// 邻接表数据结构typedef struct Edge&#123; // 边结点 int index; char city[4]; struct Edge* next;&#125;Edge;typedef struct&#123; // 顶点 char city[4]; Edge* first;&#125;Vertex;typedef struct&#123; // 图中的结点 int size; int capacity; Vertex* vertices;&#125;Graph;int find(Vertex* vertices, int count, char src[4])&#123; // 从顶点表中查找指定的结点，并返回下标 int i; for(i = 0; i &lt; count; i++) if(strcmp(src, vertices[i].city) == 0) break; return i;&#125;void add_edge(Graph* g, char src[4], char dst[4])&#123; /* */ int i, j; Edge* e; // 添加起始点 i = find(g-&gt;vertices, g-&gt;size, src); if(i == g-&gt;size)&#123; strcpy(g-&gt;vertices[g-&gt;size].city, src); g-&gt;vertices[g-&gt;size].first = NULL; g-&gt;size++; &#125; // 添加终点 j = find(g-&gt;vertices, g-&gt;size, dst); if(j == g-&gt;size)&#123; strcpy(g-&gt;vertices[g-&gt;size].city, dst); g-&gt;vertices[g-&gt;size].first = NULL; g-&gt;size; &#125; // 查找终点 for(e = g-&gt;vertices[i].first; e != NULL; e = e-&gt;next)&#123; if(strcmp(e-&gt;city, dst) == 0) break; &#125; // 图中未发现终点，将其添加到图的首部 if(e == NULL)&#123; e = (Edge*)malloc(sizeof(Edge)); strcpy(e-&gt;city, dst); e-&gt;index = j; e-&gt;next = g-&gt;vertices[i].first; g-&gt;vertices[i].first = e; &#125;&#125;bool is_possible(Graph* g, bool* visited, char src[], char dst[], int step)&#123; /* 判断两个节点之间是否可达 深度优先遍历 */ int current; Edge* e; // 在图中查找起始点 current = find(g-&gt;vertices, g-&gt;size, src); // 已经被访问过或 if(step == 0 || visited[current]) return false; else&#123; visited[current] = true; for(e = g-&gt;vertices[current].first; e != NULL; e = e-&gt;next)&#123; // 以起始点直接可达的点钟是否有终点 if(strcmp(e-&gt;city, dst) == 0 &amp;&amp; step == 1) return true; // 递归 else if(is_possible(g, visited, e-&gt;city, dst, step - 1)) return true; &#125; visited[current] = false; &#125; return false;&#125;void destruct(Graph* g)&#123; /* 释放图的内存空间 按行消除 */ int i; for(i = 0; i &lt; g-&gt;size; i++)&#123; while(g-&gt;vertices[i].first != NULL)&#123; Edge* e = g-&gt;vertices[i].first-&gt;next; free(g-&gt;vertices[i].first); g-&gt;vertices[i].first = e; &#125; &#125; free(g-&gt;vertices);&#125;void display(Graph* g)&#123; int i; Edge* edge; // 邻接列表 printf(\"adjacency list:\\n\"); for(i = 0; i &lt; g-&gt;size; i++)&#123; printf(\"%s: \", g-&gt;vertices[i].city); for(edge = g-&gt;vertices[i].first; edge != NULL; edge = edge-&gt;next) printf(\"%s \", edge-&gt;city); printf(\"\\n\"); &#125; printf(\"\\n\");&#125;int main()&#123; FILE* fpi = fopen(\"PathInput_2013.txt\", \"r\"); FILE* fpr = fopen(\"PathRequest_2013.txt\", \"r\"); FILE* fpo = fopen(\"Output_2013.txt\", \"w\"); char line[16]; char src[4]; char dst[4]; bool* visited; // 访问标识 int step; int num; Graph g; // 三个文件均被成功打开 if(!fpi || !fpr || !fpo)&#123; printf(\"failed to open files.\\n\"); exit(-1); &#125; // 全部初试化为0 memset(line, 0, sizeof(line)); // 从文件中读取第一行的数字 if(fgets(line, sizeof(line), fpi) != NULL)&#123; g.size = 0; // 将字符串转化成int g.capacity = atoi(line) * 2; g.vertices = (Vertex*)malloc(g.capacity * sizeof(Vertex)); memset(g.vertices, 0, g.capacity); &#125; // 读取序列并用邻接表 while(fgets(line, sizeof(line), fpi) != NULL)&#123; // 读取起始点 memcpy(src, line + 1, 3); src[3] = '\\0'; // 读取终点 memcpy(dst, line + 6, 3); dst[3] = '\\0'; // 添加边 add_edge(&amp;g, src, dst); &#125; display(&amp;g); // 输出航班信息 printf(\"flight info:\\n\"); visited = (bool*)malloc(g.size); if(fgets(line, sizeof(line), fpr) != NULL) num = atoi(line); // 读取请求文件 while(fgets(line, sizeof(line), fpr) != NULL)&#123; memcpy(src, line + 1, 3); src[3] = '\\0'; memcpy(dst, line + 6, 3); dst[3] = '\\0'; step = line[11] - '0'; memset(visited, false, g.size); // 判断是否可行 if(is_possible(&amp;g, visited, src, dst, step))&#123; printf(\"[%s, %s, %d, YES]\\n\", src, dst, step); fprintf(fpo, \"[%s, %s, YES]\\n\", src, dst); &#125;else&#123; printf(\"[%s, %s, %d, NO]\\n\", src, dst, step); fprintf(fpo, \"[%s, %s, NO]\\n\", src, dst); &#125; &#125; //释放内存和关闭文件 destruct(&amp;g); free(visited); fclose(fpi); fclose(fpr); fclose(fpo);&#125; 欢迎来信交流||指教。","categories":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"}],"tags":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"},{"name":"c语言","slug":"c语言","permalink":"http://zivblog.top/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"苏州大学2017年保研上机题","slug":"苏州大学2017年保研上机题","date":"2019-03-13T07:36:11.000Z","updated":"2020-03-04T07:17:37.000Z","comments":true,"path":"passages/su-zhou-da-xue-2017-nian-bao-yan-shang-ji-ti/","link":"","permalink":"http://zivblog.top/passages/su-zhou-da-xue-2017-nian-bao-yan-shang-ji-ti/","excerpt":"","text":"题目描述 文本文件input.txt里面放了一堆整数，仅仅以空格分割，其中第一个整数为k，第二个整数代表维度，剩余的整数作为点的坐标。 读取整数k和维度，并读取剩余的整数组成指定维度的点。 从所有点钟找到距离最近的两个点并输出它们的坐标和距离。 分别输出距离这两个点最近的k个点的坐标。 题目分析 先读取文件中的前两个数，第一个k，第二个是dimension，后面每dimension个数字组成一个点 循环计算距离最近的两个点，输出这两个点及其距离 对这两个点分别计算所有点到其距离，输出最近的k个 一开始点的维数未知，故点的结构体中使用指针存储坐标，每读取一个点申请一个整形的空间 代码结构 struct Point：坐标点的结构体 double distance(Point* a,Point* b)：计算两个点之间的距离 void swap(Point* a, Point* b)：交换传入的两个坐标点 int compare(Point* a, Point* b)：比较传入的两个点与指定点之间的距离 void selection_sort(Point* points, int begin, int end)：选择排序 void sorted_by_distance(Point* points, int begin, int end, int pivot)：根据与指定点知道见的距离排序 void display_point(Point* p)：显示一个点 void display_all(Point* points, int count)：显示所有点 display_nearest(Point* points, int count, int pivot, int k)：显示离指定点最近的k个点 int main()： 统计文件中的整数个数 读取前两个数字 按照维度读取每个坐标点 双循环查找最近的两个坐标点 查找并输出离这两个点最近的k个点 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;float.h&gt;typedef struct&#123; int* vector; // 坐标维度未知，使用指针 int dimension; // 坐标维度&#125;Point;Point point;double distance(Point* a, Point* b)&#123; /* 求传入的两个点之间的距离 fabs(), 求浮点数的绝对值 pow(x, y),求x的y次方 sqrt(),开根号 */ double dist = 0.0; int i; for(i = 0; i &lt; a-&gt;dimension; i++)&#123; dist += pow(fabs(a-&gt;vector[i] - b-&gt;vector[i])*1.0, 2); &#125; return sqrt(dist);&#125;void swap(Point* a, Point* b)&#123; /* 交换传入的两个点 */ Point temp = *a; *a = *b; *b = temp;&#125;int compare(Point* a, Point* b)&#123; /* 比较传入的两点浴指定点之间的距离 */ double dista = distance(a, &amp;point); double distb = distance(b, &amp;point); if(dista &lt; distb) return -1; if(dista &gt; distb) return 1; if(dista == distb) return 0;&#125;void selection_sort(Point* points, int begin, int end)&#123; /* 根据与指定点之间的距离选择排序 */ int i, j; for(i = begin; i &lt; end; i++)&#123; for(j = i+1; j &lt; end; j++) if(compare(&amp;points[i], &amp;points[j]) &gt; 0) swap(&amp;points[i], &amp;points[j]); &#125;&#125;void sorted_by_distance(Point* points, int begin, int end, int pivot)&#123; point = points[pivot]; selection_sort(points, begin, end);&#125;void display_point(Point* p)&#123; /* 输出一个点 */ int j; printf(\"(\"); for(j = 0; j &lt; p-&gt;dimension - 1; j++)&#123; printf(\"%2d, \", p-&gt;vector[j]); &#125; printf(\"%2d)\", p-&gt;vector[p-&gt;dimension-1]);&#125;void display_all(Point* points, int count)&#123; /* 输出所有点 */ int i; for(i = 0; i &lt; count; i++) display_point(&amp;points[i]); printf(\"\\n\");&#125;void display_nearest(Point* points, int count, int pivot, int k)&#123; /* 输出离指定点最近的k个点 */ // 排序 int i; sorted_by_distance(points, 0, count, pivot); printf(\"the nearest %d points to \", k); display_point(&amp;points[0]); printf(\"\\n\"); for(i = 1; i &lt;= k; i++) display_point(&amp;points[i]); printf(\"\\n\");&#125;int main()&#123; FILE* fp = fopen(\"input_2017bao.txt\", \"r\"); Point* points; int k, dimension, val, count, point_count; int i, j; // 统计文件中国的数字个数 count = 0; while(fscanf(fp, \"%s\", &amp;val) != EOF) count++; rewind(fp); // 读取k和维度 fscanf(fp, \"%d\", &amp;k); fscanf(fp, \"%d\", &amp;dimension); printf(\"k = %d\\ndimension = %d\\n\", k, dimension); // 计算点的个数 point_count = (count - 2) / dimension; // 申请存储空间 points = (Point*)malloc(sizeof(Point) * point_count); for(i = 0; i &lt; point_count; i++)&#123; points[i].dimension = dimension; // 申请一个点的存储空间 points[i].vector = (int*)malloc(sizeof(int*)*dimension); for(j = 0; j &lt; dimension; j++) fscanf(fp, \"%d\", &amp;points[i].vector[j]); &#125; // 显示所有点 display_all(points, point_count); int lhs, rhs, pivot; double min = distance(&amp;points[0], &amp;points[1]); for(pivot = 0; pivot &lt; point_count - 1; pivot++)&#123; sorted_by_distance(points, pivot + 1, point_count, pivot); if(distance(&amp;points[pivot], &amp;points[pivot+1]) &lt; min)&#123; lhs = pivot; rhs = pivot + 1; min = distance(&amp;points[pivot], &amp;points[pivot + 1]); &#125; &#125; printf(\"the shortest distance: %f\\n\", min); printf(\"the nearest two points:\\n\"); display_point(&amp;points[lhs]); display_point(&amp;points[rhs]); printf(\"\\n\"); display_nearest(points, point_count, lhs, k); display_nearest(points, point_count, 1, k); fclose(fp);&#125; 欢迎来信交流||指教。","categories":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"}],"tags":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"},{"name":"c语言","slug":"c语言","permalink":"http://zivblog.top/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"苏州大学2016年保研上机题","slug":"苏州大学2016年保研上机题","date":"2019-03-10T08:48:01.000Z","updated":"2020-03-06T10:50:58.000Z","comments":true,"path":"passages/su-zhou-da-xue-2016-nian-bao-yan-shang-ji-ti/","link":"","permalink":"http://zivblog.top/passages/su-zhou-da-xue-2016-nian-bao-yan-shang-ji-ti/","excerpt":"","text":"题目描述 从服务器上将两个数据文件input.txt和words.txt下载到本地电脑根文件夹。 在words.txt中存储了不超过30000条的英文单词，每个单词占一行。单词最大长度为20，且单词内没有空格，文件中无重复单词。 input.txt中存储了一个丢失了空格和标点符号的英文文章。每行不超过128`个字符，请将第一行和最后一行显示在屏幕上。 将words.txt中的最后三行显示在屏幕上。 利用words.txt中的单词作为字典，采用正向最大匹配切分单词算法（从左往右匹配，尽量取长词）对input.txt中的文本进行单词切分。且粉饰注意单词大小写，切分分割标记采用空格，将切分后的结果写入到out.txt中。 正想最大匹配切分算法（例）：有待切分字符串abcdefg，单词最大长度为5，则先判断abcde是否为单词，若不是则舍弃最后一个字母接着判断，即判断abcd是否为单词；只有一个字母时可直接认定是单词。 给定主函数为： 123456789101112131415161718int main()&#123; char words[SIZE][24]; clock_t start, finish; // 计算程序使用的时间 start = clock(); showFirstAndLastLine(\"input_2016b.txt\"); //将input文件的第一行和最后一行显示在屏幕上 int count = ReadWords(\"words_2016b.txt\", words); //读取英文字典，并返回单词数量 showTheLastThreeLines(count, words); //此处可以添加处理逻辑以实现题目的第3点要求 //建议将需要的功能实现为多个函数后在此直接或者间接调用 maxMatch(words, count, \"input_2016b.txt\", \"output_2016b.txt\"); finish = clock(); printf(\"Total time:%lf\\n\", (double)(finish - start) / CLOCKS_PER_SEC);&#125; 不允许修改主函数内容，不允许使用以下头文件之外的头文件 1234#include &lt;time.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt; 题目分析 问题3：文件中单词之间没有分隔符，可直接使用fgets(字符数组，长度，文件指针)按行读取读取并输出。 问题4：文件中单词按行存储，可使用格式化读取fscanf(文件指针，格式，字符数组)的方式读取到一个单词数组中，输出最后三行（即最后三个单词）。 使用qsort()对单词数组进行排序，使用bsearch()在指定数组中查询单词是否存在 代码结构 void showFirstAndLastLine(const char filename[])： 输出input.txt文件中第一行和第三行的内容 int ReadWords(const char filename[], char Words[SIZE][24]) 读取words.txt中的单词 void showTheLastThreeLines(int count, char Words[SIZE][24]) 输出words.txt中最后三行的内容（即最后三个单词） int compare(const void* a, const void* b) 比较传入的两个字符 void maxMatch(char Words[SIZE][24], int count, const char input[], const char output[])： 获取单词整箱最大匹配 int main() 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;time.h&gt;#define SIZE 30000void showFirstAndLastLine(char filename[])&#123; /* 输出input.txt中的第一行和最后一行的内容 */ FILE* fp = fopen(filename, \"r\"); char buf[128]; char temp[128]; // 输出第一行的内容 if(fgets(buf, 128, fp) != NULL)&#123; printf(\"%s\\n\", buf); &#125; // 输出最后一行的内容 while((fgets(temp, 128, fp) != NULL)) strcpy(buf, temp); fclose(fp); printf(\"%s\\n\", buf);&#125;int ReadWords(const char filename[], char words[SIZE][24])&#123; /* 读取word.txt的内容 */ int count = 0; char buf[24]; FILE* fp = fopen(filename, \"r\"); while(fscanf(fp, \"%s\", buf) != EOF) strcpy(words[count++], buf); fclose(fp); return count;&#125;void showTheLastThreeLines(count, words)&#123; /* 输出最后的word.txt的三行 */ int i = 1; while(i &lt;= 3)&#123; printf(\"%s\\n\", words[count - i]); i ++; &#125;&#125;int compare(const void* a, const coid* b)&#123; // 顺序比较两个字符串 return strcmp((char*)a, (char*)b);&#125;void maxMatch(char words[SIZE][24], int count, const char input[], const char output[])&#123; char buf[128]; char substr[128]; char *result; int i; int begin, length; // 打开文件 FILE* fin = fopen(input, \"r\"); FILE* fout = fopen(output, \"w\"); // 对words进行升序排序 qsort(words, count, sizeof(words[0]), compare); // 读取文件内容 while(fscanf(fin, \"%s\", buf) != EOF)&#123; begin = 0; length = strlen(buf); while(begin != length)&#123; // 将buf+begin中的20个字符复制到substr中 memcpy(substr, buf+begin, 20); for(i = 20; i &gt; 0; i--)&#123; substr[i] = '\\0'; // 从大到小，按个数在words中找substr if(bsearch(substr, words, count, sizeof(substr), compare)) break; &#125; // 输出到文件 fprintf(fout, \"%s\", substr); // 指针后移 begin += strlen(substr); &#125; fprintf(fout, \"\\n\"); &#125; fclose(fin); fclose(fout);&#125;int main()&#123; char words[SIZE][24]; clock_t start, finish; start = clock(); showFirstAndLastLine(\"input_2016b.txt\"); //将input文件的第一行和最后一行显示在屏幕上 int count = ReadWords(\"words_2016b.txt\", words); //读取英文字典，并返回单词数量 showTheLastThreeLines(count, words); //此处可以添加处理逻辑以实现题目的第3点要求 //建议将需要的功能实现为多个函数后在此直接或者间接调用 maxMatch(words, count, \"input_2016b.txt\", \"output_2016b.txt\"); finish = clock(); printf(\"Total time:%lf\\n\", (double)(finish - start) / CLOCKS_PER_SEC);&#125; 欢迎来信交流||指教。","categories":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"}],"tags":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"},{"name":"c语言","slug":"c语言","permalink":"http://zivblog.top/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"苏州大学2017年复试上机题","slug":"苏州大学2017年复试上机题","date":"2019-03-09T15:21:53.000Z","updated":"2020-03-04T07:18:22.000Z","comments":true,"path":"passages/su-zhou-da-xue-2017-nian-fu-shi-shang-ji-ti/","link":"","permalink":"http://zivblog.top/passages/su-zhou-da-xue-2017-nian-fu-shi-shang-ji-ti/","excerpt":"","text":"题目描述 二进制数据文件data.bin中存放了若干整数，编写程序： 读取所有数据。 每相邻的两个整数为一对坐标，构成二维平面上的坐标点 以每个坐标点为圆心，以该点与其后面第一个点的欧氏距离为半径r，计算每个圆包含的坐标点数，计算最后一个点时以其和第一个点的欧式距离为半径。 计算所有圆的点密度值，输出密度值最大的5个坐标点，以及院中包含的点数和点密度值 坐标点 包含点数 点密度 (x坐标, y坐标) (占5列, 右对齐) (占7列, 右对齐, 保留2位小数) 圆的点密度为：圆包含的点除以圆面积，在圆上也包含该点，$\\pi = 3.14$ 题目分析 二进制文件读取时用fread(data, sizeof(int), count, fp)函数每四位读做一个整数 每两个整数为一个坐标 定义结构体存储坐标和密度值 利用文件位置标记计算文件中的整数个数，申请整数数组、坐标数组的空间 按密度值按降序排序 代码结构 struct Coordinate 坐标点结构体 struct Circle 圆结构体 包含：圆心坐标、半径、圆中点的个数、点密度 static int compare(const Circle* a, const Circle* b) 比较传入的圆的点密度 static void swap(Circle* a, Circle* b) 交换传入的两个圆的位置 void selection_sort(Circle *ptr, int count) 跟据圆的点密度进行选择排序 int read_file(const char* filename, const char* mode, int* data) 根据文件中的点的个数申请空间 读取文件内容 double distance(Coordinate* a, Coordinate* b) 计算两个点之间的距离 double area(Circle* a) 计算圆的面积 void display(Circle* circles, int count) 输出圆的圆心坐标，圆中包含的点的个数，点密度 int create_circles(int * data, int coune, Circle* circles) 初始化圆的信息，包括圆心坐标、圆中点的个数、点密度 int main() 读取文件 输出坐标点 计算圆的相关属性 按照点密度排序 输出点密度最高的5个 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;time.h&gt;#include&lt;time.h&gt;#define PI 3.14typedef struct&#123; int x; int y;&#125;Coordinate;typedef struct&#123; double r; // 半径 Coordinate point; // 坐标 int points_num; // 范围内坐标点个数 double density; // 圆密度&#125;Circle;static int compare(const Circle* a, const Circle* b)&#123; /* 比较传入的圆的圆密度 */ if(a-&gt;density &gt; b-&gt;density) return -1; else if(a-&gt;density &lt; b-&gt;density) return 1; else return 0;&#125;static void swap(Circle* a, Circle* b)&#123; /* 交换传入的两个圆 */ Circle temp = *a; *a = *b; *b = temp;&#125;void selection_sort(Circle *ptr, int count)&#123; /* 根据圆密度进行选择排序 */ int i, j; for(i = 0; i &lt; count; i++)&#123; for(j = i + 1; j &lt; count; j++) if(compare(&amp;ptr[i], &amp;ptr[j]) &gt; 0) swap(&amp;ptr[i], &amp;ptr[j]); &#125;&#125;int read_file(const char* filename, const char* mode, int* data)&#123; /* 读取文件 */ FILE* fp = fopen(filename, mode); int count = 0; if(!fp)&#123; printf(\"failes to open file.\\n\"); exit(0); &#125; // 计算文件中的整数个数，申请内存空间 fseek(fp, 0, SEEK_END); count = ftell(fp) / sizeof(int); data = (int*)malloc(sizeof(int)*count); rewind(fp); fread(data, sizeof(int), count, fp); fclose(fp); return count;&#125;double distance(Coordinate* a, Coordinate* b)&#123; /* 计算两个坐标之间的距离 */ int val; val = (a-&gt;x - b-&gt;x) * (a-&gt;x - b-&gt;x) + (a-&gt;y - b-&gt;y) * (a-&gt;y - b-&gt;y); return sqrt((double)val);&#125;double area(Circle* c)&#123; // 计算圆的面积 return (c-&gt;r * c-&gt;r) *PI;&#125;void display(Circle* circles, int count)&#123; /* 输出传入的圆 */ int i; for(i = 0; i &lt; count; i++)&#123; printf(\"(%d, %d) %5d %7.2f\\n\", circles[i].point.x, circles[i].point.y, circles[i].points_num, circles[i].density); &#125;&#125;int create_circles(int* data, int count, Circle* circles)&#123; int circles_num = count - 1; int i, j; // 申请存储圆的数组空间 circles = (Circle*)malloc(sizeof(Circle) * circles_num); // 初始化圆数组 for(i = 0; i &lt; circles_num; i++)&#123; circles[i].point.x = data[i]; circles[i].point.y = data[i + 1]; circles[i].points_num = 0; &#125; // 计算圆的半径（与后面点之间的距离为r） for(i = 0; i &lt; circles_num; i++)&#123; circles[i].r = distance(&amp;circles[i].point, &amp;circles[(i+1)%circles_num].point); &#125; // 统计在圆内的点的个数（与该点之间距离小于半径） for(i = 0; i &lt; circles_num; i++)&#123; for(j = 0; j &lt; circles_num; j++)&#123; if(distance(&amp;circles[i].point, &amp;circles[j].point) &lt;= circles[i].r) circles[i].points_num++; &#125; &#125; // 计算圆的圆密度 for(i = 0; i &lt; circles_num; i++)&#123; circles[i].density = circles[i].points_num / area(&amp;circles[i]); &#125; return circles_num;&#125;int main()&#123; int *data = NULL; int count = 0; int circles_num = 0; int i; Circle* circles = NULL; // 读取文件，返回圆的个数 count = read_file(\"data_2017.bin\", \"rb\", data); printf(\"data:\\n\"); // 输出坐标点 for(i = 0; i &lt; count; i++)&#123; printf(\"%d \", data[i]); &#125; printf(\"\\n\"); // 计算圆的半径，圆中的坐标点个数，圆密度 circles_num = create_circles(data, count, circles); // 按圆密度排序 selection_sort(circles, circles_num); printf(\"result:\\n\"); // 输出密度最高的前五个 display(circles, 5);&#125; 欢迎来信交流||指教。","categories":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"}],"tags":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"},{"name":"c语言","slug":"c语言","permalink":"http://zivblog.top/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"苏州大学2016年复试上机题","slug":"苏州大学2016年复试上机题","date":"2019-03-08T09:16:40.000Z","updated":"2020-03-04T07:16:23.000Z","comments":true,"path":"passages/su-zhou-da-xue-2016-nian-fu-shi-shang-ji-ti/","link":"","permalink":"http://zivblog.top/passages/su-zhou-da-xue-2016-nian-fu-shi-shang-ji-ti/","excerpt":"","text":"题目描述 文本文件input.txt由若干英文单词和分隔符（空格、回车、换行）组成，根据如下说明编写程序统计不同单词出现的次数（频度）。将统计结果按出现频度从高到低排序，并将出现频度大于5的单词及其频度输出到文件output.txt中。 文件格式单词,次数，每个单词占一行 多个连续分隔符被视为一个分隔符 大小写敏感，即大小写不同的为两个单词 每个单词长度不超过20个字符 单词的数量未知，使用静态大数组将扣5分 题目分析 不允许使用静态大数组，先读取一遍文件，统计单词个数；或者每发现一个新单词，动态申请空间 分割符不用处理，使用以下函数按单词读取 1fscanf(fp, &quot;%s&quot;, buf); 定义结构体，存储单词及其频度 根据频度降序排序 代码结构 struct Word： 单词，频度结构体 int compare(const Word* lhs, const Word* rhs)： 比较传入的两个字符的出现次数 void swap(Word* a, Word* b)： 交换传入的两个字母的顺序 void insertion_sort(Word* ptr, int count) 插入排序 int find(Word* words, int count, char* str) 在words中查找str，并返回下标 若没有则返回数组的长度 int main()： 打开文件 统计文件中的单词个数 申请存储空间 读取文件内容，并统计相同单词的个数 按单词的出现频度排序 输出单词及其频度，并输出到文件 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;math.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;typedef struct&#123; int freq; char str[20];&#125;Word;int compare(const Word* lhs, const Word* rhs)&#123; /* 比较传入的两个字符的出现次数 */ if(lhs-&gt;freq &gt; rhs-&gt;freq) return -1; else if(lhs-&gt;freq &lt; rhs-&gt;freq) return 1; else return 0;&#125;void swap(Word* a, Word* b)&#123; /* 交换传入的两个字母的顺序 */ Word temp = *a; *a = *b; *b = temp;&#125;void insertion_sort(Word* ptr, int count)&#123; /* 插入排序 */ int i, j; for(i = 1; i &lt; count; i++)&#123; j = i; Word ref = ptr[i]; while(j &gt; 0 &amp;&amp; compare(&amp;ptr[j - 1], &amp;ref) &gt; 0)&#123; ptr[j] = ptr[j - 1]; j --; &#125; ptr[j] = ref; &#125;&#125;int find(Word* words, int count, char* str)&#123; // 在words中查找str，并返回下标 int i; for(i = 0; i &lt; count; i++)&#123; // 比较两个单词是否相等 if(strcmp(words[i].str, str) == 0) break; &#125; return i;&#125;int main()&#123; FILE* fpr = fopen(\"input_2016.txt\", \"r\"); FILE* fpw = fopen(\"output_2016.txt\", \"w\"); int i; Word* words; char buf[20]; int count = 0; // 统计该文件中共有多少单词 while(fscanf(fpr, \"%s\", buf) != EOF)&#123; count++; &#125; // 申请空间 words = (Word*)malloc(sizeof(Word)*count); rewind(fpr); count = 0; // 按单词读取文件内容，并统计个数 while(fscanf(fpr, \"%s\", buf) != EOF)&#123; // 判断之前的单词中是否有与当前单词相同的 i = find(words, count, buf); if(i == count)&#123; // 复制 strcpy(words[count].str, buf); words[count].freq = 0; count++; &#125; words[i].freq++; &#125; insertion_sort(words, count); // 将频度大于5的单词写入文件并输出 for(i = 0; i &lt; count &amp;&amp; words[i].freq &gt; 5; i++)&#123; fprintf(fpw, \"%s, %d\\n\", words[i].str, words[i].freq); printf(\"%s, %d\\n\", words[i].str, words[i].freq); &#125; free(words); fclose(fpr); fclose(fpw);&#125; 欢迎来信交流||指教。","categories":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"}],"tags":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"},{"name":"c语言","slug":"c语言","permalink":"http://zivblog.top/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"苏州大学2015年复试上机题","slug":"苏州大学2015年复试上机题","date":"2019-03-08T02:40:45.000Z","updated":"2020-03-19T11:01:12.000Z","comments":true,"path":"passages/su-zhou-da-xue-2015-nian-fu-shi-shang-ji-ti/","link":"","permalink":"http://zivblog.top/passages/su-zhou-da-xue-2015-nian-fu-shi-shang-ji-ti/","excerpt":"","text":"题目描述 从网页上下载input.dat文件，里面是用二进制编写的，里面放了一堆int型的数，每个数占4字节，每次读取两个，这两个数构成一个坐标。 处于第一象限的坐标为有效点，问其中有多少个有效点。 从键盘输入k和n，从第一问中的有效点中找出距离小于n，距离小于n的点的个数要大于k，将它们以文本格式输出到文件中。 题目分析 文件中的数据用二进制编写，故要用fread()读取 读取时每两个点做成一个坐标 要定义结构体，用于存储坐标点 要动态申请空间，不能使用大数组 12345678判断整数数组大小fseek(fp, 0, SEEK_END); // 文件标记指针指向文末total = ftell(fp); // 获取文件标记指针位置，即文件的位数count = total / sizeof(int); // 计算整数个数coord_count = count / 2; // 计算坐标点个数num = (int*)malloc(sizeof(int)*count); // 为整数数组申请空间xy = (Coordinate*)malloc(sizeof(Coordinate)* coord_count); // 为坐标数组申请空间 代码结构 struct Coordinate： 坐标点结构体 double distance(const Coordinate* a, const Coordinate* b)： 计算传入的两点之间的距离 void swap(Coordinate* a, Coordinate* b)： 交换传入的两点的位置 int comapre(const Coordinate* a, const Coordinate *b)： 比较传入的两点与指定点之间的距离 void selection_sort(Coordinate *ptr, int begin, int end)： 根据各点与指定点之间的距离进行排序 void display(Coordinate *ptr, int count) 输出传入的坐标数组 void make_data()： 生成随机数据 int main()： 读取文件，生成整数数组和坐标数组 遍历，判断有效点并计数 根据输入的k和n找出符合的坐标点，输出并写入文件 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdbool.h&gt;#include&lt;string.h&gt;#include&lt;time.h&gt;typedef struct&#123; int x; int y;&#125;Coordinate;Coordinate point;double distance(const Coordinate *a, const Coordinate *b)&#123; /* 计算两个坐标点的距离 */ int val; val = (a-&gt;x - b-&gt;x)*(a-&gt;x - b-&gt;x) + (a-&gt;y - b-&gt;y)*(a-&gt;y - b-&gt;y); return sqrt((double)val);&#125;void swap(Coordinate* a, Coordinate* b)&#123; /* 交换传入的两个坐标点 */ Coordinate temp = *a; *a = *b; *b = temp;&#125;int compare(const Coordinate* a, const Coordinate* b)&#123; /* 比较传入两个坐标点与指定点之间的距离 */ double dista = distance(a, &amp;point); double distb = distance(b, &amp;point); if(dista &gt; distb) return 1; if(dista &lt; distb) return -1; if(dista == distb) return 0;&#125;void selection_sort(Coordinate *ptr, int begin, int end)&#123; /* 根据距离选择排序 */ int i, j; for(i = begin; i &lt; end; i++)&#123; for(j = i+1; j &lt; end; j++)&#123; if(compare(&amp;ptr[i], &amp;ptr[j]) &gt; 0) swap(&amp;ptr[i], &amp;ptr[j]); &#125; &#125;&#125;void make_data()&#123; /* 生成随机数据 */ FILE* fp; int *num; int i; fp = fopen(\"org_2015.dat\", \"wb\"); num = (int*)malloc(sizeof(int) * 128); srand(time(NULL)); for(i = 0; i &lt; 128; i++) num[i] = rand() % 128 - 64; // 二进制方式写入文件 fwrite(num, sizeof(int), 128, fp); free(num); fclose(fp);&#125;void display(Coordinate* ptr, int count)&#123; /* 输出传入的坐标点数组 */ int i; for(i = 0; i &lt; count; i++) printf(\"(%2d, %2d) \", ptr[i].x, ptr[i].y); printf(\"\\n\");&#125;int main()&#123; FILE* fp; Coordinate* xy; int* num; int i; int count, coord_count; //生成数据文件 make_data(); fp = fopen(\"org_2015.dat\", \"rb\"); //申请空间 fseek(fp, 0, SEEK_END); count = ftell(fp) / sizeof(int); coord_count = count / 2; num = (int*)malloc(sizeof(int)*count); xy = (Coordinate*)malloc(sizeof(Coordinate)* coord_count); rewind(fp); // 读取文件 fread(num, sizeof(int), count, fp); fclose(fp); // 有效点计数和存储 int valid = 0; fp = fopen(\"output_2015.txt\", \"w\"); for(i = 0; i &lt; count; i += 2)&#123; if(num[i] &gt; 0 &amp;&amp; num[i+1] &gt; 0)&#123; xy[valid].x = num[i]; xy[valid].y = num[i+1]; valid++; &#125; &#125; printf(\"valid points:\\n\"); display(xy, valid); printf(\"total: %d\\n\", valid); int k, n, pivot; // 获取k，n的值 printf(\"k = \"); scanf(\"%d\", &amp;k); printf(\"n = \"); scanf(\"%d\", &amp;n); pivot = 0; // 遍历有效点 while(pivot &lt; valid)&#123; // 挨个点判断 point.x = xy[pivot].x; point.y = xy[pivot].y; pivot ++; // 根据与point点的距离将xy排序 selection_sort(xy, pivot, valid); printf(\"the points with a distance of less than %d to (%2d, %2d) are:\\n\", n, point.x, point.y); fprintf(fp, \"the points with a distance of less than %d to (%2d, %2d) are:\\n\", n, point.x, point.y); // 到指定点距离至少为n，且距离至少为n的点不少于k的指定点 // 若排序后的xy中第k个点到指定点距离仍小于n，则遍历输出 int i = 0; int j = 0; // 统计符合条件的点的个数 while(i &lt; valid &amp;&amp; distance(&amp;xy[i], &amp;point) &lt; (double)n)&#123; i++; &#125; // 输出 if(i &gt; k)&#123; while(j &lt;= i)&#123; printf(\"(%2d, %2d) %7.2f\\n\", xy[j].x, xy[j].y, distance(&amp;xy[j], &amp;point)); fprintf(fp, \"(%2d, %2d) %7.2f\\n\", xy[j].x, xy[j].y, distance(&amp;xy[j], &amp;point)); j ++; &#125; &#125; &#125;&#125; 欢迎来信交流||指教。","categories":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"}],"tags":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"},{"name":"c语言","slug":"c语言","permalink":"http://zivblog.top/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"Pytorch更新与安装","slug":"Pytorch更新与安装","date":"2019-03-07T08:19:06.000Z","updated":"2020-07-06T05:39:59.000Z","comments":true,"path":"passages/pytorch-geng-xin-yu-an-zhuang/","link":"","permalink":"http://zivblog.top/passages/pytorch-geng-xin-yu-an-zhuang/","excerpt":"pytorch 更新与卸载","text":"pytorch 更新与卸载 写在前面 本文讲解的是pytorch 更新与卸载 使用pip和conda进行操作 Pytorch更新 使用pip更新 12345# 列举可更新的包pip list --otdated --format=legacy# 更新pip install --upgrade pytorch torchvision 使用conda更新 1234# 添加源服务器conda config --add channels soumith#更新conda update pytorch torchvision Pytorch卸载 使用pip卸载 1pip uninstall torch 使用conda卸载 123conda uninstall pytorchconda uninstall libtorch 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"工具配置","slug":"工具配置","permalink":"http://zivblog.top/categories/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://zivblog.top/tags/Tools/"}]},{"title":"Leetcode之两数相加","slug":"Leetcode之两数相加","date":"2019-03-06T13:41:16.000Z","updated":"2020-07-06T05:21:18.000Z","comments":true,"path":"passages/leetcode-zhi-liang-shu-xiang-jia/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-liang-shu-xiang-jia/","excerpt":"Add Two Nums","text":"Add Two Nums 题目描述 题目详情见：两数相加 题目难度：中等 相关标签：链表，数学 思路 很遗憾，不能将链表中的元素读出来形成整数再相加，这样会内存泄漏 只能按照作者的思路，按位相加，计算本位的结果和进位的值 要注意每一位的结果都应该是整数，不是浮点数 python中//是取整除操作，向下取整 代码一是笔者实现的，其中有些地方不够简练，没有体现python的简洁的特点 代码二是leetcode评论区的大神实现的，思路与笔者相同，不过代码看起来更简练 代码一1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def addTwoNumbers(self, l1, l2): \"\"\" :type l1 ListNode :type l2 ListNode :rtype: ListNode \"\"\" # 结果链表 re = ListNode(0); # 结果列表工作指针 r = re # 进位 carry = 0; while(l1 or l2): # 读取该位的数据 if l1: x = l1.val else: x = 0 if l2: y = l2.val else: y = 0 # 计算 s = carry + x + y # 计算进位和结果 carry = s // 10 #取整除 r.next = ListNode(s%10) r = r.next # 原链表的指针后移 if(l1 != None): l1 = l1.next if(l2 != None): l2 = l2.next if(carry &gt; 0): r.next = ListNode(1) return re.next 代码二12345678910111213141516171819202122class Solution: def addTwoNumbers(self, l1, l2): \"\"\" :type l1: ListNode :type l2: ListNode :rtype: ListNode \"\"\" re = ListNode(0) r=re carry=0 while(l1 or l2): x= l1.val if l1 else 0 y= l2.val if l2 else 0 s=carry+x+y carry=s//10 r.next=ListNode(s%10) r=r.next if(l1!=None):l1=l1.next if(l2!=None):l2=l2.next if(carry&gt;0): r.next=ListNode(1) return re.next 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"苏州大学2014年复试上机题","slug":"苏州大学2014年复试上机题","date":"2019-03-06T12:36:35.000Z","updated":"2020-03-04T07:11:48.000Z","comments":true,"path":"passages/su-zhou-da-xue-2014-nian-fu-shi-shang-ji-ti/","link":"","permalink":"http://zivblog.top/passages/su-zhou-da-xue-2014-nian-fu-shi-shang-ji-ti/","excerpt":"","text":"题目描述 从网页上下载input.dat文件，这里面是用二进制编写的，里面放了一堆int类型的数，每个数占4个字节，每次读取两个，这两个数构成一个坐标。 规定处以第一象限的数是有效点（x &gt; 0&amp;&amp;y &gt; 0）,问共有 多少个有效点。 现用户从键盘输入一个左边和数字k，输出k个离该点最近的点的坐标和每个坐标到该点的距离，写入output.txt中。 题目分析 文件使用二进制编写，读取的时候要使用fread(buffer, size, count, fp)函数。 定义坐标点结构体，用该结构体定义坐标点数组。 定义计算输入点到各个点的距离的函数，判断距离是否符合条件，符合者输出。 代码结构1234567891011121314151617181920struct Coordinate) # 坐标点的结构 double distance(const Coordinate* a, const Coordinate* b) # 计算两个点之间的距离void swap(Coordinate* a, Coordinate* b) # 交换传入的两个坐标int compare(const Coordinate* a, const Coordinate* b) # 比较传入的两个坐标点与指定坐标点距离的大小void selection_sort(Coordinate *ptr, int begin, int end) # 根据与传入点的距离排序void display(Coordinate* ptr, int count) # 输出传入的坐标点void make_data() # 生成随机数据int main() 生成数据 计算文件中有多少整数，多少坐标点 根据整数个数和坐标点个数申请空间 统计合法点个数 筛选距指定坐标点最近的k个坐标点 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdbool.h&gt;#include&lt;string.h&gt;#include&lt;time.h&gt;typedef struct&#123; int x; int y;&#125;Coordinate;Coordinate point;double distance(const Coordinate* a, const Coordinate* b)&#123; /* 计算两个点之间的距离 */ int val = (a-&gt;x - b-&gt;x) * (a-&gt;x - b-&gt;x) + (a-&gt;y - b-&gt;y) * (a-&gt;y - b-&gt;y); return sqrt((double) val);&#125;void swap(Coordinate* a, Coordinate* b)&#123; /* 交换传入的两个坐标 */ Coordinate temp = *a; *a = *b; *b = temp;&#125;int compare(const Coordinate* a, const Coordinate* b)&#123; /* 比较两个传入的点与指定点的距离 */ double dista = distance(a, &amp;point); double distb = distance(b, &amp;point); if(dista &lt; distb) return -1; if(dista &gt; distb) return 1; else return 0;&#125;void selection_sort(Coordinate* ptr, int begin, int end)&#123; /* 选择排序 */ int i, j; for(i = begin; i &lt; end; i++)&#123; for(j = i+1; j &lt; end; j++)&#123; if(compare(&amp;ptr[i], &amp;ptr[j])) swap(&amp;ptr[i], &amp;ptr[j]); &#125; &#125;&#125;void display(Coordinate* ptr, int count)&#123; /* 输出传入的坐标数组 */ int i; for(i = 0; i &lt; count; i++) printf(\"(%2d, %2d) \", ptr[i].x, ptr[i].y); printf(\"\\n\");&#125;void make_date()&#123; /* 生成数据 */ FILE *fp = fopen(\"org_2014.dat\", \"wb\"); int *num; int i; // 大小为128的数组 num = (int*)malloc(sizeof(int)*128); // 初始化随机种子 srand(time(NULL)); for(i = 0; i &lt; 128; i++) num[i] = rand()%128 - 64; // 以二进制的方式读取数据 fwrite(num, sizeof(int), 128, fp); // 释放空间 free(num); fclose(fp);&#125;int main()&#123; FILE* fp; Coordinate* xy; int *num; int count, coord_count; int i; // 生成随机数据 make_date(); // 读取数据 fp = fopen(\"org_2014.dat\", \"rb\"); // 求文件有多少整数 // 使文件指针指向文件结尾 fseek(fp, 0, SEEK_END); // 获取当前文件指针位置相对于文件首的偏移字节数 count = ftell(fp) / sizeof(int); // 坐标点个数 coord_count = count / 2; // 根据坐标点个数申请内存空间 num = (int*)malloc(sizeof(int)*count); xy = (Coordinate*)malloc(sizeof(Coordinate) * coord_count); // 文件指针回到文件首 rewind(fp); // 二进制方式按四个字节为一个数读取 fread(num, sizeof(int), count, fp); fclose(fp); // 输出读取的结果 for(i = 0; i &lt; count; i+=2) printf(\"(%2d, %2d) \\n\", num[i], num[i+1]); // 统计合法坐标的个数 int valid = 0; fp = fopen(\"output_2014.txt\", \"w\"); for(i = 0; i &lt; count; i += 2)&#123; if(num[i] &gt; 0 &amp;&amp; num[i + 1] &gt; 0)&#123; xy[valid].x = num[i]; xy[valid].y = num[i + 1]; valid++; &#125; &#125; // 输出合法坐标 printf(\"valid points:\\n\"); display(xy, valid); printf(\"total: %d\\n\", valid); // KNN // 找离指定坐标最近的k个坐标点 int k; printf(\"Coordinate: \"); scanf(\"%d %d\", &amp;point.x, &amp;point.y); printf(\"k = \"); scanf(\"%d\", &amp;k); selection_sort(xy, 0, valid); printf(\"the nearest %d points to (%d, %d) are:\\n\", k, point.x, point.y); for(i = 0; i &lt; k; i++)&#123; printf(\"(%2d, %2d) %7.2f\\n\", xy[i].x, xy[i].y, distance(&amp;xy[i], &amp;point)); fprintf(fp, \"(%2d, %2d) %7.2f\\n\", xy[i].x, xy[i].y, distance(&amp;xy[i], &amp;point)); &#125; fclose(fp);&#125; 欢迎来信交流||指教。","categories":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"}],"tags":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"},{"name":"c语言","slug":"c语言","permalink":"http://zivblog.top/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"Leetcode之两数之和","slug":"Leetcode之两数之和","date":"2019-03-05T12:29:59.000Z","updated":"2020-03-04T06:27:15.000Z","comments":true,"path":"passages/leetcode-zhi-liang-shu-zhi-he/","link":"","permalink":"http://zivblog.top/passages/leetcode-zhi-liang-shu-zhi-he/","excerpt":"leetcode之twoSum","text":"leetcode之twoSum 题目描述 题目详情见：两数之和 题目难度：简单 相关标签：数组、哈希表 思路 先说题目要求，不能重复利用数组中的相同元素，所以想使用双层循环的同学在内层循环中不能再次访问外层循环正在访问的元素 问题解决的关键在于，计算当前值与指定target的差，并快速判断差是否在给定的数组中（这样，我们自然而然的就想到了python中的字典）。实现见代码一。 另一种思路是使用首尾递进查找：需要列表是有序的（假设为升序）。首先将首尾元素加起来，若大于target，则tail–；若小于target，则head–。实现见代码二 代码一12345678910111213141516171819class Solution: def twoSum(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: List[int] \"\"\" hashmap = &#123;&#125; for index, num in enumerate(nums): another_num = target - num; if another_num in hashmap: return [hashmap[another_num], index] hashmap[num] = index return None # 说明“”“ enumerate()：用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在for循环当中。”“” 代码二123456789101112131415161718192021222324252627class Solution: def twoSum(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: List[int] \"\"\" sorted_id = sorted(range(len(nums)), key=lambda k: nums[k]) head = 0 tail = len(nums) - 1 sum_result = nums[sorted_id[head]] + nums[sorted_id[tail]] while sum_result != target: if sum_result &gt; target: tail -= 1 elif sum_result &lt; target: head += 1 sum_result = nums[sorted_id[head]] + nums[sorted_id[tail]] return [sorted_id[head], sorted_id[tail]] # 说明\"\"\"sorted(iterable, key=None, reverse=False)：对传入的列表进行排序操作，返回的是一个新的列表，不对原列表进行操作；默认升序sort()：在原列表上操作\"\"\" 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"}]},{"title":"苏州大学2012年复试上机题","slug":"苏州大学2012年复试上机题","date":"2019-03-04T10:00:00.000Z","updated":"2020-03-04T07:03:16.000Z","comments":true,"path":"passages/su-zhou-da-xue-2012-nian-fu-shi-shang-ji-ti/","link":"","permalink":"http://zivblog.top/passages/su-zhou-da-xue-2012-nian-fu-shi-shang-ji-ti/","excerpt":"","text":"题目描述 从服务器上下载数据文件org.dat，文件以二进制方式存放一系列整数，每个整数占4个字节，从第一个整数开始，每两个整数组成一个坐标点。 规定处于第一象限的坐标点为有效点，统计文件中由多少个点，多少个有效点。 每个有效点与坐标原点构成一个矩形，求最小矩形的面积。 找出符合该条件的点：以该点为原点，其他有效点仍是有效点 对有效点进行分组，每个有效点仅属于一个分组，组内：若对组内所有点的x进行排序，当x1 &gt; x2时，y1 &gt; y2。 题目分析 读取文件，两个整数为一个点，四位为1个整数 判断有效点（第一象限）并得到最小的x和y 对有效点排序，并输出 找合适的有效点：x1 &gt; x2 &amp;&amp; y1 &gt; y2 代码结构12345678910111213141516171819202122232425struct Corrdinate 点的结构体void swap(Coordinate *a, Coordinate *b) 交换传入的两个点 int compare(const Coordinate *lhs, const Coordinate *rhs) 比较两个点，根据其x坐标 void selection_sort(Coordinate *ptr, int begin, int end) 选择排序 void display(Coordinate *ptr, int count) 展示坐标点 void make_data() 生成数据int main() 读取文件，两位读作一个坐标点 得到其中的有效点（第一象限） 排序 最小矩形即最小的x*y 对有效点： 选择排序 x1 &gt; x2 &amp;&amp; y1 &gt; y2 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdbool.h&gt;#include&lt;string.h&gt;#include&lt;time.h&gt;#include&lt;math.h&gt;typedef struct&#123; int x; int y;&#125;Coordinate;void swap(Coordinate *a, Coordinate *b)&#123; /* 交换传入的两个数据 */ Coordinate temp = *a; *a = *b; *b = temp;&#125;int compare(const Coordinate *lhs, const Coordinate *rhs)&#123; /* 比较传入的点 根据x坐标比较 */ if(lhs-&gt;x &lt; rhs-&gt;x) return -1; if(lhs-&gt;x &gt; rhs-&gt;x) return 1; else return 0;&#125;void selection_sort(Coordinate *ptr, int begin, int end)&#123; /* 选择排序 */ int i, j; for(i = begin; i &lt; end; i++) for(j = i+1; j &lt; end; j++) if(compare(&amp;ptr[i], &amp;ptr[j]) &gt; 0) swap(&amp;ptr[i], &amp;ptr[j]);&#125;void display(Coordinate *ptr, int count)&#123; /* 展示坐标点 */ int i; for(i = 0; i &lt; count; i++) printf(\"(%2d, %2d) \", ptr[i].x, ptr[i].y); printf(\"\\n\");&#125;void make_data()&#123; /* 生成数据 */ FILE *fp = fopen(\"org_2012.dat\", \"wb\"); int *num = (int*)malloc(sizeof(int)*128); int i; // 随机数生成其初始化 srand(time(NULL)); for(i = 0; i &lt; 128; i++) num[i] = rand() % 128 - 64; // 二进制方式写入文件 fwrite(num, sizeof(int), 128, fp); free(num); fclose(fp);&#125;int main()&#123; FILE *fp; Coordinate *xy; int *num; int n, count; // 随机生成数据 make_data(); fp = fopen(\"org_2012.dat\", \"rb\"); // 函数设置文件指针stream的位置 fseek(fp, 0, SEEK_END); // ftell(): 得到文件位置指针当前位置相对于文件首的偏移字节数 // 计算有多少个整型数据 count = ftell(fp) / sizeof(int); n = count / 2; num = (int*)malloc(sizeof(int) * count); xy = (Coordinate*)malloc(sizeof(Coordinate)*n); // 将文件指针重置 rewind(fp); // 二进制形式兑取文件 fread(num, sizeof(int), count, fp); fclose(fp); int k = 0, j, i; // RAND_MAX：rand返回的最大值 int minx = RAND_MAX; int miny = RAND_MAX; // 读取文件内容，两个一组 for(i = 0; i &lt; count; i += 2)&#123; if(num[i] &gt; 0 &amp;&amp; num[i + 1] &gt; 0)&#123; xy[k].x = num[i]; xy[k].y = num[i + 1]; // 得到最大值和最小值 if(minx &gt; xy[k].x) minx = xy[k].x; if(miny &gt; xy[k].y) miny = xy[k].y; // 第一象限点的个数 k++; &#125; &#125; // 排序 selection_sort(xy, 0, k); // 输出所有点 printf(\"valid points:\\n\"); display(xy, k); // 点的个数和第一象限的点的个数 printf(\"n - %d k = %d\\n\", n, k); printf(\"min area = %d\\n\", minx * miny); int sorted = 0; // 有效点中的符合条件的点 while(sorted &lt; k)&#123; selection_sort(xy, sorted, k); printf(\"points grouped by (%2d, %2d):\", xy[sorted].x, xy[sorted].y); miny = xy[sorted++].y; for(i = sorted; i &lt; k; i++)&#123; if(xy[i].y &gt;= miny)&#123; miny = xy[i].y; printf(\"(%2d, %2d) \", xy[i].x, xy[i].y); swap(&amp;xy[i], &amp;xy[sorted++]); &#125; &#125; printf(\"\\n\"); &#125;&#125; 欢迎来信交流||指教。","categories":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"}],"tags":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"},{"name":"c语言","slug":"c语言","permalink":"http://zivblog.top/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"苏州大学2010年复试上机题","slug":"苏州大学2010年复试上机题","date":"2019-03-04T06:48:23.000Z","updated":"2020-03-04T07:02:27.000Z","comments":true,"path":"passages/su-zhou-da-xue-2010-nian-fu-shi-shang-ji-ti/","link":"","permalink":"http://zivblog.top/passages/su-zhou-da-xue-2010-nian-fu-shi-shang-ji-ti/","excerpt":"","text":"题目描述 从ftp上下载make.exe和org.dat，运行make.exe，输入准考证后三位生成data.txt，文件为二进制编码。 data.txt中存有2048个整数，其中前n个为非0数，收2048-n个为0，将其读入数组，计算非0数的个数。 选出n个数中的最大数和最小数。 选出n个数中的最大素数。 将n个数从大到小排序，平均分成三段，选出中间一段的最大值和最小值。 题目分析 遍历寻找非0数与0的位置，并记录其索引。 遍历数据，寻找数据中的最大值和最小值以及最大素数。 将数据排序，划分为三段，截取中间一段，读取其最大值和最小值 注意二进制编码的文件要用fread读取. 代码结构12345678910111213141516bool is_prime(int num) 判断传入的数字是否为素数int compare(int a, int b) 比较传入的两个数的大小关系void selection_sort(int *ptr, int count) 对传入的数组进行选择排序 void make_data() 产生随机数据 int main() 读取数据 寻找最大值、最小值、最大素数 划分数据，获取中间一段的最大值、最小值 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdbool.h&gt;#include&lt;string.h&gt;#include&lt;time.h&gt;bool is_prime(int num)&#123; /* 判断传入的数字是否为素数 */ int i; if(num &lt; 2) return false; for(i = 2; i*i &lt;= num; i++)&#123; if(num % i == 0) return false; &#125; return true;&#125;void swap(int *a, int *b)&#123; /* 交换传入的两个数的值 */ int temp = *a; *a = *b; *b = temp;&#125;int compare(int a, int b)&#123; /* 比较传入的两个数的大小关系 */ if(a &lt; b) return -1; else if(a == b) return 0; else return 1;&#125;void selection_sort(int *ptr, int count)&#123; /* 选择排序 */ int i, j; for(i = 0; i &lt; count; i++)&#123; for(j = i + 1; j &lt; count; j++)&#123; if(compare(&amp;ptr[i], &amp;ptr[j]) &gt; 0) swap(&amp;ptr[i], &amp;ptr[j]); &#125; &#125;&#125;void make_data()&#123; // 制造数据,xieru data文件 int i; int num[2048]; FILE *fp = fopen(\"data_2010.txt\", \"wb\"); if(!fp)&#123; printf(\"File opening failed\"); return EXIT_FAILURE; &#125; srand(time(NULL)); for(i = 0; i &lt; 1000; i++)&#123; num[i] = rand() % 4096; &#125; for(i = 1000; i &lt; 2048; i++) num[i] = 0; fwrite(num, sizeof(int), 2048, fp); fclose(fp);&#125;int main()&#123; FILE *fp; int num[2048]; int min = RAND_MAX; int max = 0; int max_prime = 0; int n, i; //制造数据 make_data(); // 读取数据 fp = fopen(\"data_2010.txt\", \"rb\"); if(!fp)&#123; printf(\"File opening failed\"); return EXIT_FAILURE; &#125; fread(num, sizeof(int), 2048, fp); // 判断有多少非0数 for(n = 0; n &lt; 2048; n++)&#123; if(num[n] == 0) break; &#125; printf(\"n = %d\\n\", n); // 找最大值，最小值，最大素数 for(i = 0; i &lt; n; i++)&#123; if(min &gt; num[i]) min = num[i]; if(max &lt; num[i]) max = num[i]; if(is_prime(num[i]) &amp;&amp; num[i] &gt; max_prime) max_prime = num[i]; &#125; printf(\"min = %d,\\nmax = %d,\\nmax_prime = %d\\n\", min, max, max_prime); selection_sort(num, n); // 中间一段的最大值和最小值（降序排列） printf(\"min in mid_seg = %d\\nmax in mid_seg = %d\\n\", num[n/3*2-1],num[n/3]); fclose(fp);&#125; 欢迎来信交流||指教。","categories":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"}],"tags":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"},{"name":"c语言","slug":"c语言","permalink":"http://zivblog.top/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"苏州大学2011年复试上机题","slug":"苏州大学2011年复试上机题","date":"2019-03-04T05:36:49.000Z","updated":"2020-03-04T07:02:51.000Z","comments":true,"path":"passages/su-zhou-da-xue-2011-nian-fu-shi-shang-ji-ti/","link":"","permalink":"http://zivblog.top/passages/su-zhou-da-xue-2011-nian-fu-shi-shang-ji-ti/","excerpt":"","text":"题目描述 该数位于1000~9999之间。 该数是素数。 十位数和个位数所组成的数是素数，百位数和个位数组成的数是素数。 个位数和百位数组成的数是素数，个位数和十位数组成的数是素数。 例：1991，需分别判断1991，91，91，19，19 题目分析 分别取需判断数字的百位，十位，个位数存入一个三维数组中 组成指定数字进行判断 符合条件的输出 代码结构1234567bool is_prime(int num) 判断传入的数字是否是素数void split(int n, int num[]) 获取n的各个位置的数，存储在num中 int main() 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;stdio.h&gt;#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;bool is_prime(int num)&#123; /* 判断传入的数字是否是素数 */ int i; if(num &lt; 2) return false; for(i = 2; i*i &lt; num; i++)&#123; if(num % i == 0) return false; &#125; //printf(\"%d is prime. \\n\", num); return true;&#125;void split(int n, int num[])&#123; /* 拆分数字，分别获取其各个位上的数字 */ int i; for(i = 0; i &lt; 4; i++)&#123; num[i] = n % 10; n = n / 10; &#125;&#125;int main()&#123; int i, j; int num[4]; for(i = 1000; i &lt; 9999; i++)&#123; if(is_prime(i))&#123; // 直接传入num数组，之后就可以访问 split(i, num); // 依次分别为百位和个位，十位和个位，个位和百位，个位和十位 if(is_prime(num[1]*10 + num[0]) &amp;&amp; is_prime(num[2]*10 + num[0]) &amp;&amp; is_prime(num[0]*10 + num[2]) &amp;&amp; is_prime(num[0]*10 + num[1])) printf(\"%d\\n\", i); &#125; &#125;&#125; 欢迎来信交流||指教。","categories":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"}],"tags":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"},{"name":"c语言","slug":"c语言","permalink":"http://zivblog.top/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"matplotlib实践","slug":"matplotlib实践","date":"2019-03-03T14:23:48.000Z","updated":"2019-10-21T03:08:34.000Z","comments":true,"path":"passages/matplotlib-shi-jian/","link":"","permalink":"http://zivblog.top/passages/matplotlib-shi-jian/","excerpt":"折线图&amp;散点图","text":"折线图&amp;散点图 用matplotlib绘制折线图和散点图 更多图的绘制请见这里 使用matplotlib绘制折线图123456789101112131415161718192021222324252627import matplotlib.pyplot as pltinput_value = [1, 2, 3, 4, 5]squares = [1, 4, 9, 16, 25]# 传入squares列表，指定线条粗细为5plt.plot(input_value, squares, linewidth=5)# 设置标题,指定字体为24号plt.title(\"Squares Numbers\", fontsize=24)# 设置x轴和y轴的标题plt.xlabel(\"Value\", fontsize=14)plt.ylabel(\"Squares of Value\", fontsize=14)# 设置刻度标记的大小plt.tick_params(axis='both', labelsize=14)# 打开matplotlib显示器plt.show() 使用matplotlib绘制散点图123456789101112131415161718192021222324252627import matplotlib.pyplot as pltx_values = list(range(1001))y_values = [x**2 for x in x_values]# 绘制散点图，设置点的颜色为(0, 0, 0.8),点的外围颜色为黑色，指定点的大小为40# plt.scatter(x_value, y_value, c=(0, 0, 0.8), edgecolors='black', s=40)# 使用颜色映射plt.scatter(x_values, y_values, c=y_values, cmap=plt.cm.Blues, edgecolors='none', s=40)# 设置标题并给坐标轴加上标签plt.title(\"Square Number\", fontsize=24)plt.xlabel(\"Value\", fontsize=14)plt.ylabel(\"Square of Value\", fontsize=24)# 设置刻度标记的大小plt.tick_params(axis='both', which='major', labelsize=14)# 自动保存图表plt.savefig('squares_plot.png', bbox_inches='tight')plt.show() 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://zivblog.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://zivblog.top/tags/Python/"}]},{"title":"Python随机漫步","slug":"Python随机漫步","date":"2019-03-03T14:20:11.000Z","updated":"2019-10-21T03:08:52.000Z","comments":true,"path":"passages/python-sui-ji-man-bu/","link":"","permalink":"http://zivblog.top/passages/python-sui-ji-man-bu/","excerpt":"随机漫步：每一步都是随机决策","text":"随机漫步：每一步都是随机决策 所谓随机漫步，每次行走都完全是随机的，没有明确的方向，结果是由一系列随机决策决定的， 例如：漂浮在水滴上的花粉因不断受到水分子的挤压而在水面上的移动 randomwalk.py123456789101112131415161718192021222324252627282930313233343536373839404142from random import choiceclass RandomWalk(): ''' 生成随机漫步数据的类 ''' def __init__(self, num_points=5000): # 初始化随机漫步属性 self.num_points = num_points # 所有随机漫步都始于(0,0) self.x_values = [0] self.y_values = [0] def fill_walk(self): # 计算随机漫步包含的所有点 # 不断漫步，直至达到列表的指定长度 while len(self.x_values) &lt; self.num_points: # 决定前进方向以及沿这个方向上的距离 # 方向在左：1，右：-1上选择 x_direction = choice([1, -1]) # 距离在1~4中间选择 x_distance = choice([0, 1, 2, 3, 4]) x_step = x_direction * x_distance y_direction = choice([1, -1]) y_distance = choice([0, 1, 2, 3, 4]) y_step = y_direction * y_distance # 拒绝原地踏步 if x_step == 0 and y_step == 0: continue # 计算下一个点的x和y值 next_x = self.x_values[-1] + x_step next_y = self.y_values[-1] + y_step # 将计算得到的下一个点的值添加到列表中 self.x_values.append(next_x) self.y_values.append(next_y) rw_visual.py12345678910111213141516171819202122232425262728293031import matplotlib.pyplot as pltfrom randomwalk import RandomWalknumber = 0# 不断模拟随机漫步while True: rw = RandomWalk(50000) rw.fill_walk() # 设置绘图窗口大小 plt.figure(dpi=128, figsize=(10, 6)) point_numbers = list(range(rw.num_points)) plt.title(\"No.\" + str(number) + \" RandomWalk\") plt.scatter(rw.x_values, rw.y_values,c=point_numbers,cmap=plt.cm.Blues, edgecolors='none', s=1) # 突出起点和终点 plt.scatter(0, 0, c='green', edgecolors='none', s=100) plt.scatter(rw.x_values[-1], rw.y_values[-1], c='red', edgecolors='none', s=100) # 隐藏坐标轴 plt.axes().get_xaxis().set_visible(False) plt.axes().get_yaxis().set_visible(False) plt.show() keep_running = input(\"Make another walk ? (y/n)\") if keep_running == 'n': break 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://zivblog.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://zivblog.top/tags/Python/"}]},{"title":"Python函数的几点注意","slug":"Python函数的几点注意","date":"2019-03-03T13:49:23.000Z","updated":"2019-04-01T13:15:12.000Z","comments":true,"path":"passages/python-han-shu-de-ji-dian-zhu-yi/","link":"","permalink":"http://zivblog.top/passages/python-han-shu-de-ji-dian-zhu-yi/","excerpt":"函数定义及传参的几点注意《Python编程从入门到精通》笔记","text":"函数定义及传参的几点注意《Python编程从入门到精通》笔记 函数的定义12345# 使用关键字'def'标识,函数体内的语句都要至少比函数名一个缩进def greet(): print(\"hello world\")greet() 实参和形参12345678# 调用时传入的参数时实参，定义时的参数时形参# 下面的username是形参，而tom是实参def greet(username): print(\"hello\" + username)greet(\"tom\") 几种传参方式1234567891011121314151617181920212223242526#位置实参： 即基于顺序的参数传递，传递参数时实参的顺序必须与形参的顺序完全一致def greet(username, age): print(username + \" is \"+ str(age) + \"years old\")greet(\"tom\", 17)# 关键字实参： 即传递时传递的是名称-值对（不同于键值对，键值对的键必须时字符串），直接在传参时将名称和值关联起来了，也就不需要顺序完全一致了def greet(username, age): print(username + \" is \" + str(age) + \"years old\")greet(username=\"tom\", age=12)#默认值： 即在形参处设置默认值，当调用时未传入该形参对应的参数时使用默认值def greet(username=\"tom\", age): print(username + \" is \" + str(age) + \"years old\") greet(age=12) 返回值 返回值可以是字符串，数字，字典，列表等 传递列表和字典123456789101112131415161718# 传入列表def greet(*username, age): for name in username: print(name + \" is \" + str(age) + \"years old\")username = ['bob', 'cindy', 'flank']greet(username, 12)# 传入字典def greet(**message): for name,age in message.items(): print(name + \" is \"+ str(age) + \"years old\")message = &#123;'bob':12, 'cindy':13, 'flank':14&#125;greet(message) 形参设置成列表可以实现传入任意数量的参数的功能 形参设置成字典可以实现传入任意数量的名称-值对的功能 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://zivblog.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://zivblog.top/tags/Python/"}]},{"title":"Python用户输入及while","slug":"Python用户输入及while","date":"2019-03-03T13:39:36.000Z","updated":"2019-04-01T13:15:42.000Z","comments":true,"path":"passages/python-yong-hu-shu-ru-ji-while/","link":"","permalink":"http://zivblog.top/passages/python-yong-hu-shu-ru-ji-while/","excerpt":"while及编程语言 《Python编程从入门到精通》笔记","text":"while及编程语言 《Python编程从入门到精通》笔记 用户输入1234# 获取用户输入message = input(\"Please input something:\")print(message) while循环的使用123456789101112131415161718192021222324252627# while循环num = 0sum = 0while num &lt; 5: sum = sum + num num = num + 1print(sum)# 用户选择何时退出mess = \"\" #必须事先定义while mess != \"quit\": mess = input(\"Please input something1:\\n\") if mess != \"quit\": print(mess)# 使用标志active = Truewhile active: mess = input(\"Please input something2:\\n\") if mess == \"quit\": active = False else: print(mess) break &amp; continue12345678910111213141516171819202122# 循环中使用break跳出循环mess = \"\"while True: mess = input() if mess == \"quit\": break else: print(mess)# 循环中使用continue直接跳到下一次循环num = 0while num &lt; 10: num = num + 1 # 跳过偶数 if num % 2 == 0: continue print(num) while循环的一些应用12345678910111213141516171819202122232425262728293031323334353637383940# 列表间元素的移动unfirmed_name = ['alice','amy','lili']firmed_name = []while unfirmed_name: username = unfirmed_name.pop() print(\"Verifying name :\" + username.title()) firmed_name.append(username)print(\"\\nThe following name is confirmed:\")while firmed_name: print(firmed_name.pop())# 删除列表中的多个相同的元素animals = ['dog','cat','pig','chicken','cat']while 'cat' in animals: animals.remove('cat') #remove()只能每次删除第一个符合要求的元素 print('Removed a cat')# 用输入填充字典responses = &#123;&#125;name = input(\"What's your name ?\\n\")responses['name'] = nameage = input(\"what's your age ?\\n\")responses['age'] = ageprint(responses['name'].title() + \"'s age is \" + responses['age']) 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://zivblog.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://zivblog.top/tags/Python/"}]},{"title":"Python字典操作","slug":"Python字典操作","date":"2019-03-03T13:31:10.000Z","updated":"2019-04-01T13:15:26.000Z","comments":true,"path":"passages/python-zi-dian-cao-zuo/","link":"","permalink":"http://zivblog.top/passages/python-zi-dian-cao-zuo/","excerpt":"Python字典操作 《Python编程从入门到精通》笔记","text":"Python字典操作 《Python编程从入门到精通》笔记 创建字典1234#字典由'&#123;&#125;'标识，其中的元素是键值对# 键必须是字符串，值可以是任何类型dic = &#123;\"name\":\"ziv\", \"age\":22&#125; 字典的操作1234567891011# 访问字典的值print(dic['name'])# 修改值dic[\"age\"] = 21# 添加键值对dic[\"sex\"] = \"male\"# 删除键值对del dic[\"sex\"] 遍历字典1234567891011121314151617# 键值同时遍历for key, value in dic.items(): print(key+\":\"+value)# 仅遍历字典的键for key in dic.keys(): print(key) # 仅遍历字典的值for value in dic.values(): print(value)# 按排序顺序遍历字典的键for value in sorted(dic.values()): print(value) 嵌套123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# 创建30个外星人字典：列表中嵌套字典aliens = []for alien_num in range(1,31): alien = &#123;'color':'green', 'age':'14', 'point':'5', 'number':alien_num&#125;aliens.append(alien)# 修改前3个，用到切片for alien in aliens[:3]: if alien['color'] == 'green': alien['color'] = 'blue' alien['age'] = '20' alien['point'] = '10'for alien in aliens: print(alien)# 披萨店的点餐：字典中嵌套列表pizza = &#123; 'crust':'thick', 'toppings':['mushrooms', 'extra cheese']&#125;# 仅访问其中的列表for topping in pizza['toppings']: print(topping)# 网站用户登记：字典中嵌套字典users = &#123; 'aeinstein': &#123; 'first': 'albert', 'last': 'einstein', 'location': 'princeton', &#125;, 'mcurie': &#123; 'first': 'marie', 'last': 'curie', 'location': 'paris', &#125;,&#125;for username, user_info in users.items(): print(\"\\nUsername: \" + username) full_name = user_info['first'] + \" \" + user_info['last'] location = user_info['location'] print(\"\\tFull name: \" + full_name.title()) print(\"\\tLocation: \" + location.title()) 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://zivblog.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://zivblog.top/tags/Python/"}]},{"title":"Python条件语句","slug":"Python条件语句","date":"2019-03-03T13:21:06.000Z","updated":"2019-04-01T13:15:36.000Z","comments":true,"path":"passages/python-tiao-jian-yu-ju/","link":"","permalink":"http://zivblog.top/passages/python-tiao-jian-yu-ju/","excerpt":"Python条件语句 《Python编程从入门到精通》笔记","text":"Python条件语句 《Python编程从入门到精通》笔记 if判断相等12345678910111213# 数字if 1 == 2 print(\"1==2\")else: print(\"1!=2\")# 字符串if \"asd\" == \"zxc\": print(True)else: print(False)# 若要忽略大小写判断字符串是否相等，可以通过将两个字符串同时转换为小写之后再判断：lower()函数 if判不等123456# 判不等使用!=，格式与判等相同if 1 != 2: print(\"1 != 2\")else: print(\"1 == 2\") if-elif-else结构12345678cars = (\"audi\", \"bwm\", \"loslis\")if car[1] == \"audi\": print(\"1\")elif car[2] == \"bwm\": print(\"2\")else: print(\"3\") 检查元素是否在列表中123456789cars = [\"audi\", \"bwm\", \"loslis\"]if \"audi\" in cars: print(\"audi is in cars\")if \"audi\" not in cars: print(\"audi is not in cars\") 布尔表达式12345# 布尔表达是只有两个值：True和False，且两者首字母必须要大写bool_ = Truebool__ = False 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://zivblog.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://zivblog.top/tags/Python/"}]},{"title":"Python列表（List）操作","slug":"Python列表（List）操作","date":"2019-03-03T12:44:53.000Z","updated":"2019-04-01T13:15:18.000Z","comments":true,"path":"passages/python-lie-biao-list-cao-zuo/","link":"","permalink":"http://zivblog.top/passages/python-lie-biao-list-cao-zuo/","excerpt":"python、List 《Python编程从入门到精通》笔记","text":"python、List 《Python编程从入门到精通》笔记 列表的定义1message = [\"hello\",\"this\",\"is\",\"a\",\"demo\"] 访问及修改列表12345# 直接通过索引访问print(message[0])# 直接对要修改位置的元素赋值message[2] = \"change\" 列表的插入123456789# 在列表末尾插入message.append(\"append\")# 按指定索引插入message.insert(0,\"insert\")# 指定索引位置若有元素，则该元素及其后续元素顺序后移# 指定缩影位置若超过原有索引的范围，则一律添加到列表末尾 删除元素12345678910# 用del 删除指定位置的元素del message[2]# 用pop()弹出末尾元素并使用pop = message.pop()print(pop)# 用remove()删除指定值的元素message.remove(\"this\") 排序列表1234567891011#用sort()对列表进行永久性排序message.sort()# 用sorted()对列表进行临时性排序print(message.sorted())# 用reverse()将列表倒置message.reserve()# 用len()获取列表长度print(len(message)) 列表切片12345678910111213message = [\"hello\", \"this\", \"is\", \"a\", \"demo\"]# 指定起始和结束位置mess1 = message[1:2]# 不指定起始位置，默认从列表头开始mess2 = message[:3]# 不指定结束位置，默认从到列表尾mess3 = message[1:]# 指定倒数几个mess4 = message[-2:] 复制列表1234567# 复制列表看似有两种方式，实则真正复制了列表的只有一种。下面第一种方式是创建了两个相同的列表，列表之间的操作相互独立，不会影响到另一方；第二种方式只是将两个变量指向同一个列表，其实质还是一个列表，两者的操作都会体现在同一个列表上# 通过切片复制列表(一个包含所有元素的切片)copy_message = message[:]# 通过赋值复制列表message1 = message 元组12345678910111213# 元组实际上可以理解为布允许改变的列表；列表通过'[]'标识，元组通过'()'标识；虽然元组不允许修改，但允许赋值：可以理解为元组不允许改变单个元素，但是可以整体赋值# 元组的定义cars = (\"bwm\", \"audi\", \"toyota\", \"loslis\")# 元组的遍历for car in cars: print(car)# 元组不允许切片# 元组的赋值（必须一次修改所有的值）cars = (\"1\", \"2\", \"3\", \"4\") 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://zivblog.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://zivblog.top/tags/Python/"}]},{"title":"Python字符串操作","slug":"Python字符串操作","date":"2019-03-03T12:39:13.000Z","updated":"2019-04-01T13:15:32.000Z","comments":true,"path":"passages/python-zi-fu-chuan-cao-zuo/","link":"","permalink":"http://zivblog.top/passages/python-zi-fu-chuan-cao-zuo/","excerpt":"Python字符串操作 《Python编程从入门到精通》笔记","text":"Python字符串操作 《Python编程从入门到精通》笔记 格式化输出1print(\"this is a &#123;&#125;\".format(\"demo\")) 大小写转换12345title() 将字符串中每个单词的首字母改为大写upper() 将字符串全部字母改为大写lower() 将字符串所有字母改为小写 空格删除12345strip() 同时删除字符串首部和尾部的空格lstrip() 删除字符串首部的空格rstrip() 删除字符串尾部的空格 转化为字符串1str()将传入的数据转化为对应的字符串 注释 单行注释 注释跟在‘#’后 多行注释 前后各三个‘“’将要注释部分包起来 中文注释 在文件首部加 #coding=utf-8 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://zivblog.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://zivblog.top/tags/Python/"}]},{"title":"Python程序运行时间计算","slug":"Python程序运行时间计算","date":"2019-03-03T12:31:38.000Z","updated":"2019-04-01T13:15:48.000Z","comments":true,"path":"passages/python-cheng-xu-yun-xing-shi-jian-ji-suan/","link":"","permalink":"http://zivblog.top/passages/python-cheng-xu-yun-xing-shi-jian-ji-suan/","excerpt":"Python程序运行时间计算","text":"Python程序运行时间计算 方法1123456789import datetimestarttime = datetime.datetime.now()# long runningendtime = datetime.datetime.now()print (endtime - starttime).seconds 方法 21234567start = time.time()run_fun()end = time.time()print end-start 方法31234567start = time.clock()run_fun()end = time.clock()print end-start 方法1和方法2都包含了其他程序使用CPU的时间，是程序开始到程序结束的运行时间。 方法3算只计算了程序运行的CPU时间 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://zivblog.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://zivblog.top/tags/Python/"}]},{"title":"苏州大学2009年复试编程题","slug":"苏州大学2009年复试编程题","date":"2019-03-03T11:47:29.000Z","updated":"2020-03-04T07:02:05.000Z","comments":true,"path":"passages/su-zhou-da-xue-2009-nian-fu-shi-bian-cheng-ti/","link":"","permalink":"http://zivblog.top/passages/su-zhou-da-xue-2009-nian-fu-shi-bian-cheng-ti/","excerpt":"字符串转数字 排序 分词","text":"字符串转数字 排序 分词 题目描述 用IE浏览器从ftp上下载org.dat，并保存在D盘目录下 此文件中存放了一段文章，其中由若干长度小于15的十进制或八进制的数字，数字之间用“,”隔开，数字内部存在且仅存在空格。 八进制以起始位0作为标识与十进制数区分。 顺序读取这些数字并将它们转变为十进制，排序后输出到文件new.txt，每个数字占一行。 例：_235_,34_2,_043_1,1_3，分别是十进制235，十进制342，八进制342，十进制13，_代表空格。 题目分析 根据分隔符（逗号），将文章分割成单个的字符串（c中的字符串即字符数组） 根据标识将八进制、十进制的字符串转化成十进制的数字 将十进制的数组使用选择排序按升序排序 将数组写入文件中，每个数字一行 解法一代码结构123456789101112131415161. void swap(int *a, int *b): 交换传入的两个数字2. int compare(int a, int b): 比较传入的两个数字的大小3. void selection_sort(int *ptr, int count): 选择排序4. bool is_num(char c): 判断传入的字符是否是数字5. bool valid(char c): 判断传入字符是否合法，数字或空格6. int main(): 打开文件 按分隔符读取数字（按字符串存） 将数字转化成十进制 排序 将排序结果存入文件 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;stdbool.h&gt;void swap(int *a, int *b)&#123; /* 交换传入的两个数字 */ int temp = *a; *a = *b; *b = temp;&#125;int compare(int a, int b)&#123; /* 比较传入的两个数字的大小 前者小返回-1 相等返回0 前者大返回1 */ if(a &lt; b) return -1; else if(a == b) return 0; else&#123; return 1; &#125;&#125;void selection_sort(int *ptr, int count)&#123; /* ptr为数组 count为数组元素个数 使用选择排序对数组中的元素进行升序排序 */ int i, j; for(i = 0; i &lt; count; i++)&#123; for(j = i + 1; j &lt; count; j++)&#123; // 前者比后者大 if(compare(&amp;ptr[i], &amp;ptr[j]) &gt; 0) swap(&amp;ptr[i], &amp;ptr[j]); &#125; &#125;&#125;// 判断传入字符 是否是数字bool is_num(char c)&#123; return c &gt;= '0' &amp;&amp; c &lt;= '9';&#125;// 判断传入的字符是否合法：数字或空格bool valid(char c)&#123; return is_num(c) || c == ' ';&#125;int main()&#123; FILE *fprog = fopen(\"org_2009.dat\", \"r\"); FILE *fpnew = fopen(\"new_2009.txt\", \"w\"); int i; int count = 0; int arr[128]; char c; char num[15]; printf(\"org_2009.dat:\\n\"); while((c = fgetc(fprog)) != EOF)&#123; if(is_num(c))&#123; i = 0; num[i++] = c; /* 读取一个数字 按字符读：空格或数字 只将数字存入num，用'\\0'结束 */ while((c = fgetc(fprog)) != EOF &amp;&amp; valid(c)) if(is_num(c)) num[i++] = c; num[i] = '\\0'; printf(\"%s\\n\", num); /* long int strtol(const char *nptr, char **endptr, int base) 将传入的字符串按base指示转化成long int 可以被转换的合法字符依据base而定，举例来说，当base为2时，合法字符为‘0’，‘1’； base为8时，合法字符为‘0’，‘1’，……‘7’；base为10时，合法字符为‘0’，‘1’，……‘9’； 事实上base指定的是传入字符串的进制，函数会自动转化乘10进制 */ arr[count++] = num[0] == '0' ? strtol(num, NULL, 8) : strtol(num, NULL, 10); &#125; &#125; // 排序 selection_sort(arr, count); // 将排序后的数组写入文件 for(i = 0; i &lt; count; i++) fprintf(fpnew, \"%d\\n\", arr[i]); // 关闭文件 fclose(fprog); fclose(fpnew); // 读取结果文件并输出 fpnew = fopen(\"new_2009.txt\", \"r\"); printf(\"new_2009.txt:\\n\"); while(fgets(num, sizeof(num), fpnew)) printf(\"%s\", num); fclose(fpnew);&#125; 解法二代码结构123456789101112131415void divide(char *a, char digit[][15], int *p) 将传入的字符串（包含整个文章内容）分成单词void sort(char digit[][15], int n) 冒泡排序，升序排序 int convert(char *a) 将字符串单词转化成10进制或八进制，这里可以选择使用strtol方法 int main() 读入文件内容 分词 转化成十进制数字 排序 学如文件 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;math.h&gt;#include&lt;string.h&gt;void divide(char *a, char digit[][15], int *p)&#123; /* 对传入的字符串形式的数组按分隔符进行分词 按逗号分词 去除数字中间的空格 */ int i = 0, j = 0, k = 0; while(a[i] != '\\0')&#123; // 字符非法，跳过 while(a[i] &lt; '0' || a[i] &gt; '9')&#123; if(a[i] == '\\0') break; i++; &#125; if(a[i] == '\\0') break; k = 0; // 读取单词，存到二维数组中 while((a[i] &gt;= '0' &amp;&amp; a[i] &lt;= '9') || (a[i] == ' '))&#123; if(a[i] == ' ')&#123; i++; continue; &#125;else&#123; digit[j][k++] = '\\0'; j++; &#125; &#125; // 单词个数 *p = j; &#125;&#125;void sort(char digit[][15], int n)&#123; /* 冒泡排序 外层控制趟数，内层控制比较次数 升序排列 */ int i, j; char temp[15]; for(i = 0; i &lt; n - 1; i++)&#123; for(j = 0; j &lt; n - i - 1; j++)&#123; if(convert(digit[j]) &gt; convert(digit[j+1]))&#123; strcpy(temp, digit[j]); strcpy(digit[j], digit[j+1]); strcpy(digit[j+1], temp); &#125; &#125; &#125;&#125;int convert(char *a)&#123; /* 讲字符串中的单词转化成十进制整数 */ int number = 0, i = 0; if(a[0] == '0')&#123; // 八进制 i++; while(a[i] != '\\0')&#123; number = 8 * number + a[i++] - '0'; &#125; &#125;else&#123; // 十进制 while(a[i] != '\\0')&#123; number = 10 * number +a[i++] - '0'; &#125; &#125; return number;&#125;int main()&#123; FILE *fp; int i = 0, j = 0; char a[30]; char digit[10][15]; // 打开待处理文件 if((fp = fopen(\"org_2009.dat\", \"r\")) == NULL)&#123; printf(\"cannot open the file\"); exit(0); &#125; // 读取文件，存储到一个字符串中 while(!feof(fp))&#123; a[i++] = fgetc(fp); &#125; a[i - 1] = '\\0'; // 分词 divide(a, digit, &amp;j); printf(\"#%s#\\n\", a); printf(\"%d\\n\", j); fclose(fp); // 输出分词结果 for(i = 0; i &lt; j; i++)&#123; printf(\"#%s#\\n\", digit[i]); &#125; // 排序 sort(digit, j); if((fp = fopen(\"new_200.txt\", \"w\")) == NULL)&#123; printf(\"cannot open the file\"); exit(0); &#125; //输出排序结果并写入文件 for(i = 0; i &lt; j; i++)&#123; printf(\"#%s#\\n\", digit[i]); fprintf(fp, \"%s\\n\", digit[i]); &#125; fclose(fp);&#125; 欢迎来信交流||指教。","categories":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"}],"tags":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"},{"name":"c语言","slug":"c语言","permalink":"http://zivblog.top/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"windows下搭建基于hexo的个人博客","slug":"windows下搭建基于hexo的个人博客","date":"2019-03-03T06:31:29.000Z","updated":"2020-03-04T06:44:16.000Z","comments":true,"path":"passages/windows-xia-da-jian-ji-yu-hexo-de-ge-ren-bo-ke/","link":"","permalink":"http://zivblog.top/passages/windows-xia-da-jian-ji-yu-hexo-de-ge-ren-bo-ke/","excerpt":"Hexo搭建步骤 安装Git 安装Node.js 安装Hexo及项目搭建 Github创建个人仓库 生成ssh添加到Github 将hexo部署到github 个人域名绑定 发布文章 踩坑","text":"Hexo搭建步骤 安装Git 安装Node.js 安装Hexo及项目搭建 Github创建个人仓库 生成ssh添加到Github 将hexo部署到github 个人域名绑定 发布文章 踩坑 1. 安装Git windows用户到这里下载Git并安装 验证Git安装成功 1$ git --version 2. 安装Nodejs windows用户到这里下载并安装 验证Nodejs安装成功 12$ node -v$ npm -v 3. 安装Hexo及项目搭建 输入以下命令安装Hexo并测试是否安装成功： 12345# 安装$ npm install -g hexo-cli# 测试$ hexo -v 创建项目 123$ hexo init ziv_blog$ cd ziv_blog$ npm install 在初始化的时候可能会比较慢，或者有时候会出现连接超时的情况，这时候切换为npm国内源就好了（2019.10.09更新） 1234$ npm install -g cnpm --registry=https://registry.npm.taobao.org# 还可以使用以下命令验证是否切换成功$ npm info express 本地目录 12345678910111213# 查看目录结构$ tree -L 1.├── _config.yml # 网站配置文件├── db.json├── node_modules # 依赖包├── package-lock.json├── package.json # 应用程序信息├── public # 静态站点存放于此├── scaffolds # 模板文件夹，新建文章时会使用此文件夹下的文件作为模板├── source # 存放用户资源的地方├── themes # 主题└── yarn.lock Github搭建个人仓库 注册Github账户，这里 创建仓库（new repository） 仓库名要与你的用户名相同，后面加.github.io。例如：myname.github.io 生成ssh添加到Github 123456789$ git config --global user.name \"your name\"$ git config --global user.email \"your email\"# 核对$ git config user.name$ git config user.email# 创建SSH$ ssh-keygen -t rsa -C \"your email\" 生成的ssh在你的用户目录下的.ssh文件夹中（该文件夹默认隐藏） 其中id_rsa是你的私人密钥，id_rsa.pub是公钥，将公钥上传到Github Github的setting -&gt; SSH key -&gt; new SSH key -&gt; 添加你的公钥（title随便起） 测试Github是否连接成功 1$ ssh -T git@github.com 将hexo部署到github上 将Hexo和Github关联起来，打开config.yml，添加以下内容： 1234deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master 安装deploy-git，便于以后用命令部署 1npm install hexo-deployer-git --save hexo基本操作 123456789$ hexo g # 生成静态站点放在public文件夹中$ hexo s # 本地启动服务，预览，访问localhost:4000$ hexo clean # 清除之前生成的东西$ hexo d # 部署文章$ hexo new 文件名 # 创建新.md文件 文章的标准格式 123456789101112131415---title: 文章标题date: 文章创建日期categories: 文章分类tags: - 文章标签1 - 文章标签2 - ...---在`&lt;!-- more --&gt;`之前编写文章的摘要内容！！！&lt;!-- more --&gt;在`&lt;!-- more --&gt;`之后编写文章的正式内容！！！ 域名绑定与解析 请见另一篇博文。 截断文章，显示摘要123在文章中合适 位置添加&lt;!--more--&gt;注意&lt;!--more--&gt;前的内容为摘要，不会显示在正文中 文章模版 可以修改在博客根目录下的scafflods的post.md文件。 文件中添加图片 请见另一篇博文。 踩坑 npm install 时，长时间停留在fetchMetadata 原因：网络不好 解决方法：更换源： 1npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org&#x2F; 验证： 1npm config get registry yml文件中 每行的初始不能有空格 冒号之后必须有空格 在不同的电脑上管理博客 这里提供一个思路，在github上令创建一个仓库，用于存放源文件，或者在码云上存放 本博客使用的是ad主题，欢迎来信交流。 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"博客相关","slug":"博客相关","permalink":"http://zivblog.top/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://zivblog.top/tags/Tools/"}]},{"title":"ubuntu下搭建spark单机环境","slug":"ubuntu下搭建spark单机环境","date":"2019-03-03T06:17:36.000Z","updated":"2020-03-04T06:42:15.000Z","comments":true,"path":"passages/ubuntu-xia-da-jian-spark-dan-ji-huan-jing/","link":"","permalink":"http://zivblog.top/passages/ubuntu-xia-da-jian-spark-dan-ji-huan-jing/","excerpt":"Java SE Scala spark sbt","text":"Java SE Scala spark sbt 安装配置Java SE 下载Java SE Linux版本，这里。 注意要选择Linux版本，并且根据实际情况选择64 or 32位。 下载jdk-XXXX-linux-XXX.tar.gz，解压到自己制定目录。 1$ tar -zxvf jdk-XXXX-linux-XXX.tar.gz -C /usr/lib/java 配置java环境变量 打开.bashrc并在其尾部添加如下内容： 123456$ nano ~&#x2F;.bashrcexport JAVA_HOME&#x3D;&#x2F;usr&#x2F;lib&#x2F;java&#x2F;jdk1.8.0_131 export JRE_HOME&#x3D;$&#123;JAVA_HOME&#125;&#x2F;jre export CLASSPATH&#x3D;.:$&#123;JAVA_HOME&#125;&#x2F;lib:$&#123;JRE_HOME&#125;&#x2F;lib export PATH&#x3D;$&#123;JAVA_HOME&#125;&#x2F;bin:$&#123;JRE_HOME&#125;&#x2F;bin:$PATH 执行下列命令使环境变量生效，并测试： 1234$ source ~/.bashrc$ java -versionjava version \"XXXX\" 安装配置Scala 下载Scala的压缩文件，这里。 下载scala-2.12.2.tgz后,解压到制定目录： 1$ tar -zxvf scala-2.12.2.tgz -C /opt/scala/ 配置scala环境变量 打开.bashrc，并在其尾部添加如下内容 1234$ nano ~/.bashrcexport SCALA_HOME=/opt/scala/scala-2.12.2 export PATH=$&#123;SCALA_HOME&#125;/bin:$PATH 执行下列命令使环境变量生效，并测试： 1234$ source ~/.bashrc$ scala -versionScala code runner version 2.12.2 安装配置spark 下载spark压缩文件，这里。 下载spark-2.1.1-bin-hadoop2.7.tgz后，解压到指定的目录。 1$ tar -zxvf spark-2.1.1-bin-hadoop2.7.tgz -C /opt/spark/ 配置spark环境变量 打开.bashrc，并在其尾部添加如下内容： 1234$ nano ~/.bashrcexport SPARK_HOME=/opt/spark/spark-2.1.1-bin-hadoop2.7export PATH=$&#123;SPARK_HOME&#125;/bin:$PATH 执行下列命令时环境变量生效并测试： 123$ source ~/.bashrc$ spark-shell 安装配置sbt 下载sbt的压缩文件，这里。 下载sbt-0.13.15.tgz后，解压到指定的目录。 1$ tar -zxvf sbt-0.13.15.tgz -C /opt/scala/sbt/ 配置sbt环境变量 打开.bashrc文件，并在其尾部添加： 1234$ nano ~/.bashrcexport SBT_HOME=/opt/scala/sbtexport PATH=$&#123;SBT_HOME&#125;/bin:$PATH 执行下列命令使环境变量生效： 1$ source ~/.bashrc 创建启动sbt的脚本 1234567$ mkdir /opt/scala/sbt/ $ cd /opt/scala/sbt/ $ touch sbt # 脚本内容如下，注意sbt-launch.jar的位置SBT_OPTS=\"-Xms512M -Xmx1536M -Xss1M -XX:+CMSClassUnloadingEnabled -XX:MaxPermSize=256M\" java $SBT_OPTS -jar /opt/scala/sbt/bin/sbt-launch.jar \"$@\" 检测sbt是否正确安装 1234567$ chmod u+x sbt $ sbt sbt-version[info] 0.13.15# 若报错，使用如下命令查看$ sbt sbtVersion 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"工具配置","slug":"工具配置","permalink":"http://zivblog.top/categories/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://zivblog.top/tags/Tools/"}]},{"title":"静态连接数据数据库实例","slug":"静态连接数据数据库实例","date":"2019-03-02T14:37:03.000Z","updated":"2020-07-06T05:46:14.000Z","comments":true,"path":"passages/jing-tai-lian-jie-shu-ju-shu-ju-ku-shi-li/","link":"","permalink":"http://zivblog.top/passages/jing-tai-lian-jie-shu-ju-shu-ju-ku-shi-li/","excerpt":"数据库静态连接","text":"数据库静态连接 12345678910111213141516171819202122232425262728293031323334import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class DBUtil &#123; private static final String url = \"jdbc:mysql://127.0.0.1:3306/jdbc_db\"; private static final String NAME = \"root\"; private static final String PASS = \"123456\"; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; //加载驱动程序 Class.forName(\"com.mysql.jdbc.Driver\"); //获得数据库连接 Connection conn = DriverManager.getConnection(url, NAME, PASS); //通过数据库的连接操作数据库 Statement stat = conn.createStatement(); ResultSet rs = stat.executeQuery(\"select user_name from jdbc_db_goddess\"); while(rs.next())&#123; System.out.println(rs.getString(\"user_name\")); &#125; &#125;&#125; 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://zivblog.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://zivblog.top/tags/Java/"}]},{"title":"苏州大学2005年复试编程题","slug":"苏州大学2005年复试编程题","date":"2019-03-02T12:55:49.000Z","updated":"2020-07-06T05:47:34.000Z","comments":true,"path":"passages/su-zhou-da-xue-2005-nian-fu-shi-bian-cheng-ti/","link":"","permalink":"http://zivblog.top/passages/su-zhou-da-xue-2005-nian-fu-shi-bian-cheng-ti/","excerpt":"将给定数字拆分成若干素数的和","text":"将给定数字拆分成若干素数的和 2005-1题目描述 将给定数字拆分成若干素数的和 问题分析 素数：本身大于1，且除了1和其本身之外没有其他的素数因子。 C99之前的c语言没有bool类型，之后的标准中使用bool类型需要添加头文件stdbool.h。 代码结构12345678910111. int is_prime(int num)： 判断输入的数字是否小于二 循环判断2~$\\sqrt&#123;n&#125;$是否有输入数字的因子2. void splite(int num)： 判断数字是否小于2 判断数字本身是否为素数：输出本身 递归循环判断从n~1开始依次递减判断是否为素数：输出并递归，减去输出的数字3. int main() ： 输入并调用切分函数 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdbool.h&gt;bool is_prime(int num)&#123; /* 判断输入的数字是否为素数 */ // 小于2的不是素数 int i; if(num &lt; 2)&#123; return false; &#125; // 是否有除1和其本身之外的因子 for(i = 2; i*i &lt; num; i++)&#123; if(num % i == 0)&#123; return false; &#125; &#125; return true;&#125;void split(int num)&#123; int i; // 小于2的不是素数 if(num &lt; 2)&#123; return; &#125; // 本身是否为素数 if(is_prime(num))&#123; printf(\"%d\", num); return; &#125; // 递归判断 for(i = num; i &gt; 1; --i)&#123; if(is_prime(i) &amp;&amp; num-i &gt; 1)&#123; printf(\"%d \", i); splite(num - i); return; &#125; &#125;&#125;int main()&#123; int i; while(scanf(\"%d\", &amp;i))&#123; split(i); putchar(10); //输出换行符 &#125; getchar(); return 0;&#125; 2005-2题目描述 从指定文件中读取文件内容 统计文件中各个字母的出现次数 字母顺序按照出现次数升序排列 问题分析 从文件中读取内容 定义结构体Letter，包含两部分：字母，次数 定义长度为26的Letter数组 判断字母大小写，同一个字母的大小写按同一个计数 使用选择排序对按出现次数对Letter数组排序 代码结构123456789101112131415161718192021222324251. Letter结构体： char； n； 2. swap(Letter *a, Letter *b)： 交换传入的两个数据 3. compare(Letter *a, Letter *b)： 比较传入的两个数据 4. selection_sort(Letter *ptr, int count)： 选择排序（升序） 5. is_upper(char c)： 判断字母是否为大写 6. is_lower(char c)： 判断字母是否为小写 7. int main()： 读入文件 初始化Letter数组 统计各个字母次数 选择排序 输出 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdbool.h&gt;typedef struct&#123; char c; //字母 int n; //出现次数&#125;Letter;void swap(Letter *a, Letter *b)&#123; /* 交换传入的两个数据 */ Letter temp = *a; *a = *b; *b = temp;&#125;int compare(Letter *a, Letter *b)&#123; /* 比较两个传入字母出现次数的大小 */ if(a-&gt;n &lt; b-&gt;n) return -1; else if(a-&gt;n &gt; b-&gt;n) return 1; else return 0;&#125;void selection_sort(Letter *ptr, int count)&#123; /* 使用选择排序对传入的数组按升序排序 选择排序：第i趟选择第i小的与第i个位置的元素交换位置 第一层循环控制趟数，第二层循环控制比较 */ int i, j; for(i = 0;i &lt; count; i++)&#123; // 从第i+1个位置与第i个位置的元素比较 for(j = i+1; j &lt; count; j++) // 若前者大于后者 if(compare(&amp;ptr[i], &amp;ptr[j]) &gt; 0) swap(&amp;ptr[i], &amp;ptr[j]); &#125;&#125;// 判断是否为大写字母bool is_upper(char c)&#123;return c&gt;='A' &amp;&amp; c&lt;='Z';&#125;// 判断是否为小写字母bool is_lower(char c)&#123;return c&gt;='a' &amp;&amp; c&lt;='z';&#125;int main()&#123; FILE *fp = fopen(\"2005_2.txt\", \"r\"); Letter letter[26]; char c; int i; // 文件打开失败 if(!fp)&#123; printf(\"file opening failed\"); return EXIT_FAILURE; &#125; // 初试化letter数组 for(i = 0; i &lt; 26; i++)&#123; letter[i].c = i+'a'; letter[i].n = 0; &#125; // 统计字母个数 while((c = fgetc(fp)) != EOF)&#123; if(is_upper(c)) letter[c - 'A'].n ++; if(is_lower(c)) letter[c - 'a'].n++; &#125; // 选择排序 selection_sort(letter, 26); // 输出letter数组 for(i = 0; i &lt; 26; i++)&#123; printf(\"%c: %d\\n\", letter[i].c, letter[i].n); &#125; fclose(fp);&#125; 欢迎来信交流||指教。","categories":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"}],"tags":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"},{"name":"c语言","slug":"c语言","permalink":"http://zivblog.top/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"苏州大学2006年复试编程题","slug":"苏州大学2006年复试编程题","date":"2019-03-02T12:55:49.000Z","updated":"2020-03-04T07:00:29.000Z","comments":true,"path":"passages/su-zhou-da-xue-2006-nian-fu-shi-bian-cheng-ti/","link":"","permalink":"http://zivblog.top/passages/su-zhou-da-xue-2006-nian-fu-shi-bian-cheng-ti/","excerpt":"找出100~1000中不含9的素数，将结果输入到result文件中","text":"找出100~1000中不含9的素数，将结果输入到result文件中 问题描述 找出100~1000中不含9的素数，将结果输入到result文件中 问题分析 判断数字是否为素数 在是素数的基础上判断是否含9 写入文件 代码结构123456789101. bool is_prime(int num)： 判断传入的数字是否为素数2. bool is_has9(int num)： 判断传入的数字是否含93. int mian()： 创建文件指针 循环判断100~1000之间的数字是否为素数 是素数的数字是否含9 符合条件的数字写入文件 关闭文件 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdbool.h&gt;bool is_prime(int num)&#123; /* 判断传入的数字是否为素数 */ int i; if(num &lt; 2) return false; for(i = 2; i*i &lt; num; i++)&#123; if(num % i == 0) return false; &#125; return true;&#125;bool is_has9(int num)&#123; /* 判断传入的数字是否含9 */ if(num &lt; 9) return false; while(num &gt;= 9)&#123; if(num % 10 == 9)&#123; return true; &#125; num /= 10; &#125; return false;&#125;int main()&#123; FILE *fp = fopen(\"result.txt\", \"w\");; int i; // 循环判断 for(i = 100; i &lt; 1000; i++)&#123; if(is_prime(i) &amp;&amp; !is_has9(i)) fprintf(fp, \"%d\\n\", i); &#125; fclose(fp); return 0;&#125; 欢迎来信交流||指教。","categories":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"}],"tags":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"},{"name":"c语言","slug":"c语言","permalink":"http://zivblog.top/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"苏州大学2008年复试编程题","slug":"苏州大学2008年复试编程题","date":"2019-03-02T12:55:49.000Z","updated":"2020-03-04T07:01:39.000Z","comments":true,"path":"passages/su-zhou-da-xue-2008-nian-fu-shi-bian-cheng-ti/","link":"","permalink":"http://zivblog.top/passages/su-zhou-da-xue-2008-nian-fu-shi-bian-cheng-ti/","excerpt":"排除指定单词，转换单词格式，输入到文件中","text":"排除指定单词，转换单词格式，输入到文件中 问题描述 用IE从FTP上下载org.dat，并保存到D盘根目录 顺序读取文件内的文章内容，读取过程中排除“the”及其变形 将读取的所有单词首字母转大写后，输出到D盘根目录下new.txt，每个单词一行 问题分析 从ftp上下载文件 读取文件内容 过滤掉“the”及其变形，相同单词读写一次 将每个单词首字母大写，格式化输出到文件中 解法一代码结构12345671. bool is_the(char word[15])： 判断传入的单词是否为the，或其变形 2. int main()： 创建文件指针 读取文件org.dat，输出并过滤the及其变形并写入new.txt中 输出new.txt中的内容 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdbool.h&gt;#include&lt;string.h&gt;bool is_the(char word[15])&#123; /* 判断传入的长度不超过15的单词是否为the及其变形 */ int i; char the[] = \"the\"; if(strlen(word) != strlen(the)) return false; for(i = 0; i &lt; strlen(word); i++) word[i] |= 0x20; // 按字典顺序比较两个字符串的大小 return strcmp(word, the) == 0;&#125;int main()&#123; FILE *fporg = fopen(\"org.dat\", \"r\"); FILE *fpnew = fopen(\"new.txt\", \"w\"); char word[15]; // 保证两个文件均正常打开 if(!fporg || !fpnew)&#123; printf(\"File opening failed\"); return EXIT_FAILURE; &#125; printf(\"org.dat:\\n\"); // 按单词读取org.dat的内容并输出，同时过滤the并写入new.txt中 while(fscanf(fporg, \"%s\", word) != EOF)&#123; printf(\"%s \", word); // 'a'-'A' = 32 = 0x20 if(!is_the(word))&#123; // 首字母大写 word[0] = (word[0] | 0x20) - 0x20; fprintf(fpnew, \"%s\\n\", word); &#125; &#125; printf(\"\\n\"); fclose(fporg); fclose(fpnew); // 输出new.txt的内容 fpnew = fopen(\"new.txt\", \"r\"); printf(\"new.txt:\\n\"); while(fscanf(fporg, \"%s\", word) != EOF) printf(\"%s \", word); printf(\"\\n\"); fclose(fpnew); return 0;&#125; 解法二代码结构1234567891011121. void divide(char *a, char words[][15], int *p)```： 将读取的整个文件（含空格，含‘\\0’），划分为单词，这里可以改进为用格式化按单词读取文件。2. void printResult(char words[][15], int n)： 重复单词只往文件中读写一次 过滤THE及其变形 首字母大写并写入文件中3. int isThe(char *p)： 判断传入的单词是否是THE及其变形 将传入长度为3的单词转换成全部大写，再与THE比较4. int main： 读取文件 输出划分好的文章 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdbool.h&gt;#include&lt;ctype.h&gt;#include&lt;string.h&gt;void divide(char *a, char words[][15], int *p)&#123; /* 将直接读取整个文件（包含空格）划分成单词 */ int i = 0, j = 0, k = 0; while(a[i] != '\\0')&#123; while(!isalpha(a[i]))&#123; if(a[i] == '\\0') break; i++; &#125; if(a[i] == '\\0') break; k = 0; while(isalpha(a[i])) words[j][k++] = a[i++]; words[j][k] = '\\0'; j++; &#125; // 单词个数 *p = j;&#125;void printResult(char words[][15], int n)&#123; /* 过滤the及其变形，重复单词只写一遍，写入文件中 */ FILE *fp; int i, j, signal; char temp[15]; // 确认文件正常打开 if((fp = fopen(\"new.txt\",\"w\")) == NULL)&#123; printf(\"cannot opening file\"); exit(0); &#125; // 相同单词只读写一次 for(i = 0; i &lt; n; i++)&#123; signal = 0; for(j = 0; j &lt; i; j++)&#123; if(j == i) continue; else&#123; // 比较两个单词是否相同 if(strcmp(words[i], words[j]) == 0)&#123; signal = 1; break; &#125; &#125; &#125; // 非the及其变形的单词首字母大写并写入文件中 if((signal == 0) &amp;&amp; !isThe(words[i]))&#123; strcpy(temp, words[i]); if(islower(temp[0]))&#123; temp[0] -= 32; &#125; fprintf(fp, \"%s \", temp); &#125; &#125; fclose(fp);&#125;int isThe(char *p)&#123; /* 判断传入的单词是否为THE及其变形 */ int i, k; // 长度不为3 if(strlen(p) != 3) return 0; else&#123; // 转化成全部大写，再与THE比较 for(i = 0; i &lt; 3; i++)&#123; if(islower(p[i]))&#123; p[i] -= 32; &#125; &#125; if(strcmp(p, \"THE\") == 0) return 1; else return 0; &#125;&#125;int main()&#123; FILE *fp; int i = 0,j = 0; char a[500]; char words[100][15]; if((fp = fopen(\"org.dat\", \"r\")) == NULL)&#123; printf(\"cannot open the file\"); exit(0); &#125; // 读取文件 while(!feof(fp))&#123; a[i++] = fgetc(fp); &#125; a[i-1] = '\\0'; divide(a, words, &amp;j); // 输出划分好的文章 for(i = 0; i &lt; j; i++)&#123; printf(\"%s \", words[i]); &#125; printResult(words, j);&#125; 欢迎来信交流||指教。","categories":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"}],"tags":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"},{"name":"c语言","slug":"c语言","permalink":"http://zivblog.top/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"C语言文件操作","slug":"c语言之文件操作","date":"2019-03-02T12:55:49.000Z","updated":"2020-03-04T12:20:39.000Z","comments":true,"path":"passages/c-yu-yan-zhi-wen-jian-cao-zuo/","link":"","permalink":"http://zivblog.top/passages/c-yu-yan-zhi-wen-jian-cao-zuo/","excerpt":"文件分类 文件缓冲区 文件指针 文件的打开与关闭 文件的读写 注意事项","text":"文件分类 文件缓冲区 文件指针 文件的打开与关闭 文件的读写 注意事项 文件分类 ASCII文件：文本文件，每一个字节存放一个字符的ASCII代码 二进制文件：映像文件，相当于存放在内存中数据的映像（内存中数据是以二进制形式存放的） 文件缓冲区 从内存中输出数据必须先送到内存中的换中去，装满缓冲区之后才一起送到磁盘中去 文件指针 由系统声明，取名FILE 12FILE f1;&#96;&#96;&#96; &#x2F;&#x2F;定义结构体变量f1，用于存放一个问价的有关信息 FILE *f1;&#96;&#96;&#96; &#x2F;&#x2F;指向文件类型数据的指针变量，通过文件指针变量能够找到与它关联的文件 文件的打开与关闭 在读写之前必须先打开文件，使用结束后必须手动关闭文件 打开文件使用fopen函数，fopen(文件名, 使用方式); “r”; //读，打开一个已存在的文本文件 “w”; //写，打开一个文本文件 “a”; //向文本文件尾部追加数据 “rb”; //读，打开一个二进制文件 “wb”; //写，打开一个二进制文件 “ab”; //向二进制文件尾部追加数据 “r+”; //读写，打开文本文件 “w+”; //读写，新建文本文件 “a+”; //读写，打开文本文件 “rb+”; //读写，打开二进制文件 “wb+”; //读写，新建二进制文件 “ab+”; //读写，打开二进制文件 // 常规文件打开方式 if(fp=fopen(filename,\"w\") == NULL) { printf(\"cannot ipen this file\"); exit(0); } &lt;!--￼1--&gt; fclose(文件指针); &lt;!--￼2--&gt; fgetc(文件指针); fputc(字符, 文件指针); &lt;!--￼3--&gt; fgets(字符数组, 长度, 文件指针); fputs(字符数组, 文件指针); &lt;!--￼4--&gt; fprintf(文件指针，格式字符串，输出列表); fscanf(文件指针，格式字符串，输入列表); &lt;!--￼5--&gt; fread(buffer, size, count, fp); fwrite(buffer, size, count, fp); &lt;!--￼6--&gt; 随机读写数据文件 文件位置标记：指示接下来要读写的下一个字符的位置 文件位置标记的定位 12345678rewind() # 使文件位置标记重新返回文件头部fseek(fp, 位移量, 起始点) # 改变文件位置标记# 起始点SEEK_SET # 文件开始位置SEEK_CUR # 文件当前位置SEEK_END # 文件末尾位置 文件读写的出错检测 123ferror(fp); # 检测调用输入输出函数是是否出现错误clearerr(); #使文件出错标志和文件结束标志置为0 注意事项 null在c语言中没有预定义，必须使用大写NULL 双引号中的内容是const char，单引号中的内容是char 从控制台读字符串使用%s占位，读字符使用%c占位，读整形数字使用%d占位，读浮点数使用%f占位 使用vs2010编译c语言文件：创建项目，不勾选预编译，源文件文件夹上右键新建项，c++文件；先编译（ctrl+f7），再执行 打开文件后一定要手动关闭 欢迎转载交流，拒绝一切形式的复制抄袭。 欢迎来信交流||指教。","categories":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"}],"tags":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"},{"name":"c语言","slug":"c语言","permalink":"http://zivblog.top/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"苏州大学2007年复试编程题","slug":"苏州大学2007年复试编程题","date":"2019-03-02T12:55:49.000Z","updated":"2020-03-04T07:00:56.000Z","comments":true,"path":"passages/su-zhou-da-xue-2007-nian-fu-shi-bian-cheng-ti/","link":"","permalink":"http://zivblog.top/passages/su-zhou-da-xue-2007-nian-fu-shi-bian-cheng-ti/","excerpt":"找出指定范围内符合描述条件的数字并写入文件","text":"找出指定范围内符合描述条件的数字并写入文件 问题描述 找出10~1000之间： 本身是素数 其反数也是素数，例如123的反数是321 将结果写入result文件中 问题分析 判断数字是否为素数 求其反数并判断是否为素数 符合条件的数字写入文件中 代码结构1234567891. bool is_prime(int num)： 判断传入的数字是否为素数2. int reverse(int num)： 求传入数字的反转3. int mian()： 创建文件指针 循环判断数字是否符合条件 格式化输出到文件中 关闭文件 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdbool.h&gt;bool is_prime(int num)&#123; /* 判断传入的数字是否为素数 */ int i; if(num &lt; 2) return false; for(i = 2; i*i &lt; num; i++)&#123; if(num % i == 0) return false; &#125; return true;&#125;int reverse(int num)&#123; /* 将传入的数字反转 */ int rev = 0; while(num &gt; 0)&#123; rev = rev * 10 + num % 10; num /= 10; &#125; return rev;&#125;int main()&#123; FILE *fp = fopen(\"result_2007.txt\", \"w\"); int i; for(i = 10; i &lt;= 1000; i++)&#123; if(is_prime(i) &amp;&amp; is_prime(reverse(i)))&#123; fprintf(fp, \"%d\\n\", i); &#125; &#125; fclose(fp);&#125; 欢迎来信交流||指教。","categories":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"}],"tags":[{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"},{"name":"c语言","slug":"c语言","permalink":"http://zivblog.top/tags/c%E8%AF%AD%E8%A8%80/"}]}],"categories":[{"name":"数据竞赛","slug":"数据竞赛","permalink":"http://zivblog.top/categories/%E6%95%B0%E6%8D%AE%E7%AB%9E%E8%B5%9B/"},{"name":"自然语言处理","slug":"自然语言处理","permalink":"http://zivblog.top/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://zivblog.top/categories/Leetcode/"},{"name":"Lintcode","slug":"Lintcode","permalink":"http://zivblog.top/categories/Lintcode/"},{"name":"算法","slug":"算法","permalink":"http://zivblog.top/categories/%E7%AE%97%E6%B3%95/"},{"name":"Sword Offer","slug":"Sword-Offer","permalink":"http://zivblog.top/categories/Sword-Offer/"},{"name":"工具配置","slug":"工具配置","permalink":"http://zivblog.top/categories/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/"},{"name":"博客相关","slug":"博客相关","permalink":"http://zivblog.top/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"},{"name":"置顶","slug":"置顶","permalink":"http://zivblog.top/categories/%E7%BD%AE%E9%A1%B6/"},{"name":"机器学习","slug":"机器学习","permalink":"http://zivblog.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"编程语言","slug":"编程语言","permalink":"http://zivblog.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"}],"tags":[{"name":"炼丹手册","slug":"炼丹手册","permalink":"http://zivblog.top/tags/%E7%82%BC%E4%B8%B9%E6%89%8B%E5%86%8C/"},{"name":"深度学习","slug":"深度学习","permalink":"http://zivblog.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"leetcode","slug":"leetcode","permalink":"http://zivblog.top/tags/leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://zivblog.top/tags/Algorithm/"},{"name":"NLP","slug":"NLP","permalink":"http://zivblog.top/tags/NLP/"},{"name":"lintcode","slug":"lintcode","permalink":"http://zivblog.top/tags/lintcode/"},{"name":"Tools","slug":"Tools","permalink":"http://zivblog.top/tags/Tools/"},{"name":"AI","slug":"AI","permalink":"http://zivblog.top/tags/AI/"},{"name":"Python","slug":"Python","permalink":"http://zivblog.top/tags/Python/"},{"name":"研究生复试","slug":"研究生复试","permalink":"http://zivblog.top/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/"},{"name":"c语言","slug":"c语言","permalink":"http://zivblog.top/tags/c%E8%AF%AD%E8%A8%80/"},{"name":"Java","slug":"Java","permalink":"http://zivblog.top/tags/Java/"}]}